/**
 * regulator_atf.cpp
 *
 * This file was auto-generated from regulator_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: regulator_atf.txt
 */
 
#include "regulator_atf.h"

//=================================================================
//                    ResetPwdMessageStruct
//=================================================================

regulator::common_structs::ResetPwdMessageStruct::ResetPwdMessageStruct()
{
	clear();
}

void regulator::common_structs::ResetPwdMessageStruct::clear()
{
	user.clear();
	zip.clear();
	addr.clear();
	email.clear();
	useChallengeQuestions = false;
	answer1.clear();
	answer2.clear();
	ssn4.clear();
}

bool regulator::common_structs::ResetPwdMessageStruct::equals(const ResetPwdMessageStruct& _o) const
{
	return Atf::atfPStringEquals(user, _o.user) &&
		Atf::atfPStringEquals(zip, _o.zip) &&
		Atf::atfPStringEquals(addr, _o.addr) &&
		Atf::atfPStringEquals(email, _o.email) &&
		useChallengeQuestions == _o.useChallengeQuestions &&
		Atf::atfPStringEquals(answer1, _o.answer1) &&
		Atf::atfPStringEquals(answer2, _o.answer2) &&
		Atf::atfPStringEquals(ssn4, _o.ssn4);
}

const char *regulator::common_structs::ResetPwdMessageStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("user=");
	_buf.append(user);
	_buf.append(',');
	_buf.append("zip=");
	_buf.append(zip);
	_buf.append(',');
	_buf.append("addr=");
	_buf.append(addr);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("useChallengeQuestions=");
	_buf.appendUint(useChallengeQuestions);
	_buf.append(',');
	_buf.append("answer1=");
	_buf.append(answer1);
	_buf.append(',');
	_buf.append("answer2=");
	_buf.append(answer2);
	_buf.append(',');
	_buf.append("ssn4=");
	_buf.append(ssn4);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::common_structs::ResetPwdMessageStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("user", user, _buf);
	Atf::XmlElement::encodeAsXmlElement("zip", zip, _buf);
	Atf::XmlElement::encodeAsXmlElement("addr", addr, _buf);
	Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	Atf::XmlElement::encodeAsXmlElement("useChallengeQuestions", useChallengeQuestions, _buf);
	Atf::XmlElement::encodeAsXmlElement("answer1", answer1, _buf);
	Atf::XmlElement::encodeAsXmlElement("answer2", answer2, _buf);
	Atf::XmlElement::encodeAsXmlElement("ssn4", ssn4, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::common_structs::ResetPwdMessageStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("user"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, user)) return false;
		}
		else if (_element.equals("zip"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, zip)) return false;
		}
		else if (_element.equals("addr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, addr)) return false;
		}
		else if (_element.equals("email"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
		}
		else if (_element.equals("useChallengeQuestions"))
		{
			useChallengeQuestions = (*_value.ptr() == '1');
		}
		else if (_element.equals("answer1"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, answer1)) return false;
		}
		else if (_element.equals("answer2"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, answer2)) return false;
		}
		else if (_element.equals("ssn4"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, ssn4)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::common_structs::ResetPwdMessageStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(user);
	_msg.composeString(zip);
	_msg.composeString(addr);
	_msg.composeString(email);
	_msg.composeBOOL(useChallengeQuestions);
	_msg.composeString(answer1);
	_msg.composeString(answer2);
	_msg.composeString(ssn4);
}

void regulator::common_structs::ResetPwdMessageStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(user);
	_parser.parseStringP(zip);
	_parser.parseStringP(addr);
	_parser.parseStringP(email);
	_parser.parseBOOL(useChallengeQuestions);
	_parser.parseStringP(answer1);
	_parser.parseStringP(answer2);
	_parser.parseStringP(ssn4);
}

const char *regulator::common_structs::ResetPwdMessageStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("user", user);
	_jsonstr.compose("zip", zip);
	_jsonstr.compose("addr", addr);
	_jsonstr.compose("email", email);
	_jsonstr.compose("useChallengeQuestions", useChallengeQuestions);
	_jsonstr.compose("answer1", answer1);
	_jsonstr.compose("answer2", answer2);
	_jsonstr.compose("ssn4", ssn4);
	return _buf.c_str();
}

void regulator::common_structs::ResetPwdMessageStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("user", user);
	_jparser.parseByNameThrow("zip", zip);
	_jparser.parseByNameThrow("addr", addr);
	_jparser.parseByNameThrow("email", email);
	_jparser.parseByNameThrow("useChallengeQuestions", useChallengeQuestions);
	_jparser.parseByNameThrow("answer1", answer1);
	_jparser.parseByNameThrow("answer2", answer2);
	_jparser.parseByNameThrow("ssn4", ssn4);
}

/* static */ void regulator::common_structs::ResetPwdMessageStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString user; _jparser.validateByNameThrow("user", user);
	AtfValidator::validateIntMax(_descr, "user", user.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString zip; _jparser.validateByNameThrow("zip", zip);
	AtfValidator::validateIntMax(_descr, "zip", zip.length(), 100000, _checker, __FILE__, __LINE__);
	PString addr; _jparser.validateByNameThrow("addr", addr);
	AtfValidator::validateIntMax(_descr, "addr", addr.length(), 100000, _checker, __FILE__, __LINE__);
	PString email; _jparser.validateByNameThrow("email", email);
	AtfValidator::validateIntMax(_descr, "email", email.length(), USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	bool useChallengeQuestions; _jparser.validateByNameThrow("useChallengeQuestions", useChallengeQuestions);
	AtfValidator::validateInt(_descr, "useChallengeQuestions", useChallengeQuestions, _checker, __FILE__, __LINE__);
	PString answer1; _jparser.validateByNameThrow("answer1", answer1);
	AtfValidator::validateIntMax(_descr, "answer1", answer1.length(), 10000, _checker, __FILE__, __LINE__);
	PString answer2; _jparser.validateByNameThrow("answer2", answer2);
	AtfValidator::validateIntMax(_descr, "answer2", answer2.length(), 10000, _checker, __FILE__, __LINE__);
	PString ssn4; _jparser.validateByNameThrow("ssn4", ssn4);
	AtfValidator::validateIntMax(_descr, "ssn4", ssn4.length(), SSN_4_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::common_structs::ResetPwdMessageStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "user"); size_t szUser = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "user", szUser, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "zip"); size_t szZip = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zip", szZip, 100000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "addr"); size_t szAddr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "addr", szAddr, 100000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	bool useChallengeQuestions; _parser.parseBOOL(useChallengeQuestions);
	AtfValidator::validateInt(_descr, "useChallengeQuestions", useChallengeQuestions, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "answer1"); size_t szAnswer1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer1", szAnswer1, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "answer2"); size_t szAnswer2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer2", szAnswer2, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ssn4"); size_t szSsn4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "ssn4", szSsn4, SSN_4_LEN, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ChallengeQuestion
//=================================================================

regulator::common_structs::ChallengeQuestion::ChallengeQuestion()
{
	clear();
}

void regulator::common_structs::ChallengeQuestion::clear()
{
	id = 0;
	txt.clear();
}

bool regulator::common_structs::ChallengeQuestion::equals(const ChallengeQuestion& _o) const
{
	return id == _o.id &&
		Atf::atfPStringEquals(txt, _o.txt);
}

const char *regulator::common_structs::ChallengeQuestion::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("txt=");
	_buf.append(txt);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::common_structs::ChallengeQuestion::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("txt", txt, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::common_structs::ChallengeQuestion::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("id"))
		{
			id = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("txt"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, txt)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::common_structs::ChallengeQuestion::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(id);
	_msg.composeString(txt);
}

void regulator::common_structs::ChallengeQuestion::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
	_parser.parseStringP(txt);
}

const char *regulator::common_structs::ChallengeQuestion::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("txt", txt);
	return _buf.c_str();
}

void regulator::common_structs::ChallengeQuestion::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("txt", txt);
}

/* static */ void regulator::common_structs::ChallengeQuestion::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	PString txt; _jparser.validateByNameThrow("txt", txt);
	AtfValidator::validateInt(_descr, "txt", txt.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::common_structs::ChallengeQuestion::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "txt"); size_t szTxt = strlen(_dummy);
	AtfValidator::validateInt(_descr, "txt", szTxt, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    LobbyNameAvailableStruct
//=================================================================

regulator::common_structs::LobbyNameAvailableStruct::LobbyNameAvailableStruct()
{
	clear();
}

void regulator::common_structs::LobbyNameAvailableStruct::clear()
{
	userId.clear();
	localeId = 0;
}

bool regulator::common_structs::LobbyNameAvailableStruct::equals(const LobbyNameAvailableStruct& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		localeId == _o.localeId;
}

const char *regulator::common_structs::LobbyNameAvailableStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("localeId=");
	_buf.appendUint(localeId);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::common_structs::LobbyNameAvailableStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("localeId", localeId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::common_structs::LobbyNameAvailableStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("localeId"))
		{
			localeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::common_structs::LobbyNameAvailableStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(localeId);
}

void regulator::common_structs::LobbyNameAvailableStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(localeId);
}

const char *regulator::common_structs::LobbyNameAvailableStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("localeId", localeId);
	return _buf.c_str();
}

void regulator::common_structs::LobbyNameAvailableStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("localeId", localeId);
}

/* static */ void regulator::common_structs::LobbyNameAvailableStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 100, _checker, __FILE__, __LINE__);
	UINT32 localeId; _jparser.validateByNameThrow("localeId", localeId);
	AtfValidator::validateIntMax(_descr, "localeId", localeId, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::common_structs::LobbyNameAvailableStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 100, _checker, __FILE__, __LINE__);
	UINT32 localeId; _parser.parseUINT32(localeId);
	AtfValidator::validateIntMax(_descr, "localeId", localeId, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    LobbyNameAvailableReplyStruct
//=================================================================

regulator::common_structs::LobbyNameAvailableReplyStruct::LobbyNameAvailableReplyStruct()
{
	clear();
}

void regulator::common_structs::LobbyNameAvailableReplyStruct::clear()
{
	errCode = 0;
	errDescr.clear();
	userId_.clear();
	suggestedIds.clear();
}

bool regulator::common_structs::LobbyNameAvailableReplyStruct::equals(const LobbyNameAvailableReplyStruct& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(userId_, _o.userId_) &&
		suggestedIds.equals(_o.suggestedIds);
}

const char *regulator::common_structs::LobbyNameAvailableReplyStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userId_=");
		_buf.append(userId_);
		_buf.append(',');
		_buf.append("suggestedIds=");
		suggestedIds.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::common_structs::LobbyNameAvailableReplyStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("userId_", userId_, _buf);
		suggestedIds.toXmlString("suggestedIds", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::common_structs::LobbyNameAvailableReplyStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("errCode"))
		{
			errCode = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errDescr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
		}
		else if (_element.equals("userId_"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId_)) return false;
		}
		else if (_element.equals("suggestedIds"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, suggestedIds)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::common_structs::LobbyNameAvailableReplyStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(userId_);
		suggestedIds.composeMsg(_msg, _ignoreJSON);
	}
}

void regulator::common_structs::LobbyNameAvailableReplyStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(userId_);
		suggestedIds.parseMsg(_parser);
	}
}

const char *regulator::common_structs::LobbyNameAvailableReplyStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("userId_", userId_);
		_jsonstr.compose("suggestedIds", suggestedIds);
	}
	return _buf.c_str();
}

void regulator::common_structs::LobbyNameAvailableReplyStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("userId_", userId_);
		_jparser.parseByNameThrow("suggestedIds", suggestedIds);
	}
}

/* static */ void regulator::common_structs::LobbyNameAvailableReplyStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString userId_; _jparser.validateByNameThrow("userId_", userId_);
		AtfValidator::validateInt(_descr, "userId_", userId_.length(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< PString > suggestedIds; _jparser.validateByNameThrow("suggestedIds", suggestedIds);
		AtfValidator::validateInt(_descr, "suggestedIds", suggestedIds.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::common_structs::LobbyNameAvailableReplyStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "userId_"); size_t szUserId_ = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId_", szUserId_, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szSuggestedIds = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("suggestedIds"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "suggestedIds", szSuggestedIds, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    EmailAttachmentStruct
//=================================================================

regulator::common_structs::EmailAttachmentStruct::EmailAttachmentStruct()
{
	clear();
}

void regulator::common_structs::EmailAttachmentStruct::clear()
{
	attName.clear();
	attBody.clear();
}

bool regulator::common_structs::EmailAttachmentStruct::equals(const EmailAttachmentStruct& _o) const
{
	return Atf::atfPStringEquals(attName, _o.attName) &&
		attBody.size() == _o.attBody.size() && memcmp(attBody.ptr(), _o.attBody.ptr(), attBody.size()) == 0;
}

const char *regulator::common_structs::EmailAttachmentStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("attName=");
	_buf.append(attName);
	_buf.append(',');
	_buf.append("attBody=");
	Atf::AtfTempl<PBlock>::ToTraceString(_buf, attBody);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::common_structs::EmailAttachmentStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("attName", attName, _buf);
	Atf::XmlElement::encodeAsXmlElement("attBody", attBody, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::common_structs::EmailAttachmentStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("attName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, attName)) return false;
		}
		else if (_element.equals("attBody"))
		{
			Atf::XmlElement::_movePBlockWithNullStrip(_value, attBody);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::common_structs::EmailAttachmentStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(attName);
	_msg._composeVarBlock(attBody.ptr(), attBody.size());
}

void regulator::common_structs::EmailAttachmentStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(attName);
	_parser.parsePBlock(attBody);
}

const char *regulator::common_structs::EmailAttachmentStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("attName", attName);
	_jsonstr.compose("attBody", attBody);
	return _buf.c_str();
}

void regulator::common_structs::EmailAttachmentStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("attName", attName);
	_jparser.parseByNameThrow("attBody", attBody);
}

/* static */ void regulator::common_structs::EmailAttachmentStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString attName; _jparser.validateByNameThrow("attName", attName);
	AtfValidator::validateIntMax(_descr, "attName", attName.length(), 10000, _checker, __FILE__, __LINE__);
	PBlock attBody; _jparser.validateByNameThrow("attBody", attBody);
	AtfValidator::validateIntMax(_descr, "attBody", attBody.size(), 10000000, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::common_structs::EmailAttachmentStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "attName"); size_t szAttName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "attName", szAttName, 10000, _checker, __FILE__, __LINE__);
	const BYTE* attBody; size_t szAttBody; _parser._parseVarBlock(attBody, szAttBody);  /*attBody*/
	AtfValidator::validateIntMax(_descr, "attBody", szAttBody, 10000000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    EmailAttachmentVec
//=================================================================

regulator::common_structs::EmailAttachmentVec::EmailAttachmentVec()
{
	clear();
}

void regulator::common_structs::EmailAttachmentVec::clear()
{
	attachments.clear();
}

bool regulator::common_structs::EmailAttachmentVec::equals(const EmailAttachmentVec& _o) const
{
	return attachments.equals(_o.attachments);
}

const char *regulator::common_structs::EmailAttachmentVec::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("attachments=");
	attachments.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::common_structs::EmailAttachmentVec::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	attachments.toXmlString("attachments", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::common_structs::EmailAttachmentVec::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("attachments"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< EmailAttachmentStruct, 4 > >::FromXmlString(_value, attachments)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::common_structs::EmailAttachmentVec::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	attachments.composeMsg(_msg, _ignoreJSON);
}

void regulator::common_structs::EmailAttachmentVec::parseMsg(CommMsgParser& _parser)
{
	attachments.parseMsg(_parser);
}

const char *regulator::common_structs::EmailAttachmentVec::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("attachments", attachments);
	return _buf.c_str();
}

void regulator::common_structs::EmailAttachmentVec::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("attachments", attachments);
}

/* static */ void regulator::common_structs::EmailAttachmentVec::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< EmailAttachmentStruct > attachments; _jparser.validateByNameThrow("attachments", attachments);
	AtfValidator::validateIntMax(_descr, "attachments", attachments.size(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::common_structs::EmailAttachmentVec::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szAttachments = Atf::LAtfVector< EmailAttachmentStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("attachments"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "attachments", szAttachments, 10000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    EmailAttachmentPart
//=================================================================

regulator::common_structs::EmailAttachmentPart::EmailAttachmentPart()
{
	clear();
}

void regulator::common_structs::EmailAttachmentPart::clear()
{
	clientVersion.clear();
	clientOsInfo.clear();
	attachments.clear();
}

bool regulator::common_structs::EmailAttachmentPart::equals(const EmailAttachmentPart& _o) const
{
	return Atf::atfPStringEquals(clientVersion, _o.clientVersion) &&
		Atf::atfPStringEquals(clientOsInfo, _o.clientOsInfo) &&
		attachments.equals(_o.attachments);
}

const char *regulator::common_structs::EmailAttachmentPart::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("clientVersion=");
	_buf.append(clientVersion);
	_buf.append(',');
	_buf.append("clientOsInfo=");
	_buf.append(clientOsInfo);
	_buf.append(',');
	_buf.append("attachments=");
	attachments.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::common_structs::EmailAttachmentPart::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("clientVersion", clientVersion, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientOsInfo", clientOsInfo, _buf);
	attachments.toXmlString("attachments", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::common_structs::EmailAttachmentPart::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("clientVersion"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clientVersion)) return false;
		}
		else if (_element.equals("clientOsInfo"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clientOsInfo)) return false;
		}
		else if (_element.equals("attachments"))
		{
			if(!Atf::AtfTempl< EmailAttachmentVec >::FromXmlString(_value, attachments)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::common_structs::EmailAttachmentPart::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(clientVersion);
	_msg.composeString(clientOsInfo);
	attachments.composeMsg(_msg, _ignoreJSON);
}

void regulator::common_structs::EmailAttachmentPart::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(clientVersion);
	_parser.parseStringP(clientOsInfo);
	if(_parser.parseEnded()) return;
	attachments.parseMsg(_parser);
}

const char *regulator::common_structs::EmailAttachmentPart::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clientVersion", clientVersion);
	_jsonstr.compose("clientOsInfo", clientOsInfo);
	_jsonstr.compose("attachments", attachments);
	return _buf.c_str();
}

void regulator::common_structs::EmailAttachmentPart::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clientVersion", clientVersion);
	_jparser.parseByNameThrow("clientOsInfo", clientOsInfo);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("attachments", attachments);
}

/* static */ void regulator::common_structs::EmailAttachmentPart::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString clientVersion; _jparser.validateByNameThrow("clientVersion", clientVersion);
	AtfValidator::validateIntMax(_descr, "clientVersion", clientVersion.length(), 100, _checker, __FILE__, __LINE__);
	PString clientOsInfo; _jparser.validateByNameThrow("clientOsInfo", clientOsInfo);
	AtfValidator::validateIntMax(_descr, "clientOsInfo", clientOsInfo.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	EmailAttachmentVec attachments; _jparser.validateByNameThrow("attachments", attachments);
}

/*static*/ void regulator::common_structs::EmailAttachmentPart::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "clientVersion"); size_t szClientVersion = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientVersion", szClientVersion, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "clientOsInfo"); size_t szClientOsInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientOsInfo", szClientOsInfo, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	EmailAttachmentVec::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("attachments"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    LobbyClientToSupportEmailStruct
//=================================================================

regulator::common_structs::LobbyClientToSupportEmailStruct::LobbyClientToSupportEmailStruct()
{
	clear();
}

void regulator::common_structs::LobbyClientToSupportEmailStruct::clear()
{
	userId.clear();
	category = 0;
	subCategory = 0;
	subject.clear();
	body.clear();
	attPart.clear();
}

bool regulator::common_structs::LobbyClientToSupportEmailStruct::equals(const LobbyClientToSupportEmailStruct& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		category == _o.category &&
		subCategory == _o.subCategory &&
		Atf::atfPStringEquals(subject, _o.subject) &&
		Atf::atfPStringEquals(body, _o.body) &&
		attPart.equals(_o.attPart);
}

const char *regulator::common_structs::LobbyClientToSupportEmailStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("category=");
	_buf.appendUint(category);
	_buf.append(',');
	_buf.append("subCategory=");
	_buf.appendUint(subCategory);
	_buf.append(',');
	_buf.append("subject=");
	_buf.append(subject);
	_buf.append(',');
	_buf.append("body=");
	_buf.append(body);
	_buf.append(',');
	_buf.append("attPart=");
	attPart.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::common_structs::LobbyClientToSupportEmailStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("category", category, _buf);
	Atf::XmlElement::encodeAsXmlElement("subCategory", subCategory, _buf);
	Atf::XmlElement::encodeAsXmlElement("subject", subject, _buf);
	Atf::XmlElement::encodeAsXmlElement("body", body, _buf);
	attPart.toXmlString("attPart", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::common_structs::LobbyClientToSupportEmailStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("category"))
		{
			category = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("subCategory"))
		{
			subCategory = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("subject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, subject)) return false;
		}
		else if (_element.equals("body"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, body)) return false;
		}
		else if (_element.equals("attPart"))
		{
			if(!Atf::AtfTempl< EmailAttachmentPart >::FromXmlString(_value, attPart)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::common_structs::LobbyClientToSupportEmailStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(category);
	_msg.composeUINT32(subCategory);
	_msg.composeString(subject);
	_msg.composeString(body);
	attPart.composeMsg(_msg, _ignoreJSON);
}

void regulator::common_structs::LobbyClientToSupportEmailStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(category);
	_parser.parseUINT32(subCategory);
	_parser.parseStringP(subject);
	_parser.parseStringP(body);
	if(_parser.parseEnded()) return;
	attPart.parseMsg(_parser);
}

const char *regulator::common_structs::LobbyClientToSupportEmailStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("category", category);
	_jsonstr.compose("subCategory", subCategory);
	_jsonstr.compose("subject", subject);
	_jsonstr.compose("body", body);
	_jsonstr.compose("attPart", attPart);
	return _buf.c_str();
}

void regulator::common_structs::LobbyClientToSupportEmailStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("category", category);
	_jparser.parseByNameThrow("subCategory", subCategory);
	_jparser.parseByNameThrow("subject", subject);
	_jparser.parseByNameThrow("body", body);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("attPart", attPart);
}

/* static */ void regulator::common_structs::LobbyClientToSupportEmailStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 category; _jparser.validateByNameThrow("category", category);
	AtfValidator::validateIntRange(_descr, "category", category, eClientEmailCategory_None, eClientEmailCategory_Last, _checker, __FILE__, __LINE__);
	UINT32 subCategory; _jparser.validateByNameThrow("subCategory", subCategory);
	AtfValidator::validateInt(_descr, "subCategory", subCategory, _checker, __FILE__, __LINE__);
	PString subject; _jparser.validateByNameThrow("subject", subject);
	AtfValidator::validateIntMax(_descr, "subject", subject.length(), EMAIL_SUBJ_LEN, _checker, __FILE__, __LINE__);
	PString body; _jparser.validateByNameThrow("body", body);
	AtfValidator::validateIntMax(_descr, "body", body.length(), 10000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	EmailAttachmentPart attPart; _jparser.validateByNameThrow("attPart", attPart);
}

/*static*/ void regulator::common_structs::LobbyClientToSupportEmailStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 category; _parser.parseUINT32(category);
	AtfValidator::validateIntRange(_descr, "category", category, eClientEmailCategory_None, eClientEmailCategory_Last, _checker, __FILE__, __LINE__);
	UINT32 subCategory; _parser.parseUINT32(subCategory);
	AtfValidator::validateInt(_descr, "subCategory", subCategory, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "subject"); size_t szSubject = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "subject", szSubject, EMAIL_SUBJ_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "body"); size_t szBody = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "body", szBody, 10000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	EmailAttachmentPart::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("attPart"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    LobbyClientToSupportEmailReplyStruct
//=================================================================

regulator::common_structs::LobbyClientToSupportEmailReplyStruct::LobbyClientToSupportEmailReplyStruct()
{
	clear();
}

void regulator::common_structs::LobbyClientToSupportEmailReplyStruct::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::common_structs::LobbyClientToSupportEmailReplyStruct::equals(const LobbyClientToSupportEmailReplyStruct& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

const char *regulator::common_structs::LobbyClientToSupportEmailReplyStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::common_structs::LobbyClientToSupportEmailReplyStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::common_structs::LobbyClientToSupportEmailReplyStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("errCode"))
		{
			errCode = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errDescr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::common_structs::LobbyClientToSupportEmailReplyStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::common_structs::LobbyClientToSupportEmailReplyStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::common_structs::LobbyClientToSupportEmailReplyStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::common_structs::LobbyClientToSupportEmailReplyStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/* static */ void regulator::common_structs::LobbyClientToSupportEmailReplyStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::common_structs::LobbyClientToSupportEmailReplyStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    ChallengeAnswer
//=================================================================

regulator::common_structs::ChallengeAnswer::ChallengeAnswer()
{
	clear();
}

void regulator::common_structs::ChallengeAnswer::clear()
{
	answer.clear();
}

bool regulator::common_structs::ChallengeAnswer::equals(const ChallengeAnswer& _o) const
{
	return Atf::atfPStringEquals(answer, _o.answer);
}

const char *regulator::common_structs::ChallengeAnswer::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("answer=");
	_buf.append(answer);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::common_structs::ChallengeAnswer::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("answer", answer, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::common_structs::ChallengeAnswer::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("answer"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, answer)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::common_structs::ChallengeAnswer::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(answer);
}

void regulator::common_structs::ChallengeAnswer::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(answer);
}

const char *regulator::common_structs::ChallengeAnswer::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("answer", answer);
	return _buf.c_str();
}

void regulator::common_structs::ChallengeAnswer::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("answer", answer);
}

/* static */ void regulator::common_structs::ChallengeAnswer::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString answer; _jparser.validateByNameThrow("answer", answer);
	AtfValidator::validateIntMax(_descr, "answer", answer.length(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::common_structs::ChallengeAnswer::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "answer"); size_t szAnswer = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer", szAnswer, 10000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    UserProfile
//=================================================================

regulator::common_structs::UserProfile::UserProfile()
{
	clear();
}

void regulator::common_structs::UserProfile::clear()
{
	firstName.clear();
	lastName.clear();
	sex.clear();
	addr_1.clear();
	citymaxlen.clear();
	state.clear();
	country.clear();
	zipCode.clear();
	birthDate.setNull();
	birthCity.clear();
	birthState.clear();
	birthCountry.clear();
	phone.clear();
	mobile.clear();
	email.clear();
	fiscalCode.clear();
	documentType = 0;
	documentNumber.clear();
	documentIssueDate.setNull();
	documentPlaceOfIssue.clear();
	documentIssuingAuthority = 0;
	flags = 0;
	flags2 = 0;
	profession.clear();
}

bool regulator::common_structs::UserProfile::equals(const UserProfile& _o) const
{
	return Atf::atfPStringEquals(firstName, _o.firstName) &&
		Atf::atfPStringEquals(lastName, _o.lastName) &&
		Atf::atfPStringEquals(sex, _o.sex) &&
		Atf::atfPStringEquals(addr_1, _o.addr_1) &&
		Atf::atfPStringEquals(citymaxlen, _o.citymaxlen) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(country, _o.country) &&
		Atf::atfPStringEquals(zipCode, _o.zipCode) &&
		birthDate.equals(_o.birthDate) &&
		Atf::atfPStringEquals(birthCity, _o.birthCity) &&
		Atf::atfPStringEquals(birthState, _o.birthState) &&
		Atf::atfPStringEquals(birthCountry, _o.birthCountry) &&
		Atf::atfPStringEquals(phone, _o.phone) &&
		Atf::atfPStringEquals(mobile, _o.mobile) &&
		Atf::atfPStringEquals(email, _o.email) &&
		Atf::atfPStringEquals(fiscalCode, _o.fiscalCode) &&
		documentType == _o.documentType &&
		Atf::atfPStringEquals(documentNumber, _o.documentNumber) &&
		documentIssueDate.equals(_o.documentIssueDate) &&
		Atf::atfPStringEquals(documentPlaceOfIssue, _o.documentPlaceOfIssue) &&
		documentIssuingAuthority == _o.documentIssuingAuthority &&
		flags == _o.flags &&
		flags2 == _o.flags2 &&
		Atf::atfPStringEquals(profession, _o.profession);
}

const char *regulator::common_structs::UserProfile::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("firstName=");
	_buf.append(firstName);
	_buf.append(',');
	_buf.append("lastName=");
	_buf.append(lastName);
	_buf.append(',');
	_buf.append("sex=");
	_buf.append(sex);
	_buf.append(',');
	_buf.append("addr_1=");
	_buf.append(addr_1);
	_buf.append(',');
	_buf.append("citymaxlen=");
	_buf.append(citymaxlen);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("zipCode=");
	_buf.append(zipCode);
	_buf.append(',');
	_buf.append("birthDate=");
	Atf::AtfTempl<CommSrvDate>::ToTraceString(_buf, birthDate);
	_buf.append(',');
	_buf.append("birthCity=");
	_buf.append(birthCity);
	_buf.append(',');
	_buf.append("birthState=");
	_buf.append(birthState);
	_buf.append(',');
	_buf.append("birthCountry=");
	_buf.append(birthCountry);
	_buf.append(',');
	_buf.append("phone=");
	_buf.append(phone);
	_buf.append(',');
	_buf.append("mobile=");
	_buf.append(mobile);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("fiscalCode=");
	_buf.append(fiscalCode);
	_buf.append(',');
	_buf.append("documentType=");
	_buf.appendUint(documentType);
	_buf.append(',');
	_buf.append("documentNumber=");
	_buf.append(documentNumber);
	_buf.append(',');
	_buf.append("documentIssueDate=");
	Atf::AtfTempl<CommSrvDate>::ToTraceString(_buf, documentIssueDate);
	_buf.append(',');
	_buf.append("documentPlaceOfIssue=");
	_buf.append(documentPlaceOfIssue);
	_buf.append(',');
	_buf.append("documentIssuingAuthority=");
	_buf.appendUint(documentIssuingAuthority);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("profession=");
	_buf.append(profession);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::common_structs::UserProfile::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("firstName", firstName, _buf);
	Atf::XmlElement::encodeAsXmlElement("lastName", lastName, _buf);
	Atf::XmlElement::encodeAsXmlElement("sex", sex, _buf);
	Atf::XmlElement::encodeAsXmlElement("addr_1", addr_1, _buf);
	Atf::XmlElement::encodeAsXmlElement("citymaxlen", citymaxlen, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("zipCode", zipCode, _buf);
	Atf::AtfTempl<CommSrvDate>::ToXmlString(_buf, "birthDate", birthDate);
	Atf::XmlElement::encodeAsXmlElement("birthCity", birthCity, _buf);
	Atf::XmlElement::encodeAsXmlElement("birthState", birthState, _buf);
	Atf::XmlElement::encodeAsXmlElement("birthCountry", birthCountry, _buf);
	Atf::XmlElement::encodeAsXmlElement("phone", phone, _buf);
	Atf::XmlElement::encodeAsXmlElement("mobile", mobile, _buf);
	Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	Atf::XmlElement::encodeAsXmlElement("fiscalCode", fiscalCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("documentType", documentType, _buf);
	Atf::XmlElement::encodeAsXmlElement("documentNumber", documentNumber, _buf);
	Atf::AtfTempl<CommSrvDate>::ToXmlString(_buf, "documentIssueDate", documentIssueDate);
	Atf::XmlElement::encodeAsXmlElement("documentPlaceOfIssue", documentPlaceOfIssue, _buf);
	Atf::XmlElement::encodeAsXmlElement("documentIssuingAuthority", documentIssuingAuthority, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags2", flags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("profession", profession, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::common_structs::UserProfile::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("firstName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, firstName)) return false;
		}
		else if (_element.equals("lastName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, lastName)) return false;
		}
		else if (_element.equals("sex"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, sex)) return false;
		}
		else if (_element.equals("addr_1"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, addr_1)) return false;
		}
		else if (_element.equals("citymaxlen"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, citymaxlen)) return false;
		}
		else if (_element.equals("state"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("zipCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, zipCode)) return false;
		}
		else if (_element.equals("birthDate"))
		{
			Atf::AtfTempl<CommSrvDate>::FromXmlString(_value, birthDate);
		}
		else if (_element.equals("birthCity"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, birthCity)) return false;
		}
		else if (_element.equals("birthState"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, birthState)) return false;
		}
		else if (_element.equals("birthCountry"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, birthCountry)) return false;
		}
		else if (_element.equals("phone"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, phone)) return false;
		}
		else if (_element.equals("mobile"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, mobile)) return false;
		}
		else if (_element.equals("email"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
		}
		else if (_element.equals("fiscalCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, fiscalCode)) return false;
		}
		else if (_element.equals("documentType"))
		{
			documentType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("documentNumber"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, documentNumber)) return false;
		}
		else if (_element.equals("documentIssueDate"))
		{
			Atf::AtfTempl<CommSrvDate>::FromXmlString(_value, documentIssueDate);
		}
		else if (_element.equals("documentPlaceOfIssue"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, documentPlaceOfIssue)) return false;
		}
		else if (_element.equals("documentIssuingAuthority"))
		{
			documentIssuingAuthority = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags2"))
		{
			flags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("profession"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, profession)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::common_structs::UserProfile::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(firstName);
	_msg.composeString(lastName);
	_msg.composeString(sex);
	_msg.composeString(addr_1);
	_msg.composeString(citymaxlen);
	_msg.composeString(state);
	_msg.composeString(country);
	_msg.composeString(zipCode);
	_msg.composeSrvDate(birthDate);
	_msg.composeString(birthCity);
	_msg.composeString(birthState);
	_msg.composeString(birthCountry);
	_msg.composeString(phone);
	_msg.composeString(mobile);
	_msg.composeString(email);
	_msg.composeString(fiscalCode);
	_msg.composeUINT32(documentType);
	_msg.composeString(documentNumber);
	_msg.composeSrvDate(documentIssueDate);
	_msg.composeString(documentPlaceOfIssue);
	_msg.composeUINT32(documentIssuingAuthority);
	_msg.composeUINT32(flags);
	_msg.composeUINT64(flags2);
	_msg.composeString(profession);
}

void regulator::common_structs::UserProfile::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(firstName);
	_parser.parseStringP(lastName);
	_parser.parseStringP(sex);
	_parser.parseStringP(addr_1);
	_parser.parseStringP(citymaxlen);
	_parser.parseStringP(state);
	_parser.parseStringP(country);
	_parser.parseStringP(zipCode);
	_parser.parseSrvDate(birthDate);
	_parser.parseStringP(birthCity);
	_parser.parseStringP(birthState);
	_parser.parseStringP(birthCountry);
	_parser.parseStringP(phone);
	_parser.parseStringP(mobile);
	_parser.parseStringP(email);
	_parser.parseStringP(fiscalCode);
	_parser.parseUINT32(documentType);
	_parser.parseStringP(documentNumber);
	_parser.parseSrvDate(documentIssueDate);
	_parser.parseStringP(documentPlaceOfIssue);
	_parser.parseUINT32(documentIssuingAuthority);
	_parser.parseUINT32(flags);
	_parser.parseUINT64(flags2);
	_parser.parseStringP(profession);
}

const char *regulator::common_structs::UserProfile::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("firstName", firstName);
	_jsonstr.compose("lastName", lastName);
	_jsonstr.compose("sex", sex);
	_jsonstr.compose("addr_1", addr_1);
	_jsonstr.compose("citymaxlen", citymaxlen);
	_jsonstr.compose("state", state);
	_jsonstr.compose("country", country);
	_jsonstr.compose("zipCode", zipCode);
	_jsonstr.compose("birthDate", birthDate);
	_jsonstr.compose("birthCity", birthCity);
	_jsonstr.compose("birthState", birthState);
	_jsonstr.compose("birthCountry", birthCountry);
	_jsonstr.compose("phone", phone);
	_jsonstr.compose("mobile", mobile);
	_jsonstr.compose("email", email);
	_jsonstr.compose("fiscalCode", fiscalCode);
	_jsonstr.compose("documentType", documentType);
	_jsonstr.compose("documentNumber", documentNumber);
	_jsonstr.compose("documentIssueDate", documentIssueDate);
	_jsonstr.compose("documentPlaceOfIssue", documentPlaceOfIssue);
	_jsonstr.compose("documentIssuingAuthority", documentIssuingAuthority);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("flags2", flags2);
	_jsonstr.compose("profession", profession);
	return _buf.c_str();
}

void regulator::common_structs::UserProfile::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("firstName", firstName);
	_jparser.parseByNameThrow("lastName", lastName);
	_jparser.parseByNameThrow("sex", sex);
	_jparser.parseByNameThrow("addr_1", addr_1);
	_jparser.parseByNameThrow("citymaxlen", citymaxlen);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("zipCode", zipCode);
	_jparser.parseByNameThrow("birthDate", birthDate);
	_jparser.parseByNameThrow("birthCity", birthCity);
	_jparser.parseByNameThrow("birthState", birthState);
	_jparser.parseByNameThrow("birthCountry", birthCountry);
	_jparser.parseByNameThrow("phone", phone);
	_jparser.parseByNameThrow("mobile", mobile);
	_jparser.parseByNameThrow("email", email);
	_jparser.parseByNameThrow("fiscalCode", fiscalCode);
	_jparser.parseByNameThrow("documentType", documentType);
	_jparser.parseByNameThrow("documentNumber", documentNumber);
	_jparser.parseByNameThrow("documentIssueDate", documentIssueDate);
	_jparser.parseByNameThrow("documentPlaceOfIssue", documentPlaceOfIssue);
	_jparser.parseByNameThrow("documentIssuingAuthority", documentIssuingAuthority);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("flags2", flags2);
	_jparser.parseByNameThrow("profession", profession);
}

/* static */ void regulator::common_structs::UserProfile::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString firstName; _jparser.validateByNameThrow("firstName", firstName);
	AtfValidator::validateIntMax(_descr, "firstName", firstName.length(), USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	PString lastName; _jparser.validateByNameThrow("lastName", lastName);
	AtfValidator::validateIntMax(_descr, "lastName", lastName.length(), USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
	PString sex; _jparser.validateByNameThrow("sex", sex);
	AtfValidator::validateIntMax(_descr, "sex", sex.length(), USER_SEX_LEN, _checker, __FILE__, __LINE__);
	PString addr_1; _jparser.validateByNameThrow("addr_1", addr_1);
	AtfValidator::validateIntMax(_descr, "addr_1", addr_1.length(), USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	PString citymaxlen; _jparser.validateByNameThrow("citymaxlen", citymaxlen);
	AtfValidator::validateIntMax(_descr, "citymaxlen", citymaxlen.length(), USER_CITY_LEN, _checker, __FILE__, __LINE__);
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateIntMax(_descr, "state", state.length(), USER_STATE_LEN, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	PString zipCode; _jparser.validateByNameThrow("zipCode", zipCode);
	AtfValidator::validateIntMax(_descr, "zipCode", zipCode.length(), USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	CommSrvDate birthDate; _jparser.validateByNameThrow("birthDate", birthDate);
	AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
	PString birthCity; _jparser.validateByNameThrow("birthCity", birthCity);
	AtfValidator::validateIntMax(_descr, "birthCity", birthCity.length(), USER_CITY_LEN, _checker, __FILE__, __LINE__);
	PString birthState; _jparser.validateByNameThrow("birthState", birthState);
	AtfValidator::validateIntMax(_descr, "birthState", birthState.length(), USER_STATE_LEN, _checker, __FILE__, __LINE__);
	PString birthCountry; _jparser.validateByNameThrow("birthCountry", birthCountry);
	AtfValidator::validateIntMax(_descr, "birthCountry", birthCountry.length(), USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	PString phone; _jparser.validateByNameThrow("phone", phone);
	AtfValidator::validateIntMax(_descr, "phone", phone.length(), 100, _checker, __FILE__, __LINE__);
	PString mobile; _jparser.validateByNameThrow("mobile", mobile);
	AtfValidator::validateIntMax(_descr, "mobile", mobile.length(), USER_MOBILE_LEN, _checker, __FILE__, __LINE__);
	PString email; _jparser.validateByNameThrow("email", email);
	AtfValidator::validateIntMax(_descr, "email", email.length(), USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	PString fiscalCode; _jparser.validateByNameThrow("fiscalCode", fiscalCode);
	AtfValidator::validateIntMax(_descr, "fiscalCode", fiscalCode.length(), USER_FISCAL_CODE_LEN, _checker, __FILE__, __LINE__);
	UINT32 documentType; _jparser.validateByNameThrow("documentType", documentType);
	AtfValidator::validateInt(_descr, "documentType", documentType, _checker, __FILE__, __LINE__);
	PString documentNumber; _jparser.validateByNameThrow("documentNumber", documentNumber);
	AtfValidator::validateIntMax(_descr, "documentNumber", documentNumber.length(), 100, _checker, __FILE__, __LINE__);
	CommSrvDate documentIssueDate; _jparser.validateByNameThrow("documentIssueDate", documentIssueDate);
	AtfValidator::validateSrvDateTime(_descr, "documentIssueDate", documentIssueDate, _checker, __FILE__, __LINE__);
	PString documentPlaceOfIssue; _jparser.validateByNameThrow("documentPlaceOfIssue", documentPlaceOfIssue);
	AtfValidator::validateIntMax(_descr, "documentPlaceOfIssue", documentPlaceOfIssue.length(), 300, _checker, __FILE__, __LINE__);
	UINT32 documentIssuingAuthority; _jparser.validateByNameThrow("documentIssuingAuthority", documentIssuingAuthority);
	AtfValidator::validateIntMax(_descr, "documentIssuingAuthority", documentIssuingAuthority, 100, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateIntRange(_descr, "flags", flags, 0, ((UINT32(1)<<(userFlagsLastUsedBit+UINT32(1)))-UINT32(1)), _checker, __FILE__, __LINE__);
	UINT64 flags2; _jparser.validateByNameThrow("flags2", flags2);
	AtfValidator::validateUintRange(_descr, "flags2", flags2, 0, ((ONE64<<(userFlags2LastUsedBit+ONE64))-ONE64), _checker, __FILE__, __LINE__);
	PString profession; _jparser.validateByNameThrow("profession", profession);
	AtfValidator::validateIntMax(_descr, "profession", profession.length(), 100, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::common_structs::UserProfile::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "firstName", szFirstName, USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "lastName"); size_t szLastName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "lastName", szLastName, USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "sex"); size_t szSex = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "sex", szSex, USER_SEX_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "addr_1"); size_t szAddr_1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "addr_1", szAddr_1, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "citymaxlen"); size_t szCitymaxlen = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "citymaxlen", szCitymaxlen, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "zipCode"); size_t szZipCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zipCode", szZipCode, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	CommSrvDate birthDate; _parser.parseSrvDate(birthDate);
	AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "birthCity"); size_t szBirthCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "birthCity", szBirthCity, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "birthState"); size_t szBirthState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "birthState", szBirthState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "birthCountry"); size_t szBirthCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "birthCountry", szBirthCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phone", szPhone, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "mobile"); size_t szMobile = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "mobile", szMobile, USER_MOBILE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "fiscalCode"); size_t szFiscalCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fiscalCode", szFiscalCode, USER_FISCAL_CODE_LEN, _checker, __FILE__, __LINE__);
	UINT32 documentType; _parser.parseUINT32(documentType);
	AtfValidator::validateInt(_descr, "documentType", documentType, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "documentNumber"); size_t szDocumentNumber = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "documentNumber", szDocumentNumber, 100, _checker, __FILE__, __LINE__);
	CommSrvDate documentIssueDate; _parser.parseSrvDate(documentIssueDate);
	AtfValidator::validateSrvDateTime(_descr, "documentIssueDate", documentIssueDate, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "documentPlaceOfIssue"); size_t szDocumentPlaceOfIssue = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "documentPlaceOfIssue", szDocumentPlaceOfIssue, 300, _checker, __FILE__, __LINE__);
	UINT32 documentIssuingAuthority; _parser.parseUINT32(documentIssuingAuthority);
	AtfValidator::validateIntMax(_descr, "documentIssuingAuthority", documentIssuingAuthority, 100, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateIntRange(_descr, "flags", flags, 0, ((UINT32(1)<<(userFlagsLastUsedBit+UINT32(1)))-UINT32(1)), _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser.parseUINT64(flags2);
	AtfValidator::validateUintRange(_descr, "flags2", flags2, 0, ((ONE64<<(userFlags2LastUsedBit+ONE64))-ONE64), _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "profession"); size_t szProfession = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "profession", szProfession, 100, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    UserUpdateElement
//=================================================================

regulator::common_structs::UserUpdateElement::UserUpdateElement()
{
	clear();
}

void regulator::common_structs::UserUpdateElement::clear()
{
	updateType = 0;
	addr_1.clear();
	addr_2.clear();
	city.clear();
	state.clear();
	country.clear();
	zipCode.clear();
	email.clear();
	autoValidateEmail = false;
	pwd.clear();
	imageType = 0;
	imgData.clear();
	fullName.clear();
	phone.clear();
	firstName.clear();
	lastName.clear();
	fiscalCode.clear();
	encrFiscalCode.clear();
	properties.clear();
	birthDate.setNull();
	imageId = 0;
	currentImageId = 0;
	isCurrentImageFromGallery = false;
	isGalleryImage = false;
	adminIntId = 0;
	adminId.clear();
	sex.clear();
	mobile.clear();
	verificationCertificate.clear();
	verificationSignedData.clear();
	mailListIn = false;
	mailListPokerIn = false;
	mailListCasinoIn = false;
	mailListSportsIn = false;
	mailListSportsLiveAlertIn = false;
	profile.clear();
	realMoneyOkSet = false;
	comment.clear();
	weeklyDepositLimit = 0;
	buyInLimit = 0;
	isBuyInLimitValid = false;
	sportsAccumulatedLimit = NO_TABLE_LIMIT_MARKER;
	allowSMSPwdReset = false;
	smsMarketingFlagValue = false;
	answer1.clear();
	answer2.clear();
	ssn4.clear();
	booleanActions = 0;
	optinLeaderBoard = false;
	appLoginId = 0;
	brandId = 0;
	requestCtx = 0;
	dummy_makeATFdefinitionForThisUpdateType.clear();
}

bool regulator::common_structs::UserUpdateElement::equals(const UserUpdateElement& _o) const
{
	return updateType == _o.updateType &&
		Atf::atfPStringEquals(addr_1, _o.addr_1) &&
		Atf::atfPStringEquals(addr_2, _o.addr_2) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(country, _o.country) &&
		Atf::atfPStringEquals(zipCode, _o.zipCode) &&
		Atf::atfPStringEquals(email, _o.email) &&
		autoValidateEmail == _o.autoValidateEmail &&
		Atf::atfPStringEquals(pwd, _o.pwd) &&
		imageType == _o.imageType &&
		imgData.size() == _o.imgData.size() && memcmp(imgData.ptr(), _o.imgData.ptr(), imgData.size()) == 0 &&
		Atf::atfPStringEquals(fullName, _o.fullName) &&
		Atf::atfPStringEquals(phone, _o.phone) &&
		Atf::atfPStringEquals(firstName, _o.firstName) &&
		Atf::atfPStringEquals(lastName, _o.lastName) &&
		Atf::atfPStringEquals(fiscalCode, _o.fiscalCode) &&
		Atf::atfPStringEquals(encrFiscalCode, _o.encrFiscalCode) &&
		properties.equals(_o.properties) &&
		birthDate.equals(_o.birthDate) &&
		imageId == _o.imageId &&
		currentImageId == _o.currentImageId &&
		isCurrentImageFromGallery == _o.isCurrentImageFromGallery &&
		isGalleryImage == _o.isGalleryImage &&
		adminIntId == _o.adminIntId &&
		Atf::atfPStringEquals(adminId, _o.adminId) &&
		Atf::atfPStringEquals(sex, _o.sex) &&
		Atf::atfPStringEquals(mobile, _o.mobile) &&
		Atf::atfPStringEquals(verificationCertificate, _o.verificationCertificate) &&
		Atf::atfPStringEquals(verificationSignedData, _o.verificationSignedData) &&
		mailListIn == _o.mailListIn &&
		mailListPokerIn == _o.mailListPokerIn &&
		mailListCasinoIn == _o.mailListCasinoIn &&
		mailListSportsIn == _o.mailListSportsIn &&
		mailListSportsLiveAlertIn == _o.mailListSportsLiveAlertIn &&
		profile.equals(_o.profile) &&
		realMoneyOkSet == _o.realMoneyOkSet &&
		Atf::atfPStringEquals(comment, _o.comment) &&
		weeklyDepositLimit == _o.weeklyDepositLimit &&
		buyInLimit == _o.buyInLimit &&
		isBuyInLimitValid == _o.isBuyInLimitValid &&
		sportsAccumulatedLimit == _o.sportsAccumulatedLimit &&
		allowSMSPwdReset == _o.allowSMSPwdReset &&
		smsMarketingFlagValue == _o.smsMarketingFlagValue &&
		Atf::atfPStringEquals(answer1, _o.answer1) &&
		Atf::atfPStringEquals(answer2, _o.answer2) &&
		Atf::atfPStringEquals(ssn4, _o.ssn4) &&
		booleanActions == _o.booleanActions &&
		optinLeaderBoard == _o.optinLeaderBoard &&
		appLoginId == _o.appLoginId &&
		brandId == _o.brandId &&
		requestCtx == _o.requestCtx &&
		dummy_makeATFdefinitionForThisUpdateType.equals(_o.dummy_makeATFdefinitionForThisUpdateType);
}

const char *regulator::common_structs::UserUpdateElement::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("updateType=");
	_buf.appendUint(updateType);
	if (updateType == eUserUpdateTypeAddress)
	{
		_buf.append(',');
		_buf.append("addr_1=");
		_buf.append(addr_1);
		_buf.append(',');
		_buf.append("addr_2=");
		_buf.append(addr_2);
		_buf.append(',');
		_buf.append("city=");
		_buf.append(city);
		_buf.append(',');
		_buf.append("state=");
		_buf.append(state);
		_buf.append(',');
		_buf.append("country=");
		_buf.append(country);
		_buf.append(',');
		_buf.append("zipCode=");
		_buf.append(zipCode);
	}
	else if (updateType == eUserUpdateTypeEmail)
	{
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
		_buf.append(',');
		_buf.append("autoValidateEmail=");
		_buf.appendUint(autoValidateEmail);
	}
	else if (updateType == eUserUpdateTypePassword)
	{
		_buf.append(',');
		_buf.append("pwd=");
		_buf.append(pwd);
	}
	else if (updateType == eUserUpdateTypeImage)
	{
		_buf.append(',');
		_buf.append("imageType=");
		_buf.appendUint(imageType);
		_buf.append(',');
		_buf.append("imgData=");
		Atf::AtfTempl<PBlock>::ToTraceString(_buf, imgData);
	}
	else if (updateType == eUserUpdateTypeFullName)
	{
		_buf.append(',');
		_buf.append("fullName=");
		_buf.append(fullName);
	}
	else if (updateType == eUserUpdateTypePhone)
	{
		_buf.append(',');
		_buf.append("phone=");
		_buf.append(phone);
	}
	else if (updateType == eUserUpdateTypeRealMoney)
	{
		_buf.append(',');
	}
	else if (updateType == eUserUpdateTypeFirstNameLastName)
	{
		_buf.append(',');
		_buf.append("firstName=");
		_buf.append(firstName);
		_buf.append(',');
		_buf.append("lastName=");
		_buf.append(lastName);
	}
	else if (updateType == eUserUpdateTypeFiscalCode)
	{
		_buf.append(',');
		_buf.append("fiscalCode=");
		_buf.append(fiscalCode);
	}
	else if (updateType == eUserUpdateTypeEncrFiscalCode)
	{
		_buf.append(',');
		_buf.append("encrFiscalCode=");
		_buf.append(encrFiscalCode);
	}
	else if (updateType == eUserUpdateTypeProperties)
	{
		_buf.append(',');
		_buf.append("properties=");
		properties.toTraceString(_buf);
	}
	else if (updateType == eUserUpdateTypeBirthday)
	{
		_buf.append(',');
		_buf.append("birthDate=");
		Atf::AtfTempl<CommSrvDate>::ToTraceString(_buf, birthDate);
	}
	else if (updateType == eUserUpdateTypeImageId)
	{
		_buf.append(',');
		_buf.append("imageId=");
		_buf.appendUint(imageId);
		_buf.append(',');
		_buf.append("currentImageId=");
		_buf.appendUint(currentImageId);
		_buf.append(',');
		_buf.append("isCurrentImageFromGallery=");
		_buf.appendUint(isCurrentImageFromGallery);
	}
	else if (updateType == eUserUpdateTypeSwitchImageId)
	{
		_buf.append(',');
		_buf.append("imageId=");
		_buf.appendUint(imageId);
		_buf.append(',');
		_buf.append("isGalleryImage=");
		_buf.appendUint(isGalleryImage);
		_buf.append(',');
		_buf.append("currentImageId=");
		_buf.appendUint(currentImageId);
		_buf.append(',');
		_buf.append("isCurrentImageFromGallery=");
		_buf.appendUint(isCurrentImageFromGallery);
		_buf.append(',');
		_buf.append("adminIntId=");
		_buf.appendUint(adminIntId);
		_buf.append(',');
		_buf.append("adminId=");
		_buf.append(adminId);
	}
	else if (updateType == eUserUpdateTypeSex)
	{
		_buf.append(',');
		_buf.append("sex=");
		_buf.append(sex);
	}
	else if (updateType == eUserUpdateTypeMobile)
	{
		_buf.append(',');
		_buf.append("mobile=");
		_buf.append(mobile);
	}
	else if (updateType == eUserUpdateTypeEstoniaValidation)
	{
		_buf.append(',');
		_buf.append("verificationCertificate=");
		_buf.append(verificationCertificate);
		_buf.append(',');
		_buf.append("verificationSignedData=");
		_buf.append(verificationSignedData);
	}
	else if (updateType == eUserUpdateTypeMailList)
	{
		_buf.append(',');
		_buf.append("mailListIn=");
		_buf.appendUint(mailListIn);
	}
	else if (updateType == eUserUpdateTypeMailListNew)
	{
		_buf.append(',');
		_buf.append("mailListPokerIn=");
		_buf.appendUint(mailListPokerIn);
		_buf.append(',');
		_buf.append("mailListCasinoIn=");
		_buf.appendUint(mailListCasinoIn);
		_buf.append(',');
		_buf.append("mailListSportsIn=");
		_buf.appendUint(mailListSportsIn);
		_buf.append(',');
		_buf.append("mailListSportsLiveAlertIn=");
		_buf.appendUint(mailListSportsLiveAlertIn);
	}
	else if (updateType == eUserUpdateTypeExternalValidation)
	{
		_buf.append(',');
		_buf.append("profile=");
		profile.toTraceString(_buf);
	}
	else if (updateType == eUserUpdateTypeRealMoneyOkFlag)
	{
		_buf.append(',');
		_buf.append("realMoneyOkSet=");
		_buf.appendUint(realMoneyOkSet);
		_buf.append(',');
		_buf.append("comment=");
		_buf.append(comment);
	}
	else if (updateType == eUserUpdateTypeSetLimits)
	{
		_buf.append(',');
		_buf.append("weeklyDepositLimit=");
		_buf.appendInt(weeklyDepositLimit);
		_buf.append(',');
		_buf.append("buyInLimit=");
		_buf.appendInt(buyInLimit);
		_buf.append(',');
		_buf.append("isBuyInLimitValid=");
		_buf.appendUint(isBuyInLimitValid);
		_buf.append(',');
		_buf.append("sportsAccumulatedLimit=");
		_buf.appendInt(sportsAccumulatedLimit);
	}
	else if (updateType == eUserUpdateTypeSMSPwdReset)
	{
		_buf.append(',');
		_buf.append("allowSMSPwdReset=");
		_buf.appendUint(allowSMSPwdReset);
	}
	else if (updateType == eUserUpdateTypeSmsMarketingFlag)
	{
		_buf.append(',');
		_buf.append("smsMarketingFlagValue=");
		_buf.appendUint(smsMarketingFlagValue);
	}
	else if (updateType == eUserUpdateTypePwdStrongAuth)
	{
		_buf.append(',');
		_buf.append("answer1=");
		_buf.append(answer1);
		_buf.append(',');
		_buf.append("answer2=");
		_buf.append(answer2);
		_buf.append(',');
		_buf.append("ssn4=");
		_buf.append(ssn4);
	}
	else if (updateType == eUserUpdateTypeBooleanActions)
	{
		_buf.append(',');
		_buf.append("booleanActions=");
		_buf.appendUint(booleanActions);
	}
	else if (updateType == eUserUpdateTypeLeaderBoard)
	{
		_buf.append(',');
		_buf.append("optinLeaderBoard=");
		_buf.appendUint(optinLeaderBoard);
	}
	else if (updateType == eUserUpdateTypeInternalServerNonUpdInfo)
	{
		_buf.append(',');
		_buf.append("appLoginId=");
		_buf.appendUint64(appLoginId);
		_buf.append(',');
		_buf.append("brandId=");
		_buf.appendUint(brandId);
		_buf.append(',');
		_buf.append("adminIntId=");
		_buf.appendUint(adminIntId);
		_buf.append(',');
		_buf.append("adminId=");
		_buf.append(adminId);
	}
	else if (updateType == eUserUpdateTypeAgeVerification)
	{
		_buf.append(',');
		_buf.append("requestCtx=");
		_buf.appendInt(requestCtx);
	}
	else
	{
		_buf.append(',');
		_buf.append("dummy_makeATFdefinitionForThisUpdateType=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(dummy_makeATFdefinitionForThisUpdateType, _buf); _buf.append('}');
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::common_structs::UserUpdateElement::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("updateType", updateType, _buf);
	if (updateType == eUserUpdateTypeAddress)
	{
		Atf::XmlElement::encodeAsXmlElement("addr_1", addr_1, _buf);
		Atf::XmlElement::encodeAsXmlElement("addr_2", addr_2, _buf);
		Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
		Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
		Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
		Atf::XmlElement::encodeAsXmlElement("zipCode", zipCode, _buf);
	}
	else if (updateType == eUserUpdateTypeEmail)
	{
		Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
		Atf::XmlElement::encodeAsXmlElement("autoValidateEmail", autoValidateEmail, _buf);
	}
	else if (updateType == eUserUpdateTypePassword)
	{
		Atf::XmlElement::encodeAsXmlElement("pwd", pwd, _buf);
	}
	else if (updateType == eUserUpdateTypeImage)
	{
		Atf::XmlElement::encodeAsXmlElement("imageType", imageType, _buf);
		Atf::XmlElement::encodeAsXmlElement("imgData", imgData, _buf);
	}
	else if (updateType == eUserUpdateTypeFullName)
	{
		Atf::XmlElement::encodeAsXmlElement("fullName", fullName, _buf);
	}
	else if (updateType == eUserUpdateTypePhone)
	{
		Atf::XmlElement::encodeAsXmlElement("phone", phone, _buf);
	}
	else if (updateType == eUserUpdateTypeRealMoney)
	{
	}
	else if (updateType == eUserUpdateTypeFirstNameLastName)
	{
		Atf::XmlElement::encodeAsXmlElement("firstName", firstName, _buf);
		Atf::XmlElement::encodeAsXmlElement("lastName", lastName, _buf);
	}
	else if (updateType == eUserUpdateTypeFiscalCode)
	{
		Atf::XmlElement::encodeAsXmlElement("fiscalCode", fiscalCode, _buf);
	}
	else if (updateType == eUserUpdateTypeEncrFiscalCode)
	{
		Atf::XmlElement::encodeAsXmlElement("encrFiscalCode", encrFiscalCode, _buf);
	}
	else if (updateType == eUserUpdateTypeProperties)
	{
		properties.toXmlString("properties", _buf);
	}
	else if (updateType == eUserUpdateTypeBirthday)
	{
		Atf::AtfTempl<CommSrvDate>::ToXmlString(_buf, "birthDate", birthDate);
	}
	else if (updateType == eUserUpdateTypeImageId)
	{
		Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
		Atf::XmlElement::encodeAsXmlElement("currentImageId", currentImageId, _buf);
		Atf::XmlElement::encodeAsXmlElement("isCurrentImageFromGallery", isCurrentImageFromGallery, _buf);
	}
	else if (updateType == eUserUpdateTypeSwitchImageId)
	{
		Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
		Atf::XmlElement::encodeAsXmlElement("isGalleryImage", isGalleryImage, _buf);
		Atf::XmlElement::encodeAsXmlElement("currentImageId", currentImageId, _buf);
		Atf::XmlElement::encodeAsXmlElement("isCurrentImageFromGallery", isCurrentImageFromGallery, _buf);
		Atf::XmlElement::encodeAsXmlElement("adminIntId", adminIntId, _buf);
		Atf::XmlElement::encodeAsXmlElement("adminId", adminId, _buf);
	}
	else if (updateType == eUserUpdateTypeSex)
	{
		Atf::XmlElement::encodeAsXmlElement("sex", sex, _buf);
	}
	else if (updateType == eUserUpdateTypeMobile)
	{
		Atf::XmlElement::encodeAsXmlElement("mobile", mobile, _buf);
	}
	else if (updateType == eUserUpdateTypeEstoniaValidation)
	{
		Atf::XmlElement::encodeAsXmlElement("verificationCertificate", verificationCertificate, _buf);
		Atf::XmlElement::encodeAsXmlElement("verificationSignedData", verificationSignedData, _buf);
	}
	else if (updateType == eUserUpdateTypeMailList)
	{
		Atf::XmlElement::encodeAsXmlElement("mailListIn", mailListIn, _buf);
	}
	else if (updateType == eUserUpdateTypeMailListNew)
	{
		Atf::XmlElement::encodeAsXmlElement("mailListPokerIn", mailListPokerIn, _buf);
		Atf::XmlElement::encodeAsXmlElement("mailListCasinoIn", mailListCasinoIn, _buf);
		Atf::XmlElement::encodeAsXmlElement("mailListSportsIn", mailListSportsIn, _buf);
		Atf::XmlElement::encodeAsXmlElement("mailListSportsLiveAlertIn", mailListSportsLiveAlertIn, _buf);
	}
	else if (updateType == eUserUpdateTypeExternalValidation)
	{
		profile.toXmlString("profile", _buf);
	}
	else if (updateType == eUserUpdateTypeRealMoneyOkFlag)
	{
		Atf::XmlElement::encodeAsXmlElement("realMoneyOkSet", realMoneyOkSet, _buf);
		Atf::XmlElement::encodeAsXmlElement("comment", comment, _buf);
	}
	else if (updateType == eUserUpdateTypeSetLimits)
	{
		Atf::XmlElement::encodeAsXmlElement("weeklyDepositLimit", weeklyDepositLimit, _buf);
		Atf::XmlElement::encodeAsXmlElement("buyInLimit", buyInLimit, _buf);
		Atf::XmlElement::encodeAsXmlElement("isBuyInLimitValid", isBuyInLimitValid, _buf);
		Atf::XmlElement::encodeAsXmlElement("sportsAccumulatedLimit", sportsAccumulatedLimit, _buf);
	}
	else if (updateType == eUserUpdateTypeSMSPwdReset)
	{
		Atf::XmlElement::encodeAsXmlElement("allowSMSPwdReset", allowSMSPwdReset, _buf);
	}
	else if (updateType == eUserUpdateTypeSmsMarketingFlag)
	{
		Atf::XmlElement::encodeAsXmlElement("smsMarketingFlagValue", smsMarketingFlagValue, _buf);
	}
	else if (updateType == eUserUpdateTypePwdStrongAuth)
	{
		Atf::XmlElement::encodeAsXmlElement("answer1", answer1, _buf);
		Atf::XmlElement::encodeAsXmlElement("answer2", answer2, _buf);
		Atf::XmlElement::encodeAsXmlElement("ssn4", ssn4, _buf);
	}
	else if (updateType == eUserUpdateTypeBooleanActions)
	{
		Atf::XmlElement::encodeAsXmlElement("booleanActions", booleanActions, _buf);
	}
	else if (updateType == eUserUpdateTypeLeaderBoard)
	{
		Atf::XmlElement::encodeAsXmlElement("optinLeaderBoard", optinLeaderBoard, _buf);
	}
	else if (updateType == eUserUpdateTypeInternalServerNonUpdInfo)
	{
		Atf::XmlElement::encodeAsXmlElement("appLoginId", appLoginId, _buf);
		Atf::XmlElement::encodeAsXmlElement("brandId", brandId, _buf);
		Atf::XmlElement::encodeAsXmlElement("adminIntId", adminIntId, _buf);
		Atf::XmlElement::encodeAsXmlElement("adminId", adminId, _buf);
	}
	else if (updateType == eUserUpdateTypeAgeVerification)
	{
		Atf::XmlElement::encodeAsXmlElement("requestCtx", requestCtx, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("dummy_makeATFdefinitionForThisUpdateType", dummy_makeATFdefinitionForThisUpdateType, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::common_structs::UserUpdateElement::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("updateType"))
		{
			updateType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("addr_1"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, addr_1)) return false;
		}
		else if (_element.equals("addr_2"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, addr_2)) return false;
		}
		else if (_element.equals("city"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
		}
		else if (_element.equals("state"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("zipCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, zipCode)) return false;
		}
		else if (_element.equals("email"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
		}
		else if (_element.equals("autoValidateEmail"))
		{
			autoValidateEmail = (*_value.ptr() == '1');
		}
		else if (_element.equals("pwd"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, pwd)) return false;
		}
		else if (_element.equals("imageType"))
		{
			imageType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("imgData"))
		{
			Atf::XmlElement::_movePBlockWithNullStrip(_value, imgData);
		}
		else if (_element.equals("fullName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, fullName)) return false;
		}
		else if (_element.equals("phone"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, phone)) return false;
		}
		else if (_element.equals("firstName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, firstName)) return false;
		}
		else if (_element.equals("lastName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, lastName)) return false;
		}
		else if (_element.equals("fiscalCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, fiscalCode)) return false;
		}
		else if (_element.equals("encrFiscalCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, encrFiscalCode)) return false;
		}
		else if (_element.equals("properties"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< Common::AtfShared::UserPropertyLegacy, 4 > >::FromXmlString(_value, properties)) return false;
		}
		else if (_element.equals("birthDate"))
		{
			Atf::AtfTempl<CommSrvDate>::FromXmlString(_value, birthDate);
		}
		else if (_element.equals("imageId"))
		{
			imageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currentImageId"))
		{
			currentImageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isCurrentImageFromGallery"))
		{
			isCurrentImageFromGallery = (*_value.ptr() == '1');
		}
		else if (_element.equals("isGalleryImage"))
		{
			isGalleryImage = (*_value.ptr() == '1');
		}
		else if (_element.equals("adminIntId"))
		{
			adminIntId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("adminId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, adminId)) return false;
		}
		else if (_element.equals("sex"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, sex)) return false;
		}
		else if (_element.equals("mobile"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, mobile)) return false;
		}
		else if (_element.equals("verificationCertificate"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, verificationCertificate)) return false;
		}
		else if (_element.equals("verificationSignedData"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, verificationSignedData)) return false;
		}
		else if (_element.equals("mailListIn"))
		{
			mailListIn = (*_value.ptr() == '1');
		}
		else if (_element.equals("mailListPokerIn"))
		{
			mailListPokerIn = (*_value.ptr() == '1');
		}
		else if (_element.equals("mailListCasinoIn"))
		{
			mailListCasinoIn = (*_value.ptr() == '1');
		}
		else if (_element.equals("mailListSportsIn"))
		{
			mailListSportsIn = (*_value.ptr() == '1');
		}
		else if (_element.equals("mailListSportsLiveAlertIn"))
		{
			mailListSportsLiveAlertIn = (*_value.ptr() == '1');
		}
		else if (_element.equals("profile"))
		{
			if(!Atf::AtfTempl< UserProfile >::FromXmlString(_value, profile)) return false;
		}
		else if (_element.equals("realMoneyOkSet"))
		{
			realMoneyOkSet = (*_value.ptr() == '1');
		}
		else if (_element.equals("comment"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, comment)) return false;
		}
		else if (_element.equals("weeklyDepositLimit"))
		{
			weeklyDepositLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyInLimit"))
		{
			buyInLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isBuyInLimitValid"))
		{
			isBuyInLimitValid = (*_value.ptr() == '1');
		}
		else if (_element.equals("sportsAccumulatedLimit"))
		{
			sportsAccumulatedLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("allowSMSPwdReset"))
		{
			allowSMSPwdReset = (*_value.ptr() == '1');
		}
		else if (_element.equals("smsMarketingFlagValue"))
		{
			smsMarketingFlagValue = (*_value.ptr() == '1');
		}
		else if (_element.equals("answer1"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, answer1)) return false;
		}
		else if (_element.equals("answer2"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, answer2)) return false;
		}
		else if (_element.equals("ssn4"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, ssn4)) return false;
		}
		else if (_element.equals("booleanActions"))
		{
			booleanActions = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("optinLeaderBoard"))
		{
			optinLeaderBoard = (*_value.ptr() == '1');
		}
		else if (_element.equals("appLoginId"))
		{
			appLoginId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandId"))
		{
			brandId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("requestCtx"))
		{
			requestCtx = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("dummy_makeATFdefinitionForThisUpdateType"))
		{
			if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, dummy_makeATFdefinitionForThisUpdateType)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::common_structs::UserUpdateElement::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(updateType);
	if (updateType == eUserUpdateTypeAddress)
	{
		CommMsgBody _msg0;
		_msg0.composeString(addr_1);
		_msg0.composeString(addr_2);
		_msg0.composeString(city);
		_msg0.composeString(state);
		_msg0.composeString(country);
		_msg0.composeString(zipCode);
		_msg.composeMsgBody(_msg0);
	}
	else if (updateType == eUserUpdateTypeEmail)
	{
		CommMsgBody _msg1;
		_msg1.composeString(email);
		_msg1.composeBOOL(autoValidateEmail);
		_msg.composeMsgBody(_msg1);
	}
	else if (updateType == eUserUpdateTypePassword)
	{
		CommMsgBody _msg2;
		_msg2.composeString(pwd);
		_msg.composeMsgBody(_msg2);
	}
	else if (updateType == eUserUpdateTypeImage)
	{
		CommMsgBody _msg3;
		_msg3.composeBYTE(imageType);
		_msg3._composeVarBlock(imgData.ptr(), imgData.size());
		_msg.composeMsgBody(_msg3);
	}
	else if (updateType == eUserUpdateTypeFullName)
	{
		CommMsgBody _msg4;
		_msg4.composeString(fullName);
		_msg.composeMsgBody(_msg4);
	}
	else if (updateType == eUserUpdateTypePhone)
	{
		CommMsgBody _msg5;
		_msg5.composeString(phone);
		_msg.composeMsgBody(_msg5);
	}
	else if (updateType == eUserUpdateTypeRealMoney)
	{
		CommMsgBody _msg6;
		_msg.composeMsgBody(_msg6);
	}
	else if (updateType == eUserUpdateTypeFirstNameLastName)
	{
		CommMsgBody _msg7;
		_msg7.composeString(firstName);
		_msg7.composeString(lastName);
		_msg.composeMsgBody(_msg7);
	}
	else if (updateType == eUserUpdateTypeFiscalCode)
	{
		CommMsgBody _msg8;
		_msg8.composeString(fiscalCode);
		_msg.composeMsgBody(_msg8);
	}
	else if (updateType == eUserUpdateTypeEncrFiscalCode)
	{
		CommMsgBody _msg9;
		_msg9.composeString(encrFiscalCode);
		_msg.composeMsgBody(_msg9);
	}
	else if (updateType == eUserUpdateTypeProperties)
	{
		CommMsgBody _msg90;
		properties.composeMsg(_msg90, _ignoreJSON);
		_msg.composeMsgBody(_msg90);
	}
	else if (updateType == eUserUpdateTypeBirthday)
	{
		CommMsgBody _msg91;
		_msg91.composeSrvDate(birthDate);
		_msg.composeMsgBody(_msg91);
	}
	else if (updateType == eUserUpdateTypeImageId)
	{
		CommMsgBody _msg92;
		_msg92.composeUINT32(imageId);
		_msg92.composeUINT32(currentImageId);
		_msg92.composeBOOL(isCurrentImageFromGallery);
		_msg.composeMsgBody(_msg92);
	}
	else if (updateType == eUserUpdateTypeSwitchImageId)
	{
		CommMsgBody _msg93;
		_msg93.composeUINT32(imageId);
		_msg93.composeBOOL(isGalleryImage);
		_msg93.composeUINT32(currentImageId);
		_msg93.composeBOOL(isCurrentImageFromGallery);
		_msg93.composeUINT32(adminIntId);
		_msg93.composeString(adminId);
		_msg.composeMsgBody(_msg93);
	}
	else if (updateType == eUserUpdateTypeSex)
	{
		CommMsgBody _msg94;
		_msg94.composeString(sex);
		_msg.composeMsgBody(_msg94);
	}
	else if (updateType == eUserUpdateTypeMobile)
	{
		CommMsgBody _msg95;
		_msg95.composeString(mobile);
		_msg.composeMsgBody(_msg95);
	}
	else if (updateType == eUserUpdateTypeEstoniaValidation)
	{
		CommMsgBody _msg96;
		_msg96.composeString(verificationCertificate);
		_msg96.composeString(verificationSignedData);
		_msg.composeMsgBody(_msg96);
	}
	else if (updateType == eUserUpdateTypeMailList)
	{
		CommMsgBody _msg97;
		_msg97.composeBOOL(mailListIn);
		_msg.composeMsgBody(_msg97);
	}
	else if (updateType == eUserUpdateTypeMailListNew)
	{
		CommMsgBody _msg98;
		_msg98.composeBOOL(mailListPokerIn);
		_msg98.composeBOOL(mailListCasinoIn);
		_msg98.composeBOOL(mailListSportsIn);
		_msg98.composeBOOL(mailListSportsLiveAlertIn);
		_msg.composeMsgBody(_msg98);
	}
	else if (updateType == eUserUpdateTypeExternalValidation)
	{
		CommMsgBody _msg99;
		profile.composeMsg(_msg99, _ignoreJSON);
		_msg.composeMsgBody(_msg99);
	}
	else if (updateType == eUserUpdateTypeRealMoneyOkFlag)
	{
		CommMsgBody _msg990;
		_msg990.composeBOOL(realMoneyOkSet);
		_msg990.composeString(comment);
		_msg.composeMsgBody(_msg990);
	}
	else if (updateType == eUserUpdateTypeSetLimits)
	{
		CommMsgBody _msg991;
		_msg991.composeINT32(weeklyDepositLimit);
		_msg991.composeINT32(buyInLimit);
		_msg991.composeBOOL(isBuyInLimitValid);
		_msg991.composeINT32(sportsAccumulatedLimit);
		_msg.composeMsgBody(_msg991);
	}
	else if (updateType == eUserUpdateTypeSMSPwdReset)
	{
		CommMsgBody _msg992;
		_msg992.composeBOOL(allowSMSPwdReset);
		_msg.composeMsgBody(_msg992);
	}
	else if (updateType == eUserUpdateTypeSmsMarketingFlag)
	{
		CommMsgBody _msg993;
		_msg993.composeBOOL(smsMarketingFlagValue);
		_msg.composeMsgBody(_msg993);
	}
	else if (updateType == eUserUpdateTypePwdStrongAuth)
	{
		CommMsgBody _msg994;
		_msg994.composeString(answer1);
		_msg994.composeString(answer2);
		_msg994.composeString(ssn4);
		_msg.composeMsgBody(_msg994);
	}
	else if (updateType == eUserUpdateTypeBooleanActions)
	{
		CommMsgBody _msg995;
		_msg995.composeUINT32(booleanActions);
		_msg.composeMsgBody(_msg995);
	}
	else if (updateType == eUserUpdateTypeLeaderBoard)
	{
		CommMsgBody _msg996;
		_msg996.composeBOOL(optinLeaderBoard);
		_msg.composeMsgBody(_msg996);
	}
	else if (updateType == eUserUpdateTypeInternalServerNonUpdInfo)
	{
		CommMsgBody _msg997;
		_msg997.composeUINT64(appLoginId);
		_msg997.composeUINT32(brandId);
		_msg997.composeUINT32(adminIntId);
		_msg997.composeString(adminId);
		_msg.composeMsgBody(_msg997);
	}
	else if (updateType == eUserUpdateTypeAgeVerification)
	{
		CommMsgBody _msg998;
		_msg998.composeINT32(requestCtx);
		_msg.composeMsgBody(_msg998);
	}
	else
	{
		_msg.composeMsgBody(dummy_makeATFdefinitionForThisUpdateType);
	}
}

void regulator::common_structs::UserUpdateElement::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(updateType);
	if (updateType == eUserUpdateTypeAddress)
	{
		parseAnonymousMsgBody0(_parser);
	}
	else if (updateType == eUserUpdateTypeEmail)
	{
		parseAnonymousMsgBody1(_parser);
	}
	else if (updateType == eUserUpdateTypePassword)
	{
		parseAnonymousMsgBody2(_parser);
	}
	else if (updateType == eUserUpdateTypeImage)
	{
		parseAnonymousMsgBody3(_parser);
	}
	else if (updateType == eUserUpdateTypeFullName)
	{
		parseAnonymousMsgBody4(_parser);
	}
	else if (updateType == eUserUpdateTypePhone)
	{
		parseAnonymousMsgBody5(_parser);
	}
	else if (updateType == eUserUpdateTypeRealMoney)
	{
		parseAnonymousMsgBody6(_parser);
	}
	else if (updateType == eUserUpdateTypeFirstNameLastName)
	{
		parseAnonymousMsgBody7(_parser);
	}
	else if (updateType == eUserUpdateTypeFiscalCode)
	{
		parseAnonymousMsgBody8(_parser);
	}
	else if (updateType == eUserUpdateTypeEncrFiscalCode)
	{
		parseAnonymousMsgBody9(_parser);
	}
	else if (updateType == eUserUpdateTypeProperties)
	{
		parseAnonymousMsgBody10(_parser);
	}
	else if (updateType == eUserUpdateTypeBirthday)
	{
		parseAnonymousMsgBody11(_parser);
	}
	else if (updateType == eUserUpdateTypeImageId)
	{
		parseAnonymousMsgBody12(_parser);
	}
	else if (updateType == eUserUpdateTypeSwitchImageId)
	{
		parseAnonymousMsgBody13(_parser);
	}
	else if (updateType == eUserUpdateTypeSex)
	{
		parseAnonymousMsgBody14(_parser);
	}
	else if (updateType == eUserUpdateTypeMobile)
	{
		parseAnonymousMsgBody15(_parser);
	}
	else if (updateType == eUserUpdateTypeEstoniaValidation)
	{
		parseAnonymousMsgBody16(_parser);
	}
	else if (updateType == eUserUpdateTypeMailList)
	{
		parseAnonymousMsgBody17(_parser);
	}
	else if (updateType == eUserUpdateTypeMailListNew)
	{
		parseAnonymousMsgBody18(_parser);
	}
	else if (updateType == eUserUpdateTypeExternalValidation)
	{
		parseAnonymousMsgBody19(_parser);
	}
	else if (updateType == eUserUpdateTypeRealMoneyOkFlag)
	{
		parseAnonymousMsgBody20(_parser);
	}
	else if (updateType == eUserUpdateTypeSetLimits)
	{
		parseAnonymousMsgBody21(_parser);
	}
	else if (updateType == eUserUpdateTypeSMSPwdReset)
	{
		parseAnonymousMsgBody22(_parser);
	}
	else if (updateType == eUserUpdateTypeSmsMarketingFlag)
	{
		parseAnonymousMsgBody23(_parser);
	}
	else if (updateType == eUserUpdateTypePwdStrongAuth)
	{
		parseAnonymousMsgBody24(_parser);
	}
	else if (updateType == eUserUpdateTypeBooleanActions)
	{
		parseAnonymousMsgBody25(_parser);
	}
	else if (updateType == eUserUpdateTypeLeaderBoard)
	{
		parseAnonymousMsgBody26(_parser);
	}
	else if (updateType == eUserUpdateTypeInternalServerNonUpdInfo)
	{
		parseAnonymousMsgBody27(_parser);
	}
	else if (updateType == eUserUpdateTypeAgeVerification)
	{
		parseAnonymousMsgBody28(_parser);
	}
	else
	{
		_parser.parseMsgBody(dummy_makeATFdefinitionForThisUpdateType);
	}
}

const char *regulator::common_structs::UserUpdateElement::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("updateType", updateType);
	if (updateType == eUserUpdateTypeAddress)
	{
		_jsonstr.compose("addr_1", addr_1);
		_jsonstr.compose("addr_2", addr_2);
		_jsonstr.compose("city", city);
		_jsonstr.compose("state", state);
		_jsonstr.compose("country", country);
		_jsonstr.compose("zipCode", zipCode);
	}
	else if (updateType == eUserUpdateTypeEmail)
	{
		_jsonstr.compose("email", email);
		_jsonstr.compose("autoValidateEmail", autoValidateEmail);
	}
	else if (updateType == eUserUpdateTypePassword)
	{
		_jsonstr.compose("pwd", pwd);
	}
	else if (updateType == eUserUpdateTypeImage)
	{
		_jsonstr.compose("imageType", imageType);
		_jsonstr.compose("imgData", imgData);
	}
	else if (updateType == eUserUpdateTypeFullName)
	{
		_jsonstr.compose("fullName", fullName);
	}
	else if (updateType == eUserUpdateTypePhone)
	{
		_jsonstr.compose("phone", phone);
	}
	else if (updateType == eUserUpdateTypeRealMoney)
	{
	}
	else if (updateType == eUserUpdateTypeFirstNameLastName)
	{
		_jsonstr.compose("firstName", firstName);
		_jsonstr.compose("lastName", lastName);
	}
	else if (updateType == eUserUpdateTypeFiscalCode)
	{
		_jsonstr.compose("fiscalCode", fiscalCode);
	}
	else if (updateType == eUserUpdateTypeEncrFiscalCode)
	{
		_jsonstr.compose("encrFiscalCode", encrFiscalCode);
	}
	else if (updateType == eUserUpdateTypeProperties)
	{
		_jsonstr.compose("properties", properties);
	}
	else if (updateType == eUserUpdateTypeBirthday)
	{
		_jsonstr.compose("birthDate", birthDate);
	}
	else if (updateType == eUserUpdateTypeImageId)
	{
		_jsonstr.compose("imageId", imageId);
		_jsonstr.compose("currentImageId", currentImageId);
		_jsonstr.compose("isCurrentImageFromGallery", isCurrentImageFromGallery);
	}
	else if (updateType == eUserUpdateTypeSwitchImageId)
	{
		_jsonstr.compose("imageId", imageId);
		_jsonstr.compose("isGalleryImage", isGalleryImage);
		_jsonstr.compose("currentImageId", currentImageId);
		_jsonstr.compose("isCurrentImageFromGallery", isCurrentImageFromGallery);
		_jsonstr.compose("adminIntId", adminIntId);
		_jsonstr.compose("adminId", adminId);
	}
	else if (updateType == eUserUpdateTypeSex)
	{
		_jsonstr.compose("sex", sex);
	}
	else if (updateType == eUserUpdateTypeMobile)
	{
		_jsonstr.compose("mobile", mobile);
	}
	else if (updateType == eUserUpdateTypeEstoniaValidation)
	{
		_jsonstr.compose("verificationCertificate", verificationCertificate);
		_jsonstr.compose("verificationSignedData", verificationSignedData);
	}
	else if (updateType == eUserUpdateTypeMailList)
	{
		_jsonstr.compose("mailListIn", mailListIn);
	}
	else if (updateType == eUserUpdateTypeMailListNew)
	{
		_jsonstr.compose("mailListPokerIn", mailListPokerIn);
		_jsonstr.compose("mailListCasinoIn", mailListCasinoIn);
		_jsonstr.compose("mailListSportsIn", mailListSportsIn);
		_jsonstr.compose("mailListSportsLiveAlertIn", mailListSportsLiveAlertIn);
	}
	else if (updateType == eUserUpdateTypeExternalValidation)
	{
		_jsonstr.compose("profile", profile);
	}
	else if (updateType == eUserUpdateTypeRealMoneyOkFlag)
	{
		_jsonstr.compose("realMoneyOkSet", realMoneyOkSet);
		_jsonstr.compose("comment", comment);
	}
	else if (updateType == eUserUpdateTypeSetLimits)
	{
		_jsonstr.compose("weeklyDepositLimit", weeklyDepositLimit);
		_jsonstr.compose("buyInLimit", buyInLimit);
		_jsonstr.compose("isBuyInLimitValid", isBuyInLimitValid);
		_jsonstr.compose("sportsAccumulatedLimit", sportsAccumulatedLimit);
	}
	else if (updateType == eUserUpdateTypeSMSPwdReset)
	{
		_jsonstr.compose("allowSMSPwdReset", allowSMSPwdReset);
	}
	else if (updateType == eUserUpdateTypeSmsMarketingFlag)
	{
		_jsonstr.compose("smsMarketingFlagValue", smsMarketingFlagValue);
	}
	else if (updateType == eUserUpdateTypePwdStrongAuth)
	{
		_jsonstr.compose("answer1", answer1);
		_jsonstr.compose("answer2", answer2);
		_jsonstr.compose("ssn4", ssn4);
	}
	else if (updateType == eUserUpdateTypeBooleanActions)
	{
		_jsonstr.compose("booleanActions", booleanActions);
	}
	else if (updateType == eUserUpdateTypeLeaderBoard)
	{
		_jsonstr.compose("optinLeaderBoard", optinLeaderBoard);
	}
	else if (updateType == eUserUpdateTypeInternalServerNonUpdInfo)
	{
		_jsonstr.compose("appLoginId", appLoginId);
		_jsonstr.compose("brandId", brandId);
		_jsonstr.compose("adminIntId", adminIntId);
		_jsonstr.compose("adminId", adminId);
	}
	else if (updateType == eUserUpdateTypeAgeVerification)
	{
		_jsonstr.compose("requestCtx", requestCtx);
	}
	else
	{
		_jsonstr.compose("dummy_makeATFdefinitionForThisUpdateType", dummy_makeATFdefinitionForThisUpdateType);
	}
	return _buf.c_str();
}

void regulator::common_structs::UserUpdateElement::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("updateType", updateType);
	if (updateType == eUserUpdateTypeAddress)
	{
		_jparser.parseByNameThrow("addr_1", addr_1);
		_jparser.parseByNameThrow("addr_2", addr_2);
		_jparser.parseByNameThrow("city", city);
		_jparser.parseByNameThrow("state", state);
		_jparser.parseByNameThrow("country", country);
		_jparser.parseByNameThrow("zipCode", zipCode);
	}
	else if (updateType == eUserUpdateTypeEmail)
	{
		_jparser.parseByNameThrow("email", email);
		_jparser.parseByName("autoValidateEmail", autoValidateEmail);
	}
	else if (updateType == eUserUpdateTypePassword)
	{
		_jparser.parseByNameThrow("pwd", pwd);
	}
	else if (updateType == eUserUpdateTypeImage)
	{
		_jparser.parseByNameThrow("imageType", imageType);
		_jparser.parseByNameThrow("imgData", imgData);
	}
	else if (updateType == eUserUpdateTypeFullName)
	{
		_jparser.parseByNameThrow("fullName", fullName);
	}
	else if (updateType == eUserUpdateTypePhone)
	{
		_jparser.parseByNameThrow("phone", phone);
	}
	else if (updateType == eUserUpdateTypeRealMoney)
	{
	}
	else if (updateType == eUserUpdateTypeFirstNameLastName)
	{
		_jparser.parseByNameThrow("firstName", firstName);
		_jparser.parseByNameThrow("lastName", lastName);
	}
	else if (updateType == eUserUpdateTypeFiscalCode)
	{
		_jparser.parseByNameThrow("fiscalCode", fiscalCode);
	}
	else if (updateType == eUserUpdateTypeEncrFiscalCode)
	{
		_jparser.parseByNameThrow("encrFiscalCode", encrFiscalCode);
	}
	else if (updateType == eUserUpdateTypeProperties)
	{
		_jparser.parseByNameThrow("properties", properties);
	}
	else if (updateType == eUserUpdateTypeBirthday)
	{
		_jparser.parseByNameThrow("birthDate", birthDate);
	}
	else if (updateType == eUserUpdateTypeImageId)
	{
		_jparser.parseByNameThrow("imageId", imageId);
		_jparser.parseByNameThrow("currentImageId", currentImageId);
		_jparser.parseByNameThrow("isCurrentImageFromGallery", isCurrentImageFromGallery);
	}
	else if (updateType == eUserUpdateTypeSwitchImageId)
	{
		_jparser.parseByNameThrow("imageId", imageId);
		_jparser.parseByNameThrow("isGalleryImage", isGalleryImage);
		_jparser.parseByNameThrow("currentImageId", currentImageId);
		_jparser.parseByNameThrow("isCurrentImageFromGallery", isCurrentImageFromGallery);
		_jparser.parseByNameThrow("adminIntId", adminIntId);
		_jparser.parseByNameThrow("adminId", adminId);
	}
	else if (updateType == eUserUpdateTypeSex)
	{
		_jparser.parseByNameThrow("sex", sex);
	}
	else if (updateType == eUserUpdateTypeMobile)
	{
		_jparser.parseByNameThrow("mobile", mobile);
	}
	else if (updateType == eUserUpdateTypeEstoniaValidation)
	{
		_jparser.parseByNameThrow("verificationCertificate", verificationCertificate);
		_jparser.parseByNameThrow("verificationSignedData", verificationSignedData);
	}
	else if (updateType == eUserUpdateTypeMailList)
	{
		_jparser.parseByNameThrow("mailListIn", mailListIn);
	}
	else if (updateType == eUserUpdateTypeMailListNew)
	{
		_jparser.parseByNameThrow("mailListPokerIn", mailListPokerIn);
		_jparser.parseByNameThrow("mailListCasinoIn", mailListCasinoIn);
		_jparser.parseByNameThrow("mailListSportsIn", mailListSportsIn);
		_jparser.parseByName("mailListSportsLiveAlertIn", mailListSportsLiveAlertIn);
	}
	else if (updateType == eUserUpdateTypeExternalValidation)
	{
		_jparser.parseByNameThrow("profile", profile);
	}
	else if (updateType == eUserUpdateTypeRealMoneyOkFlag)
	{
		_jparser.parseByNameThrow("realMoneyOkSet", realMoneyOkSet);
		_jparser.parseByNameThrow("comment", comment);
	}
	else if (updateType == eUserUpdateTypeSetLimits)
	{
		_jparser.parseByNameThrow("weeklyDepositLimit", weeklyDepositLimit);
		_jparser.parseByNameThrow("buyInLimit", buyInLimit);
		_jparser.parseByNameThrow("isBuyInLimitValid", isBuyInLimitValid);
		_jparser.parseByName("sportsAccumulatedLimit", sportsAccumulatedLimit);
	}
	else if (updateType == eUserUpdateTypeSMSPwdReset)
	{
		_jparser.parseByNameThrow("allowSMSPwdReset", allowSMSPwdReset);
	}
	else if (updateType == eUserUpdateTypeSmsMarketingFlag)
	{
		_jparser.parseByNameThrow("smsMarketingFlagValue", smsMarketingFlagValue);
	}
	else if (updateType == eUserUpdateTypePwdStrongAuth)
	{
		_jparser.parseByNameThrow("answer1", answer1);
		_jparser.parseByNameThrow("answer2", answer2);
		_jparser.parseByNameThrow("ssn4", ssn4);
	}
	else if (updateType == eUserUpdateTypeBooleanActions)
	{
		_jparser.parseByNameThrow("booleanActions", booleanActions);
	}
	else if (updateType == eUserUpdateTypeLeaderBoard)
	{
		_jparser.parseByNameThrow("optinLeaderBoard", optinLeaderBoard);
	}
	else if (updateType == eUserUpdateTypeInternalServerNonUpdInfo)
	{
		_jparser.parseByNameThrow("appLoginId", appLoginId);
		_jparser.parseByNameThrow("brandId", brandId);
		_jparser.parseByNameThrow("adminIntId", adminIntId);
		_jparser.parseByNameThrow("adminId", adminId);
	}
	else if (updateType == eUserUpdateTypeAgeVerification)
	{
		_jparser.parseByNameThrow("requestCtx", requestCtx);
	}
	else
	{
		_jparser.parseByNameThrow("dummy_makeATFdefinitionForThisUpdateType", dummy_makeATFdefinitionForThisUpdateType);
	}
}

/* static */ void regulator::common_structs::UserUpdateElement::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 updateType = 0;
	_jparser.validateByNameThrow("updateType", updateType);
	AtfValidator::validateIntRange(_descr, "updateType", updateType, eUserUpdateTypeUndefined, eUserUpdateTypeLast, _checker, __FILE__, __LINE__);
	if (updateType == eUserUpdateTypeAddress)
	{
		PString addr_1; _jparser.validateByNameThrow("addr_1", addr_1);
		AtfValidator::validateIntMax(_descr, "addr_1", addr_1.length(), USER_ADDR_LEN, _checker, __FILE__, __LINE__);
		PString addr_2; _jparser.validateByNameThrow("addr_2", addr_2);
		AtfValidator::validateIntMax(_descr, "addr_2", addr_2.length(), USER_ADDR2_LEN, _checker, __FILE__, __LINE__);
		PString city; _jparser.validateByNameThrow("city", city);
		AtfValidator::validateIntMax(_descr, "city", city.length(), USER_CITY_LEN, _checker, __FILE__, __LINE__);
		PString state; _jparser.validateByNameThrow("state", state);
		AtfValidator::validateIntMax(_descr, "state", state.length(), USER_STATE_LEN, _checker, __FILE__, __LINE__);
		PString country; _jparser.validateByNameThrow("country", country);
		AtfValidator::validateIntMax(_descr, "country", country.length(), USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
		PString zipCode; _jparser.validateByNameThrow("zipCode", zipCode);
		AtfValidator::validateIntMax(_descr, "zipCode", zipCode.length(), USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeEmail)
	{
		PString email; _jparser.validateByNameThrow("email", email);
		AtfValidator::validateIntMax(_descr, "email", email.length(), USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
		bool autoValidateEmail; _jparser.validateByName("autoValidateEmail", autoValidateEmail);
		AtfValidator::validateInt(_descr, "autoValidateEmail", autoValidateEmail, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypePassword)
	{
		PString pwd; _jparser.validateByNameThrow("pwd", pwd);
		AtfValidator::validateIntMax(_descr, "pwd", pwd.length(), USER_PWD_LEN, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeImage)
	{
		BYTE imageType; _jparser.validateByNameThrow("imageType", imageType);
		{ const BYTE imageType_enum[] = { IMAGE_TYPE_NONE, IMAGE_TYPE_PRIVATE }; AtfValidator::validateEnum(_descr, "imageType", imageType, imageType_enum, _checker, __FILE__, __LINE__); }
		PBlock imgData; _jparser.validateByNameThrow("imgData", imgData);
		AtfValidator::validateIntMax(_descr, "imgData", imgData.size(), IMAGE_LEN, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeFullName)
	{
		PString fullName; _jparser.validateByNameThrow("fullName", fullName);
		AtfValidator::validateIntMax(_descr, "fullName", fullName.length(), USER_FULLNAME_LEN, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypePhone)
	{
		PString phone; _jparser.validateByNameThrow("phone", phone);
		AtfValidator::validateIntMax(_descr, "phone", phone.length(), 100, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeRealMoney)
	{
	}
	else if (updateType == eUserUpdateTypeFirstNameLastName)
	{
		PString firstName; _jparser.validateByNameThrow("firstName", firstName);
		AtfValidator::validateIntMax(_descr, "firstName", firstName.length(), USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
		PString lastName; _jparser.validateByNameThrow("lastName", lastName);
		AtfValidator::validateIntMax(_descr, "lastName", lastName.length(), USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeFiscalCode)
	{
		PString fiscalCode; _jparser.validateByNameThrow("fiscalCode", fiscalCode);
		AtfValidator::validateIntMax(_descr, "fiscalCode", fiscalCode.length(), USER_FISCAL_CODE_LEN, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeEncrFiscalCode)
	{
		PString encrFiscalCode; _jparser.validateByNameThrow("encrFiscalCode", encrFiscalCode);
		AtfValidator::validateIntMax(_descr, "encrFiscalCode", encrFiscalCode.length(), 4000, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeProperties)
	{
		Atf::AtfVectorBase< Common::AtfShared::UserPropertyLegacy > properties; _jparser.validateByNameThrow("properties", properties);
		AtfValidator::validateIntMax(_descr, "properties", properties.size(), 2000, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeBirthday)
	{
		CommSrvDate birthDate; _jparser.validateByNameThrow("birthDate", birthDate);
		AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeImageId)
	{
		UINT32 imageId; _jparser.validateByNameThrow("imageId", imageId);
		AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
		UINT32 currentImageId; _jparser.validateByNameThrow("currentImageId", currentImageId);
		AtfValidator::validateInt(_descr, "currentImageId", currentImageId, _checker, __FILE__, __LINE__);
		bool isCurrentImageFromGallery; _jparser.validateByNameThrow("isCurrentImageFromGallery", isCurrentImageFromGallery);
		AtfValidator::validateInt(_descr, "isCurrentImageFromGallery", isCurrentImageFromGallery, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeSwitchImageId)
	{
		UINT32 imageId; _jparser.validateByNameThrow("imageId", imageId);
		AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
		bool isGalleryImage; _jparser.validateByNameThrow("isGalleryImage", isGalleryImage);
		AtfValidator::validateInt(_descr, "isGalleryImage", isGalleryImage, _checker, __FILE__, __LINE__);
		UINT32 currentImageId; _jparser.validateByNameThrow("currentImageId", currentImageId);
		AtfValidator::validateInt(_descr, "currentImageId", currentImageId, _checker, __FILE__, __LINE__);
		bool isCurrentImageFromGallery; _jparser.validateByNameThrow("isCurrentImageFromGallery", isCurrentImageFromGallery);
		AtfValidator::validateInt(_descr, "isCurrentImageFromGallery", isCurrentImageFromGallery, _checker, __FILE__, __LINE__);
		UINT32 adminIntId; _jparser.validateByNameThrow("adminIntId", adminIntId);
		AtfValidator::validateInt(_descr, "adminIntId", adminIntId, _checker, __FILE__, __LINE__);
		PString adminId; _jparser.validateByNameThrow("adminId", adminId);
		AtfValidator::validateInt(_descr, "adminId", adminId.length(), _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeSex)
	{
		PString sex; _jparser.validateByNameThrow("sex", sex);
		AtfValidator::validateIntMax(_descr, "sex", sex.length(), USER_SEX_LEN, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeMobile)
	{
		PString mobile; _jparser.validateByNameThrow("mobile", mobile);
		AtfValidator::validateIntMax(_descr, "mobile", mobile.length(), 100, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeEstoniaValidation)
	{
		PString verificationCertificate; _jparser.validateByNameThrow("verificationCertificate", verificationCertificate);
		AtfValidator::validateIntMax(_descr, "verificationCertificate", verificationCertificate.length(), 2000, _checker, __FILE__, __LINE__);
		PString verificationSignedData; _jparser.validateByNameThrow("verificationSignedData", verificationSignedData);
		AtfValidator::validateIntMax(_descr, "verificationSignedData", verificationSignedData.length(), 2000, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeMailList)
	{
		bool mailListIn; _jparser.validateByNameThrow("mailListIn", mailListIn);
		AtfValidator::validateInt(_descr, "mailListIn", mailListIn, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeMailListNew)
	{
		bool mailListPokerIn; _jparser.validateByNameThrow("mailListPokerIn", mailListPokerIn);
		AtfValidator::validateInt(_descr, "mailListPokerIn", mailListPokerIn, _checker, __FILE__, __LINE__);
		bool mailListCasinoIn; _jparser.validateByNameThrow("mailListCasinoIn", mailListCasinoIn);
		AtfValidator::validateInt(_descr, "mailListCasinoIn", mailListCasinoIn, _checker, __FILE__, __LINE__);
		bool mailListSportsIn; _jparser.validateByNameThrow("mailListSportsIn", mailListSportsIn);
		AtfValidator::validateInt(_descr, "mailListSportsIn", mailListSportsIn, _checker, __FILE__, __LINE__);
		bool mailListSportsLiveAlertIn; _jparser.validateByName("mailListSportsLiveAlertIn", mailListSportsLiveAlertIn);
		AtfValidator::validateInt(_descr, "mailListSportsLiveAlertIn", mailListSportsLiveAlertIn, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeExternalValidation)
	{
		UserProfile profile; _jparser.validateByNameThrow("profile", profile);
	}
	else if (updateType == eUserUpdateTypeRealMoneyOkFlag)
	{
		bool realMoneyOkSet; _jparser.validateByNameThrow("realMoneyOkSet", realMoneyOkSet);
		AtfValidator::validateInt(_descr, "realMoneyOkSet", realMoneyOkSet, _checker, __FILE__, __LINE__);
		PString comment; _jparser.validateByNameThrow("comment", comment);
		AtfValidator::validateIntMax(_descr, "comment", comment.length(), 1000, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeSetLimits)
	{
		INT32 weeklyDepositLimit; _jparser.validateByNameThrow("weeklyDepositLimit", weeklyDepositLimit);
		AtfValidator::validateIntRange(_descr, "weeklyDepositLimit", weeklyDepositLimit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
		INT32 buyInLimit; _jparser.validateByNameThrow("buyInLimit", buyInLimit);
		AtfValidator::validateIntRange(_descr, "buyInLimit", buyInLimit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
		bool isBuyInLimitValid; _jparser.validateByNameThrow("isBuyInLimitValid", isBuyInLimitValid);
		AtfValidator::validateInt(_descr, "isBuyInLimitValid", isBuyInLimitValid, _checker, __FILE__, __LINE__);
		INT32 sportsAccumulatedLimit; _jparser.validateByName("sportsAccumulatedLimit", sportsAccumulatedLimit);
		AtfValidator::validateInt(_descr, "sportsAccumulatedLimit", sportsAccumulatedLimit, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeSMSPwdReset)
	{
		bool allowSMSPwdReset; _jparser.validateByNameThrow("allowSMSPwdReset", allowSMSPwdReset);
		AtfValidator::validateInt(_descr, "allowSMSPwdReset", allowSMSPwdReset, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeSmsMarketingFlag)
	{
		bool smsMarketingFlagValue; _jparser.validateByNameThrow("smsMarketingFlagValue", smsMarketingFlagValue);
		AtfValidator::validateInt(_descr, "smsMarketingFlagValue", smsMarketingFlagValue, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypePwdStrongAuth)
	{
		PString answer1; _jparser.validateByNameThrow("answer1", answer1);
		AtfValidator::validateIntMax(_descr, "answer1", answer1.length(), 1000, _checker, __FILE__, __LINE__);
		PString answer2; _jparser.validateByNameThrow("answer2", answer2);
		AtfValidator::validateIntMax(_descr, "answer2", answer2.length(), 1000, _checker, __FILE__, __LINE__);
		PString ssn4; _jparser.validateByNameThrow("ssn4", ssn4);
		AtfValidator::validateIntMax(_descr, "ssn4", ssn4.length(), SSN_4_LEN, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeBooleanActions)
	{
		UINT32 booleanActions; _jparser.validateByNameThrow("booleanActions", booleanActions);
		AtfValidator::validateInt(_descr, "booleanActions", booleanActions, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeLeaderBoard)
	{
		bool optinLeaderBoard; _jparser.validateByNameThrow("optinLeaderBoard", optinLeaderBoard);
		AtfValidator::validateInt(_descr, "optinLeaderBoard", optinLeaderBoard, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeInternalServerNonUpdInfo)
	{
		UINT64 appLoginId; _jparser.validateByNameThrow("appLoginId", appLoginId);
		AtfValidator::validateUint(_descr, "appLoginId", appLoginId, _checker, __FILE__, __LINE__);
		UINT32 brandId; _jparser.validateByNameThrow("brandId", brandId);
		AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, BrandType_Last, _checker, __FILE__, __LINE__);
		UINT32 adminIntId; _jparser.validateByNameThrow("adminIntId", adminIntId);
		AtfValidator::validateInt(_descr, "adminIntId", adminIntId, _checker, __FILE__, __LINE__);
		PString adminId; _jparser.validateByNameThrow("adminId", adminId);
		AtfValidator::validateIntMax(_descr, "adminId", adminId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	}
	else if (updateType == eUserUpdateTypeAgeVerification)
	{
		INT32 requestCtx; _jparser.validateByNameThrow("requestCtx", requestCtx);
		AtfValidator::validateInt(_descr, "requestCtx", requestCtx, _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::CopyableMsgBody dummy_makeATFdefinitionForThisUpdateType; _jparser.validateByNameThrow("dummy_makeATFdefinitionForThisUpdateType", dummy_makeATFdefinitionForThisUpdateType);
		AtfValidator::validateIntMax(_descr, "dummy_makeATFdefinitionForThisUpdateType", dummy_makeATFdefinitionForThisUpdateType._size(), 0, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 updateType = 0;
	_parser.parseUINT32(updateType);
	AtfValidator::validateIntRange(_descr, "updateType", updateType, eUserUpdateTypeUndefined, eUserUpdateTypeLast, _checker, __FILE__, __LINE__);
	if (updateType == eUserUpdateTypeAddress)
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeEmail)
	{
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypePassword)
	{
		validateAnonymousMsgBody2(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeImage)
	{
		validateAnonymousMsgBody3(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeFullName)
	{
		validateAnonymousMsgBody4(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypePhone)
	{
		validateAnonymousMsgBody5(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeRealMoney)
	{
		validateAnonymousMsgBody6(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeFirstNameLastName)
	{
		validateAnonymousMsgBody7(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeFiscalCode)
	{
		validateAnonymousMsgBody8(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeEncrFiscalCode)
	{
		validateAnonymousMsgBody9(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeProperties)
	{
		validateAnonymousMsgBody10(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeBirthday)
	{
		validateAnonymousMsgBody11(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeImageId)
	{
		validateAnonymousMsgBody12(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeSwitchImageId)
	{
		validateAnonymousMsgBody13(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeSex)
	{
		validateAnonymousMsgBody14(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeMobile)
	{
		validateAnonymousMsgBody15(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeEstoniaValidation)
	{
		validateAnonymousMsgBody16(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeMailList)
	{
		validateAnonymousMsgBody17(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeMailListNew)
	{
		validateAnonymousMsgBody18(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeExternalValidation)
	{
		validateAnonymousMsgBody19(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeRealMoneyOkFlag)
	{
		validateAnonymousMsgBody20(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeSetLimits)
	{
		validateAnonymousMsgBody21(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeSMSPwdReset)
	{
		validateAnonymousMsgBody22(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeSmsMarketingFlag)
	{
		validateAnonymousMsgBody23(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypePwdStrongAuth)
	{
		validateAnonymousMsgBody24(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeBooleanActions)
	{
		validateAnonymousMsgBody25(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeLeaderBoard)
	{
		validateAnonymousMsgBody26(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeInternalServerNonUpdInfo)
	{
		validateAnonymousMsgBody27(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeAgeVerification)
	{
		validateAnonymousMsgBody28(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else
	{
		size_t szDummy_makeATFdefinitionForThisUpdateType; _parser.skipMsgBody(szDummy_makeATFdefinitionForThisUpdateType);  /*dummy_makeATFdefinitionForThisUpdateType*/
		AtfValidator::validateIntMax(_descr, "dummy_makeATFdefinitionForThisUpdateType", szDummy_makeATFdefinitionForThisUpdateType, 0, _checker, __FILE__, __LINE__);
	}
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(addr_1);
	_parser0.parseStringP(addr_2);
	_parser0.parseStringP(city);
	_parser0.parseStringP(state);
	_parser0.parseStringP(country);
	_parser0.parseStringP(zipCode);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "addr_1"); size_t szAddr_1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "addr_1", szAddr_1, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "addr_2"); size_t szAddr_2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "addr_2", szAddr_2, USER_ADDR2_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "zipCode"); size_t szZipCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zipCode", szZipCode, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(email);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(autoValidateEmail);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool autoValidateEmail; _parser0.parseBOOL(autoValidateEmail);
	AtfValidator::validateInt(_descr, "autoValidateEmail", autoValidateEmail, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(pwd);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "pwd"); size_t szPwd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "pwd", szPwd, USER_PWD_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody3(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(imageType);
	_parser0.parsePBlock(imgData);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody3(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE imageType; _parser0.parseBYTE(imageType);
	{ const BYTE imageType_enum[] = { IMAGE_TYPE_NONE, IMAGE_TYPE_PRIVATE }; AtfValidator::validateEnum(_descr, "imageType", imageType, imageType_enum, _checker, __FILE__, __LINE__); }
	const BYTE* imgData; size_t szImgData; _parser0._parseVarBlock(imgData, szImgData);  /*imgData*/
	AtfValidator::validateIntMax(_descr, "imgData", szImgData, IMAGE_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody4(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(fullName);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody4(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "fullName"); size_t szFullName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fullName", szFullName, USER_FULLNAME_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody5(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(phone);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody5(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phone", szPhone, 100, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody6(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody6(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody7(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(firstName);
	_parser0.parseStringP(lastName);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody7(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "firstName", szFirstName, USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "lastName"); size_t szLastName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "lastName", szLastName, USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody8(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(fiscalCode);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody8(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "fiscalCode"); size_t szFiscalCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fiscalCode", szFiscalCode, USER_FISCAL_CODE_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody9(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(encrFiscalCode);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody9(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "encrFiscalCode"); size_t szEncrFiscalCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "encrFiscalCode", szEncrFiscalCode, 4000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody10(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	properties.parseMsg(_parser0);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody10(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szProperties = Atf::LAtfVector< Common::AtfShared::UserPropertyLegacy, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("properties"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "properties", szProperties, 2000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody11(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseSrvDate(birthDate);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody11(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	CommSrvDate birthDate; _parser0.parseSrvDate(birthDate);
	AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody12(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(imageId);
	_parser0.parseUINT32(currentImageId);
	_parser0.parseBOOL(isCurrentImageFromGallery);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody12(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 imageId; _parser0.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	UINT32 currentImageId; _parser0.parseUINT32(currentImageId);
	AtfValidator::validateInt(_descr, "currentImageId", currentImageId, _checker, __FILE__, __LINE__);
	bool isCurrentImageFromGallery; _parser0.parseBOOL(isCurrentImageFromGallery);
	AtfValidator::validateInt(_descr, "isCurrentImageFromGallery", isCurrentImageFromGallery, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody13(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(imageId);
	_parser0.parseBOOL(isGalleryImage);
	_parser0.parseUINT32(currentImageId);
	_parser0.parseBOOL(isCurrentImageFromGallery);
	_parser0.parseUINT32(adminIntId);
	_parser0.parseStringP(adminId);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody13(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 imageId; _parser0.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	bool isGalleryImage; _parser0.parseBOOL(isGalleryImage);
	AtfValidator::validateInt(_descr, "isGalleryImage", isGalleryImage, _checker, __FILE__, __LINE__);
	UINT32 currentImageId; _parser0.parseUINT32(currentImageId);
	AtfValidator::validateInt(_descr, "currentImageId", currentImageId, _checker, __FILE__, __LINE__);
	bool isCurrentImageFromGallery; _parser0.parseBOOL(isCurrentImageFromGallery);
	AtfValidator::validateInt(_descr, "isCurrentImageFromGallery", isCurrentImageFromGallery, _checker, __FILE__, __LINE__);
	UINT32 adminIntId; _parser0.parseUINT32(adminIntId);
	AtfValidator::validateInt(_descr, "adminIntId", adminIntId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "adminId"); size_t szAdminId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "adminId", szAdminId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody14(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(sex);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody14(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "sex"); size_t szSex = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "sex", szSex, USER_SEX_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody15(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(mobile);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody15(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "mobile"); size_t szMobile = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "mobile", szMobile, 100, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody16(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(verificationCertificate);
	_parser0.parseStringP(verificationSignedData);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody16(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "verificationCertificate"); size_t szVerificationCertificate = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "verificationCertificate", szVerificationCertificate, 2000, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "verificationSignedData"); size_t szVerificationSignedData = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "verificationSignedData", szVerificationSignedData, 2000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody17(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(mailListIn);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody17(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool mailListIn; _parser0.parseBOOL(mailListIn);
	AtfValidator::validateInt(_descr, "mailListIn", mailListIn, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody18(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(mailListPokerIn);
	_parser0.parseBOOL(mailListCasinoIn);
	_parser0.parseBOOL(mailListSportsIn);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(mailListSportsLiveAlertIn);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody18(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool mailListPokerIn; _parser0.parseBOOL(mailListPokerIn);
	AtfValidator::validateInt(_descr, "mailListPokerIn", mailListPokerIn, _checker, __FILE__, __LINE__);
	bool mailListCasinoIn; _parser0.parseBOOL(mailListCasinoIn);
	AtfValidator::validateInt(_descr, "mailListCasinoIn", mailListCasinoIn, _checker, __FILE__, __LINE__);
	bool mailListSportsIn; _parser0.parseBOOL(mailListSportsIn);
	AtfValidator::validateInt(_descr, "mailListSportsIn", mailListSportsIn, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool mailListSportsLiveAlertIn; _parser0.parseBOOL(mailListSportsLiveAlertIn);
	AtfValidator::validateInt(_descr, "mailListSportsLiveAlertIn", mailListSportsLiveAlertIn, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody19(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	profile.parseMsg(_parser0);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody19(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	UserProfile::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("profile"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody20(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(realMoneyOkSet);
	_parser0.parseStringP(comment);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody20(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	bool realMoneyOkSet; _parser0.parseBOOL(realMoneyOkSet);
	AtfValidator::validateInt(_descr, "realMoneyOkSet", realMoneyOkSet, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "comment", szComment, 1000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody21(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(weeklyDepositLimit);
	_parser0.parseINT32(buyInLimit);
	_parser0.parseBOOL(isBuyInLimitValid);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(sportsAccumulatedLimit);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody21(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 weeklyDepositLimit; _parser0.parseINT32(weeklyDepositLimit);
	AtfValidator::validateIntRange(_descr, "weeklyDepositLimit", weeklyDepositLimit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 buyInLimit; _parser0.parseINT32(buyInLimit);
	AtfValidator::validateIntRange(_descr, "buyInLimit", buyInLimit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	bool isBuyInLimitValid; _parser0.parseBOOL(isBuyInLimitValid);
	AtfValidator::validateInt(_descr, "isBuyInLimitValid", isBuyInLimitValid, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 sportsAccumulatedLimit; _parser0.parseINT32(sportsAccumulatedLimit);
	AtfValidator::validateInt(_descr, "sportsAccumulatedLimit", sportsAccumulatedLimit, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody22(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(allowSMSPwdReset);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody22(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool allowSMSPwdReset; _parser0.parseBOOL(allowSMSPwdReset);
	AtfValidator::validateInt(_descr, "allowSMSPwdReset", allowSMSPwdReset, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody23(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(smsMarketingFlagValue);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody23(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool smsMarketingFlagValue; _parser0.parseBOOL(smsMarketingFlagValue);
	AtfValidator::validateInt(_descr, "smsMarketingFlagValue", smsMarketingFlagValue, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody24(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(answer1);
	_parser0.parseStringP(answer2);
	_parser0.parseStringP(ssn4);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody24(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "answer1"); size_t szAnswer1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer1", szAnswer1, 1000, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "answer2"); size_t szAnswer2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer2", szAnswer2, 1000, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "ssn4"); size_t szSsn4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "ssn4", szSsn4, SSN_4_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody25(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(booleanActions);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody25(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 booleanActions; _parser0.parseUINT32(booleanActions);
	AtfValidator::validateInt(_descr, "booleanActions", booleanActions, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody26(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(optinLeaderBoard);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody26(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool optinLeaderBoard; _parser0.parseBOOL(optinLeaderBoard);
	AtfValidator::validateInt(_descr, "optinLeaderBoard", optinLeaderBoard, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody27(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(appLoginId);
	_parser0.parseUINT32(brandId);
	_parser0.parseUINT32(adminIntId);
	_parser0.parseStringP(adminId);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody27(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT64 appLoginId; _parser0.parseUINT64(appLoginId);
	AtfValidator::validateUint(_descr, "appLoginId", appLoginId, _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, BrandType_Last, _checker, __FILE__, __LINE__);
	UINT32 adminIntId; _parser0.parseUINT32(adminIntId);
	AtfValidator::validateInt(_descr, "adminIntId", adminIntId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "adminId"); size_t szAdminId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "adminId", szAdminId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody28(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(requestCtx);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody28(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 requestCtx; _parser0.parseINT32(requestCtx);
	AtfValidator::validateInt(_descr, "requestCtx", requestCtx, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserUpdateValidationResult
//=================================================================

regulator::common_structs::UserUpdateValidationResult::UserUpdateValidationResult()
{
	clear();
}

void regulator::common_structs::UserUpdateValidationResult::clear()
{
	updateType = 0;
	errCode = 0;
	errDescr.clear();
}

bool regulator::common_structs::UserUpdateValidationResult::equals(const UserUpdateValidationResult& _o) const
{
	return updateType == _o.updateType &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

const char *regulator::common_structs::UserUpdateValidationResult::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("updateType=");
	_buf.appendInt(updateType);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::common_structs::UserUpdateValidationResult::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("updateType", updateType, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::common_structs::UserUpdateValidationResult::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("updateType"))
		{
			updateType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errCode"))
		{
			errCode = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errDescr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::common_structs::UserUpdateValidationResult::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(updateType);
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
}

void regulator::common_structs::UserUpdateValidationResult::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(updateType);
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
}

const char *regulator::common_structs::UserUpdateValidationResult::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("updateType", updateType);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errDescr", errDescr);
	return _buf.c_str();
}

void regulator::common_structs::UserUpdateValidationResult::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("updateType", updateType);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errDescr", errDescr);
}

/* static */ void regulator::common_structs::UserUpdateValidationResult::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 updateType; _jparser.validateByNameThrow("updateType", updateType);
	AtfValidator::validateInt(_descr, "updateType", updateType, _checker, __FILE__, __LINE__);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
	AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::common_structs::UserUpdateValidationResult::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 updateType; _parser.parseINT32(updateType);
	AtfValidator::validateInt(_descr, "updateType", updateType, _checker, __FILE__, __LINE__);
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    SwissUrlParamString
//=================================================================

regulator::common_structs::SwissUrlParamString::SwissUrlParamString()
{
	clear();
}

void regulator::common_structs::SwissUrlParamString::clear()
{
	param.clear();
}

bool regulator::common_structs::SwissUrlParamString::equals(const SwissUrlParamString& _o) const
{
	return Atf::atfPStringEquals(param, _o.param);
}

const char *regulator::common_structs::SwissUrlParamString::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("param=");
	_buf.append(param);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::common_structs::SwissUrlParamString::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("param", param, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::common_structs::SwissUrlParamString::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("param"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, param)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::common_structs::SwissUrlParamString::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(param);
}

void regulator::common_structs::SwissUrlParamString::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(param);
}

const char *regulator::common_structs::SwissUrlParamString::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("param", param);
	return _buf.c_str();
}

void regulator::common_structs::SwissUrlParamString::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("param", param);
}

/* static */ void regulator::common_structs::SwissUrlParamString::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString param; _jparser.validateByNameThrow("param", param);
	AtfValidator::validateIntMax(_descr, "param", param.length(), 256, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::common_structs::SwissUrlParamString::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "param"); size_t szParam = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "param", szParam, 256, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    SwissUrlRequest
//=================================================================

regulator::common_structs::SwissUrlRequest::SwissUrlRequest()
{
	clear();
}

void regulator::common_structs::SwissUrlRequest::clear()
{
	locale = 0;
	urlType = 0;
	params.clear();
}

bool regulator::common_structs::SwissUrlRequest::equals(const SwissUrlRequest& _o) const
{
	return locale == _o.locale &&
		urlType == _o.urlType &&
		params.equals(_o.params);
}

const char *regulator::common_structs::SwissUrlRequest::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("urlType=");
	_buf.appendUint(urlType);
	_buf.append(',');
	_buf.append("params=");
	_buf.append("...");
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::common_structs::SwissUrlRequest::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("urlType", urlType, _buf);
	params.toXmlString("params", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::common_structs::SwissUrlRequest::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("locale"))
		{
			locale = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("urlType"))
		{
			urlType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("params"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SwissUrlParamString, 4 > >::FromXmlString(_value, params)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::common_structs::SwissUrlRequest::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(locale);
	_msg.composeUINT32(urlType);
	params.composeMsg(_msg, _ignoreJSON);
}

void regulator::common_structs::SwissUrlRequest::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(locale);
	_parser.parseUINT32(urlType);
	params.parseMsg(_parser);
}

const char *regulator::common_structs::SwissUrlRequest::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("urlType", urlType);
	_jsonstr.compose("params", params);
	return _buf.c_str();
}

void regulator::common_structs::SwissUrlRequest::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("urlType", urlType);
	_jparser.parseByNameThrow("params", params);
}

/* static */ void regulator::common_structs::SwissUrlRequest::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	UINT32 urlType; _jparser.validateByNameThrow("urlType", urlType);
	AtfValidator::validateInt(_descr, "urlType", urlType, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SwissUrlParamString > params; _jparser.validateByNameThrow("params", params);
	AtfValidator::validateIntMax(_descr, "params", params.size(), 8, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::common_structs::SwissUrlRequest::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	UINT32 urlType; _parser.parseUINT32(urlType);
	AtfValidator::validateInt(_descr, "urlType", urlType, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szParams = Atf::LAtfVector< SwissUrlParamString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("params"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "params", szParams, 8, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_UPDATE_USER2
//=================================================================

regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::Protocol_MSG_LOBBY_UPDATE_USER2()
{
	clear();
}

void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::clear()
{
	userId_ignore.clear();
	elements.clear();
	flags_ingore = 0;
	flags2_ignore = 0;
}

bool regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::equals(const Protocol_MSG_LOBBY_UPDATE_USER2& _o) const
{
	return Atf::atfPStringEquals(userId_ignore, _o.userId_ignore) &&
		elements.equals(_o.elements) &&
		flags_ingore == _o.flags_ingore &&
		flags2_ignore == _o.flags2_ignore;
}

bool regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_UPDATE_USER2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_UPDATE_USER2*)_other));
}

const char *regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_UPDATE_USER2).append(")");
	_buf.append(',');
	_buf.append("userId_ignore=");
	_buf.append(userId_ignore);
	_buf.append(',');
	_buf.append("elements=");
	elements.toTraceString(_buf);
	_buf.append(',');
	_buf.append("flags_ingore=");
	_buf.appendUint(flags_ingore);
	_buf.append(',');
	_buf.append("flags2_ignore=");
	_buf.appendUint64(flags2_ignore);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_UPDATE_USER2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId_ignore", userId_ignore, _buf);
	elements.toXmlString("elements", _buf);
	Atf::XmlElement::encodeAsXmlElement("flags_ingore", flags_ingore, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags2_ignore", flags2_ignore, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId_ignore"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId_ignore)) return false;
			}
			else if (_element.equals("elements"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< common_structs::UserUpdateElement, 4 > >::FromXmlString(_value, elements)) return false;
			}
			else if (_element.equals("flags_ingore"))
			{
				flags_ingore = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags2_ignore"))
			{
				flags2_ignore = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId_ignore);
	elements.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(flags_ingore);
	_msg.composeUINT64(flags2_ignore);
}

void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId_ignore);
	elements.parseMsg(_parser);
	_parser.parseUINT32(flags_ingore);
	_parser.parseUINT64(flags2_ignore);
}

const char *regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId_ignore", userId_ignore);
	_jsonstr.compose("elements", elements);
	_jsonstr.compose("flags_ingore", flags_ingore);
	_jsonstr.compose("flags2_ignore", flags2_ignore);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId_ignore", userId_ignore);
	_jparser.parseByNameThrow("elements", elements);
	_jparser.parseByNameThrow("flags_ingore", flags_ingore);
	_jparser.parseByNameThrow("flags2_ignore", flags2_ignore);
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_USER2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId_ignore; _jparser.validateByNameThrow("userId_ignore", userId_ignore);
	AtfValidator::validateIntMax(_descr, "userId_ignore", userId_ignore.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< common_structs::UserUpdateElement > elements; _jparser.validateByNameThrow("elements", elements);
	AtfValidator::validateIntMax(_descr, "elements", elements.size(), 1000, _checker, __FILE__, __LINE__);
	UINT32 flags_ingore; _jparser.validateByNameThrow("flags_ingore", flags_ingore);
	AtfValidator::validateInt(_descr, "flags_ingore", flags_ingore, _checker, __FILE__, __LINE__);
	UINT64 flags2_ignore; _jparser.validateByNameThrow("flags2_ignore", flags2_ignore);
	AtfValidator::validateUint(_descr, "flags2_ignore", flags2_ignore, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_USER2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId_ignore"); size_t szUserId_ignore = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId_ignore", szUserId_ignore, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szElements = Atf::LAtfVector< common_structs::UserUpdateElement, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("elements"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "elements", szElements, 1000, _checker, __FILE__, __LINE__);
	UINT32 flags_ingore; _parser.parseUINT32(flags_ingore);
	AtfValidator::validateInt(_descr, "flags_ingore", flags_ingore, _checker, __FILE__, __LINE__);
	UINT64 flags2_ignore; _parser.parseUINT64(flags2_ignore);
	AtfValidator::validateUint(_descr, "flags2_ignore", flags2_ignore, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_UPDATE_USER2_REPLY
//=================================================================

regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	frArjelUserHash.clear();
	doReconnect = false;
	emailAutoValidated = false;
	specificContext.clear();
}

bool regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::equals(const Protocol_MSG_LOBBY_UPDATE_USER2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(frArjelUserHash, _o.frArjelUserHash) &&
		doReconnect == _o.doReconnect &&
		emailAutoValidated == _o.emailAutoValidated &&
		specificContext.equals(_o.specificContext);
}

bool regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_UPDATE_USER2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_UPDATE_USER2_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_UPDATE_USER2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("frArjelUserHash=");
		_buf.append(frArjelUserHash);
		_buf.append(',');
		_buf.append("doReconnect=");
		_buf.appendUint(doReconnect);
		_buf.append(',');
		_buf.append("emailAutoValidated=");
		_buf.appendUint(emailAutoValidated);
		_buf.append(',');
		_buf.append("specificContext=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(specificContext, _buf); _buf.append('}');
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_UPDATE_USER2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("frArjelUserHash", frArjelUserHash, _buf);
		Atf::XmlElement::encodeAsXmlElement("doReconnect", doReconnect, _buf);
		Atf::XmlElement::encodeAsXmlElement("emailAutoValidated", emailAutoValidated, _buf);
		Atf::XmlElement::encodeAsXmlElement("specificContext", specificContext, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("frArjelUserHash"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, frArjelUserHash)) return false;
			}
			else if (_element.equals("doReconnect"))
			{
				doReconnect = (*_value.ptr() == '1');
			}
			else if (_element.equals("emailAutoValidated"))
			{
				emailAutoValidated = (*_value.ptr() == '1');
			}
			else if (_element.equals("specificContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, specificContext)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(frArjelUserHash);
		_msg.composeBOOL(doReconnect);
		_msg.composeBOOL(emailAutoValidated);
		_msg.composeMsgBody(specificContext);
	}
}

void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(frArjelUserHash);
		_parser.parseBOOL(doReconnect);
		_parser.parseBOOL(emailAutoValidated);
		if(_parser.parseEnded()) return;
		_parser.parseMsgBody(specificContext);
	}
}

const char *regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("frArjelUserHash", frArjelUserHash);
		_jsonstr.compose("doReconnect", doReconnect);
		_jsonstr.compose("emailAutoValidated", emailAutoValidated);
		_jsonstr.compose("specificContext", specificContext);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("frArjelUserHash", frArjelUserHash);
		_jparser.parseByNameThrow("doReconnect", doReconnect);
		_jparser.parseByNameThrow("emailAutoValidated", emailAutoValidated);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("specificContext", specificContext);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_USER2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString frArjelUserHash; _jparser.validateByNameThrow("frArjelUserHash", frArjelUserHash);
		AtfValidator::validateInt(_descr, "frArjelUserHash", frArjelUserHash.length(), _checker, __FILE__, __LINE__);
		bool doReconnect; _jparser.validateByNameThrow("doReconnect", doReconnect);
		AtfValidator::validateInt(_descr, "doReconnect", doReconnect, _checker, __FILE__, __LINE__);
		bool emailAutoValidated; _jparser.validateByNameThrow("emailAutoValidated", emailAutoValidated);
		AtfValidator::validateInt(_descr, "emailAutoValidated", emailAutoValidated, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		Atf::CopyableMsgBody specificContext; _jparser.validateByNameThrow("specificContext", specificContext);
		AtfValidator::validateInt(_descr, "specificContext", specificContext._size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_USER2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "frArjelUserHash"); size_t szFrArjelUserHash = strlen(_dummy);
		AtfValidator::validateInt(_descr, "frArjelUserHash", szFrArjelUserHash, _checker, __FILE__, __LINE__);
		bool doReconnect; _parser.parseBOOL(doReconnect);
		AtfValidator::validateInt(_descr, "doReconnect", doReconnect, _checker, __FILE__, __LINE__);
		bool emailAutoValidated; _parser.parseBOOL(emailAutoValidated);
		AtfValidator::validateInt(_descr, "emailAutoValidated", emailAutoValidated, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		size_t szSpecificContext; _parser.skipMsgBody(szSpecificContext);  /*specificContext*/
		AtfValidator::validateInt(_descr, "specificContext", szSpecificContext, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE
//=================================================================

regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE()
{
	clear();
}

void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::clear()
{
	fiscalCode.clear();
}

bool regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::equals(const Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE& _o) const
{
	return Atf::atfPStringEquals(fiscalCode, _o.fiscalCode);
}

bool regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_LOOKUP_FISCAL_CODE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE*)_other));
}

const char *regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_LOOKUP_FISCAL_CODE).append(")");
	_buf.append(',');
	_buf.append("fiscalCode=");
	_buf.append(fiscalCode);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_LOOKUP_FISCAL_CODE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("fiscalCode", fiscalCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("fiscalCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fiscalCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(fiscalCode);
}

void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(fiscalCode);
}

const char *regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("fiscalCode", fiscalCode);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("fiscalCode", fiscalCode);
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_LOOKUP_FISCAL_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString fiscalCode; _jparser.validateByNameThrow("fiscalCode", fiscalCode);
	AtfValidator::validateIntMax(_descr, "fiscalCode", fiscalCode.length(), 32, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_LOOKUP_FISCAL_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "fiscalCode"); size_t szFiscalCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fiscalCode", szFiscalCode, 32, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    FiscalCodeCountry
//=================================================================

regulator::cli::FiscalCodeCountry::FiscalCodeCountry()
{
	clear();
}

void regulator::cli::FiscalCodeCountry::clear()
{
	code.clear();
	country.clear();
}

bool regulator::cli::FiscalCodeCountry::equals(const FiscalCodeCountry& _o) const
{
	return Atf::atfPStringEquals(code, _o.code) &&
		Atf::atfPStringEquals(country, _o.country);
}

const char *regulator::cli::FiscalCodeCountry::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("code=");
	_buf.append(code);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::FiscalCodeCountry::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("code", code, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::FiscalCodeCountry::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("code"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, code)) return false;
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::FiscalCodeCountry::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FiscalCodeCountry())) // not empty
	{
		_body.composeString(code);
		_body.composeString(country);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::FiscalCodeCountry::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(code);
	_parser0.parseStringP(country);
}

const char *regulator::cli::FiscalCodeCountry::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("code", code);
	_jsonstr.compose("country", country);
	return _buf.c_str();
}

void regulator::cli::FiscalCodeCountry::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("code", code);
	_jparser.parseByNameThrow("country", country);
}

/* static */ void regulator::cli::FiscalCodeCountry::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString code; _jparser.validateByNameThrow("code", code);
	AtfValidator::validateInt(_descr, "code", code.length(), _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::FiscalCodeCountry::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "code"); size_t szCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "code", szCode, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FiscalCodeCity
//=================================================================

regulator::cli::FiscalCodeCity::FiscalCodeCity()
{
	clear();
}

void regulator::cli::FiscalCodeCity::clear()
{
	province.clear();
	city.clear();
}

bool regulator::cli::FiscalCodeCity::equals(const FiscalCodeCity& _o) const
{
	return Atf::atfPStringEquals(province, _o.province) &&
		Atf::atfPStringEquals(city, _o.city);
}

const char *regulator::cli::FiscalCodeCity::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("province=");
	_buf.append(province);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::FiscalCodeCity::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("province", province, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::FiscalCodeCity::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("province"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, province)) return false;
		}
		else if (_element.equals("city"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::FiscalCodeCity::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FiscalCodeCity())) // not empty
	{
		_body.composeString(province);
		_body.composeString(city);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::FiscalCodeCity::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(province);
	_parser0.parseStringP(city);
}

const char *regulator::cli::FiscalCodeCity::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("province", province);
	_jsonstr.compose("city", city);
	return _buf.c_str();
}

void regulator::cli::FiscalCodeCity::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("province", province);
	_jparser.parseByNameThrow("city", city);
}

/* static */ void regulator::cli::FiscalCodeCity::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString province; _jparser.validateByNameThrow("province", province);
	AtfValidator::validateInt(_descr, "province", province.length(), _checker, __FILE__, __LINE__);
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateInt(_descr, "city", city.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::FiscalCodeCity::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "province"); size_t szProvince = strlen(_dummy);
	AtfValidator::validateInt(_descr, "province", szProvince, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY
//=================================================================

regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	cities.clear();
	countries.clear();
}

bool regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::equals(const Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		cities.equals(_o.cities) &&
		countries.equals(_o.countries);
}

bool regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("cities=");
		cities.toTraceString(_buf);
		_buf.append(',');
		_buf.append("countries=");
		countries.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		cities.toXmlString("cities", _buf);
		countries.toXmlString("countries", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("cities"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< FiscalCodeCity, 4 > >::FromXmlString(_value, cities)) return false;
			}
			else if (_element.equals("countries"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< FiscalCodeCountry, 2 > >::FromXmlString(_value, countries)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		cities.composeMsg(_msg, _ignoreJSON);
		countries.composeMsg(_msg, _ignoreJSON);
	}
}

void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		cities.parseMsg(_parser);
		countries.parseMsg(_parser);
	}
}

const char *regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("cities", cities);
		_jsonstr.compose("countries", countries);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("cities", cities);
		_jparser.parseByNameThrow("countries", countries);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< FiscalCodeCity > cities; _jparser.validateByNameThrow("cities", cities);
		AtfValidator::validateInt(_descr, "cities", cities.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< FiscalCodeCountry > countries; _jparser.validateByNameThrow("countries", countries);
		AtfValidator::validateInt(_descr, "countries", countries.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szCities = Atf::LAtfVector< FiscalCodeCity, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cities"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "cities", szCities, _checker, __FILE__, __LINE__);
		int szCountries = Atf::LAtfVector< FiscalCodeCountry, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("countries"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "countries", szCountries, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::clear()
{
	unusedUserIntId = 0;
	unusedUserId.clear();
	fiscalCode.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::equals(const Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE& _o) const
{
	return unusedUserIntId == _o.unusedUserIntId &&
		Atf::atfPStringEquals(unusedUserId, _o.unusedUserId) &&
		Atf::atfPStringEquals(fiscalCode, _o.fiscalCode);
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE).append(")");
	_buf.append(',');
	_buf.append("unusedUserIntId=");
	_buf.appendUint(unusedUserIntId);
	_buf.append(',');
	_buf.append("unusedUserId=");
	_buf.append(unusedUserId);
	_buf.append(',');
	_buf.append("fiscalCode=");
	_buf.append(fiscalCode);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("unusedUserIntId", unusedUserIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("unusedUserId", unusedUserId, _buf);
	Atf::XmlElement::encodeAsXmlElement("fiscalCode", fiscalCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("unusedUserIntId"))
			{
				unusedUserIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("unusedUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, unusedUserId)) return false;
			}
			else if (_element.equals("fiscalCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fiscalCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(unusedUserIntId);
	_msg.composeString(unusedUserId);
	_msg.composeString(fiscalCode);
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(unusedUserIntId);
	_parser.parseStringP(unusedUserId);
	_parser.parseStringP(fiscalCode);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("unusedUserIntId", unusedUserIntId);
	_jsonstr.compose("unusedUserId", unusedUserId);
	_jsonstr.compose("fiscalCode", fiscalCode);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("unusedUserIntId", unusedUserIntId);
	_jparser.parseByNameThrow("unusedUserId", unusedUserId);
	_jparser.parseByNameThrow("fiscalCode", fiscalCode);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 unusedUserIntId; _jparser.validateByNameThrow("unusedUserIntId", unusedUserIntId);
	AtfValidator::validateInt(_descr, "unusedUserIntId", unusedUserIntId, _checker, __FILE__, __LINE__);
	PString unusedUserId; _jparser.validateByNameThrow("unusedUserId", unusedUserId);
	AtfValidator::validateIntMax(_descr, "unusedUserId", unusedUserId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString fiscalCode; _jparser.validateByNameThrow("fiscalCode", fiscalCode);
	AtfValidator::validateIntMax(_descr, "fiscalCode", fiscalCode.length(), 32, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 unusedUserIntId; _parser.parseUINT32(unusedUserIntId);
	AtfValidator::validateInt(_descr, "unusedUserIntId", unusedUserIntId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "unusedUserId"); size_t szUnusedUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedUserId", szUnusedUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "fiscalCode"); size_t szFiscalCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fiscalCode", szFiscalCode, 32, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::equals(const Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDesc);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDesc);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_USER_GET_INFO
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::Protocol_MSG_REGULATOR_USER_GET_INFO()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::clear()
{
	clientVersionInfo.clear();
	requestFlags = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::equals(const Protocol_MSG_REGULATOR_USER_GET_INFO& _o) const
{
	return Atf::atfPStringEquals(clientVersionInfo, _o.clientVersionInfo) &&
		requestFlags == _o.requestFlags;
}

bool regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_USER_GET_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_USER_GET_INFO*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_USER_GET_INFO).append(")");
	_buf.append(',');
	_buf.append("clVer=");
	_buf.append(clientVersionInfo);
	_buf.append(',');
	_buf.append("f=");
	_buf.appendUint(requestFlags);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_USER_GET_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clVer", clientVersionInfo, _buf);
	Atf::XmlElement::encodeAsXmlElement("f", requestFlags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clVer") || _element.equals("clientVersionInfo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clientVersionInfo)) return false;
			}
			else if (_element.equals("f") || _element.equals("requestFlags"))
			{
				requestFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(clientVersionInfo);
	_msg.composeUINT32(requestFlags);
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(clientVersionInfo);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(requestFlags);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clVer", clientVersionInfo);
	_jsonstr.compose("f", requestFlags);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("clVer", clientVersionInfo)) _jparser.parseByNameThrow("clientVersionInfo", clientVersionInfo);
	if(_jparser.parseEnded()) return;
	if(!_jparser.parseByName("f", requestFlags)) _jparser.parseByNameThrow("requestFlags", requestFlags);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_USER_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString clientVersionInfo; if(!_jparser.validateByName("clVer", clientVersionInfo)) _jparser.validateByNameThrow("clientVersionInfo", clientVersionInfo);
	AtfValidator::validateIntMax(_descr, "clientVersionInfo", clientVersionInfo.length(), 1000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 requestFlags; if(!_jparser.validateByName("f", requestFlags)) _jparser.validateByNameThrow("requestFlags", requestFlags);
	AtfValidator::validateInt(_descr, "requestFlags", requestFlags, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_USER_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "clientVersionInfo"); size_t szClientVersionInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientVersionInfo", szClientVersionInfo, 1000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 requestFlags; _parser.parseUINT32(requestFlags);
	AtfValidator::validateInt(_descr, "requestFlags", requestFlags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserInfoCurrencyAccountBody
//=================================================================

regulator::cli::UserInfoCurrencyAccountBody::UserInfoCurrencyAccountBody()
{
	clear();
}

void regulator::cli::UserInfoCurrencyAccountBody::clear()
{
	currency.clear();
	chips = 0;
	tChips = 0;
}

bool regulator::cli::UserInfoCurrencyAccountBody::equals(const UserInfoCurrencyAccountBody& _o) const
{
	return Atf::atfPStringEquals(currency, _o.currency) &&
		chips == _o.chips &&
		tChips == _o.tChips;
}

const char *regulator::cli::UserInfoCurrencyAccountBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt64(chips);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt64(tChips);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::UserInfoCurrencyAccountBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::UserInfoCurrencyAccountBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("chips"))
		{
			chips = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tChips"))
		{
			tChips = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::UserInfoCurrencyAccountBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(UserInfoCurrencyAccountBody())) // not empty
	{
		_body.composeString(currency);
		_body.composeINT64(chips);
		_body.composeINT64(tChips);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::UserInfoCurrencyAccountBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(chips);
	_parser0.parseINT64(tChips);
}

const char *regulator::cli::UserInfoCurrencyAccountBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("tChips", tChips);
	return _buf.c_str();
}

void regulator::cli::UserInfoCurrencyAccountBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("tChips", tChips);
}

/* static */ void regulator::cli::UserInfoCurrencyAccountBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT64 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT64 tChips; _jparser.validateByNameThrow("tChips", tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::UserInfoCurrencyAccountBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 chips; _parser0.parseINT64(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT64 tChips; _parser0.parseINT64(tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserInfoCommonBody
//=================================================================

regulator::cli::UserInfoCommonBody::UserInfoCommonBody()
{
	clear();
}

void regulator::cli::UserInfoCommonBody::clear()
{
	userOptions = 0;
	flags = 0;
	flags2 = 0;
	privileges = 0;
	privileges2 = 0;
	registered.setNull();
	firstDeposit.setNull();
	privileges3 = 0;
	userWebId.clear();
	licenseId = 0;
	country.clear();
	locale = 0;
	balances.clear();
	userId.clear();
	fppAmountCents = 0;
	playChips = 0;
	imageId = 0;
	email.clear();
	phone.clear();
	mobile.clear();
	sex.clear();
	addr1.clear();
	addr2.clear();
	city.clear();
	state.clear();
	zipCode.clear();
	timezone = 0;
	firstName.clear();
	lastName.clear();
	fullName.clear();
	flags3 = 0;
	userProperies.clear();
	emLocale = 0;
}

bool regulator::cli::UserInfoCommonBody::equals(const UserInfoCommonBody& _o) const
{
	return userOptions == _o.userOptions &&
		flags == _o.flags &&
		flags2 == _o.flags2 &&
		privileges == _o.privileges &&
		privileges2 == _o.privileges2 &&
		registered.equals(_o.registered) &&
		firstDeposit.equals(_o.firstDeposit) &&
		privileges3 == _o.privileges3 &&
		Atf::atfPStringEquals(userWebId, _o.userWebId) &&
		licenseId == _o.licenseId &&
		Atf::atfPStringEquals(country, _o.country) &&
		locale == _o.locale &&
		balances.equals(_o.balances) &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		fppAmountCents == _o.fppAmountCents &&
		playChips == _o.playChips &&
		imageId == _o.imageId &&
		Atf::atfPStringEquals(email, _o.email) &&
		Atf::atfPStringEquals(phone, _o.phone) &&
		Atf::atfPStringEquals(mobile, _o.mobile) &&
		Atf::atfPStringEquals(sex, _o.sex) &&
		Atf::atfPStringEquals(addr1, _o.addr1) &&
		Atf::atfPStringEquals(addr2, _o.addr2) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(zipCode, _o.zipCode) &&
		timezone == _o.timezone &&
		Atf::atfPStringEquals(firstName, _o.firstName) &&
		Atf::atfPStringEquals(lastName, _o.lastName) &&
		Atf::atfPStringEquals(fullName, _o.fullName) &&
		flags3 == _o.flags3 &&
		userProperies.equals(_o.userProperies) &&
		emLocale == _o.emLocale;
}

const char *regulator::cli::UserInfoCommonBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userOptions=");
	_buf.appendUint(userOptions);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("privileges=");
	_buf.appendUint(privileges);
	_buf.append(',');
	_buf.append("privileges2=");
	_buf.appendUint64(privileges2);
	_buf.append(',');
	_buf.append("registered=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, registered);
	_buf.append(',');
	_buf.append("firstDeposit=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, firstDeposit);
	_buf.append(',');
	_buf.append("privileges3=");
	_buf.appendUint64(privileges3);
	_buf.append(',');
	_buf.append("userWebId=");
	_buf.append(userWebId);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendInt(licenseId);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendInt(locale);
	_buf.append(',');
	_buf.append("balances=");
	balances.toTraceString(_buf);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("fppAmountCents=");
	_buf.appendInt64(fppAmountCents);
	_buf.append(',');
	_buf.append("playChips=");
	_buf.appendInt64(playChips);
	_buf.append(',');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("phone=");
	_buf.append(phone);
	_buf.append(',');
	_buf.append("mobile=");
	_buf.append(mobile);
	_buf.append(',');
	_buf.append("sex=");
	_buf.append(sex);
	_buf.append(',');
	_buf.append("addr1=");
	_buf.append(addr1);
	_buf.append(',');
	_buf.append("addr2=");
	_buf.append(addr2);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("zipCode=");
	_buf.append(zipCode);
	_buf.append(',');
	_buf.append("timezone=");
	_buf.appendUint(timezone);
	_buf.append(',');
	_buf.append("firstName=");
	_buf.append(firstName);
	_buf.append(',');
	_buf.append("lastName=");
	_buf.append(lastName);
	_buf.append(',');
	_buf.append("fullName=");
	_buf.append(fullName);
	_buf.append(',');
	_buf.append("flags3=");
	_buf.appendUint64(flags3);
	_buf.append(',');
	_buf.append("userProperies=");
	userProperies.toTraceString(_buf);
	_buf.append(',');
	_buf.append("emLocale=");
	_buf.appendInt(emLocale);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::UserInfoCommonBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userOptions", userOptions, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags2", flags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("privileges", privileges, _buf);
	Atf::XmlElement::encodeAsXmlElement("privileges2", privileges2, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "registered", registered);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "firstDeposit", firstDeposit);
	Atf::XmlElement::encodeAsXmlElement("privileges3", privileges3, _buf);
	Atf::XmlElement::encodeAsXmlElement("userWebId", userWebId, _buf);
	Atf::XmlElement::encodeAsXmlElement("licenseId", licenseId, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	balances.toXmlString("balances", _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppAmountCents", fppAmountCents, _buf);
	Atf::XmlElement::encodeAsXmlElement("playChips", playChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
	Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	Atf::XmlElement::encodeAsXmlElement("phone", phone, _buf);
	Atf::XmlElement::encodeAsXmlElement("mobile", mobile, _buf);
	Atf::XmlElement::encodeAsXmlElement("sex", sex, _buf);
	Atf::XmlElement::encodeAsXmlElement("addr1", addr1, _buf);
	Atf::XmlElement::encodeAsXmlElement("addr2", addr2, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("zipCode", zipCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("timezone", timezone, _buf);
	Atf::XmlElement::encodeAsXmlElement("firstName", firstName, _buf);
	Atf::XmlElement::encodeAsXmlElement("lastName", lastName, _buf);
	Atf::XmlElement::encodeAsXmlElement("fullName", fullName, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags3", flags3, _buf);
	userProperies.toXmlString("userProperies", _buf);
	Atf::XmlElement::encodeAsXmlElement("emLocale", emLocale, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::UserInfoCommonBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userOptions"))
		{
			userOptions = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags2"))
		{
			flags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("privileges"))
		{
			privileges = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("privileges2"))
		{
			privileges2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("registered"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, registered);
		}
		else if (_element.equals("firstDeposit"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, firstDeposit);
		}
		else if (_element.equals("privileges3"))
		{
			privileges3 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userWebId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userWebId)) return false;
		}
		else if (_element.equals("licenseId"))
		{
			licenseId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("locale"))
		{
			locale = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("balances"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UserInfoCurrencyAccountBody, 4 > >::FromXmlString(_value, balances)) return false;
		}
		else if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("fppAmountCents"))
		{
			fppAmountCents = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playChips"))
		{
			playChips = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("imageId"))
		{
			imageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("email"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
		}
		else if (_element.equals("phone"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, phone)) return false;
		}
		else if (_element.equals("mobile"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, mobile)) return false;
		}
		else if (_element.equals("sex"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, sex)) return false;
		}
		else if (_element.equals("addr1"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, addr1)) return false;
		}
		else if (_element.equals("addr2"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, addr2)) return false;
		}
		else if (_element.equals("city"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
		}
		else if (_element.equals("state"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
		}
		else if (_element.equals("zipCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, zipCode)) return false;
		}
		else if (_element.equals("timezone"))
		{
			timezone = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("firstName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, firstName)) return false;
		}
		else if (_element.equals("lastName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, lastName)) return false;
		}
		else if (_element.equals("fullName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, fullName)) return false;
		}
		else if (_element.equals("flags3"))
		{
			flags3 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userProperies"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< Common::AtfShared::UserPropertyBody, 4 > >::FromXmlString(_value, userProperies)) return false;
		}
		else if (_element.equals("emLocale"))
		{
			emLocale = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::UserInfoCommonBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(UserInfoCommonBody())) // not empty
	{
		_body.composeUINT32(userOptions);
		_body.composeUINT32(flags);
		_body.composeUINT64(flags2);
		_body.composeUINT32(privileges);
		_body.composeUINT64(privileges2);
		_body.composeSrvTime(registered);
		_body.composeSrvTime(firstDeposit);
		_body.composeUINT64(privileges3);
		_body.composeString(userWebId);
		_body.composeINT32(licenseId);
		_body.composeString(country);
		_body.composeINT32(locale);
		balances.composeMsg(_body, _ignoreJSON);
		_body.composeString(userId);
		_body.composeINT64(fppAmountCents);
		_body.composeINT64(playChips);
		_body.composeUINT32(imageId);
		_body.composeString(email);
		_body.composeString(phone);
		_body.composeString(mobile);
		_body.composeString(sex);
		_body.composeString(addr1);
		_body.composeString(addr2);
		_body.composeString(city);
		_body.composeString(state);
		_body.composeString(zipCode);
		_body.composeUINT32(timezone);
		_body.composeString(firstName);
		_body.composeString(lastName);
		_body.composeString(fullName);
		_body.composeUINT64(flags3);
		userProperies.composeMsg(_body, _ignoreJSON);
		_body.composeINT32(emLocale);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::UserInfoCommonBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(userOptions);
	_parser0.parseUINT32(flags);
	_parser0.parseUINT64(flags2);
	_parser0.parseUINT32(privileges);
	_parser0.parseUINT64(privileges2);
	_parser0.parseSrvTime(registered);
	_parser0.parseSrvTime(firstDeposit);
	_parser0.parseUINT64(privileges3);
	_parser0.parseStringP(userWebId);
	_parser0.parseINT32(licenseId);
	_parser0.parseStringP(country);
	_parser0.parseINT32(locale);
	balances.parseMsg(_parser0);
	_parser0.parseStringP(userId);
	_parser0.parseINT64(fppAmountCents);
	_parser0.parseINT64(playChips);
	_parser0.parseUINT32(imageId);
	_parser0.parseStringP(email);
	_parser0.parseStringP(phone);
	_parser0.parseStringP(mobile);
	_parser0.parseStringP(sex);
	_parser0.parseStringP(addr1);
	_parser0.parseStringP(addr2);
	_parser0.parseStringP(city);
	_parser0.parseStringP(state);
	_parser0.parseStringP(zipCode);
	_parser0.parseUINT32(timezone);
	_parser0.parseStringP(firstName);
	_parser0.parseStringP(lastName);
	_parser0.parseStringP(fullName);
	_parser0.parseUINT64(flags3);
	userProperies.parseMsg(_parser0);
	_parser0.parseINT32(emLocale);
}

const char *regulator::cli::UserInfoCommonBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userOptions", userOptions);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("flags2", flags2);
	_jsonstr.compose("privileges", privileges);
	_jsonstr.compose("privileges2", privileges2);
	_jsonstr.compose("registered", registered);
	_jsonstr.compose("firstDeposit", firstDeposit);
	_jsonstr.compose("privileges3", privileges3);
	_jsonstr.compose("userWebId", userWebId);
	_jsonstr.compose("licenseId", licenseId);
	_jsonstr.compose("country", country);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("balances", balances);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("fppAmountCents", fppAmountCents);
	_jsonstr.compose("playChips", playChips);
	_jsonstr.compose("imageId", imageId);
	_jsonstr.compose("email", email);
	_jsonstr.compose("phone", phone);
	_jsonstr.compose("mobile", mobile);
	_jsonstr.compose("sex", sex);
	_jsonstr.compose("addr1", addr1);
	_jsonstr.compose("addr2", addr2);
	_jsonstr.compose("city", city);
	_jsonstr.compose("state", state);
	_jsonstr.compose("zipCode", zipCode);
	_jsonstr.compose("timezone", timezone);
	_jsonstr.compose("firstName", firstName);
	_jsonstr.compose("lastName", lastName);
	_jsonstr.compose("fullName", fullName);
	_jsonstr.compose("flags3", flags3);
	_jsonstr.compose("userProperies", userProperies);
	_jsonstr.compose("emLocale", emLocale);
	return _buf.c_str();
}

void regulator::cli::UserInfoCommonBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userOptions", userOptions);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("flags2", flags2);
	_jparser.parseByNameThrow("privileges", privileges);
	_jparser.parseByNameThrow("privileges2", privileges2);
	_jparser.parseByNameThrow("registered", registered);
	_jparser.parseByNameThrow("firstDeposit", firstDeposit);
	_jparser.parseByNameThrow("privileges3", privileges3);
	_jparser.parseByNameThrow("userWebId", userWebId);
	_jparser.parseByNameThrow("licenseId", licenseId);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("balances", balances);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("fppAmountCents", fppAmountCents);
	_jparser.parseByNameThrow("playChips", playChips);
	_jparser.parseByNameThrow("imageId", imageId);
	_jparser.parseByNameThrow("email", email);
	_jparser.parseByNameThrow("phone", phone);
	_jparser.parseByNameThrow("mobile", mobile);
	_jparser.parseByNameThrow("sex", sex);
	_jparser.parseByNameThrow("addr1", addr1);
	_jparser.parseByNameThrow("addr2", addr2);
	_jparser.parseByNameThrow("city", city);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("zipCode", zipCode);
	_jparser.parseByNameThrow("timezone", timezone);
	_jparser.parseByNameThrow("firstName", firstName);
	_jparser.parseByNameThrow("lastName", lastName);
	_jparser.parseByNameThrow("fullName", fullName);
	_jparser.parseByNameThrow("flags3", flags3);
	_jparser.parseByNameThrow("userProperies", userProperies);
	_jparser.parseByNameThrow("emLocale", emLocale);
}

/* static */ void regulator::cli::UserInfoCommonBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 userOptions; _jparser.validateByNameThrow("userOptions", userOptions);
	AtfValidator::validateInt(_descr, "userOptions", userOptions, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _jparser.validateByNameThrow("flags2", flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	UINT32 privileges; _jparser.validateByNameThrow("privileges", privileges);
	AtfValidator::validateInt(_descr, "privileges", privileges, _checker, __FILE__, __LINE__);
	UINT64 privileges2; _jparser.validateByNameThrow("privileges2", privileges2);
	AtfValidator::validateUint(_descr, "privileges2", privileges2, _checker, __FILE__, __LINE__);
	CommSrvTime registered; _jparser.validateByNameThrow("registered", registered);
	AtfValidator::validateSrvDateTime(_descr, "registered", registered, _checker, __FILE__, __LINE__);
	CommSrvTime firstDeposit; _jparser.validateByNameThrow("firstDeposit", firstDeposit);
	AtfValidator::validateSrvDateTime(_descr, "firstDeposit", firstDeposit, _checker, __FILE__, __LINE__);
	UINT64 privileges3; _jparser.validateByNameThrow("privileges3", privileges3);
	AtfValidator::validateUint(_descr, "privileges3", privileges3, _checker, __FILE__, __LINE__);
	PString userWebId; _jparser.validateByNameThrow("userWebId", userWebId);
	AtfValidator::validateInt(_descr, "userWebId", userWebId.length(), _checker, __FILE__, __LINE__);
	INT32 licenseId; _jparser.validateByNameThrow("licenseId", licenseId);
	AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	INT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UserInfoCurrencyAccountBody > balances; _jparser.validateByNameThrow("balances", balances);
	AtfValidator::validateInt(_descr, "balances", balances.size(), _checker, __FILE__, __LINE__);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	INT64 fppAmountCents; _jparser.validateByNameThrow("fppAmountCents", fppAmountCents);
	AtfValidator::validateInt(_descr, "fppAmountCents", fppAmountCents, _checker, __FILE__, __LINE__);
	INT64 playChips; _jparser.validateByNameThrow("playChips", playChips);
	AtfValidator::validateInt(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
	UINT32 imageId; _jparser.validateByNameThrow("imageId", imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	PString email; _jparser.validateByNameThrow("email", email);
	AtfValidator::validateInt(_descr, "email", email.length(), _checker, __FILE__, __LINE__);
	PString phone; _jparser.validateByNameThrow("phone", phone);
	AtfValidator::validateInt(_descr, "phone", phone.length(), _checker, __FILE__, __LINE__);
	PString mobile; _jparser.validateByNameThrow("mobile", mobile);
	AtfValidator::validateInt(_descr, "mobile", mobile.length(), _checker, __FILE__, __LINE__);
	PString sex; _jparser.validateByNameThrow("sex", sex);
	AtfValidator::validateInt(_descr, "sex", sex.length(), _checker, __FILE__, __LINE__);
	PString addr1; _jparser.validateByNameThrow("addr1", addr1);
	AtfValidator::validateInt(_descr, "addr1", addr1.length(), _checker, __FILE__, __LINE__);
	PString addr2; _jparser.validateByNameThrow("addr2", addr2);
	AtfValidator::validateInt(_descr, "addr2", addr2.length(), _checker, __FILE__, __LINE__);
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateInt(_descr, "city", city.length(), _checker, __FILE__, __LINE__);
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateInt(_descr, "state", state.length(), _checker, __FILE__, __LINE__);
	PString zipCode; _jparser.validateByNameThrow("zipCode", zipCode);
	AtfValidator::validateInt(_descr, "zipCode", zipCode.length(), _checker, __FILE__, __LINE__);
	UINT32 timezone; _jparser.validateByNameThrow("timezone", timezone);
	AtfValidator::validateInt(_descr, "timezone", timezone, _checker, __FILE__, __LINE__);
	PString firstName; _jparser.validateByNameThrow("firstName", firstName);
	AtfValidator::validateInt(_descr, "firstName", firstName.length(), _checker, __FILE__, __LINE__);
	PString lastName; _jparser.validateByNameThrow("lastName", lastName);
	AtfValidator::validateInt(_descr, "lastName", lastName.length(), _checker, __FILE__, __LINE__);
	PString fullName; _jparser.validateByNameThrow("fullName", fullName);
	AtfValidator::validateInt(_descr, "fullName", fullName.length(), _checker, __FILE__, __LINE__);
	UINT64 flags3; _jparser.validateByNameThrow("flags3", flags3);
	AtfValidator::validateUint(_descr, "flags3", flags3, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< Common::AtfShared::UserPropertyBody > userProperies; _jparser.validateByNameThrow("userProperies", userProperies);
	AtfValidator::validateInt(_descr, "userProperies", userProperies.size(), _checker, __FILE__, __LINE__);
	INT32 emLocale; _jparser.validateByNameThrow("emLocale", emLocale);
	AtfValidator::validateInt(_descr, "emLocale", emLocale, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::UserInfoCommonBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 userOptions; _parser0.parseUINT32(userOptions);
	AtfValidator::validateInt(_descr, "userOptions", userOptions, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser0.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	UINT32 privileges; _parser0.parseUINT32(privileges);
	AtfValidator::validateInt(_descr, "privileges", privileges, _checker, __FILE__, __LINE__);
	UINT64 privileges2; _parser0.parseUINT64(privileges2);
	AtfValidator::validateUint(_descr, "privileges2", privileges2, _checker, __FILE__, __LINE__);
	CommSrvTime registered; _parser0.parseSrvTime(registered);
	AtfValidator::validateSrvDateTime(_descr, "registered", registered, _checker, __FILE__, __LINE__);
	CommSrvTime firstDeposit; _parser0.parseSrvTime(firstDeposit);
	AtfValidator::validateSrvDateTime(_descr, "firstDeposit", firstDeposit, _checker, __FILE__, __LINE__);
	UINT64 privileges3; _parser0.parseUINT64(privileges3);
	AtfValidator::validateUint(_descr, "privileges3", privileges3, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "userWebId"); size_t szUserWebId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userWebId", szUserWebId, _checker, __FILE__, __LINE__);
	INT32 licenseId; _parser0.parseINT32(licenseId);
	AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	INT32 locale; _parser0.parseINT32(locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szBalances = Atf::LAtfVector< UserInfoCurrencyAccountBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("balances"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "balances", szBalances, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	INT64 fppAmountCents; _parser0.parseINT64(fppAmountCents);
	AtfValidator::validateInt(_descr, "fppAmountCents", fppAmountCents, _checker, __FILE__, __LINE__);
	INT64 playChips; _parser0.parseINT64(playChips);
	AtfValidator::validateInt(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
	UINT32 imageId; _parser0.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateInt(_descr, "phone", szPhone, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "mobile"); size_t szMobile = strlen(_dummy);
	AtfValidator::validateInt(_descr, "mobile", szMobile, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "sex"); size_t szSex = strlen(_dummy);
	AtfValidator::validateInt(_descr, "sex", szSex, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "addr1"); size_t szAddr1 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "addr1", szAddr1, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "addr2"); size_t szAddr2 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "addr2", szAddr2, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateInt(_descr, "state", szState, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "zipCode"); size_t szZipCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "zipCode", szZipCode, _checker, __FILE__, __LINE__);
	UINT32 timezone; _parser0.parseUINT32(timezone);
	AtfValidator::validateInt(_descr, "timezone", timezone, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "firstName", szFirstName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "lastName"); size_t szLastName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "lastName", szLastName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "fullName"); size_t szFullName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "fullName", szFullName, _checker, __FILE__, __LINE__);
	UINT64 flags3; _parser0.parseUINT64(flags3);
	AtfValidator::validateUint(_descr, "flags3", flags3, _checker, __FILE__, __LINE__);
	int szUserProperies = Atf::LAtfVector< Common::AtfShared::UserPropertyBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("userProperies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userProperies", szUserProperies, _checker, __FILE__, __LINE__);
	INT32 emLocale; _parser0.parseINT32(emLocale);
	AtfValidator::validateInt(_descr, "emLocale", emLocale, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserInfoRegulatorAction
//=================================================================

regulator::cli::UserInfoRegulatorAction::UserInfoRegulatorAction()
{
	clear();
}

void regulator::cli::UserInfoRegulatorAction::clear()
{
	actionRequest = 0;
	specificBody.clear();
}

bool regulator::cli::UserInfoRegulatorAction::equals(const UserInfoRegulatorAction& _o) const
{
	return actionRequest == _o.actionRequest &&
		specificBody.equals(_o.specificBody);
}

const char *regulator::cli::UserInfoRegulatorAction::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("actionRequest=");
	_buf.appendUint(actionRequest);
	_buf.append(',');
	_buf.append("specificBody=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(specificBody, _buf); _buf.append('}');
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::UserInfoRegulatorAction::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("actionRequest", actionRequest, _buf);
	Atf::XmlElement::encodeAsXmlElement("specificBody", specificBody, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::UserInfoRegulatorAction::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("actionRequest"))
		{
			actionRequest = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("specificBody"))
		{
			if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, specificBody)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::UserInfoRegulatorAction::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(actionRequest);
	_msg.composeMsgBody(specificBody);
}

void regulator::cli::UserInfoRegulatorAction::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(actionRequest);
	_parser.parseMsgBody(specificBody);
}

const char *regulator::cli::UserInfoRegulatorAction::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("actionRequest", actionRequest);
	_jsonstr.compose("specificBody", specificBody);
	return _buf.c_str();
}

void regulator::cli::UserInfoRegulatorAction::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("actionRequest", actionRequest);
	_jparser.parseByNameThrow("specificBody", specificBody);
}

/* static */ void regulator::cli::UserInfoRegulatorAction::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 actionRequest; _jparser.validateByNameThrow("actionRequest", actionRequest);
	AtfValidator::validateInt(_descr, "actionRequest", actionRequest, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody specificBody; _jparser.validateByNameThrow("specificBody", specificBody);
	AtfValidator::validateInt(_descr, "specificBody", specificBody._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::UserInfoRegulatorAction::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 actionRequest; _parser.parseUINT32(actionRequest);
	AtfValidator::validateInt(_descr, "actionRequest", actionRequest, _checker, __FILE__, __LINE__);
	size_t szSpecificBody; _parser.skipMsgBody(szSpecificBody);  /*specificBody*/
	AtfValidator::validateInt(_descr, "specificBody", szSpecificBody, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    UserInfoRegulatorNotification
//=================================================================

regulator::cli::UserInfoRegulatorNotification::UserInfoRegulatorNotification()
{
	clear();
}

void regulator::cli::UserInfoRegulatorNotification::clear()
{
	notificationType = 0;
	specificBody.clear();
}

bool regulator::cli::UserInfoRegulatorNotification::equals(const UserInfoRegulatorNotification& _o) const
{
	return notificationType == _o.notificationType &&
		specificBody.equals(_o.specificBody);
}

const char *regulator::cli::UserInfoRegulatorNotification::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("notificationType=");
	_buf.appendUint(notificationType);
	_buf.append(',');
	_buf.append("specificBody=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(specificBody, _buf); _buf.append('}');
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::UserInfoRegulatorNotification::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("notificationType", notificationType, _buf);
	Atf::XmlElement::encodeAsXmlElement("specificBody", specificBody, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::UserInfoRegulatorNotification::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("notificationType"))
		{
			notificationType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("specificBody"))
		{
			if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, specificBody)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::UserInfoRegulatorNotification::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(notificationType);
	_msg.composeMsgBody(specificBody);
}

void regulator::cli::UserInfoRegulatorNotification::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(notificationType);
	_parser.parseMsgBody(specificBody);
}

const char *regulator::cli::UserInfoRegulatorNotification::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notificationType", notificationType);
	_jsonstr.compose("specificBody", specificBody);
	return _buf.c_str();
}

void regulator::cli::UserInfoRegulatorNotification::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notificationType", notificationType);
	_jparser.parseByNameThrow("specificBody", specificBody);
}

/* static */ void regulator::cli::UserInfoRegulatorNotification::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 notificationType; _jparser.validateByNameThrow("notificationType", notificationType);
	AtfValidator::validateInt(_descr, "notificationType", notificationType, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody specificBody; _jparser.validateByNameThrow("specificBody", specificBody);
	AtfValidator::validateInt(_descr, "specificBody", specificBody._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::UserInfoRegulatorNotification::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 notificationType; _parser.parseUINT32(notificationType);
	AtfValidator::validateInt(_descr, "notificationType", notificationType, _checker, __FILE__, __LINE__);
	size_t szSpecificBody; _parser.skipMsgBody(szSpecificBody);  /*specificBody*/
	AtfValidator::validateInt(_descr, "specificBody", szSpecificBody, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	commonBody.clear();
	regulatorActions.clear();
	regulatorNotifications.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::equals(const Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		commonBody.equals(_o.commonBody) &&
		regulatorActions.equals(_o.regulatorActions) &&
		regulatorNotifications.equals(_o.regulatorNotifications);
}

bool regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_USER_GET_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_USER_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("commonBody=");
		commonBody.toTraceString(_buf);
		_buf.append(',');
		_buf.append("regulatorActions=");
		regulatorActions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("regulatorNotifications=");
		regulatorNotifications.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_USER_GET_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		commonBody.toXmlString("commonBody", _buf);
		regulatorActions.toXmlString("regulatorActions", _buf);
		regulatorNotifications.toXmlString("regulatorNotifications", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("commonBody"))
			{
				if(!Atf::AtfTempl< UserInfoCommonBody >::FromXmlString(_value, commonBody)) return false;
			}
			else if (_element.equals("regulatorActions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserInfoRegulatorAction, 4 > >::FromXmlString(_value, regulatorActions)) return false;
			}
			else if (_element.equals("regulatorNotifications"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserInfoRegulatorNotification, 4 > >::FromXmlString(_value, regulatorNotifications)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		commonBody.composeMsg(_msg, _ignoreJSON);
		regulatorActions.composeMsg(_msg, _ignoreJSON);
		CommMsgBody _msg0;
		regulatorNotifications.composeMsg(_msg0, _ignoreJSON);
		_msg.composeMsgBody(_msg0);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		commonBody.parseMsg(_parser);
		regulatorActions.parseMsg(_parser);
		parseAnonymousMsgBody0(_parser);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("commonBody", commonBody);
		_jsonstr.compose("regulatorActions", regulatorActions);
		_jsonstr.compose("regulatorNotifications", regulatorNotifications);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("commonBody", commonBody);
		_jparser.parseByNameThrow("regulatorActions", regulatorActions);
		_jparser.parseByNameThrow("regulatorNotifications", regulatorNotifications);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_USER_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UserInfoCommonBody commonBody; _jparser.validateByNameThrow("commonBody", commonBody);
		Atf::AtfVectorBase< UserInfoRegulatorAction > regulatorActions; _jparser.validateByNameThrow("regulatorActions", regulatorActions);
		AtfValidator::validateInt(_descr, "regulatorActions", regulatorActions.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UserInfoRegulatorNotification > regulatorNotifications; _jparser.validateByNameThrow("regulatorNotifications", regulatorNotifications);
		AtfValidator::validateInt(_descr, "regulatorNotifications", regulatorNotifications.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_USER_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserInfoCommonBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("commonBody"), _fieldsWithUnparsedContent);
		int szRegulatorActions = Atf::LAtfVector< UserInfoRegulatorAction, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("regulatorActions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "regulatorActions", szRegulatorActions, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	regulatorNotifications.parseMsg(_parser0);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szRegulatorNotifications = Atf::LAtfVector< UserInfoRegulatorNotification, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("regulatorNotifications"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "regulatorNotifications", szRegulatorNotifications, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::clear()
{
	clientVersionInfo.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::equals(const Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS& _o) const
{
	return Atf::atfPStringEquals(clientVersionInfo, _o.clientVersionInfo);
}

bool regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS).append(")");
	_buf.append(',');
	_buf.append("clientVersionInfo=");
	_buf.append(clientVersionInfo);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clientVersionInfo", clientVersionInfo, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clientVersionInfo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clientVersionInfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(clientVersionInfo);
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(clientVersionInfo);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clientVersionInfo", clientVersionInfo);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clientVersionInfo", clientVersionInfo);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString clientVersionInfo; _jparser.validateByNameThrow("clientVersionInfo", clientVersionInfo);
	AtfValidator::validateIntMax(_descr, "clientVersionInfo", clientVersionInfo.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "clientVersionInfo"); size_t szClientVersionInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientVersionInfo", szClientVersionInfo, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	commonBody.clear();
	regulatorActions_alwaysEmpty.clear();
	regulatorNotifications_alwaysEmpty.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::equals(const Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		commonBody.equals(_o.commonBody) &&
		regulatorActions_alwaysEmpty.equals(_o.regulatorActions_alwaysEmpty) &&
		regulatorNotifications_alwaysEmpty.equals(_o.regulatorNotifications_alwaysEmpty);
}

bool regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("commonBody=");
		commonBody.toTraceString(_buf);
		_buf.append(',');
		_buf.append("regulatorActions_alwaysEmpty=");
		regulatorActions_alwaysEmpty.toTraceString(_buf);
		_buf.append(',');
		_buf.append("regulatorNotifications_alwaysEmpty=");
		regulatorNotifications_alwaysEmpty.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		commonBody.toXmlString("commonBody", _buf);
		regulatorActions_alwaysEmpty.toXmlString("regulatorActions_alwaysEmpty", _buf);
		regulatorNotifications_alwaysEmpty.toXmlString("regulatorNotifications_alwaysEmpty", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("commonBody"))
			{
				if(!Atf::AtfTempl< UserInfoCommonBody >::FromXmlString(_value, commonBody)) return false;
			}
			else if (_element.equals("regulatorActions_alwaysEmpty"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserInfoRegulatorAction, 4 > >::FromXmlString(_value, regulatorActions_alwaysEmpty)) return false;
			}
			else if (_element.equals("regulatorNotifications_alwaysEmpty"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserInfoRegulatorNotification, 4 > >::FromXmlString(_value, regulatorNotifications_alwaysEmpty)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		commonBody.composeMsg(_msg, _ignoreJSON);
		regulatorActions_alwaysEmpty.composeMsg(_msg, _ignoreJSON);
		CommMsgBody _msg0;
		regulatorNotifications_alwaysEmpty.composeMsg(_msg0, _ignoreJSON);
		_msg.composeMsgBody(_msg0);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		commonBody.parseMsg(_parser);
		regulatorActions_alwaysEmpty.parseMsg(_parser);
		parseAnonymousMsgBody0(_parser);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("commonBody", commonBody);
		_jsonstr.compose("regulatorActions_alwaysEmpty", regulatorActions_alwaysEmpty);
		_jsonstr.compose("regulatorNotifications_alwaysEmpty", regulatorNotifications_alwaysEmpty);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("commonBody", commonBody);
		_jparser.parseByNameThrow("regulatorActions_alwaysEmpty", regulatorActions_alwaysEmpty);
		_jparser.parseByNameThrow("regulatorNotifications_alwaysEmpty", regulatorNotifications_alwaysEmpty);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UserInfoCommonBody commonBody; _jparser.validateByNameThrow("commonBody", commonBody);
		Atf::AtfVectorBase< UserInfoRegulatorAction > regulatorActions_alwaysEmpty; _jparser.validateByNameThrow("regulatorActions_alwaysEmpty", regulatorActions_alwaysEmpty);
		AtfValidator::validateInt(_descr, "regulatorActions_alwaysEmpty", regulatorActions_alwaysEmpty.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UserInfoRegulatorNotification > regulatorNotifications_alwaysEmpty; _jparser.validateByNameThrow("regulatorNotifications_alwaysEmpty", regulatorNotifications_alwaysEmpty);
		AtfValidator::validateInt(_descr, "regulatorNotifications_alwaysEmpty", regulatorNotifications_alwaysEmpty.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserInfoCommonBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("commonBody"), _fieldsWithUnparsedContent);
		int szRegulatorActions_alwaysEmpty = Atf::LAtfVector< UserInfoRegulatorAction, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("regulatorActions_alwaysEmpty"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "regulatorActions_alwaysEmpty", szRegulatorActions_alwaysEmpty, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	regulatorNotifications_alwaysEmpty.parseMsg(_parser0);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szRegulatorNotifications_alwaysEmpty = Atf::LAtfVector< UserInfoRegulatorNotification, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("regulatorNotifications_alwaysEmpty"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "regulatorNotifications_alwaysEmpty", szRegulatorNotifications_alwaysEmpty, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_MIGRATION_GET_INFO
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::equals(const Protocol_MSG_REGULATOR_MIGRATION_GET_INFO& _o) const
{
	return true;
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_MIGRATION_GET_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_MIGRATION_GET_INFO*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_MIGRATION_GET_INFO).append(")");
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_MIGRATION_GET_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::parseMsg(CommMsgParser& _parser)
{
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::equals(const Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_MIGRATION_GET_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_MIGRATION_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_MIGRATION_GET_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_MIGRATION_PERFORM
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::Protocol_MSG_REGULATOR_MIGRATION_PERFORM()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::clear()
{
	migrFlags = 0;
	migrSiteId = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::equals(const Protocol_MSG_REGULATOR_MIGRATION_PERFORM& _o) const
{
	return migrFlags == _o.migrFlags &&
		migrSiteId == _o.migrSiteId;
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_MIGRATION_PERFORM != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_MIGRATION_PERFORM*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_MIGRATION_PERFORM).append(")");
	_buf.append(',');
	_buf.append("migrFlags=");
	_buf.appendUint(migrFlags);
	_buf.append(',');
	_buf.append("migrSiteId=");
	_buf.appendUint(migrSiteId);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_MIGRATION_PERFORM).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("migrFlags", migrFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("migrSiteId", migrSiteId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("migrFlags"))
			{
				migrFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("migrSiteId"))
			{
				migrSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(migrFlags);
	_msg.composeUINT32(migrSiteId);
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(migrFlags);
	_parser.parseUINT32(migrSiteId);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("migrFlags", migrFlags);
	_jsonstr.compose("migrSiteId", migrSiteId);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("migrFlags", migrFlags);
	_jparser.parseByNameThrow("migrSiteId", migrSiteId);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_PERFORM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 migrFlags; _jparser.validateByNameThrow("migrFlags", migrFlags);
	AtfValidator::validateIntMax(_descr, "migrFlags", migrFlags, ((UINT32(eMigrationFlagLast)<<1)-UINT32(1)), _checker, __FILE__, __LINE__);
	UINT32 migrSiteId; _jparser.validateByNameThrow("migrSiteId", migrSiteId);
	AtfValidator::validateIntRange(_descr, "migrSiteId", migrSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_PERFORM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 migrFlags; _parser.parseUINT32(migrFlags);
	AtfValidator::validateIntMax(_descr, "migrFlags", migrFlags, ((UINT32(eMigrationFlagLast)<<1)-UINT32(1)), _checker, __FILE__, __LINE__);
	UINT32 migrSiteId; _parser.parseUINT32(migrSiteId);
	AtfValidator::validateIntRange(_descr, "migrSiteId", migrSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::equals(const Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_MIGRATION_PERFORM_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_MIGRATION_PERFORM_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_MIGRATION_PERFORM_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errDescr", errDescr);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errDescr", errDescr);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_PERFORM_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
	AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_PERFORM_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::clear()
{
	migrFlags = 0;
	migrSiteId = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::equals(const Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY& _o) const
{
	return migrFlags == _o.migrFlags &&
		migrSiteId == _o.migrSiteId;
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_MIGRATION_CHECK_ONLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_MIGRATION_CHECK_ONLY).append(")");
	_buf.append(',');
	_buf.append("migrFlags=");
	_buf.appendUint(migrFlags);
	_buf.append(',');
	_buf.append("migrSiteId=");
	_buf.appendUint(migrSiteId);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_MIGRATION_CHECK_ONLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("migrFlags", migrFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("migrSiteId", migrSiteId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("migrFlags"))
			{
				migrFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("migrSiteId"))
			{
				migrSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(migrFlags);
	_msg.composeUINT32(migrSiteId);
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(migrFlags);
	_parser.parseUINT32(migrSiteId);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("migrFlags", migrFlags);
	_jsonstr.compose("migrSiteId", migrSiteId);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("migrFlags", migrFlags);
	_jparser.parseByNameThrow("migrSiteId", migrSiteId);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_CHECK_ONLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 migrFlags; _jparser.validateByNameThrow("migrFlags", migrFlags);
	AtfValidator::validateIntMax(_descr, "migrFlags", migrFlags, ((UINT32(eMigrationCheckFlagLast)<<1)-UINT32(1)), _checker, __FILE__, __LINE__);
	UINT32 migrSiteId; _jparser.validateByNameThrow("migrSiteId", migrSiteId);
	AtfValidator::validateIntRange(_descr, "migrSiteId", migrSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_CHECK_ONLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 migrFlags; _parser.parseUINT32(migrFlags);
	AtfValidator::validateIntMax(_descr, "migrFlags", migrFlags, ((UINT32(eMigrationCheckFlagLast)<<1)-UINT32(1)), _checker, __FILE__, __LINE__);
	UINT32 migrSiteId; _parser.parseUINT32(migrSiteId);
	AtfValidator::validateIntRange(_descr, "migrSiteId", migrSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    RegulatorMigrCheckOnlyReplyStruct
//=================================================================

regulator::cli::RegulatorMigrCheckOnlyReplyStruct::RegulatorMigrCheckOnlyReplyStruct()
{
	clear();
}

void regulator::cli::RegulatorMigrCheckOnlyReplyStruct::clear()
{
	targetLicenceId = 0;
	migrToken.clear();
}

bool regulator::cli::RegulatorMigrCheckOnlyReplyStruct::equals(const RegulatorMigrCheckOnlyReplyStruct& _o) const
{
	return targetLicenceId == _o.targetLicenceId &&
		Atf::atfPStringEquals(migrToken, _o.migrToken);
}

const char *regulator::cli::RegulatorMigrCheckOnlyReplyStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("targetLicenceId=");
	_buf.appendUint(targetLicenceId);
	if (targetLicenceId == eLicenceCH)
	{
		_buf.append(',');
		_buf.append("migrToken=");
		_buf.append(migrToken);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::RegulatorMigrCheckOnlyReplyStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("targetLicenceId", targetLicenceId, _buf);
	if (targetLicenceId == eLicenceCH)
	{
		Atf::XmlElement::encodeAsXmlElement("migrToken", migrToken, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::RegulatorMigrCheckOnlyReplyStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("targetLicenceId"))
		{
			targetLicenceId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("migrToken"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, migrToken)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::RegulatorMigrCheckOnlyReplyStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(targetLicenceId);
	if (targetLicenceId == eLicenceCH)
	{
		CommMsgBody _msg0;
		_msg0.composeString(migrToken);
		_msg.composeMsgBody(_msg0);
	}
}

void regulator::cli::RegulatorMigrCheckOnlyReplyStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(targetLicenceId);
	if (targetLicenceId == eLicenceCH)
	{
		parseAnonymousMsgBody0(_parser);
	}
}

const char *regulator::cli::RegulatorMigrCheckOnlyReplyStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("targetLicenceId", targetLicenceId);
	if (targetLicenceId == eLicenceCH)
	{
		_jsonstr.compose("migrToken", migrToken);
	}
	return _buf.c_str();
}

void regulator::cli::RegulatorMigrCheckOnlyReplyStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("targetLicenceId", targetLicenceId);
	if (targetLicenceId == eLicenceCH)
	{
		_jparser.parseByNameThrow("migrToken", migrToken);
	}
}

/* static */ void regulator::cli::RegulatorMigrCheckOnlyReplyStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 targetLicenceId = 0;
	_jparser.validateByNameThrow("targetLicenceId", targetLicenceId);
	{ const UINT32 targetLicenceId_enum[] = {
				eLicenceCH, 
			}; AtfValidator::validateEnum(_descr, "targetLicenceId", targetLicenceId, targetLicenceId_enum, _checker, __FILE__, __LINE__); }
	if (targetLicenceId == eLicenceCH)
	{
		PString migrToken; _jparser.validateByNameThrow("migrToken", migrToken);
		AtfValidator::validateIntMax(_descr, "migrToken", migrToken.length(), 24, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::RegulatorMigrCheckOnlyReplyStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 targetLicenceId = 0;
	_parser.parseUINT32(targetLicenceId);
	{ const UINT32 targetLicenceId_enum[] = {
				eLicenceCH, 
			}; AtfValidator::validateEnum(_descr, "targetLicenceId", targetLicenceId, targetLicenceId_enum, _checker, __FILE__, __LINE__); }
	if (targetLicenceId == eLicenceCH)
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
}

void regulator::cli::RegulatorMigrCheckOnlyReplyStruct::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(migrToken);
}

/*static*/ void regulator::cli::RegulatorMigrCheckOnlyReplyStruct::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "migrToken"); size_t szMigrToken = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "migrToken", szMigrToken, 24, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	replyStruct.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::equals(const Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		replyStruct.equals(_o.replyStruct);
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("replyStruct=");
		replyStruct.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		replyStruct.toXmlString("replyStruct", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("replyStruct"))
			{
				if(!Atf::AtfTempl< RegulatorMigrCheckOnlyReplyStruct >::FromXmlString(_value, replyStruct)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		replyStruct.composeMsg(_msg, _ignoreJSON);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		replyStruct.parseMsg(_parser);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("replyStruct", replyStruct);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("replyStruct", replyStruct);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		RegulatorMigrCheckOnlyReplyStruct replyStruct; _jparser.validateByNameThrow("replyStruct", replyStruct);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		RegulatorMigrCheckOnlyReplyStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("replyStruct"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::equals(const Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR& _o) const
{
	return true;
}

bool regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR).append(")");
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::parseMsg(CommMsgParser& _parser)
{
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::equals(const Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::clear()
{
	mailList = false;
	useMailList = false;
}

bool regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::equals(const Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED& _o) const
{
	return mailList == _o.mailList &&
		useMailList == _o.useMailList;
}

bool regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_EULA_TERMS_SIGNED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_EULA_TERMS_SIGNED).append(")");
	_buf.append(',');
	_buf.append("mailList=");
	_buf.appendUint(mailList);
	_buf.append(',');
	_buf.append("useMailList=");
	_buf.appendUint(useMailList);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_EULA_TERMS_SIGNED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("mailList", mailList, _buf);
	Atf::XmlElement::encodeAsXmlElement("useMailList", useMailList, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("mailList"))
			{
				mailList = (*_value.ptr() == '1');
			}
			else if (_element.equals("useMailList"))
			{
				useMailList = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(mailList);
	_msg.composeBOOL(useMailList);
}

void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(mailList);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(useMailList);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("mailList", mailList);
	_jsonstr.compose("useMailList", useMailList);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("mailList", mailList);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("useMailList", useMailList);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_EULA_TERMS_SIGNED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	bool mailList; _jparser.validateByNameThrow("mailList", mailList);
	AtfValidator::validateInt(_descr, "mailList", mailList, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool useMailList; _jparser.validateByNameThrow("useMailList", useMailList);
	AtfValidator::validateInt(_descr, "useMailList", useMailList, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_EULA_TERMS_SIGNED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	bool mailList; _parser.parseBOOL(mailList);
	AtfValidator::validateInt(_descr, "mailList", mailList, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool useMailList; _parser.parseBOOL(useMailList);
	AtfValidator::validateInt(_descr, "useMailList", useMailList, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::equals(const Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT
//=================================================================

regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT()
{
	clear();
}

void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::clear()
{
	bankName.clear();
	accountNumberDecrypted.clear();
	bankCountry.clear();
}

bool regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::equals(const Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT& _o) const
{
	return Atf::atfPStringEquals(bankName, _o.bankName) &&
		Atf::atfPStringEquals(accountNumberDecrypted, _o.accountNumberDecrypted) &&
		Atf::atfPStringEquals(bankCountry, _o.bankCountry);
}

bool regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_RMF_BANKACCOUNT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT*)_other));
}

const char *regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_RMF_BANKACCOUNT).append(")");
	_buf.append(',');
	_buf.append("bankName=");
	_buf.append(bankName);
	_buf.append(',');
	_buf.append("accountNumberDecrypted=");
	_buf.append(accountNumberDecrypted);
	_buf.append(',');
	_buf.append("bankCountry=");
	_buf.append(bankCountry);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_RMF_BANKACCOUNT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("bankName", bankName, _buf);
	Atf::XmlElement::encodeAsXmlElement("accountNumberDecrypted", accountNumberDecrypted, _buf);
	Atf::XmlElement::encodeAsXmlElement("bankCountry", bankCountry, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("bankName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bankName)) return false;
			}
			else if (_element.equals("accountNumberDecrypted"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, accountNumberDecrypted)) return false;
			}
			else if (_element.equals("bankCountry"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bankCountry)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(bankName);
	_msg.composeString(accountNumberDecrypted);
	_msg.composeString(bankCountry);
}

void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(bankName);
	_parser.parseStringP(accountNumberDecrypted);
	_parser.parseStringP(bankCountry);
}

const char *regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("bankName", bankName);
	_jsonstr.compose("accountNumberDecrypted", accountNumberDecrypted);
	_jsonstr.compose("bankCountry", bankCountry);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("bankName", bankName);
	_jparser.parseByNameThrow("accountNumberDecrypted", accountNumberDecrypted);
	_jparser.parseByNameThrow("bankCountry", bankCountry);
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_RMF_BANKACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString bankName; _jparser.validateByNameThrow("bankName", bankName);
	AtfValidator::validateIntMax(_descr, "bankName", bankName.length(), 1000, _checker, __FILE__, __LINE__);
	PString accountNumberDecrypted; _jparser.validateByNameThrow("accountNumberDecrypted", accountNumberDecrypted);
	AtfValidator::validateIntMax(_descr, "accountNumberDecrypted", accountNumberDecrypted.length(), 1000, _checker, __FILE__, __LINE__);
	PString bankCountry; _jparser.validateByNameThrow("bankCountry", bankCountry);
	AtfValidator::validateIntMax(_descr, "bankCountry", bankCountry.length(), 100, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_RMF_BANKACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "bankName"); size_t szBankName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankName", szBankName, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "accountNumberDecrypted"); size_t szAccountNumberDecrypted = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "accountNumberDecrypted", szAccountNumberDecrypted, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bankCountry"); size_t szBankCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankCountry", szBankCountry, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY
//=================================================================

regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	reference.clear();
	isValid = false;
	realMoneyOk = 0;
	accountNumberDecrypted.clear();
}

bool regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::equals(const Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(reference, _o.reference) &&
		isValid == _o.isValid &&
		realMoneyOk == _o.realMoneyOk &&
		Atf::atfPStringEquals(accountNumberDecrypted, _o.accountNumberDecrypted);
}

bool regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("reference=");
		_buf.append(reference);
		_buf.append(',');
		_buf.append("isValid=");
		_buf.appendUint(isValid);
		_buf.append(',');
		_buf.append("realMoneyOk=");
		_buf.appendUint(realMoneyOk);
		_buf.append(',');
		_buf.append("accountNumberDecrypted=");
		_buf.append(accountNumberDecrypted);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("reference", reference, _buf);
		Atf::XmlElement::encodeAsXmlElement("isValid", isValid, _buf);
		Atf::XmlElement::encodeAsXmlElement("realMoneyOk", realMoneyOk, _buf);
		Atf::XmlElement::encodeAsXmlElement("accountNumberDecrypted", accountNumberDecrypted, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("reference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, reference)) return false;
			}
			else if (_element.equals("isValid"))
			{
				isValid = (*_value.ptr() == '1');
			}
			else if (_element.equals("realMoneyOk"))
			{
				realMoneyOk = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("accountNumberDecrypted"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, accountNumberDecrypted)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(reference);
		_msg.composeBOOL(isValid);
		CommMsgBody _msg0;
		_msg0.composeBYTE(realMoneyOk);
		_msg0.composeString(accountNumberDecrypted);
		_msg.composeMsgBody(_msg0);
	}
}

void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(reference);
		_parser.parseBOOL(isValid);
		parseAnonymousMsgBody0(_parser);
	}
}

const char *regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("reference", reference);
		_jsonstr.compose("isValid", isValid);
		_jsonstr.compose("realMoneyOk", realMoneyOk);
		_jsonstr.compose("accountNumberDecrypted", accountNumberDecrypted);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("reference", reference);
		_jparser.parseByNameThrow("isValid", isValid);
		_jparser.parseByNameThrow("realMoneyOk", realMoneyOk);
		_jparser.parseByNameThrow("accountNumberDecrypted", accountNumberDecrypted);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString reference; _jparser.validateByNameThrow("reference", reference);
		AtfValidator::validateInt(_descr, "reference", reference.length(), _checker, __FILE__, __LINE__);
		bool isValid; _jparser.validateByNameThrow("isValid", isValid);
		AtfValidator::validateInt(_descr, "isValid", isValid, _checker, __FILE__, __LINE__);
		BYTE realMoneyOk; _jparser.validateByNameThrow("realMoneyOk", realMoneyOk);
		AtfValidator::validateIntRange(_descr, "realMoneyOk", realMoneyOk, 0, 1, _checker, __FILE__, __LINE__);
		PString accountNumberDecrypted; _jparser.validateByNameThrow("accountNumberDecrypted", accountNumberDecrypted);
		AtfValidator::validateInt(_descr, "accountNumberDecrypted", accountNumberDecrypted.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "reference"); size_t szReference = strlen(_dummy);
		AtfValidator::validateInt(_descr, "reference", szReference, _checker, __FILE__, __LINE__);
		bool isValid; _parser.parseBOOL(isValid);
		AtfValidator::validateInt(_descr, "isValid", isValid, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(realMoneyOk);
	_parser0.parseStringP(accountNumberDecrypted);
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE realMoneyOk; _parser0.parseBYTE(realMoneyOk);
	AtfValidator::validateIntRange(_descr, "realMoneyOk", realMoneyOk, 0, 1, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "accountNumberDecrypted"); size_t szAccountNumberDecrypted = strlen(_dummy);
	AtfValidator::validateInt(_descr, "accountNumberDecrypted", szAccountNumberDecrypted, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::equals(const Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS& _o) const
{
	return true;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_LAST_LOGIN_DETAILS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_LAST_LOGIN_DETAILS).append(")");
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_LAST_LOGIN_DETAILS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::parseMsg(CommMsgParser& _parser)
{
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_LAST_LOGIN_DETAILS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_LAST_LOGIN_DETAILS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    LoginDetailsClientTournBody
//=================================================================

regulator::cli::LoginDetailsClientTournBody::LoginDetailsClientTournBody()
{
	clear();
}

void regulator::cli::LoginDetailsClientTournBody::clear()
{
	tournId = 0;
	tournName.clear();
	isPublished = false;
}

bool regulator::cli::LoginDetailsClientTournBody::equals(const LoginDetailsClientTournBody& _o) const
{
	return tournId == _o.tournId &&
		Atf::atfPStringEquals(tournName, _o.tournName) &&
		isPublished == _o.isPublished;
}

const char *regulator::cli::LoginDetailsClientTournBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("tournName=");
	_buf.append(tournName);
	_buf.append(',');
	_buf.append("isPublished=");
	_buf.appendUint(isPublished);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::LoginDetailsClientTournBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournName", tournName, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPublished", isPublished, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::LoginDetailsClientTournBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournId"))
		{
			tournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tournName)) return false;
		}
		else if (_element.equals("isPublished"))
		{
			isPublished = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::LoginDetailsClientTournBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(LoginDetailsClientTournBody())) // not empty
	{
		_body.composeUINT32(tournId);
		_body.composeString(tournName);
		_body.composeBOOL(isPublished);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::LoginDetailsClientTournBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournId);
	_parser0.parseStringP(tournName);
	_parser0.parseBOOL(isPublished);
}

const char *regulator::cli::LoginDetailsClientTournBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("tournName", tournName);
	_jsonstr.compose("isPublished", isPublished);
	return _buf.c_str();
}

void regulator::cli::LoginDetailsClientTournBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("tournName", tournName);
	_jparser.parseByNameThrow("isPublished", isPublished);
}

/* static */ void regulator::cli::LoginDetailsClientTournBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	PString tournName; _jparser.validateByNameThrow("tournName", tournName);
	AtfValidator::validateInt(_descr, "tournName", tournName.length(), _checker, __FILE__, __LINE__);
	bool isPublished; _jparser.validateByNameThrow("isPublished", isPublished);
	AtfValidator::validateInt(_descr, "isPublished", isPublished, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::LoginDetailsClientTournBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tournId; _parser0.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tournName"); size_t szTournName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournName", szTournName, _checker, __FILE__, __LINE__);
	bool isPublished; _parser0.parseBOOL(isPublished);
	AtfValidator::validateInt(_descr, "isPublished", isPublished, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    LoginDetailsBody
//=================================================================

regulator::cli::LoginDetailsBody::LoginDetailsBody()
{
	clear();
}

void regulator::cli::LoginDetailsBody::clear()
{
	lastLogoutIp.clear();
}

bool regulator::cli::LoginDetailsBody::equals(const LoginDetailsBody& _o) const
{
	return Atf::atfPStringEquals(lastLogoutIp, _o.lastLogoutIp);
}

const char *regulator::cli::LoginDetailsBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("lastLogoutIp=");
	_buf.append(lastLogoutIp);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::LoginDetailsBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("lastLogoutIp", lastLogoutIp, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::LoginDetailsBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("lastLogoutIp"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, lastLogoutIp)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::LoginDetailsBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(LoginDetailsBody())) // not empty
	{
		_body.composeString(lastLogoutIp);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::LoginDetailsBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(lastLogoutIp);
}

const char *regulator::cli::LoginDetailsBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("lastLogoutIp", lastLogoutIp);
	return _buf.c_str();
}

void regulator::cli::LoginDetailsBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("lastLogoutIp", lastLogoutIp);
}

/* static */ void regulator::cli::LoginDetailsBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString lastLogoutIp; _jparser.validateByNameThrow("lastLogoutIp", lastLogoutIp);
	AtfValidator::validateInt(_descr, "lastLogoutIp", lastLogoutIp.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::LoginDetailsBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "lastLogoutIp"); size_t szLastLogoutIp = strlen(_dummy);
	AtfValidator::validateInt(_descr, "lastLogoutIp", szLastLogoutIp, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	lastLoginTime.setNull();
	loginDetails.clear();
	isFirstLoginSession = false;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::equals(const Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		lastLoginTime.equals(_o.lastLoginTime) &&
		loginDetails.equals(_o.loginDetails) &&
		isFirstLoginSession == _o.isFirstLoginSession;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("lastLoginTime=");
		Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, lastLoginTime);
		_buf.append(',');
		_buf.append("loginDetails=");
		loginDetails.toTraceString(_buf);
		_buf.append(',');
		_buf.append("isFirstLoginSession=");
		_buf.appendUint(isFirstLoginSession);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "lastLoginTime", lastLoginTime);
		loginDetails.toXmlString("loginDetails", _buf);
		Atf::XmlElement::encodeAsXmlElement("isFirstLoginSession", isFirstLoginSession, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("lastLoginTime"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, lastLoginTime);
			}
			else if (_element.equals("loginDetails"))
			{
				if(!Atf::AtfTempl< LoginDetailsBody >::FromXmlString(_value, loginDetails)) return false;
			}
			else if (_element.equals("isFirstLoginSession"))
			{
				isFirstLoginSession = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeSrvTime(lastLoginTime);
		loginDetails.composeMsg(_msg, _ignoreJSON);
		_msg.composeBOOL(isFirstLoginSession);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseSrvTime(lastLoginTime);
		loginDetails.parseMsg(_parser);
		_parser.parseBOOL(isFirstLoginSession);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("lastLoginTime", lastLoginTime);
		_jsonstr.compose("loginDetails", loginDetails);
		_jsonstr.compose("isFirstLoginSession", isFirstLoginSession);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("lastLoginTime", lastLoginTime);
		_jparser.parseByNameThrow("loginDetails", loginDetails);
		_jparser.parseByNameThrow("isFirstLoginSession", isFirstLoginSession);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		CommSrvTime lastLoginTime; _jparser.validateByNameThrow("lastLoginTime", lastLoginTime);
		AtfValidator::validateSrvDateTime(_descr, "lastLoginTime", lastLoginTime, _checker, __FILE__, __LINE__);
		LoginDetailsBody loginDetails; _jparser.validateByNameThrow("loginDetails", loginDetails);
		bool isFirstLoginSession; _jparser.validateByNameThrow("isFirstLoginSession", isFirstLoginSession);
		AtfValidator::validateInt(_descr, "isFirstLoginSession", isFirstLoginSession, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		CommSrvTime lastLoginTime; _parser.parseSrvTime(lastLoginTime);
		AtfValidator::validateSrvDateTime(_descr, "lastLoginTime", lastLoginTime, _checker, __FILE__, __LINE__);
		PString _descbuf;
		LoginDetailsBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginDetails"), _fieldsWithUnparsedContent);
		bool isFirstLoginSession; _parser.parseBOOL(isFirstLoginSession);
		AtfValidator::validateInt(_descr, "isFirstLoginSession", isFirstLoginSession, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_USER_WINNINGS
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::Protocol_MSG_REGULATOR_GET_USER_WINNINGS()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::clear()
{
	loginTime.setNull();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::equals(const Protocol_MSG_REGULATOR_GET_USER_WINNINGS& _o) const
{
	return loginTime.equals(_o.loginTime);
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_USER_WINNINGS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_USER_WINNINGS*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_USER_WINNINGS).append(")");
	_buf.append(',');
	_buf.append("loginTime=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, loginTime);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_USER_WINNINGS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "loginTime", loginTime);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("loginTime"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, loginTime);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(loginTime);
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(loginTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("loginTime", loginTime);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("loginTime", loginTime);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_WINNINGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	CommSrvTime loginTime; _jparser.validateByNameThrow("loginTime", loginTime);
	AtfValidator::validateSrvDateTime(_descr, "loginTime", loginTime, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_WINNINGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	CommSrvTime loginTime; _parser.parseSrvTime(loginTime);
	AtfValidator::validateSrvDateTime(_descr, "loginTime", loginTime, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	totalPlayed = 0;
	totalWon = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::equals(const Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		totalPlayed == _o.totalPlayed &&
		totalWon == _o.totalWon;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_USER_WINNINGS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_USER_WINNINGS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("totalPlayed=");
		_buf.appendInt64(totalPlayed);
		_buf.append(',');
		_buf.append("totalWon=");
		_buf.appendInt64(totalWon);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_USER_WINNINGS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("totalPlayed", totalPlayed, _buf);
		Atf::XmlElement::encodeAsXmlElement("totalWon", totalWon, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("totalPlayed"))
			{
				totalPlayed = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("totalWon"))
			{
				totalWon = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT64(totalPlayed);
		_msg.composeINT64(totalWon);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT64(totalPlayed);
		_parser.parseINT64(totalWon);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("totalPlayed", totalPlayed);
		_jsonstr.compose("totalWon", totalWon);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("totalPlayed", totalPlayed);
		_jparser.parseByNameThrow("totalWon", totalWon);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_WINNINGS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 totalPlayed; _jparser.validateByNameThrow("totalPlayed", totalPlayed);
		AtfValidator::validateInt(_descr, "totalPlayed", totalPlayed, _checker, __FILE__, __LINE__);
		INT64 totalWon; _jparser.validateByNameThrow("totalWon", totalWon);
		AtfValidator::validateInt(_descr, "totalWon", totalWon, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_WINNINGS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 totalPlayed; _parser.parseINT64(totalPlayed);
		AtfValidator::validateInt(_descr, "totalPlayed", totalPlayed, _checker, __FILE__, __LINE__);
		INT64 totalWon; _parser.parseINT64(totalWon);
		AtfValidator::validateInt(_descr, "totalWon", totalWon, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::equals(const Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE& _o) const
{
	return true;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_FACEBOOK_LINK_CODE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_FACEBOOK_LINK_CODE).append(")");
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_FACEBOOK_LINK_CODE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::parseMsg(CommMsgParser& _parser)
{
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FACEBOOK_LINK_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FACEBOOK_LINK_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	facebookLinkCode = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::equals(const Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		facebookLinkCode == _o.facebookLinkCode;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("facebookLinkCode=");
		_buf.appendUint(facebookLinkCode);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("facebookLinkCode", facebookLinkCode, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("facebookLinkCode"))
			{
				facebookLinkCode = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(facebookLinkCode);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(facebookLinkCode);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("facebookLinkCode", facebookLinkCode);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("facebookLinkCode", facebookLinkCode);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 facebookLinkCode; _jparser.validateByNameThrow("facebookLinkCode", facebookLinkCode);
		AtfValidator::validateInt(_descr, "facebookLinkCode", facebookLinkCode, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 facebookLinkCode; _parser.parseUINT32(facebookLinkCode);
		AtfValidator::validateInt(_descr, "facebookLinkCode", facebookLinkCode, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::equals(const Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE& _o) const
{
	return true;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_FTP_PAIRING_CODE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_FTP_PAIRING_CODE).append(")");
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_FTP_PAIRING_CODE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::parseMsg(CommMsgParser& _parser)
{
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FTP_PAIRING_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FTP_PAIRING_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::equals(const Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY
//=================================================================

regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY()
{
	clear();
}

void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::clear()
{
	userIdNotUsed.clear();
}

bool regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::equals(const Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY& _o) const
{
	return Atf::atfPStringEquals(userIdNotUsed, _o.userIdNotUsed);
}

bool regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SUPPORT_EMAIL_READY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY*)_other));
}

const char *regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SUPPORT_EMAIL_READY).append(")");
	_buf.append(',');
	_buf.append("userIdNotUsed=");
	_buf.append(userIdNotUsed);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SUPPORT_EMAIL_READY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userIdNotUsed", userIdNotUsed, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userIdNotUsed"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userIdNotUsed)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userIdNotUsed);
}

void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(userIdNotUsed);
}

const char *regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIdNotUsed", userIdNotUsed);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("userIdNotUsed", userIdNotUsed);
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUPPORT_EMAIL_READY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString userIdNotUsed; _jparser.validateByNameThrow("userIdNotUsed", userIdNotUsed);
	AtfValidator::validateIntMax(_descr, "userIdNotUsed", userIdNotUsed.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUPPORT_EMAIL_READY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "userIdNotUsed"); size_t szUserIdNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userIdNotUsed", szUserIdNotUsed, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY
//=================================================================

regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::equals(const Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL
//=================================================================

regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL()
{
	clear();
}

void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::clear()
{
	body.clear();
}

bool regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::equals(const Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL& _o) const
{
	return body.equals(_o.body);
}

bool regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL*)_other));
}

const char *regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL).append(")");
	_buf.append(',');
	_buf.append("body=");
	body.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	body.toXmlString("body", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("body"))
			{
				if(!Atf::AtfTempl< common_structs::LobbyClientToSupportEmailStruct >::FromXmlString(_value, body)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	body.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::parseMsg(CommMsgParser& _parser)
{
	body.parseMsg(_parser);
}

const char *regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("body", body);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("body", body);
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::LobbyClientToSupportEmailStruct body; _jparser.validateByNameThrow("body", body);
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::LobbyClientToSupportEmailStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("body"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY
//=================================================================

regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::clear()
{
	replyBody.clear();
}

bool regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::equals(const Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY& _o) const
{
	return replyBody.equals(_o.replyBody);
}

bool regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY).append(")");
	_buf.append(',');
	_buf.append("replyBody=");
	replyBody.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	replyBody.toXmlString("replyBody", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("replyBody"))
			{
				if(!Atf::AtfTempl< common_structs::LobbyClientToSupportEmailReplyStruct >::FromXmlString(_value, replyBody)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	replyBody.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::parseMsg(CommMsgParser& _parser)
{
	replyBody.parseMsg(_parser);
}

const char *regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("replyBody", replyBody);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("replyBody", replyBody);
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::LobbyClientToSupportEmailReplyStruct replyBody; _jparser.validateByNameThrow("replyBody", replyBody);
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::LobbyClientToSupportEmailReplyStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("replyBody"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    NjDepositLimitActionBody
//=================================================================

regulator::cli::NjDepositLimitActionBody::NjDepositLimitActionBody()
{
	clear();
}

void regulator::cli::NjDepositLimitActionBody::clear()
{
	limitType = 0;
	limitId = 0;
	isApprove = false;
	prevLimit = 0;
	limit = 0;
	currency.clear();
}

bool regulator::cli::NjDepositLimitActionBody::equals(const NjDepositLimitActionBody& _o) const
{
	return limitType == _o.limitType &&
		limitId == _o.limitId &&
		isApprove == _o.isApprove &&
		prevLimit == _o.prevLimit &&
		limit == _o.limit &&
		Atf::atfPStringEquals(currency, _o.currency);
}

const char *regulator::cli::NjDepositLimitActionBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limitType=");
	_buf.appendUint(limitType);
	_buf.append(',');
	_buf.append("limitId=");
	_buf.appendUint(limitId);
	_buf.append(',');
	_buf.append("isApprove=");
	_buf.appendUint(isApprove);
	_buf.append(',');
	_buf.append("prevLimit=");
	_buf.appendInt(prevLimit);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendInt(limit);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::NjDepositLimitActionBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("limitType", limitType, _buf);
	Atf::XmlElement::encodeAsXmlElement("limitId", limitId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isApprove", isApprove, _buf);
	Atf::XmlElement::encodeAsXmlElement("prevLimit", prevLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::NjDepositLimitActionBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("limitType"))
		{
			limitType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("limitId"))
		{
			limitId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isApprove"))
		{
			isApprove = (*_value.ptr() == '1');
		}
		else if (_element.equals("prevLimit"))
		{
			prevLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("limit"))
		{
			limit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::NjDepositLimitActionBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(NjDepositLimitActionBody())) // not empty
	{
		_body.composeUINT32(limitType);
		_body.composeUINT32(limitId);
		_body.composeBOOL(isApprove);
		_body.composeINT32(prevLimit);
		_body.composeINT32(limit);
		_body.composeString(currency);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::NjDepositLimitActionBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(limitType);
	_parser0.parseUINT32(limitId);
	_parser0.parseBOOL(isApprove);
	_parser0.parseINT32(prevLimit);
	_parser0.parseINT32(limit);
	_parser0.parseStringP(currency);
}

const char *regulator::cli::NjDepositLimitActionBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limitType", limitType);
	_jsonstr.compose("limitId", limitId);
	_jsonstr.compose("isApprove", isApprove);
	_jsonstr.compose("prevLimit", prevLimit);
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void regulator::cli::NjDepositLimitActionBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("limitType", limitType);
	_jparser.parseByNameThrow("limitId", limitId);
	_jparser.parseByNameThrow("isApprove", isApprove);
	_jparser.parseByNameThrow("prevLimit", prevLimit);
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("currency", currency);
}

/* static */ void regulator::cli::NjDepositLimitActionBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 limitType; _jparser.validateByNameThrow("limitType", limitType);
	{ const UINT32 limitType_enum[] = {eDailyDepositLimit, eWeeklyDepositLimit, eMonthlyDepositLimit}; AtfValidator::validateEnum(_descr, "limitType", limitType, limitType_enum, _checker, __FILE__, __LINE__); }
	UINT32 limitId; _jparser.validateByNameThrow("limitId", limitId);
	AtfValidator::validateInt(_descr, "limitId", limitId, _checker, __FILE__, __LINE__);
	bool isApprove; _jparser.validateByNameThrow("isApprove", isApprove);
	AtfValidator::validateInt(_descr, "isApprove", isApprove, _checker, __FILE__, __LINE__);
	INT32 prevLimit; _jparser.validateByNameThrow("prevLimit", prevLimit);
	AtfValidator::validateIntRange(_descr, "prevLimit", prevLimit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateIntRange(_descr, "limit", limit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::NjDepositLimitActionBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 limitType; _parser0.parseUINT32(limitType);
	{ const UINT32 limitType_enum[] = {eDailyDepositLimit, eWeeklyDepositLimit, eMonthlyDepositLimit}; AtfValidator::validateEnum(_descr, "limitType", limitType, limitType_enum, _checker, __FILE__, __LINE__); }
	UINT32 limitId; _parser0.parseUINT32(limitId);
	AtfValidator::validateInt(_descr, "limitId", limitId, _checker, __FILE__, __LINE__);
	bool isApprove; _parser0.parseBOOL(isApprove);
	AtfValidator::validateInt(_descr, "isApprove", isApprove, _checker, __FILE__, __LINE__);
	INT32 prevLimit; _parser0.parseINT32(prevLimit);
	AtfValidator::validateIntRange(_descr, "prevLimit", prevLimit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 limit; _parser0.parseINT32(limit);
	AtfValidator::validateIntRange(_descr, "limit", limit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    NjGameLimitActionBody
//=================================================================

regulator::cli::NjGameLimitActionBody::NjGameLimitActionBody()
{
	clear();
}

void regulator::cli::NjGameLimitActionBody::clear()
{
	limitType = 0;
	limitId = 0;
	isApprove = false;
	prevLimit = 0;
	limit = 0;
	currency.clear();
}

bool regulator::cli::NjGameLimitActionBody::equals(const NjGameLimitActionBody& _o) const
{
	return limitType == _o.limitType &&
		limitId == _o.limitId &&
		isApprove == _o.isApprove &&
		prevLimit == _o.prevLimit &&
		limit == _o.limit &&
		Atf::atfPStringEquals(currency, _o.currency);
}

const char *regulator::cli::NjGameLimitActionBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limitType=");
	_buf.appendUint(limitType);
	_buf.append(',');
	_buf.append("limitId=");
	_buf.appendUint(limitId);
	_buf.append(',');
	_buf.append("isApprove=");
	_buf.appendUint(isApprove);
	_buf.append(',');
	_buf.append("prevLimit=");
	_buf.appendInt(prevLimit);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendInt(limit);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::NjGameLimitActionBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("limitType", limitType, _buf);
	Atf::XmlElement::encodeAsXmlElement("limitId", limitId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isApprove", isApprove, _buf);
	Atf::XmlElement::encodeAsXmlElement("prevLimit", prevLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::NjGameLimitActionBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("limitType"))
		{
			limitType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("limitId"))
		{
			limitId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isApprove"))
		{
			isApprove = (*_value.ptr() == '1');
		}
		else if (_element.equals("prevLimit"))
		{
			prevLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("limit"))
		{
			limit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::NjGameLimitActionBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(NjGameLimitActionBody())) // not empty
	{
		_body.composeUINT32(limitType);
		_body.composeUINT32(limitId);
		_body.composeBOOL(isApprove);
		_body.composeINT32(prevLimit);
		_body.composeINT32(limit);
		_body.composeString(currency);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::NjGameLimitActionBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(limitType);
	_parser0.parseUINT32(limitId);
	_parser0.parseBOOL(isApprove);
	_parser0.parseINT32(prevLimit);
	_parser0.parseINT32(limit);
	_parser0.parseStringP(currency);
}

const char *regulator::cli::NjGameLimitActionBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limitType", limitType);
	_jsonstr.compose("limitId", limitId);
	_jsonstr.compose("isApprove", isApprove);
	_jsonstr.compose("prevLimit", prevLimit);
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void regulator::cli::NjGameLimitActionBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("limitType", limitType);
	_jparser.parseByNameThrow("limitId", limitId);
	_jparser.parseByNameThrow("isApprove", isApprove);
	_jparser.parseByNameThrow("prevLimit", prevLimit);
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("currency", currency);
}

/* static */ void regulator::cli::NjGameLimitActionBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 limitType; _jparser.validateByNameThrow("limitType", limitType);
	AtfValidator::validateIntRange(_descr, "limitType", limitType, eTableLimitTypeAny, (numLimitTypes-1), _checker, __FILE__, __LINE__);
	UINT32 limitId; _jparser.validateByNameThrow("limitId", limitId);
	AtfValidator::validateInt(_descr, "limitId", limitId, _checker, __FILE__, __LINE__);
	bool isApprove; _jparser.validateByNameThrow("isApprove", isApprove);
	AtfValidator::validateInt(_descr, "isApprove", isApprove, _checker, __FILE__, __LINE__);
	INT32 prevLimit; _jparser.validateByNameThrow("prevLimit", prevLimit);
	AtfValidator::validateIntRange(_descr, "prevLimit", prevLimit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateIntRange(_descr, "limit", limit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::NjGameLimitActionBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 limitType; _parser0.parseUINT32(limitType);
	AtfValidator::validateIntRange(_descr, "limitType", limitType, eTableLimitTypeAny, (numLimitTypes-1), _checker, __FILE__, __LINE__);
	UINT32 limitId; _parser0.parseUINT32(limitId);
	AtfValidator::validateInt(_descr, "limitId", limitId, _checker, __FILE__, __LINE__);
	bool isApprove; _parser0.parseBOOL(isApprove);
	AtfValidator::validateInt(_descr, "isApprove", isApprove, _checker, __FILE__, __LINE__);
	INT32 prevLimit; _parser0.parseINT32(prevLimit);
	AtfValidator::validateIntRange(_descr, "prevLimit", prevLimit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 limit; _parser0.parseINT32(limit);
	AtfValidator::validateIntRange(_descr, "limit", limit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserDepositLimitsBody
//=================================================================

regulator::cli::UserDepositLimitsBody::UserDepositLimitsBody()
{
	clear();
}

void regulator::cli::UserDepositLimitsBody::clear()
{
	limits.clear();
}

bool regulator::cli::UserDepositLimitsBody::equals(const UserDepositLimitsBody& _o) const
{
	return limits.equals(_o.limits);
}

const char *regulator::cli::UserDepositLimitsBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limits=");
	limits.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::UserDepositLimitsBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	limits.toXmlString("limits", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::UserDepositLimitsBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("limits"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< NjDepositLimitActionBody, 4 > >::FromXmlString(_value, limits)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::UserDepositLimitsBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(UserDepositLimitsBody())) // not empty
	{
		limits.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::UserDepositLimitsBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	limits.parseMsg(_parser0);
}

const char *regulator::cli::UserDepositLimitsBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limits", limits);
	return _buf.c_str();
}

void regulator::cli::UserDepositLimitsBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("limits", limits);
}

/* static */ void regulator::cli::UserDepositLimitsBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< NjDepositLimitActionBody > limits; _jparser.validateByNameThrow("limits", limits);
	AtfValidator::validateIntMax(_descr, "limits", limits.size(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::UserDepositLimitsBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szLimits = Atf::LAtfVector< NjDepositLimitActionBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "limits", szLimits, 1000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserGameLimitsBody
//=================================================================

regulator::cli::UserGameLimitsBody::UserGameLimitsBody()
{
	clear();
}

void regulator::cli::UserGameLimitsBody::clear()
{
	limits.clear();
}

bool regulator::cli::UserGameLimitsBody::equals(const UserGameLimitsBody& _o) const
{
	return limits.equals(_o.limits);
}

const char *regulator::cli::UserGameLimitsBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limits=");
	limits.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::UserGameLimitsBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	limits.toXmlString("limits", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::UserGameLimitsBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("limits"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< NjGameLimitActionBody, 4 > >::FromXmlString(_value, limits)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::UserGameLimitsBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(UserGameLimitsBody())) // not empty
	{
		limits.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::UserGameLimitsBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	limits.parseMsg(_parser0);
}

const char *regulator::cli::UserGameLimitsBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limits", limits);
	return _buf.c_str();
}

void regulator::cli::UserGameLimitsBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("limits", limits);
}

/* static */ void regulator::cli::UserGameLimitsBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< NjGameLimitActionBody > limits; _jparser.validateByNameThrow("limits", limits);
	AtfValidator::validateIntMax(_descr, "limits", limits.size(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::UserGameLimitsBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szLimits = Atf::LAtfVector< NjGameLimitActionBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "limits", szLimits, 1000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::clear()
{
	depositLimits.clear();
	gameLimits.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::equals(const Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS& _o) const
{
	return depositLimits.equals(_o.depositLimits) &&
		gameLimits.equals(_o.gameLimits);
}

bool regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CONFIRMED_USER_LIMITS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CONFIRMED_USER_LIMITS).append(")");
	_buf.append(',');
	_buf.append("depositLimits=");
	depositLimits.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameLimits=");
	gameLimits.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CONFIRMED_USER_LIMITS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	depositLimits.toXmlString("depositLimits", _buf);
	gameLimits.toXmlString("gameLimits", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("depositLimits"))
			{
				if(!Atf::AtfTempl< UserDepositLimitsBody >::FromXmlString(_value, depositLimits)) return false;
			}
			else if (_element.equals("gameLimits"))
			{
				if(!Atf::AtfTempl< UserGameLimitsBody >::FromXmlString(_value, gameLimits)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	depositLimits.composeMsg(_msg, _ignoreJSON);
	gameLimits.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::parseMsg(CommMsgParser& _parser)
{
	depositLimits.parseMsg(_parser);
	gameLimits.parseMsg(_parser);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("depositLimits", depositLimits);
	_jsonstr.compose("gameLimits", gameLimits);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("depositLimits", depositLimits);
	_jparser.parseByNameThrow("gameLimits", gameLimits);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CONFIRMED_USER_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UserDepositLimitsBody depositLimits; _jparser.validateByNameThrow("depositLimits", depositLimits);
	UserGameLimitsBody gameLimits; _jparser.validateByNameThrow("gameLimits", gameLimits);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CONFIRMED_USER_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	UserDepositLimitsBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("depositLimits"), _fieldsWithUnparsedContent);
	UserGameLimitsBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameLimits"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserDepositLimitsResultBody
//=================================================================

regulator::cli::UserDepositLimitsResultBody::UserDepositLimitsResultBody()
{
	clear();
}

void regulator::cli::UserDepositLimitsResultBody::clear()
{
	errCode = 0;
	errDescr.clear();
	limits.clear();
}

bool regulator::cli::UserDepositLimitsResultBody::equals(const UserDepositLimitsResultBody& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		limits.equals(_o.limits);
}

const char *regulator::cli::UserDepositLimitsResultBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limits=");
		limits.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::UserDepositLimitsResultBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		limits.toXmlString("limits", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::UserDepositLimitsResultBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("errCode"))
		{
			errCode = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errDescr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
		}
		else if (_element.equals("limits"))
		{
			if(!Atf::AtfTempl< UserDepositLimitsBody >::FromXmlString(_value, limits)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::UserDepositLimitsResultBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(UserDepositLimitsResultBody())) // not empty
	{
		_body.composeINT16(errCode);
		if (errCode)
		{
			_body.composeString(errDescr);
		}
		else
		{
			limits.composeMsg(_body, _ignoreJSON);
		}
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::UserDepositLimitsResultBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT16(errCode);
	if (errCode)
	{
		_parser0.parseStringP(errDescr);
	}
	else
	{
		limits.parseMsg(_parser0);
	}
}

const char *regulator::cli::UserDepositLimitsResultBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("limits", limits);
	}
	return _buf.c_str();
}

void regulator::cli::UserDepositLimitsResultBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("limits", limits);
	}
}

/* static */ void regulator::cli::UserDepositLimitsResultBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UserDepositLimitsBody limits; _jparser.validateByNameThrow("limits", limits);
	}
}

/*static*/ void regulator::cli::UserDepositLimitsResultBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser0.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser0.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserDepositLimitsBody::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
	}
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserGameLimitsResultBody
//=================================================================

regulator::cli::UserGameLimitsResultBody::UserGameLimitsResultBody()
{
	clear();
}

void regulator::cli::UserGameLimitsResultBody::clear()
{
	errCode = 0;
	errDescr.clear();
	limits.clear();
}

bool regulator::cli::UserGameLimitsResultBody::equals(const UserGameLimitsResultBody& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		limits.equals(_o.limits);
}

const char *regulator::cli::UserGameLimitsResultBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limits=");
		limits.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::UserGameLimitsResultBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		limits.toXmlString("limits", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::UserGameLimitsResultBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("errCode"))
		{
			errCode = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errDescr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
		}
		else if (_element.equals("limits"))
		{
			if(!Atf::AtfTempl< UserGameLimitsBody >::FromXmlString(_value, limits)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::UserGameLimitsResultBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(UserGameLimitsResultBody())) // not empty
	{
		_body.composeINT16(errCode);
		if (errCode)
		{
			_body.composeString(errDescr);
		}
		else
		{
			limits.composeMsg(_body, _ignoreJSON);
		}
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::UserGameLimitsResultBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT16(errCode);
	if (errCode)
	{
		_parser0.parseStringP(errDescr);
	}
	else
	{
		limits.parseMsg(_parser0);
	}
}

const char *regulator::cli::UserGameLimitsResultBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("limits", limits);
	}
	return _buf.c_str();
}

void regulator::cli::UserGameLimitsResultBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("limits", limits);
	}
}

/* static */ void regulator::cli::UserGameLimitsResultBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UserGameLimitsBody limits; _jparser.validateByNameThrow("limits", limits);
	}
}

/*static*/ void regulator::cli::UserGameLimitsResultBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser0.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser0.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserGameLimitsBody::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
	}
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::clear()
{
	depositLimits.clear();
	gameLimits.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::equals(const Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY& _o) const
{
	return depositLimits.equals(_o.depositLimits) &&
		gameLimits.equals(_o.gameLimits);
}

bool regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY).append(")");
	_buf.append(',');
	_buf.append("depositLimits=");
	depositLimits.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameLimits=");
	gameLimits.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	depositLimits.toXmlString("depositLimits", _buf);
	gameLimits.toXmlString("gameLimits", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("depositLimits"))
			{
				if(!Atf::AtfTempl< UserDepositLimitsResultBody >::FromXmlString(_value, depositLimits)) return false;
			}
			else if (_element.equals("gameLimits"))
			{
				if(!Atf::AtfTempl< UserGameLimitsResultBody >::FromXmlString(_value, gameLimits)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	depositLimits.composeMsg(_msg, _ignoreJSON);
	gameLimits.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::parseMsg(CommMsgParser& _parser)
{
	depositLimits.parseMsg(_parser);
	gameLimits.parseMsg(_parser);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("depositLimits", depositLimits);
	_jsonstr.compose("gameLimits", gameLimits);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("depositLimits", depositLimits);
	_jparser.parseByNameThrow("gameLimits", gameLimits);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UserDepositLimitsResultBody depositLimits; _jparser.validateByNameThrow("depositLimits", depositLimits);
	UserGameLimitsResultBody gameLimits; _jparser.validateByNameThrow("gameLimits", gameLimits);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	UserDepositLimitsResultBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("depositLimits"), _fieldsWithUnparsedContent);
	UserGameLimitsResultBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameLimits"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CHALLENGE_QUESTION
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::clear()
{
	locale = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::equals(const Protocol_MSG_REGULATOR_CHALLENGE_QUESTION& _o) const
{
	return locale == _o.locale;
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CHALLENGE_QUESTION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CHALLENGE_QUESTION*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CHALLENGE_QUESTION).append(")");
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CHALLENGE_QUESTION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(locale);
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(locale);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHALLENGE_QUESTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHALLENGE_QUESTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	challengeQuestions.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::equals(const Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		challengeQuestions.equals(_o.challengeQuestions);
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CHALLENGE_QUESTION_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CHALLENGE_QUESTION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("challengeQuestions=");
		challengeQuestions.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CHALLENGE_QUESTION_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		challengeQuestions.toXmlString("challengeQuestions", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("challengeQuestions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< common_structs::ChallengeQuestion, 2 > >::FromXmlString(_value, challengeQuestions)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		challengeQuestions.composeMsg(_msg, _ignoreJSON);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		challengeQuestions.parseMsg(_parser);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("challengeQuestions", challengeQuestions);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("challengeQuestions", challengeQuestions);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHALLENGE_QUESTION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< common_structs::ChallengeQuestion > challengeQuestions; _jparser.validateByNameThrow("challengeQuestions", challengeQuestions);
		AtfValidator::validateInt(_descr, "challengeQuestions", challengeQuestions.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHALLENGE_QUESTION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szChallengeQuestions = Atf::LAtfVector< common_structs::ChallengeQuestion, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("challengeQuestions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "challengeQuestions", szChallengeQuestions, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED
//=================================================================

regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED()
{
	clear();
}

void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::clear()
{
}

bool regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::equals(const Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED& _o) const
{
	return true;
}

bool regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED*)_other));
}

const char *regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED).append(")");
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::parseMsg(CommMsgParser& _parser)
{
}

const char *regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY
//=================================================================

regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::equals(const Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::equals(const Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER& _o) const
{
	return true;
}

bool regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CLIENT_FTPLAUNCHER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CLIENT_FTPLAUNCHER).append(")");
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CLIENT_FTPLAUNCHER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::parseMsg(CommMsgParser& _parser)
{
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLIENT_FTPLAUNCHER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLIENT_FTPLAUNCHER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::equals(const Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_PROMO_CODE
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::Protocol_MSG_REGULATOR_SET_PROMO_CODE()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::clear()
{
	promoCode.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::equals(const Protocol_MSG_REGULATOR_SET_PROMO_CODE& _o) const
{
	return Atf::atfPStringEquals(promoCode, _o.promoCode);
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SET_PROMO_CODE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SET_PROMO_CODE*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_PROMO_CODE).append(")");
	_buf.append(',');
	_buf.append("promoCode=");
	_buf.append(promoCode);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SET_PROMO_CODE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("promoCode", promoCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("promoCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, promoCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(promoCode);
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(promoCode);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("promoCode", promoCode);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("promoCode", promoCode);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PROMO_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString promoCode; _jparser.validateByNameThrow("promoCode", promoCode);
	AtfValidator::validateIntMax(_descr, "promoCode", promoCode.length(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PROMO_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "promoCode"); size_t szPromoCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "promoCode", szPromoCode, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::equals(const Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SET_PROMO_CODE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_PROMO_CODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SET_PROMO_CODE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PROMO_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PROMO_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_PWD_REMINDER
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::Protocol_MSG_REGULATOR_SET_PWD_REMINDER()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::clear()
{
	remind = false;
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::equals(const Protocol_MSG_REGULATOR_SET_PWD_REMINDER& _o) const
{
	return remind == _o.remind;
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SET_PWD_REMINDER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SET_PWD_REMINDER*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_PWD_REMINDER).append(")");
	_buf.append(',');
	_buf.append("remind=");
	_buf.appendUint(remind);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SET_PWD_REMINDER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("remind", remind, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("remind"))
			{
				remind = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(remind);
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(remind);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("remind", remind);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("remind", remind);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PWD_REMINDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool remind; _jparser.validateByNameThrow("remind", remind);
	AtfValidator::validateInt(_descr, "remind", remind, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PWD_REMINDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool remind; _parser.parseBOOL(remind);
	AtfValidator::validateInt(_descr, "remind", remind, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::equals(const Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SET_PWD_REMINDER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_PWD_REMINDER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SET_PWD_REMINDER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PWD_REMINDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PWD_REMINDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::clear()
{
	answers.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::equals(const Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS& _o) const
{
	return answers.equals(_o.answers);
}

bool regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS).append(")");
	_buf.append(',');
	_buf.append("answers=");
	answers.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	answers.toXmlString("answers", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("answers"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< common_structs::ChallengeAnswer, 4 > >::FromXmlString(_value, answers)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	answers.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::parseMsg(CommMsgParser& _parser)
{
	answers.parseMsg(_parser);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("answers", answers);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("answers", answers);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< common_structs::ChallengeAnswer > answers; _jparser.validateByNameThrow("answers", answers);
	AtfValidator::validateIntRange(_descr, "answers", answers.size(), CHALLENGE_ANSWERS_SIZE, CHALLENGE_ANSWERS_SIZE, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szAnswers = Atf::LAtfVector< common_structs::ChallengeAnswer, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("answers"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntRange(_descr, "answers", szAnswers, CHALLENGE_ANSWERS_SIZE, CHALLENGE_ANSWERS_SIZE, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	match = false;
	allowMoreAttempts = false;
}

bool regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::equals(const Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		match == _o.match &&
		allowMoreAttempts == _o.allowMoreAttempts;
}

bool regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("match=");
		_buf.appendUint(match);
		_buf.append(',');
		_buf.append("allowMoreAttempts=");
		_buf.appendUint(allowMoreAttempts);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("match", match, _buf);
		Atf::XmlElement::encodeAsXmlElement("allowMoreAttempts", allowMoreAttempts, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("match"))
			{
				match = (*_value.ptr() == '1');
			}
			else if (_element.equals("allowMoreAttempts"))
			{
				allowMoreAttempts = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(match);
		_msg.composeBOOL(allowMoreAttempts);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(match);
		_parser.parseBOOL(allowMoreAttempts);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("match", match);
		_jsonstr.compose("allowMoreAttempts", allowMoreAttempts);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("match", match);
		_jparser.parseByNameThrow("allowMoreAttempts", allowMoreAttempts);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool match; _jparser.validateByNameThrow("match", match);
		AtfValidator::validateInt(_descr, "match", match, _checker, __FILE__, __LINE__);
		bool allowMoreAttempts; _jparser.validateByNameThrow("allowMoreAttempts", allowMoreAttempts);
		AtfValidator::validateInt(_descr, "allowMoreAttempts", allowMoreAttempts, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool match; _parser.parseBOOL(match);
		AtfValidator::validateInt(_descr, "match", match, _checker, __FILE__, __LINE__);
		bool allowMoreAttempts; _parser.parseBOOL(allowMoreAttempts);
		AtfValidator::validateInt(_descr, "allowMoreAttempts", allowMoreAttempts, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::equals(const Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS& _o) const
{
	return true;
}

bool regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS).append(")");
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::parseMsg(CommMsgParser& _parser)
{
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::equals(const Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::clear()
{
	remind = true;
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::equals(const Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER& _o) const
{
	return remind == _o.remind;
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER).append(")");
	_buf.append(',');
	_buf.append("remind=");
	_buf.appendUint(remind);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("remind", remind, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("remind"))
			{
				remind = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(remind);
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(remind);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("remind", remind);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("remind", remind);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	bool remind; _jparser.validateByNameThrow("remind", remind);
	AtfValidator::validateInt(_descr, "remind", remind, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	bool remind; _parser.parseBOOL(remind);
	AtfValidator::validateInt(_descr, "remind", remind, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::equals(const Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::equals(const Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED& _o) const
{
	return true;
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED).append(")");
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::parseMsg(CommMsgParser& _parser)
{
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::equals(const Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_MATCH_ZIP_CODE
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::clear()
{
	streetNum.clear();
	zipCode.clear();
	countryCode.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::equals(const Protocol_MSG_REGULATOR_MATCH_ZIP_CODE& _o) const
{
	return Atf::atfPStringEquals(streetNum, _o.streetNum) &&
		Atf::atfPStringEquals(zipCode, _o.zipCode) &&
		Atf::atfPStringEquals(countryCode, _o.countryCode);
}

bool regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_MATCH_ZIP_CODE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_MATCH_ZIP_CODE*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_MATCH_ZIP_CODE).append(")");
	_buf.append(',');
	_buf.append("streetNum=");
	_buf.append(streetNum);
	_buf.append(',');
	_buf.append("zipCode=");
	_buf.append(zipCode);
	_buf.append(',');
	_buf.append("countryCode=");
	_buf.append(countryCode);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_MATCH_ZIP_CODE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("streetNum", streetNum, _buf);
	Atf::XmlElement::encodeAsXmlElement("zipCode", zipCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryCode", countryCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("streetNum"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, streetNum)) return false;
			}
			else if (_element.equals("zipCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, zipCode)) return false;
			}
			else if (_element.equals("countryCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, countryCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(streetNum);
	_msg.composeString(zipCode);
	_msg.composeString(countryCode);
}

void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(streetNum);
	_parser.parseStringP(zipCode);
	_parser.parseStringP(countryCode);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("streetNum", streetNum);
	_jsonstr.compose("zipCode", zipCode);
	_jsonstr.compose("countryCode", countryCode);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("streetNum", streetNum);
	_jparser.parseByNameThrow("zipCode", zipCode);
	_jparser.parseByNameThrow("countryCode", countryCode);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MATCH_ZIP_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString streetNum; _jparser.validateByNameThrow("streetNum", streetNum);
	AtfValidator::validateIntMax(_descr, "streetNum", streetNum.length(), USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	PString zipCode; _jparser.validateByNameThrow("zipCode", zipCode);
	AtfValidator::validateIntMax(_descr, "zipCode", zipCode.length(), USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	PString countryCode; _jparser.validateByNameThrow("countryCode", countryCode);
	AtfValidator::validateIntMax(_descr, "countryCode", countryCode.length(), COUNTRY_CODE_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MATCH_ZIP_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "streetNum"); size_t szStreetNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "streetNum", szStreetNum, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "zipCode"); size_t szZipCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zipCode", szZipCode, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "countryCode"); size_t szCountryCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "countryCode", szCountryCode, COUNTRY_CODE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    Address
//=================================================================

regulator::cli::Address::Address()
{
	clear();
}

void regulator::cli::Address::clear()
{
	address.clear();
	city.clear();
	state.clear();
	zip.clear();
	country.clear();
}

bool regulator::cli::Address::equals(const Address& _o) const
{
	return Atf::atfPStringEquals(address, _o.address) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(zip, _o.zip) &&
		Atf::atfPStringEquals(country, _o.country);
}

const char *regulator::cli::Address::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("zip=");
	_buf.append(zip);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::Address::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("address", address, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("zip", zip, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::Address::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("address"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, address)) return false;
		}
		else if (_element.equals("city"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
		}
		else if (_element.equals("state"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
		}
		else if (_element.equals("zip"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, zip)) return false;
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::Address::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(Address())) // not empty
	{
		_body.composeString(address);
		_body.composeString(city);
		_body.composeString(state);
		_body.composeString(zip);
		_body.composeString(country);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::Address::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(address);
	_parser0.parseStringP(city);
	_parser0.parseStringP(state);
	_parser0.parseStringP(zip);
	_parser0.parseStringP(country);
}

const char *regulator::cli::Address::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("address", address);
	_jsonstr.compose("city", city);
	_jsonstr.compose("state", state);
	_jsonstr.compose("zip", zip);
	_jsonstr.compose("country", country);
	return _buf.c_str();
}

void regulator::cli::Address::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("address", address);
	_jparser.parseByNameThrow("city", city);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("zip", zip);
	_jparser.parseByNameThrow("country", country);
}

/* static */ void regulator::cli::Address::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString address; _jparser.validateByNameThrow("address", address);
	AtfValidator::validateInt(_descr, "address", address.length(), _checker, __FILE__, __LINE__);
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateInt(_descr, "city", city.length(), _checker, __FILE__, __LINE__);
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateInt(_descr, "state", state.length(), _checker, __FILE__, __LINE__);
	PString zip; _jparser.validateByNameThrow("zip", zip);
	AtfValidator::validateInt(_descr, "zip", zip.length(), _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Address::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "address", szAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateInt(_descr, "state", szState, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "zip"); size_t szZip = strlen(_dummy);
	AtfValidator::validateInt(_descr, "zip", szZip, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	addresses.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::equals(const Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		addresses.equals(_o.addresses);
}

bool regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_MATCH_ZIP_CODE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_MATCH_ZIP_CODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("addresses=");
		addresses.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_MATCH_ZIP_CODE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		addresses.toXmlString("addresses", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("addresses"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< Address, 4 > >::FromXmlString(_value, addresses)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		addresses.composeMsg(_msg, _ignoreJSON);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		addresses.parseMsg(_parser);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("addresses", addresses);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("addresses", addresses);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MATCH_ZIP_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< Address > addresses; _jparser.validateByNameThrow("addresses", addresses);
		AtfValidator::validateInt(_descr, "addresses", addresses.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MATCH_ZIP_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szAddresses = Atf::LAtfVector< Address, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("addresses"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "addresses", szAddresses, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::clear()
{
	setNotRemove = false;
	userId.clear();
	comment.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::equals(const Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG& _o) const
{
	return setNotRemove == _o.setNotRemove &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(comment, _o.comment);
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG).append(")");
	_buf.append(',');
	_buf.append("setNotRemove=");
	_buf.appendUint(setNotRemove);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("comment=");
	_buf.append(comment);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("setNotRemove", setNotRemove, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("comment", comment, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("setNotRemove"))
			{
				setNotRemove = (*_value.ptr() == '1');
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("comment"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, comment)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(setNotRemove);
	_msg.composeString(userId);
	_msg.composeString(comment);
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(setNotRemove);
	_parser.parseStringP(userId);
	_parser.parseStringP(comment);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("setNotRemove", setNotRemove);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("comment", comment);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("setNotRemove", setNotRemove);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("comment", comment);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool setNotRemove; _jparser.validateByNameThrow("setNotRemove", setNotRemove);
	AtfValidator::validateInt(_descr, "setNotRemove", setNotRemove, _checker, __FILE__, __LINE__);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString comment; _jparser.validateByNameThrow("comment", comment);
	AtfValidator::validateIntMax(_descr, "comment", comment.length(), USER_COMMENTS_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	bool setNotRemove; _parser.parseBOOL(setNotRemove);
	AtfValidator::validateInt(_descr, "setNotRemove", setNotRemove, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "comment", szComment, USER_COMMENTS_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::equals(const Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_RESET_PWD
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::Protocol_MSG_REGULATOR_RESET_PWD()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::clear()
{
	resetPwd.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::equals(const Protocol_MSG_REGULATOR_RESET_PWD& _o) const
{
	return resetPwd.equals(_o.resetPwd);
}

bool regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_RESET_PWD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_RESET_PWD*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_RESET_PWD).append(")");
	_buf.append(',');
	_buf.append("resetPwd=");
	resetPwd.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_RESET_PWD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	resetPwd.toXmlString("resetPwd", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("resetPwd"))
			{
				if(!Atf::AtfTempl< common_structs::ResetPwdMessageStruct >::FromXmlString(_value, resetPwd)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	resetPwd.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::parseMsg(CommMsgParser& _parser)
{
	resetPwd.parseMsg(_parser);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("resetPwd", resetPwd);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("resetPwd", resetPwd);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RESET_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::ResetPwdMessageStruct resetPwd; _jparser.validateByNameThrow("resetPwd", resetPwd);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RESET_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::ResetPwdMessageStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("resetPwd"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_RESET_PWD_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::Protocol_MSG_REGULATOR_RESET_PWD_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::equals(const Protocol_MSG_REGULATOR_RESET_PWD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_RESET_PWD_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_RESET_PWD_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_RESET_PWD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_RESET_PWD_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RESET_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RESET_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_CONFIG_INFO
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::Protocol_MSG_REGULATOR_GET_CONFIG_INFO()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::clear()
{
	configInfoMask = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::equals(const Protocol_MSG_REGULATOR_GET_CONFIG_INFO& _o) const
{
	return configInfoMask == _o.configInfoMask;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_CONFIG_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_CONFIG_INFO*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_CONFIG_INFO).append(")");
	_buf.append(',');
	_buf.append("configInfoMask=");
	_buf.appendUint(configInfoMask);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_CONFIG_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("configInfoMask", configInfoMask, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("configInfoMask"))
			{
				configInfoMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(configInfoMask);
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(configInfoMask);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("configInfoMask", configInfoMask);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("configInfoMask", configInfoMask);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_CONFIG_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 configInfoMask; _jparser.validateByNameThrow("configInfoMask", configInfoMask);
	AtfValidator::validateIntMax(_descr, "configInfoMask", configInfoMask, 3, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_CONFIG_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 configInfoMask; _parser.parseUINT32(configInfoMask);
	AtfValidator::validateIntMax(_descr, "configInfoMask", configInfoMask, 3, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    RegulatorConfigInfo
//=================================================================

regulator::cli::RegulatorConfigInfo::RegulatorConfigInfo()
{
	clear();
}

void regulator::cli::RegulatorConfigInfo::clear()
{
	configInfoType = 0;
	showAddressLookup = false;
	addressLookupRMFtypesMask = 0;
	deshMaxAgeVerifyAttempts = 0;
}

bool regulator::cli::RegulatorConfigInfo::equals(const RegulatorConfigInfo& _o) const
{
	return configInfoType == _o.configInfoType &&
		showAddressLookup == _o.showAddressLookup &&
		addressLookupRMFtypesMask == _o.addressLookupRMFtypesMask &&
		deshMaxAgeVerifyAttempts == _o.deshMaxAgeVerifyAttempts;
}

const char *regulator::cli::RegulatorConfigInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("configInfoType=");
	_buf.appendUint(configInfoType);
	if (configInfoType == eRegulatorConfigInfoType_AddressLookup)
	{
		_buf.append(',');
		_buf.append("showAddressLookup=");
		_buf.appendUint(showAddressLookup);
		_buf.append(',');
		_buf.append("addressLookupRMFtypesMask=");
		_buf.appendUint(addressLookupRMFtypesMask);
	}
	if (configInfoType == eRegulatorConfigInfoType_AgeVerifyAttempts)
	{
		_buf.append(',');
		_buf.append("deshMaxAgeVerifyAttempts=");
		_buf.appendInt(deshMaxAgeVerifyAttempts);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::RegulatorConfigInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("configInfoType", configInfoType, _buf);
	if (configInfoType == eRegulatorConfigInfoType_AddressLookup)
	{
		Atf::XmlElement::encodeAsXmlElement("showAddressLookup", showAddressLookup, _buf);
		Atf::XmlElement::encodeAsXmlElement("addressLookupRMFtypesMask", addressLookupRMFtypesMask, _buf);
	}
	if (configInfoType == eRegulatorConfigInfoType_AgeVerifyAttempts)
	{
		Atf::XmlElement::encodeAsXmlElement("deshMaxAgeVerifyAttempts", deshMaxAgeVerifyAttempts, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::RegulatorConfigInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("configInfoType"))
		{
			configInfoType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("showAddressLookup"))
		{
			showAddressLookup = (*_value.ptr() == '1');
		}
		else if (_element.equals("addressLookupRMFtypesMask"))
		{
			addressLookupRMFtypesMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("deshMaxAgeVerifyAttempts"))
		{
			deshMaxAgeVerifyAttempts = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::RegulatorConfigInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(configInfoType);
	if (configInfoType == eRegulatorConfigInfoType_AddressLookup)
	{
		CommMsgBody _msg0;
		_msg0.composeBOOL(showAddressLookup);
		_msg0.composeUINT32(addressLookupRMFtypesMask);
		_msg.composeMsgBody(_msg0);
	}
	if (configInfoType == eRegulatorConfigInfoType_AgeVerifyAttempts)
	{
		CommMsgBody _msg1;
		_msg1.composeINT32(deshMaxAgeVerifyAttempts);
		_msg.composeMsgBody(_msg1);
	}
}

void regulator::cli::RegulatorConfigInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(configInfoType);
	if (configInfoType == eRegulatorConfigInfoType_AddressLookup)
	{
		parseAnonymousMsgBody0(_parser);
	}
	if (configInfoType == eRegulatorConfigInfoType_AgeVerifyAttempts)
	{
		parseAnonymousMsgBody1(_parser);
	}
}

const char *regulator::cli::RegulatorConfigInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("configInfoType", configInfoType);
	if (configInfoType == eRegulatorConfigInfoType_AddressLookup)
	{
		_jsonstr.compose("showAddressLookup", showAddressLookup);
		_jsonstr.compose("addressLookupRMFtypesMask", addressLookupRMFtypesMask);
	}
	if (configInfoType == eRegulatorConfigInfoType_AgeVerifyAttempts)
	{
		_jsonstr.compose("deshMaxAgeVerifyAttempts", deshMaxAgeVerifyAttempts);
	}
	return _buf.c_str();
}

void regulator::cli::RegulatorConfigInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("configInfoType", configInfoType);
	if (configInfoType == eRegulatorConfigInfoType_AddressLookup)
	{
		_jparser.parseByNameThrow("showAddressLookup", showAddressLookup);
		_jparser.parseByNameThrow("addressLookupRMFtypesMask", addressLookupRMFtypesMask);
	}
	if (configInfoType == eRegulatorConfigInfoType_AgeVerifyAttempts)
	{
		_jparser.parseByNameThrow("deshMaxAgeVerifyAttempts", deshMaxAgeVerifyAttempts);
	}
}

/* static */ void regulator::cli::RegulatorConfigInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 configInfoType = 0;
	_jparser.validateByNameThrow("configInfoType", configInfoType);
	AtfValidator::validateIntRange(_descr, "configInfoType", configInfoType, eRegulatorConfigInfoType_None, eRegulatorConfigInfoType_AgeVerifyAttempts, _checker, __FILE__, __LINE__);
	if (configInfoType == eRegulatorConfigInfoType_AddressLookup)
	{
		bool showAddressLookup; _jparser.validateByNameThrow("showAddressLookup", showAddressLookup);
		AtfValidator::validateInt(_descr, "showAddressLookup", showAddressLookup, _checker, __FILE__, __LINE__);
		UINT32 addressLookupRMFtypesMask; _jparser.validateByNameThrow("addressLookupRMFtypesMask", addressLookupRMFtypesMask);
		AtfValidator::validateInt(_descr, "addressLookupRMFtypesMask", addressLookupRMFtypesMask, _checker, __FILE__, __LINE__);
	}
	if (configInfoType == eRegulatorConfigInfoType_AgeVerifyAttempts)
	{
		INT32 deshMaxAgeVerifyAttempts; _jparser.validateByNameThrow("deshMaxAgeVerifyAttempts", deshMaxAgeVerifyAttempts);
		AtfValidator::validateInt(_descr, "deshMaxAgeVerifyAttempts", deshMaxAgeVerifyAttempts, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::RegulatorConfigInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 configInfoType = 0;
	_parser.parseUINT32(configInfoType);
	AtfValidator::validateIntRange(_descr, "configInfoType", configInfoType, eRegulatorConfigInfoType_None, eRegulatorConfigInfoType_AgeVerifyAttempts, _checker, __FILE__, __LINE__);
	if (configInfoType == eRegulatorConfigInfoType_AddressLookup)
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if (configInfoType == eRegulatorConfigInfoType_AgeVerifyAttempts)
	{
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
}

void regulator::cli::RegulatorConfigInfo::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(showAddressLookup);
	_parser0.parseUINT32(addressLookupRMFtypesMask);
}

/*static*/ void regulator::cli::RegulatorConfigInfo::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool showAddressLookup; _parser0.parseBOOL(showAddressLookup);
	AtfValidator::validateInt(_descr, "showAddressLookup", showAddressLookup, _checker, __FILE__, __LINE__);
	UINT32 addressLookupRMFtypesMask; _parser0.parseUINT32(addressLookupRMFtypesMask);
	AtfValidator::validateInt(_descr, "addressLookupRMFtypesMask", addressLookupRMFtypesMask, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::cli::RegulatorConfigInfo::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(deshMaxAgeVerifyAttempts);
}

/*static*/ void regulator::cli::RegulatorConfigInfo::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 deshMaxAgeVerifyAttempts; _parser0.parseINT32(deshMaxAgeVerifyAttempts);
	AtfValidator::validateInt(_descr, "deshMaxAgeVerifyAttempts", deshMaxAgeVerifyAttempts, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	configInfoData.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::equals(const Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		configInfoData.equals(_o.configInfoData);
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_CONFIG_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_CONFIG_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("configInfoData=");
		configInfoData.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_CONFIG_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		configInfoData.toXmlString("configInfoData", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("configInfoData"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< RegulatorConfigInfo, 4 > >::FromXmlString(_value, configInfoData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		configInfoData.composeMsg(_msg, _ignoreJSON);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		configInfoData.parseMsg(_parser);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("configInfoData", configInfoData);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("configInfoData", configInfoData);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_CONFIG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< RegulatorConfigInfo > configInfoData; _jparser.validateByNameThrow("configInfoData", configInfoData);
		AtfValidator::validateInt(_descr, "configInfoData", configInfoData.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_CONFIG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szConfigInfoData = Atf::LAtfVector< RegulatorConfigInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("configInfoData"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "configInfoData", szConfigInfoData, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::clear()
{
	setNotRemove = false;
	userId.clear();
	comment.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::equals(const Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG& _o) const
{
	return setNotRemove == _o.setNotRemove &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(comment, _o.comment);
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SET_RATE_MOBILE_FLAG != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_RATE_MOBILE_FLAG).append(")");
	_buf.append(',');
	_buf.append("setNotRemove=");
	_buf.appendUint(setNotRemove);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("comment=");
	_buf.append(comment);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SET_RATE_MOBILE_FLAG).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("setNotRemove", setNotRemove, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("comment", comment, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("setNotRemove"))
			{
				setNotRemove = (*_value.ptr() == '1');
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("comment"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, comment)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(setNotRemove);
	_msg.composeString(userId);
	_msg.composeString(comment);
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(setNotRemove);
	_parser.parseStringP(userId);
	_parser.parseStringP(comment);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("setNotRemove", setNotRemove);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("comment", comment);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("setNotRemove", setNotRemove);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("comment", comment);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_RATE_MOBILE_FLAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool setNotRemove; _jparser.validateByNameThrow("setNotRemove", setNotRemove);
	AtfValidator::validateInt(_descr, "setNotRemove", setNotRemove, _checker, __FILE__, __LINE__);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 0, _checker, __FILE__, __LINE__);
	PString comment; _jparser.validateByNameThrow("comment", comment);
	AtfValidator::validateIntMax(_descr, "comment", comment.length(), 0, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_RATE_MOBILE_FLAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	bool setNotRemove; _parser.parseBOOL(setNotRemove);
	AtfValidator::validateInt(_descr, "setNotRemove", setNotRemove, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 0, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "comment", szComment, 0, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::equals(const Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SAVE_CONSENT
//=================================================================

regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::Protocol_MSG_LOBBY_SAVE_CONSENT()
{
	clear();
}

void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::clear()
{
	userId.clear();
	consentId = 0;
	status = 0;
}

bool regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::equals(const Protocol_MSG_LOBBY_SAVE_CONSENT& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		consentId == _o.consentId &&
		status == _o.status;
}

bool regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SAVE_CONSENT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SAVE_CONSENT*)_other));
}

const char *regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SAVE_CONSENT).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("consentId=");
	_buf.appendUint(consentId);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SAVE_CONSENT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("consentId", consentId, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("consentId"))
			{
				consentId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("status"))
			{
				status = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(consentId);
	_msg.composeUINT32(status);
}

void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(consentId);
	_parser.parseUINT32(status);
}

const char *regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("consentId", consentId);
	_jsonstr.compose("status", status);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("consentId", consentId);
	_jparser.parseByNameThrow("status", status);
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SAVE_CONSENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 consentId; _jparser.validateByNameThrow("consentId", consentId);
	AtfValidator::validateInt(_descr, "consentId", consentId, _checker, __FILE__, __LINE__);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateIntRange(_descr, "status", status, 1, 2, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SAVE_CONSENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 consentId; _parser.parseUINT32(consentId);
	AtfValidator::validateInt(_descr, "consentId", consentId, _checker, __FILE__, __LINE__);
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateIntRange(_descr, "status", status, 1, 2, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY
//=================================================================

regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::equals(const Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SAVE_CONSENT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SAVE_CONSENT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SAVE_CONSENT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SAVE_CONSENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SAVE_CONSENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::clear()
{
	playerix = 0;
	userIntId = 0;
	ftToken.clear();
	conversionType = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::equals(const Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM& _o) const
{
	return playerix == _o.playerix &&
		userIntId == _o.userIntId &&
		Atf::atfPStringEquals(ftToken, _o.ftToken) &&
		conversionType == _o.conversionType;
}

bool regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM).append(")");
	_buf.append(',');
	_buf.append("playerix=");
	_buf.appendUint(playerix);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("ftToken=");
	_buf.append(ftToken);
	_buf.append(',');
	_buf.append("conversionType=");
	_buf.appendInt(conversionType);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("playerix", playerix, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("ftToken", ftToken, _buf);
	Atf::XmlElement::encodeAsXmlElement("conversionType", conversionType, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("playerix"))
			{
				playerix = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ftToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, ftToken)) return false;
			}
			else if (_element.equals("conversionType"))
			{
				conversionType = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(playerix);
	_msg.composeUINT32(userIntId);
	_msg.composeString(ftToken);
	_msg.composeINT32(conversionType);
}

void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(playerix);
	_parser.parseUINT32(userIntId);
	_parser.parseStringP(ftToken);
	_parser.parseINT32(conversionType);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("playerix", playerix);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("ftToken", ftToken);
	_jsonstr.compose("conversionType", conversionType);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("playerix", playerix);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("ftToken", ftToken);
	_jparser.parseByNameThrow("conversionType", conversionType);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 playerix; _jparser.validateByNameThrow("playerix", playerix);
	AtfValidator::validateInt(_descr, "playerix", playerix, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	PString ftToken; _jparser.validateByNameThrow("ftToken", ftToken);
	AtfValidator::validateIntMax(_descr, "ftToken", ftToken.length(), 10000, _checker, __FILE__, __LINE__);
	INT32 conversionType; _jparser.validateByNameThrow("conversionType", conversionType);
	AtfValidator::validateIntRange(_descr, "conversionType", conversionType, eFullTiltConversionType_Unknown, eFullTiltConversionType_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 playerix; _parser.parseUINT32(playerix);
	AtfValidator::validateInt(_descr, "playerix", playerix, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ftToken"); size_t szFtToken = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "ftToken", szFtToken, 10000, _checker, __FILE__, __LINE__);
	INT32 conversionType; _parser.parseINT32(conversionType);
	AtfValidator::validateIntRange(_descr, "conversionType", conversionType, eFullTiltConversionType_Unknown, eFullTiltConversionType_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	isRmPlayer = false;
}

bool regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::equals(const Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		isRmPlayer == _o.isRmPlayer;
}

bool regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("isRmPlayer=");
		_buf.appendUint(isRmPlayer);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("isRmPlayer", isRmPlayer, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("isRmPlayer"))
			{
				isRmPlayer = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(isRmPlayer);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(isRmPlayer);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("isRmPlayer", isRmPlayer);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("isRmPlayer", isRmPlayer);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool isRmPlayer; _jparser.validateByNameThrow("isRmPlayer", isRmPlayer);
		AtfValidator::validateInt(_descr, "isRmPlayer", isRmPlayer, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool isRmPlayer; _parser.parseBOOL(isRmPlayer);
		AtfValidator::validateInt(_descr, "isRmPlayer", isRmPlayer, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::equals(const Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS& _o) const
{
	return true;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_USER_SESSION_WINNINGS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_USER_SESSION_WINNINGS).append(")");
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_USER_SESSION_WINNINGS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::parseMsg(CommMsgParser& _parser)
{
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_SESSION_WINNINGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_SESSION_WINNINGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	isLastSession = false;
	sessionStartTime.setNull();
	sessionEndTime.setNull();
	wager = 0;
	winLoss = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::equals(const Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		isLastSession == _o.isLastSession &&
		sessionStartTime.equals(_o.sessionStartTime) &&
		sessionEndTime.equals(_o.sessionEndTime) &&
		wager == _o.wager &&
		winLoss == _o.winLoss;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("isLastSession=");
		_buf.appendUint(isLastSession);
		_buf.append(',');
		_buf.append("sessionStartTime=");
		Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, sessionStartTime);
		_buf.append(',');
		_buf.append("sessionEndTime=");
		Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, sessionEndTime);
		_buf.append(',');
		_buf.append("wager=");
		_buf.appendInt64(wager);
		_buf.append(',');
		_buf.append("winLoss=");
		_buf.appendInt64(winLoss);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("isLastSession", isLastSession, _buf);
		Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "sessionStartTime", sessionStartTime);
		Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "sessionEndTime", sessionEndTime);
		Atf::XmlElement::encodeAsXmlElement("wager", wager, _buf);
		Atf::XmlElement::encodeAsXmlElement("winLoss", winLoss, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("isLastSession"))
			{
				isLastSession = (*_value.ptr() == '1');
			}
			else if (_element.equals("sessionStartTime"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, sessionStartTime);
			}
			else if (_element.equals("sessionEndTime"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, sessionEndTime);
			}
			else if (_element.equals("wager"))
			{
				wager = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("winLoss"))
			{
				winLoss = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(isLastSession);
		_msg.composeSrvTime(sessionStartTime);
		_msg.composeSrvTime(sessionEndTime);
		_msg.composeINT64(wager);
		_msg.composeINT64(winLoss);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(isLastSession);
		_parser.parseSrvTime(sessionStartTime);
		_parser.parseSrvTime(sessionEndTime);
		_parser.parseINT64(wager);
		_parser.parseINT64(winLoss);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("isLastSession", isLastSession);
		_jsonstr.compose("sessionStartTime", sessionStartTime);
		_jsonstr.compose("sessionEndTime", sessionEndTime);
		_jsonstr.compose("wager", wager);
		_jsonstr.compose("winLoss", winLoss);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("isLastSession", isLastSession);
		_jparser.parseByNameThrow("sessionStartTime", sessionStartTime);
		_jparser.parseByNameThrow("sessionEndTime", sessionEndTime);
		_jparser.parseByNameThrow("wager", wager);
		_jparser.parseByNameThrow("winLoss", winLoss);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool isLastSession; _jparser.validateByNameThrow("isLastSession", isLastSession);
		AtfValidator::validateInt(_descr, "isLastSession", isLastSession, _checker, __FILE__, __LINE__);
		CommSrvTime sessionStartTime; _jparser.validateByNameThrow("sessionStartTime", sessionStartTime);
		AtfValidator::validateSrvDateTime(_descr, "sessionStartTime", sessionStartTime, _checker, __FILE__, __LINE__);
		CommSrvTime sessionEndTime; _jparser.validateByNameThrow("sessionEndTime", sessionEndTime);
		AtfValidator::validateSrvDateTime(_descr, "sessionEndTime", sessionEndTime, _checker, __FILE__, __LINE__);
		INT64 wager; _jparser.validateByNameThrow("wager", wager);
		AtfValidator::validateInt(_descr, "wager", wager, _checker, __FILE__, __LINE__);
		INT64 winLoss; _jparser.validateByNameThrow("winLoss", winLoss);
		AtfValidator::validateInt(_descr, "winLoss", winLoss, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool isLastSession; _parser.parseBOOL(isLastSession);
		AtfValidator::validateInt(_descr, "isLastSession", isLastSession, _checker, __FILE__, __LINE__);
		CommSrvTime sessionStartTime; _parser.parseSrvTime(sessionStartTime);
		AtfValidator::validateSrvDateTime(_descr, "sessionStartTime", sessionStartTime, _checker, __FILE__, __LINE__);
		CommSrvTime sessionEndTime; _parser.parseSrvTime(sessionEndTime);
		AtfValidator::validateSrvDateTime(_descr, "sessionEndTime", sessionEndTime, _checker, __FILE__, __LINE__);
		INT64 wager; _parser.parseINT64(wager);
		AtfValidator::validateInt(_descr, "wager", wager, _checker, __FILE__, __LINE__);
		INT64 winLoss; _parser.parseINT64(winLoss);
		AtfValidator::validateInt(_descr, "winLoss", winLoss, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::clear()
{
	userId_ignore.clear();
	elements.clear();
	locale = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::equals(const Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE& _o) const
{
	return Atf::atfPStringEquals(userId_ignore, _o.userId_ignore) &&
		elements.equals(_o.elements) &&
		locale == _o.locale;
}

bool regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_VALIDATE_USER_UPDATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_USER_UPDATE).append(")");
	_buf.append(',');
	_buf.append("userId_ignore=");
	_buf.append(userId_ignore);
	_buf.append(',');
	_buf.append("elements=");
	elements.toTraceString(_buf);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_VALIDATE_USER_UPDATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId_ignore", userId_ignore, _buf);
	elements.toXmlString("elements", _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId_ignore"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId_ignore)) return false;
			}
			else if (_element.equals("elements"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< common_structs::UserUpdateElement, 4 > >::FromXmlString(_value, elements)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId_ignore);
	elements.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(locale);
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId_ignore);
	elements.parseMsg(_parser);
	_parser.parseUINT32(locale);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId_ignore", userId_ignore);
	_jsonstr.compose("elements", elements);
	_jsonstr.compose("locale", locale);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId_ignore", userId_ignore);
	_jparser.parseByNameThrow("elements", elements);
	_jparser.parseByNameThrow("locale", locale);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_USER_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId_ignore; _jparser.validateByNameThrow("userId_ignore", userId_ignore);
	AtfValidator::validateIntMax(_descr, "userId_ignore", userId_ignore.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< common_structs::UserUpdateElement > elements; _jparser.validateByNameThrow("elements", elements);
	AtfValidator::validateIntMax(_descr, "elements", elements.size(), 1000, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_USER_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId_ignore"); size_t szUserId_ignore = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId_ignore", szUserId_ignore, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szElements = Atf::LAtfVector< common_structs::UserUpdateElement, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("elements"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "elements", szElements, 1000, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	validationResults.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::equals(const Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		validationResults.equals(_o.validationResults);
}

bool regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("validationResults=");
		validationResults.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		validationResults.toXmlString("validationResults", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("validationResults"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< common_structs::UserUpdateValidationResult, 4 > >::FromXmlString(_value, validationResults)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		validationResults.composeMsg(_msg, _ignoreJSON);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		validationResults.parseMsg(_parser);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("validationResults", validationResults);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("validationResults", validationResults);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< common_structs::UserUpdateValidationResult > validationResults; _jparser.validateByNameThrow("validationResults", validationResults);
		AtfValidator::validateInt(_descr, "validationResults", validationResults.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szValidationResults = Atf::LAtfVector< common_structs::UserUpdateValidationResult, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("validationResults"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "validationResults", szValidationResults, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::clear()
{
	action = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::equals(const Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION& _o) const
{
	return action == _o.action;
}

bool regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION).append(")");
	_buf.append(',');
	_buf.append("action=");
	_buf.appendInt(action);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("action", action, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("action"))
			{
				action = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(action);
}

void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(action);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("action", action);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("action", action);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 action; _jparser.validateByNameThrow("action", action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 action; _parser.parseINT32(action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::equals(const Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::clear()
{
	document.clear();
	docType = 0;
	country.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::equals(const Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE& _o) const
{
	return Atf::atfPStringEquals(document, _o.document) &&
		docType == _o.docType &&
		Atf::atfPStringEquals(country, _o.country);
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE).append(")");
	_buf.append(',');
	_buf.append("document=");
	_buf.append(document);
	_buf.append(',');
	_buf.append("docType=");
	_buf.appendInt(docType);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("document", document, _buf);
	Atf::XmlElement::encodeAsXmlElement("docType", docType, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("document"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, document)) return false;
			}
			else if (_element.equals("docType"))
			{
				docType = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(document);
	_msg.composeINT32(docType);
	_msg.composeString(country);
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(document);
	_parser.parseINT32(docType);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(country);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("document", document);
	_jsonstr.compose("docType", docType);
	_jsonstr.compose("country", country);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("document", document);
	_jparser.parseByNameThrow("docType", docType);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("country", country);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString document; _jparser.validateByNameThrow("document", document);
	AtfValidator::validateIntMax(_descr, "document", document.length(), 10000, _checker, __FILE__, __LINE__);
	INT32 docType; _jparser.validateByNameThrow("docType", docType);
	AtfValidator::validateIntMax(_descr, "docType", docType, 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), COUNTRY_CODE_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "document"); size_t szDocument = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "document", szDocument, 10000, _checker, __FILE__, __LINE__);
	INT32 docType; _parser.parseINT32(docType);
	AtfValidator::validateIntMax(_descr, "docType", docType, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, COUNTRY_CODE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::equals(const Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SE_BANKID_VERIFY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::clear()
{
	personalNumber.clear();
	mobileBankIdOnly = false;
}

bool regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::equals(const Protocol_MSG_REGULATOR_SE_BANKID_VERIFY& _o) const
{
	return Atf::atfPStringEquals(personalNumber, _o.personalNumber) &&
		mobileBankIdOnly == _o.mobileBankIdOnly;
}

bool regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SE_BANKID_VERIFY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SE_BANKID_VERIFY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SE_BANKID_VERIFY).append(")");
	_buf.append(',');
	_buf.append("personalNumber=");
	_buf.append(personalNumber);
	_buf.append(',');
	_buf.append("mobileBankIdOnly=");
	_buf.appendUint(mobileBankIdOnly);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SE_BANKID_VERIFY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("personalNumber", personalNumber, _buf);
	Atf::XmlElement::encodeAsXmlElement("mobileBankIdOnly", mobileBankIdOnly, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("personalNumber"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, personalNumber)) return false;
			}
			else if (_element.equals("mobileBankIdOnly"))
			{
				mobileBankIdOnly = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(personalNumber);
	_msg.composeBOOL(mobileBankIdOnly);
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(personalNumber);
	_parser.parseBOOL(mobileBankIdOnly);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("personalNumber", personalNumber);
	_jsonstr.compose("mobileBankIdOnly", mobileBankIdOnly);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("personalNumber", personalNumber);
	_jparser.parseByNameThrow("mobileBankIdOnly", mobileBankIdOnly);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SE_BANKID_VERIFY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString personalNumber; _jparser.validateByNameThrow("personalNumber", personalNumber);
	AtfValidator::validateIntMax(_descr, "personalNumber", personalNumber.length(), 12, _checker, __FILE__, __LINE__);
	bool mobileBankIdOnly; _jparser.validateByNameThrow("mobileBankIdOnly", mobileBankIdOnly);
	AtfValidator::validateInt(_descr, "mobileBankIdOnly", mobileBankIdOnly, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SE_BANKID_VERIFY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "personalNumber"); size_t szPersonalNumber = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "personalNumber", szPersonalNumber, 12, _checker, __FILE__, __LINE__);
	bool mobileBankIdOnly; _parser.parseBOOL(mobileBankIdOnly);
	AtfValidator::validateInt(_descr, "mobileBankIdOnly", mobileBankIdOnly, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	status = 0;
	replyDetails.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::equals(const Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		status == _o.status &&
		replyDetails.equals(_o.replyDetails);
}

bool regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SE_BANKID_VERIFY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SE_BANKID_VERIFY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("status=");
		_buf.appendInt(status);
		_buf.append(',');
		_buf.append("replyDetails=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(replyDetails, _buf); _buf.append('}');
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SE_BANKID_VERIFY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
		Atf::XmlElement::encodeAsXmlElement("replyDetails", replyDetails, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("status"))
			{
				status = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("replyDetails"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, replyDetails)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(status);
		_msg.composeMsgBody(replyDetails);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(status);
		_parser.parseMsgBody(replyDetails);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("status", status);
		_jsonstr.compose("replyDetails", replyDetails);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("status", status);
		_jparser.parseByNameThrow("replyDetails", replyDetails);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SE_BANKID_VERIFY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 status; _jparser.validateByNameThrow("status", status);
		AtfValidator::validateIntRange(_descr, "status", status, 0, 2, _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody replyDetails; _jparser.validateByNameThrow("replyDetails", replyDetails);
		AtfValidator::validateInt(_descr, "replyDetails", replyDetails._size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SE_BANKID_VERIFY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 status; _parser.parseINT32(status);
		AtfValidator::validateIntRange(_descr, "status", status, 0, 2, _checker, __FILE__, __LINE__);
		size_t szReplyDetails; _parser.skipMsgBody(szReplyDetails);  /*replyDetails*/
		AtfValidator::validateInt(_descr, "replyDetails", szReplyDetails, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SE_BANKID_COLLECT
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::clear()
{
	orderId = 0;
	bankIdClientStartedAutomatically = false;
}

bool regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::equals(const Protocol_MSG_REGULATOR_SE_BANKID_COLLECT& _o) const
{
	return orderId == _o.orderId &&
		bankIdClientStartedAutomatically == _o.bankIdClientStartedAutomatically;
}

bool regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SE_BANKID_COLLECT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SE_BANKID_COLLECT*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SE_BANKID_COLLECT).append(")");
	_buf.append(',');
	_buf.append("orderId=");
	_buf.appendInt(orderId);
	_buf.append(',');
	_buf.append("bankIdClientStartedAutomatically=");
	_buf.appendUint(bankIdClientStartedAutomatically);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SE_BANKID_COLLECT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("orderId", orderId, _buf);
	Atf::XmlElement::encodeAsXmlElement("bankIdClientStartedAutomatically", bankIdClientStartedAutomatically, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("orderId"))
			{
				orderId = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bankIdClientStartedAutomatically"))
			{
				bankIdClientStartedAutomatically = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(orderId);
	_msg.composeBOOL(bankIdClientStartedAutomatically);
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(orderId);
	_parser.parseBOOL(bankIdClientStartedAutomatically);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("orderId", orderId);
	_jsonstr.compose("bankIdClientStartedAutomatically", bankIdClientStartedAutomatically);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("orderId", orderId);
	_jparser.parseByNameThrow("bankIdClientStartedAutomatically", bankIdClientStartedAutomatically);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SE_BANKID_COLLECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 orderId; _jparser.validateByNameThrow("orderId", orderId);
	AtfValidator::validateIntMin(_descr, "orderId", orderId, 1, _checker, __FILE__, __LINE__);
	bool bankIdClientStartedAutomatically; _jparser.validateByNameThrow("bankIdClientStartedAutomatically", bankIdClientStartedAutomatically);
	AtfValidator::validateInt(_descr, "bankIdClientStartedAutomatically", bankIdClientStartedAutomatically, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SE_BANKID_COLLECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 orderId; _parser.parseINT32(orderId);
	AtfValidator::validateIntMin(_descr, "orderId", orderId, 1, _checker, __FILE__, __LINE__);
	bool bankIdClientStartedAutomatically; _parser.parseBOOL(bankIdClientStartedAutomatically);
	AtfValidator::validateInt(_descr, "bankIdClientStartedAutomatically", bankIdClientStartedAutomatically, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	status = 0;
	replyDetails.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::equals(const Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		status == _o.status &&
		replyDetails.equals(_o.replyDetails);
}

bool regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SE_BANKID_COLLECT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SE_BANKID_COLLECT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("status=");
		_buf.appendInt(status);
		_buf.append(',');
		_buf.append("replyDetails=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(replyDetails, _buf); _buf.append('}');
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SE_BANKID_COLLECT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
		Atf::XmlElement::encodeAsXmlElement("replyDetails", replyDetails, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("status"))
			{
				status = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("replyDetails"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, replyDetails)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(status);
		_msg.composeMsgBody(replyDetails);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(status);
		_parser.parseMsgBody(replyDetails);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("status", status);
		_jsonstr.compose("replyDetails", replyDetails);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("status", status);
		_jparser.parseByNameThrow("replyDetails", replyDetails);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SE_BANKID_COLLECT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 status; _jparser.validateByNameThrow("status", status);
		AtfValidator::validateIntRange(_descr, "status", status, 0, 2, _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody replyDetails; _jparser.validateByNameThrow("replyDetails", replyDetails);
		AtfValidator::validateInt(_descr, "replyDetails", replyDetails._size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SE_BANKID_COLLECT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 status; _parser.parseINT32(status);
		AtfValidator::validateIntRange(_descr, "status", status, 0, 2, _checker, __FILE__, __LINE__);
		size_t szReplyDetails; _parser.skipMsgBody(szReplyDetails);  /*replyDetails*/
		AtfValidator::validateInt(_descr, "replyDetails", szReplyDetails, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    BlackListInfo
//=================================================================

regulator::cli::BlackListInfo::BlackListInfo()
{
	clear();
}

void regulator::cli::BlackListInfo::clear()
{
	durationDays = 0;
	timeFrom.setNull();
	timeUntil.setNull();
}

bool regulator::cli::BlackListInfo::equals(const BlackListInfo& _o) const
{
	return durationDays == _o.durationDays &&
		timeFrom.equals(_o.timeFrom) &&
		timeUntil.equals(_o.timeUntil);
}

const char *regulator::cli::BlackListInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("durationDays=");
	_buf.appendInt(durationDays);
	_buf.append(',');
	_buf.append("timeFrom=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, timeFrom);
	_buf.append(',');
	_buf.append("timeUntil=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, timeUntil);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::BlackListInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("durationDays", durationDays, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "timeFrom", timeFrom);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "timeUntil", timeUntil);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::BlackListInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("durationDays"))
		{
			durationDays = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timeFrom"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, timeFrom);
		}
		else if (_element.equals("timeUntil"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, timeUntil);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::BlackListInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(BlackListInfo())) // not empty
	{
		_body.composeINT32(durationDays);
		_body.composeSrvTime(timeFrom);
		_body.composeSrvTime(timeUntil);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::BlackListInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(durationDays);
	_parser0.parseSrvTime(timeFrom);
	_parser0.parseSrvTime(timeUntil);
}

const char *regulator::cli::BlackListInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("durationDays", durationDays);
	_jsonstr.compose("timeFrom", timeFrom);
	_jsonstr.compose("timeUntil", timeUntil);
	return _buf.c_str();
}

void regulator::cli::BlackListInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("durationDays", durationDays);
	_jparser.parseByNameThrow("timeFrom", timeFrom);
	_jparser.parseByNameThrow("timeUntil", timeUntil);
}

/* static */ void regulator::cli::BlackListInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 durationDays; _jparser.validateByNameThrow("durationDays", durationDays);
	AtfValidator::validateIntRange(_descr, "durationDays", durationDays, 0, 90, _checker, __FILE__, __LINE__);
	SrvTime timeFrom; _jparser.validateByNameThrow("timeFrom", timeFrom);
	AtfValidator::validateSrvDateTime(_descr, "timeFrom", timeFrom, _checker, __FILE__, __LINE__);
	SrvTime timeUntil; _jparser.validateByNameThrow("timeUntil", timeUntil);
	AtfValidator::validateSrvDateTime(_descr, "timeUntil", timeUntil, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::BlackListInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 durationDays; _parser0.parseINT32(durationDays);
	AtfValidator::validateIntRange(_descr, "durationDays", durationDays, 0, 90, _checker, __FILE__, __LINE__);
	SrvTime timeFrom; _parser0.parseSrvTime(timeFrom);
	AtfValidator::validateSrvDateTime(_descr, "timeFrom", timeFrom, _checker, __FILE__, __LINE__);
	SrvTime timeUntil; _parser0.parseSrvTime(timeUntil);
	AtfValidator::validateSrvDateTime(_descr, "timeUntil", timeUntil, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    BlackListInfoConditional
//=================================================================

regulator::cli::BlackListInfoConditional::BlackListInfoConditional()
{
	clear();
}

void regulator::cli::BlackListInfoConditional::clear()
{
	isBlacklisted = false;
	infoBody.clear();
}

bool regulator::cli::BlackListInfoConditional::equals(const BlackListInfoConditional& _o) const
{
	return isBlacklisted == _o.isBlacklisted &&
		infoBody.equals(_o.infoBody);
}

const char *regulator::cli::BlackListInfoConditional::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("isBlacklisted=");
	_buf.appendUint(isBlacklisted);
	if(isBlacklisted)
	{
		_buf.append(',');
		_buf.append("infoBody=");
		infoBody.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli::BlackListInfoConditional::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("isBlacklisted", isBlacklisted, _buf);
	if(isBlacklisted)
	{
		infoBody.toXmlString("infoBody", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli::BlackListInfoConditional::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("isBlacklisted"))
		{
			isBlacklisted = (*_value.ptr() == '1');
		}
		else if (_element.equals("infoBody"))
		{
			if(!Atf::AtfTempl< BlackListInfo >::FromXmlString(_value, infoBody)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli::BlackListInfoConditional::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(isBlacklisted);
	if(isBlacklisted)
	{
		infoBody.composeMsg(_msg, _ignoreJSON);
	}
}

void regulator::cli::BlackListInfoConditional::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(isBlacklisted);
	if(isBlacklisted)
	{
		infoBody.parseMsg(_parser);
	}
}

const char *regulator::cli::BlackListInfoConditional::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("isBlacklisted", isBlacklisted);
	if(isBlacklisted)
	{
		_jsonstr.compose("infoBody", infoBody);
	}
	return _buf.c_str();
}

void regulator::cli::BlackListInfoConditional::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("isBlacklisted", isBlacklisted);
	if(isBlacklisted)
	{
		_jparser.parseByNameThrow("infoBody", infoBody);
	}
}

/* static */ void regulator::cli::BlackListInfoConditional::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool isBlacklisted = false;
	_jparser.validateByNameThrow("isBlacklisted", isBlacklisted);
	AtfValidator::validateInt(_descr, "isBlacklisted", isBlacklisted, _checker, __FILE__, __LINE__);
	if(isBlacklisted)
	{
		BlackListInfo infoBody; _jparser.validateByNameThrow("infoBody", infoBody);
	}
}

/*static*/ void regulator::cli::BlackListInfoConditional::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool isBlacklisted = false;
	_parser.parseBOOL(isBlacklisted);
	AtfValidator::validateInt(_descr, "isBlacklisted", isBlacklisted, _checker, __FILE__, __LINE__);
	if(isBlacklisted)
	{
		PString _descbuf;
		BlackListInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("infoBody"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::equals(const Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO& _o) const
{
	return true;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_USER_BLACKLIST_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_USER_BLACKLIST_INFO).append(")");
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_USER_BLACKLIST_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::parseMsg(CommMsgParser& _parser)
{
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_BLACKLIST_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_BLACKLIST_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	blackListInfo.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::equals(const Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		blackListInfo.equals(_o.blackListInfo);
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("blackListInfo=");
		blackListInfo.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		blackListInfo.toXmlString("blackListInfo", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("blackListInfo"))
			{
				if(!Atf::AtfTempl< BlackListInfoConditional >::FromXmlString(_value, blackListInfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		blackListInfo.composeMsg(_msg, _ignoreJSON);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		blackListInfo.parseMsg(_parser);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("blackListInfo", blackListInfo);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("blackListInfo", blackListInfo);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		BlackListInfoConditional blackListInfo; _jparser.validateByNameThrow("blackListInfo", blackListInfo);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		BlackListInfoConditional::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("blackListInfo"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::clear()
{
	durationDays = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::equals(const Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED& _o) const
{
	return durationDays == _o.durationDays;
}

bool regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_REQUEST_USER_BLACKLISTED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_REQUEST_USER_BLACKLISTED).append(")");
	_buf.append(',');
	_buf.append("durationDays=");
	_buf.appendInt(durationDays);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_REQUEST_USER_BLACKLISTED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("durationDays", durationDays, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("durationDays"))
			{
				durationDays = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(durationDays);
}

void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(durationDays);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("durationDays", durationDays);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("durationDays", durationDays);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REQUEST_USER_BLACKLISTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 durationDays; _jparser.validateByNameThrow("durationDays", durationDays);
	AtfValidator::validateIntRange(_descr, "durationDays", durationDays, 0, 90, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REQUEST_USER_BLACKLISTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 durationDays; _parser.parseINT32(durationDays);
	AtfValidator::validateIntRange(_descr, "durationDays", durationDays, 0, 90, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	infoBody.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::equals(const Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		infoBody.equals(_o.infoBody);
}

bool regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("infoBody=");
		infoBody.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		infoBody.toXmlString("infoBody", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("infoBody"))
			{
				if(!Atf::AtfTempl< BlackListInfo >::FromXmlString(_value, infoBody)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		infoBody.composeMsg(_msg, _ignoreJSON);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		infoBody.parseMsg(_parser);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("infoBody", infoBody);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("infoBody", infoBody);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		BlackListInfo infoBody; _jparser.validateByNameThrow("infoBody", infoBody);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		BlackListInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("infoBody"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_SWISS_URL
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::Protocol_MSG_REGULATOR_GET_SWISS_URL()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::clear()
{
	commonRequest.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::equals(const Protocol_MSG_REGULATOR_GET_SWISS_URL& _o) const
{
	return commonRequest.equals(_o.commonRequest);
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_SWISS_URL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_SWISS_URL*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_SWISS_URL).append(")");
	_buf.append(',');
	_buf.append("commonRequest=");
	commonRequest.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_SWISS_URL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	commonRequest.toXmlString("commonRequest", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("commonRequest"))
			{
				if(!Atf::AtfTempl< common_structs::SwissUrlRequest >::FromXmlString(_value, commonRequest)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	commonRequest.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::parseMsg(CommMsgParser& _parser)
{
	commonRequest.parseMsg(_parser);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("commonRequest", commonRequest);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("commonRequest", commonRequest);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_SWISS_URL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::SwissUrlRequest commonRequest; _jparser.validateByNameThrow("commonRequest", commonRequest);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_SWISS_URL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SwissUrlRequest::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("commonRequest"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	url.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::equals(const Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(url, _o.url);
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_SWISS_URL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_SWISS_URL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("url=");
		_buf.append(url);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_SWISS_URL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("url", url, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("url"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, url)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(url);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(url);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("url", url);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("url", url);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_SWISS_URL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString url; _jparser.validateByNameThrow("url", url);
		AtfValidator::validateInt(_descr, "url", url.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_SWISS_URL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::clear()
{
	urlType = 1;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::equals(const Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL& _o) const
{
	return urlType == _o.urlType;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_ASIA_GAMING_URL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_ASIA_GAMING_URL).append(")");
	_buf.append(',');
	_buf.append("urlType=");
	_buf.appendInt(urlType);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_ASIA_GAMING_URL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("urlType", urlType, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("urlType"))
			{
				urlType = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(urlType);
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseINT16(urlType);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("urlType", urlType);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("urlType", urlType);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_ASIA_GAMING_URL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	INT16 urlType; _jparser.validateByNameThrow("urlType", urlType);
	AtfValidator::validateIntMax(_descr, "urlType", urlType, eAsiaB2B_LinkType_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_ASIA_GAMING_URL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	INT16 urlType; _parser.parseINT16(urlType);
	AtfValidator::validateIntMax(_descr, "urlType", urlType, eAsiaB2B_LinkType_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	url.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::equals(const Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(url, _o.url);
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("url=");
		_buf.append("...");
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("url", url, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("url"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, url)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(url);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(url);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("url", url);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("url", url);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString url; _jparser.validateByNameThrow("url", url);
		AtfValidator::validateInt(_descr, "url", url.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::equals(const Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT& _o) const
{
	return true;
}

bool regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT).append(")");
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::parseMsg(CommMsgParser& _parser)
{
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::equals(const Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::clear()
{
	journeyId.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::equals(const Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION& _o) const
{
	return Atf::atfPStringEquals(journeyId, _o.journeyId);
}

bool regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION).append(")");
	_buf.append(',');
	_buf.append("journeyId=");
	_buf.append(journeyId);
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("journeyId", journeyId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("journeyId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, journeyId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(journeyId);
}

void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(journeyId);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("journeyId", journeyId);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("journeyId", journeyId);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString journeyId; _jparser.validateByNameThrow("journeyId", journeyId);
	AtfValidator::validateIntMax(_descr, "journeyId", journeyId.length(), 40, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "journeyId"); size_t szJourneyId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "journeyId", szJourneyId, 40, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::equals(const Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY*)_other));
}

const char *regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::clear()
{
	installId.clear();
	siteId = 0;
	platformId = 0;
	accountWizardPageName.clear();
	clientExtra.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::equals(const Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP& _o) const
{
	return Atf::atfPStringEquals(installId, _o.installId) &&
		siteId == _o.siteId &&
		platformId == _o.platformId &&
		Atf::atfPStringEquals(accountWizardPageName, _o.accountWizardPageName) &&
		clientExtra.equals(_o.clientExtra);
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP).append(")");
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("platformId=");
	_buf.appendUint(platformId);
	_buf.append(',');
	_buf.append("accountWizardPageName=");
	_buf.append(accountWizardPageName);
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("installId", installId, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("platformId", platformId, _buf);
	Atf::XmlElement::encodeAsXmlElement("accountWizardPageName", accountWizardPageName, _buf);
	clientExtra.toXmlString("clientExtra", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("installId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, installId)) return false;
			}
			else if (_element.equals("siteId"))
			{
				siteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("platformId"))
			{
				platformId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("accountWizardPageName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, accountWizardPageName)) return false;
			}
			else if (_element.equals("clientExtra"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, clientExtra)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(installId);
	_msg.composeUINT32(siteId);
	_msg.composeUINT32(platformId);
	_msg.composeString(accountWizardPageName);
	clientExtra.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(installId);
	_parser.parseUINT32(siteId);
	_parser.parseUINT32(platformId);
	_parser.parseStringP(accountWizardPageName);
	if(_parser.parseEnded()) return;
	clientExtra.parseMsg(_parser);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("installId", installId);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("platformId", platformId);
	_jsonstr.compose("accountWizardPageName", accountWizardPageName);
	_jsonstr.compose("clientExtra", clientExtra);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("installId", installId);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("platformId", platformId);
	_jparser.parseByNameThrow("accountWizardPageName", accountWizardPageName);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientExtra", clientExtra);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString installId; _jparser.validateByNameThrow("installId", installId);
	AtfValidator::validateIntMax(_descr, "installId", installId.length(), 100, _checker, __FILE__, __LINE__);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 platformId; _jparser.validateByNameThrow("platformId", platformId);
	AtfValidator::validateIntRange(_descr, "platformId", platformId, Client_UnknownPlatform, Client_Last, _checker, __FILE__, __LINE__);
	PString accountWizardPageName; _jparser.validateByNameThrow("accountWizardPageName", accountWizardPageName);
	AtfValidator::validateIntMax(_descr, "accountWizardPageName", accountWizardPageName.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Common::AtfShared::LoginExtra clientExtra; _jparser.validateByNameThrow("clientExtra", clientExtra);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 100, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 platformId; _parser.parseUINT32(platformId);
	AtfValidator::validateIntRange(_descr, "platformId", platformId, Client_UnknownPlatform, Client_Last, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "accountWizardPageName"); size_t szAccountWizardPageName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "accountWizardPageName", szAccountWizardPageName, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_NAME_AVAILABLE
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::Protocol_MSG_LOBBY_NAME_AVAILABLE()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::clear()
{
	body.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::equals(const Protocol_MSG_LOBBY_NAME_AVAILABLE& _o) const
{
	return body.equals(_o.body);
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_NAME_AVAILABLE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_NAME_AVAILABLE*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_NAME_AVAILABLE).append(")");
	_buf.append(',');
	_buf.append("body=");
	body.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_NAME_AVAILABLE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	body.toXmlString("body", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("body"))
			{
				if(!Atf::AtfTempl< common_structs::LobbyNameAvailableStruct >::FromXmlString(_value, body)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	body.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::parseMsg(CommMsgParser& _parser)
{
	body.parseMsg(_parser);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("body", body);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("body", body);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_NAME_AVAILABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::LobbyNameAvailableStruct body; _jparser.validateByNameThrow("body", body);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_NAME_AVAILABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::LobbyNameAvailableStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("body"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::clear()
{
	replyBody.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::equals(const Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY& _o) const
{
	return replyBody.equals(_o.replyBody);
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_NAME_AVAILABLE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_NAME_AVAILABLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("replyBody=");
	replyBody.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_NAME_AVAILABLE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	replyBody.toXmlString("replyBody", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("replyBody"))
			{
				if(!Atf::AtfTempl< common_structs::LobbyNameAvailableReplyStruct >::FromXmlString(_value, replyBody)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	replyBody.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	replyBody.parseMsg(_parser);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("replyBody", replyBody);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("replyBody", replyBody);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_NAME_AVAILABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::LobbyNameAvailableReplyStruct replyBody; _jparser.validateByNameThrow("replyBody", replyBody);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_NAME_AVAILABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::LobbyNameAvailableReplyStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("replyBody"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::clear()
{
	siteId = 0;
	clientExtra.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::equals(const Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP& _o) const
{
	return siteId == _o.siteId &&
		clientExtra.equals(_o.clientExtra);
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_COMPARE_SITE_FOR_IP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_COMPARE_SITE_FOR_IP).append(")");
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_COMPARE_SITE_FOR_IP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	clientExtra.toXmlString("clientExtra", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("siteId"))
			{
				siteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientExtra"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, clientExtra)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(siteId);
	clientExtra.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(siteId);
	if(_parser.parseEnded()) return;
	clientExtra.parseMsg(_parser);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("clientExtra", clientExtra);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("siteId", siteId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientExtra", clientExtra);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_COMPARE_SITE_FOR_IP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Common::AtfShared::LoginExtra clientExtra; _jparser.validateByNameThrow("clientExtra", clientExtra);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_COMPARE_SITE_FOR_IP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SiteMetadata
//=================================================================

regulator::cli_unauth::SiteMetadata::SiteMetadata()
{
	clear();
}

void regulator::cli_unauth::SiteMetadata::clear()
{
	siteId = 0;
	name.clear();
	contactEmail.clear();
	contactURL.clear();
	downloadURL.clear();
	faqURL.clear();
}

bool regulator::cli_unauth::SiteMetadata::equals(const SiteMetadata& _o) const
{
	return siteId == _o.siteId &&
		Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(contactEmail, _o.contactEmail) &&
		Atf::atfPStringEquals(contactURL, _o.contactURL) &&
		Atf::atfPStringEquals(downloadURL, _o.downloadURL) &&
		Atf::atfPStringEquals(faqURL, _o.faqURL);
}

const char *regulator::cli_unauth::SiteMetadata::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("contactEmail=");
	_buf.append(contactEmail);
	_buf.append(',');
	_buf.append("contactURL=");
	_buf.append(contactURL);
	_buf.append(',');
	_buf.append("downloadURL=");
	_buf.append(downloadURL);
	_buf.append(',');
	_buf.append("faqURL=");
	_buf.append(faqURL);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli_unauth::SiteMetadata::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("contactEmail", contactEmail, _buf);
	Atf::XmlElement::encodeAsXmlElement("contactURL", contactURL, _buf);
	Atf::XmlElement::encodeAsXmlElement("downloadURL", downloadURL, _buf);
	Atf::XmlElement::encodeAsXmlElement("faqURL", faqURL, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli_unauth::SiteMetadata::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("siteId"))
		{
			siteId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("contactEmail"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, contactEmail)) return false;
		}
		else if (_element.equals("contactURL"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, contactURL)) return false;
		}
		else if (_element.equals("downloadURL"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, downloadURL)) return false;
		}
		else if (_element.equals("faqURL"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, faqURL)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli_unauth::SiteMetadata::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(siteId);
	_msg.composeString(name);
	_msg.composeString(contactEmail);
	_msg.composeString(contactURL);
	_msg.composeString(downloadURL);
	_msg.composeString(faqURL);
}

void regulator::cli_unauth::SiteMetadata::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(siteId);
	_parser.parseStringP(name);
	_parser.parseStringP(contactEmail);
	_parser.parseStringP(contactURL);
	_parser.parseStringP(downloadURL);
	_parser.parseStringP(faqURL);
}

const char *regulator::cli_unauth::SiteMetadata::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("name", name);
	_jsonstr.compose("contactEmail", contactEmail);
	_jsonstr.compose("contactURL", contactURL);
	_jsonstr.compose("downloadURL", downloadURL);
	_jsonstr.compose("faqURL", faqURL);
	return _buf.c_str();
}

void regulator::cli_unauth::SiteMetadata::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("contactEmail", contactEmail);
	_jparser.parseByNameThrow("contactURL", contactURL);
	_jparser.parseByNameThrow("downloadURL", downloadURL);
	_jparser.parseByNameThrow("faqURL", faqURL);
}

/* static */ void regulator::cli_unauth::SiteMetadata::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString contactEmail; _jparser.validateByNameThrow("contactEmail", contactEmail);
	AtfValidator::validateInt(_descr, "contactEmail", contactEmail.length(), _checker, __FILE__, __LINE__);
	PString contactURL; _jparser.validateByNameThrow("contactURL", contactURL);
	AtfValidator::validateInt(_descr, "contactURL", contactURL.length(), _checker, __FILE__, __LINE__);
	PString downloadURL; _jparser.validateByNameThrow("downloadURL", downloadURL);
	AtfValidator::validateInt(_descr, "downloadURL", downloadURL.length(), _checker, __FILE__, __LINE__);
	PString faqURL; _jparser.validateByNameThrow("faqURL", faqURL);
	AtfValidator::validateInt(_descr, "faqURL", faqURL.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::SiteMetadata::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "contactEmail"); size_t szContactEmail = strlen(_dummy);
	AtfValidator::validateInt(_descr, "contactEmail", szContactEmail, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "contactURL"); size_t szContactURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "contactURL", szContactURL, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "downloadURL"); size_t szDownloadURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "downloadURL", szDownloadURL, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "faqURL"); size_t szFaqURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "faqURL", szFaqURL, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::clear()
{
	errCode = 0;
	country.clear();
	siteMetadata.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::equals(const Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(country, _o.country) &&
		siteMetadata.equals(_o.siteMetadata);
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("siteMetadata=");
	siteMetadata.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	siteMetadata.toXmlString("siteMetadata", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("siteMetadata"))
			{
				if(!Atf::AtfTempl< SiteMetadata >::FromXmlString(_value, siteMetadata)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(country);
	siteMetadata.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(country);
	siteMetadata.parseMsg(_parser);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("country", country);
	_jsonstr.compose("siteMetadata", siteMetadata);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("siteMetadata", siteMetadata);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	SiteMetadata siteMetadata; _jparser.validateByNameThrow("siteMetadata", siteMetadata);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	PString _descbuf;
	SiteMetadata::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("siteMetadata"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::clear()
{
	country.clear();
	locale = 0;
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::equals(const Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE& _o) const
{
	return Atf::atfPStringEquals(country, _o.country) &&
		locale == _o.locale;
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SIGNUP_QUESTIONNAIRE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SIGNUP_QUESTIONNAIRE).append(")");
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SIGNUP_QUESTIONNAIRE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(country);
	_msg.composeUINT32(locale);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(country);
	_parser.parseUINT32(locale);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("country", country);
	_jsonstr.compose("locale", locale);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("locale", locale);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SIGNUP_QUESTIONNAIRE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), 5, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SIGNUP_QUESTIONNAIRE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 5, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ReferralSource
//=================================================================

regulator::cli_unauth::ReferralSource::ReferralSource()
{
	clear();
}

void regulator::cli_unauth::ReferralSource::clear()
{
	sourceId = 0;
	sourceName.clear();
	pleaseSpecify.clear();
	options.clear();
}

bool regulator::cli_unauth::ReferralSource::equals(const ReferralSource& _o) const
{
	return sourceId == _o.sourceId &&
		Atf::atfPStringEquals(sourceName, _o.sourceName) &&
		Atf::atfPStringEquals(pleaseSpecify, _o.pleaseSpecify) &&
		options.equals(_o.options);
}

const char *regulator::cli_unauth::ReferralSource::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sourceId=");
	_buf.appendUint(sourceId);
	_buf.append(',');
	_buf.append("sourceName=");
	_buf.append(sourceName);
	_buf.append(',');
	_buf.append("pleaseSpecify=");
	_buf.append(pleaseSpecify);
	_buf.append(',');
	_buf.append("options=");
	options.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli_unauth::ReferralSource::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("sourceId", sourceId, _buf);
	Atf::XmlElement::encodeAsXmlElement("sourceName", sourceName, _buf);
	Atf::XmlElement::encodeAsXmlElement("pleaseSpecify", pleaseSpecify, _buf);
	options.toXmlString("options", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli_unauth::ReferralSource::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("sourceId"))
		{
			sourceId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sourceName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, sourceName)) return false;
		}
		else if (_element.equals("pleaseSpecify"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, pleaseSpecify)) return false;
		}
		else if (_element.equals("options"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, options)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli_unauth::ReferralSource::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(sourceId);
	_msg.composeString(sourceName);
	_msg.composeString(pleaseSpecify);
	options.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli_unauth::ReferralSource::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sourceId);
	_parser.parseStringP(sourceName);
	_parser.parseStringP(pleaseSpecify);
	options.parseMsg(_parser);
}

const char *regulator::cli_unauth::ReferralSource::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sourceId", sourceId);
	_jsonstr.compose("sourceName", sourceName);
	_jsonstr.compose("pleaseSpecify", pleaseSpecify);
	_jsonstr.compose("options", options);
	return _buf.c_str();
}

void regulator::cli_unauth::ReferralSource::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sourceId", sourceId);
	_jparser.parseByNameThrow("sourceName", sourceName);
	_jparser.parseByNameThrow("pleaseSpecify", pleaseSpecify);
	_jparser.parseByNameThrow("options", options);
}

/* static */ void regulator::cli_unauth::ReferralSource::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 sourceId; _jparser.validateByNameThrow("sourceId", sourceId);
	AtfValidator::validateInt(_descr, "sourceId", sourceId, _checker, __FILE__, __LINE__);
	PString sourceName; _jparser.validateByNameThrow("sourceName", sourceName);
	AtfValidator::validateInt(_descr, "sourceName", sourceName.length(), _checker, __FILE__, __LINE__);
	PString pleaseSpecify; _jparser.validateByNameThrow("pleaseSpecify", pleaseSpecify);
	AtfValidator::validateInt(_descr, "pleaseSpecify", pleaseSpecify.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > options; _jparser.validateByNameThrow("options", options);
	AtfValidator::validateInt(_descr, "options", options.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::ReferralSource::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 sourceId; _parser.parseUINT32(sourceId);
	AtfValidator::validateInt(_descr, "sourceId", sourceId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "sourceName"); size_t szSourceName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "sourceName", szSourceName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "pleaseSpecify"); size_t szPleaseSpecify = strlen(_dummy);
	AtfValidator::validateInt(_descr, "pleaseSpecify", szPleaseSpecify, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szOptions = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("options"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "options", szOptions, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	sources.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::equals(const Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		sources.equals(_o.sources);
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("sources=");
		sources.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		sources.toXmlString("sources", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("sources"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ReferralSource, 4 > >::FromXmlString(_value, sources)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		sources.composeMsg(_msg, _ignoreJSON);
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		sources.parseMsg(_parser);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("sources", sources);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("sources", sources);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ReferralSource > sources; _jparser.validateByNameThrow("sources", sources);
		AtfValidator::validateInt(_descr, "sources", sources.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSources = Atf::LAtfVector< ReferralSource, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sources"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "sources", szSources, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    RegisterNewUserPrivileges
//=================================================================

regulator::cli_unauth::RegisterNewUserPrivileges::RegisterNewUserPrivileges()
{
	clear();
}

void regulator::cli_unauth::RegisterNewUserPrivileges::clear()
{
	untrustedPriv = 0;
	untrustedPrivMask = 0;
	untrustedPriv2 = 0;
	untrustedPriv2Mask = 0;
	untrustedPriv3 = 0;
	untrustedPriv3Mask = 0;
}

bool regulator::cli_unauth::RegisterNewUserPrivileges::equals(const RegisterNewUserPrivileges& _o) const
{
	return untrustedPriv == _o.untrustedPriv &&
		untrustedPrivMask == _o.untrustedPrivMask &&
		untrustedPriv2 == _o.untrustedPriv2 &&
		untrustedPriv2Mask == _o.untrustedPriv2Mask &&
		untrustedPriv3 == _o.untrustedPriv3 &&
		untrustedPriv3Mask == _o.untrustedPriv3Mask;
}

const char *regulator::cli_unauth::RegisterNewUserPrivileges::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("untrustedPriv=");
	_buf.appendUint(untrustedPriv);
	_buf.append(',');
	_buf.append("untrustedPrivMask=");
	_buf.appendUint(untrustedPrivMask);
	_buf.append(',');
	_buf.append("untrustedPriv2=");
	_buf.appendUint64(untrustedPriv2);
	_buf.append(',');
	_buf.append("untrustedPriv2Mask=");
	_buf.appendUint64(untrustedPriv2Mask);
	_buf.append(',');
	_buf.append("untrustedPriv3=");
	_buf.appendUint64(untrustedPriv3);
	_buf.append(',');
	_buf.append("untrustedPriv3Mask=");
	_buf.appendUint64(untrustedPriv3Mask);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli_unauth::RegisterNewUserPrivileges::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("untrustedPriv", untrustedPriv, _buf);
	Atf::XmlElement::encodeAsXmlElement("untrustedPrivMask", untrustedPrivMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("untrustedPriv2", untrustedPriv2, _buf);
	Atf::XmlElement::encodeAsXmlElement("untrustedPriv2Mask", untrustedPriv2Mask, _buf);
	Atf::XmlElement::encodeAsXmlElement("untrustedPriv3", untrustedPriv3, _buf);
	Atf::XmlElement::encodeAsXmlElement("untrustedPriv3Mask", untrustedPriv3Mask, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli_unauth::RegisterNewUserPrivileges::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("untrustedPriv"))
		{
			untrustedPriv = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("untrustedPrivMask"))
		{
			untrustedPrivMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("untrustedPriv2"))
		{
			untrustedPriv2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("untrustedPriv2Mask"))
		{
			untrustedPriv2Mask = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("untrustedPriv3"))
		{
			untrustedPriv3 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("untrustedPriv3Mask"))
		{
			untrustedPriv3Mask = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli_unauth::RegisterNewUserPrivileges::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(RegisterNewUserPrivileges())) // not empty
	{
		_body.composeUINT32(untrustedPriv);
		_body.composeUINT32(untrustedPrivMask);
		_body.composeUINT64(untrustedPriv2);
		_body.composeUINT64(untrustedPriv2Mask);
		_body.composeUINT64(untrustedPriv3);
		_body.composeUINT64(untrustedPriv3Mask);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli_unauth::RegisterNewUserPrivileges::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(untrustedPriv);
	_parser0.parseUINT32(untrustedPrivMask);
	_parser0.parseUINT64(untrustedPriv2);
	_parser0.parseUINT64(untrustedPriv2Mask);
	_parser0.parseUINT64(untrustedPriv3);
	_parser0.parseUINT64(untrustedPriv3Mask);
}

const char *regulator::cli_unauth::RegisterNewUserPrivileges::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("untrustedPriv", untrustedPriv);
	_jsonstr.compose("untrustedPrivMask", untrustedPrivMask);
	_jsonstr.compose("untrustedPriv2", untrustedPriv2);
	_jsonstr.compose("untrustedPriv2Mask", untrustedPriv2Mask);
	_jsonstr.compose("untrustedPriv3", untrustedPriv3);
	_jsonstr.compose("untrustedPriv3Mask", untrustedPriv3Mask);
	return _buf.c_str();
}

void regulator::cli_unauth::RegisterNewUserPrivileges::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("untrustedPriv", untrustedPriv);
	_jparser.parseByNameThrow("untrustedPrivMask", untrustedPrivMask);
	_jparser.parseByNameThrow("untrustedPriv2", untrustedPriv2);
	_jparser.parseByNameThrow("untrustedPriv2Mask", untrustedPriv2Mask);
	_jparser.parseByNameThrow("untrustedPriv3", untrustedPriv3);
	_jparser.parseByNameThrow("untrustedPriv3Mask", untrustedPriv3Mask);
}

/* static */ void regulator::cli_unauth::RegisterNewUserPrivileges::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 untrustedPriv; _jparser.validateByNameThrow("untrustedPriv", untrustedPriv);
	AtfValidator::validateInt(_descr, "untrustedPriv", untrustedPriv, _checker, __FILE__, __LINE__);
	UINT32 untrustedPrivMask; _jparser.validateByNameThrow("untrustedPrivMask", untrustedPrivMask);
	AtfValidator::validateInt(_descr, "untrustedPrivMask", untrustedPrivMask, _checker, __FILE__, __LINE__);
	UINT64 untrustedPriv2; _jparser.validateByNameThrow("untrustedPriv2", untrustedPriv2);
	AtfValidator::validateUint(_descr, "untrustedPriv2", untrustedPriv2, _checker, __FILE__, __LINE__);
	UINT64 untrustedPriv2Mask; _jparser.validateByNameThrow("untrustedPriv2Mask", untrustedPriv2Mask);
	AtfValidator::validateUint(_descr, "untrustedPriv2Mask", untrustedPriv2Mask, _checker, __FILE__, __LINE__);
	UINT64 untrustedPriv3; _jparser.validateByNameThrow("untrustedPriv3", untrustedPriv3);
	AtfValidator::validateUint(_descr, "untrustedPriv3", untrustedPriv3, _checker, __FILE__, __LINE__);
	UINT64 untrustedPriv3Mask; _jparser.validateByNameThrow("untrustedPriv3Mask", untrustedPriv3Mask);
	AtfValidator::validateUint(_descr, "untrustedPriv3Mask", untrustedPriv3Mask, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::RegisterNewUserPrivileges::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 untrustedPriv; _parser0.parseUINT32(untrustedPriv);
	AtfValidator::validateInt(_descr, "untrustedPriv", untrustedPriv, _checker, __FILE__, __LINE__);
	UINT32 untrustedPrivMask; _parser0.parseUINT32(untrustedPrivMask);
	AtfValidator::validateInt(_descr, "untrustedPrivMask", untrustedPrivMask, _checker, __FILE__, __LINE__);
	UINT64 untrustedPriv2; _parser0.parseUINT64(untrustedPriv2);
	AtfValidator::validateUint(_descr, "untrustedPriv2", untrustedPriv2, _checker, __FILE__, __LINE__);
	UINT64 untrustedPriv2Mask; _parser0.parseUINT64(untrustedPriv2Mask);
	AtfValidator::validateUint(_descr, "untrustedPriv2Mask", untrustedPriv2Mask, _checker, __FILE__, __LINE__);
	UINT64 untrustedPriv3; _parser0.parseUINT64(untrustedPriv3);
	AtfValidator::validateUint(_descr, "untrustedPriv3", untrustedPriv3, _checker, __FILE__, __LINE__);
	UINT64 untrustedPriv3Mask; _parser0.parseUINT64(untrustedPriv3Mask);
	AtfValidator::validateUint(_descr, "untrustedPriv3Mask", untrustedPriv3Mask, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    RegisterNewUserRequest
//=================================================================

regulator::cli_unauth::RegisterNewUserRequest::RegisterNewUserRequest()
{
	clear();
}

void regulator::cli_unauth::RegisterNewUserRequest::clear()
{
	id.clear();
	pwd.clear();
	fullName.clear();
	email.clear();
	addr_1.clear();
	addr_2.clear();
	city.clear();
	state.clear();
	country.clear();
	zipCode.clear();
	userInstallId.clear();
	imageType = 0;
	imageData.clear();
	_dummy.clear();
	siteIdShifted = 0;
	referenceType = 0;
	referenceStr.clear();
	_promisedFppDummy = 0;
	dob.setNull();
	locale = 0;
	tiVer.clear();
	tiGUID.clear();
	tiManualPromo.clear();
	tiPromoCode.clear();
	tiInfoFile.clear();
	ignoreInvalidManualPromo = false;
	firstName.clear();
	lastName.clear();
	captchaData.clear();
	captchaText.clear();
	mailList = false;
	sex.clear();
	refDomain.clear();
	mobile.clear();
	timezone = 0;
	clientExtra.clear();
	imageId = 0;
	clientFlags = 0;
	clientExtra_ignored.clear();
	privileges.clear();
	regSiteId = 0;
}

bool regulator::cli_unauth::RegisterNewUserRequest::equals(const RegisterNewUserRequest& _o) const
{
	return Atf::atfPStringEquals(id, _o.id) &&
		Atf::atfPStringEquals(pwd, _o.pwd) &&
		Atf::atfPStringEquals(fullName, _o.fullName) &&
		Atf::atfPStringEquals(email, _o.email) &&
		Atf::atfPStringEquals(addr_1, _o.addr_1) &&
		Atf::atfPStringEquals(addr_2, _o.addr_2) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(country, _o.country) &&
		Atf::atfPStringEquals(zipCode, _o.zipCode) &&
		Atf::atfPStringEquals(userInstallId, _o.userInstallId) &&
		imageType == _o.imageType &&
		imageData.size() == _o.imageData.size() && memcmp(imageData.ptr(), _o.imageData.ptr(), imageData.size()) == 0 &&
		Atf::atfPStringEquals(_dummy, _o._dummy) &&
		siteIdShifted == _o.siteIdShifted &&
		referenceType == _o.referenceType &&
		Atf::atfPStringEquals(referenceStr, _o.referenceStr) &&
		_promisedFppDummy == _o._promisedFppDummy &&
		dob.equals(_o.dob) &&
		locale == _o.locale &&
		Atf::atfPStringEquals(tiVer, _o.tiVer) &&
		Atf::atfPStringEquals(tiGUID, _o.tiGUID) &&
		Atf::atfPStringEquals(tiManualPromo, _o.tiManualPromo) &&
		Atf::atfPStringEquals(tiPromoCode, _o.tiPromoCode) &&
		Atf::atfPStringEquals(tiInfoFile, _o.tiInfoFile) &&
		ignoreInvalidManualPromo == _o.ignoreInvalidManualPromo &&
		Atf::atfPStringEquals(firstName, _o.firstName) &&
		Atf::atfPStringEquals(lastName, _o.lastName) &&
		captchaData.size() == _o.captchaData.size() && memcmp(captchaData.ptr(), _o.captchaData.ptr(), captchaData.size()) == 0 &&
		Atf::atfPStringEquals(captchaText, _o.captchaText) &&
		mailList == _o.mailList &&
		Atf::atfPStringEquals(sex, _o.sex) &&
		Atf::atfPStringEquals(refDomain, _o.refDomain) &&
		Atf::atfPStringEquals(mobile, _o.mobile) &&
		timezone == _o.timezone &&
		clientExtra.equals(_o.clientExtra) &&
		imageId == _o.imageId &&
		clientFlags == _o.clientFlags &&
		clientExtra_ignored.equals(_o.clientExtra_ignored) &&
		privileges.equals(_o.privileges) &&
		regSiteId == _o.regSiteId;
}

const char *regulator::cli_unauth::RegisterNewUserRequest::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.append(id);
	_buf.append(',');
	_buf.append("pwd=");
	_buf.append(pwd);
	_buf.append(',');
	_buf.append("fullName=");
	_buf.append(fullName);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("addr_1=");
	_buf.append(addr_1);
	_buf.append(',');
	_buf.append("addr_2=");
	_buf.append(addr_2);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("zipCode=");
	_buf.append(zipCode);
	_buf.append(',');
	_buf.append("userInstallId=");
	_buf.append(userInstallId);
	_buf.append(',');
	_buf.append("imageType=");
	_buf.appendUint(imageType);
	_buf.append(',');
	_buf.append("imageData=");
	Atf::AtfTempl<PBlock>::ToTraceString(_buf, imageData);
	_buf.append(',');
	_buf.append("_dummy=");
	_buf.append(_dummy);
	_buf.append(',');
	_buf.append("siteIdShifted=");
	_buf.appendUint(siteIdShifted);
	_buf.append(',');
	_buf.append("referenceType=");
	_buf.appendInt(referenceType);
	_buf.append(',');
	_buf.append("referenceStr=");
	_buf.append(referenceStr);
	_buf.append(',');
	_buf.append("_promisedFppDummy=");
	_buf.appendInt(_promisedFppDummy);
	_buf.append(',');
	_buf.append("dob=");
	Atf::AtfTempl<CommSrvDate>::ToTraceString(_buf, dob);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("tiVer=");
	_buf.append(tiVer);
	_buf.append(',');
	_buf.append("tiGUID=");
	_buf.append(tiGUID);
	_buf.append(',');
	_buf.append("tiManualPromo=");
	_buf.append(tiManualPromo);
	_buf.append(',');
	_buf.append("tiPromoCode=");
	_buf.append(tiPromoCode);
	_buf.append(',');
	_buf.append("tiInfoFile=");
	_buf.append(tiInfoFile);
	_buf.append(',');
	_buf.append("ignoreInvalidManualPromo=");
	_buf.appendUint(ignoreInvalidManualPromo);
	_buf.append(',');
	_buf.append("firstName=");
	_buf.append(firstName);
	_buf.append(',');
	_buf.append("lastName=");
	_buf.append(lastName);
	_buf.append(',');
	_buf.append("captchaData=");
	Atf::AtfTempl<PBlock>::ToTraceString(_buf, captchaData);
	_buf.append(',');
	_buf.append("captchaText=");
	_buf.append(captchaText);
	_buf.append(',');
	_buf.append("mailList=");
	_buf.appendUint(mailList);
	_buf.append(',');
	_buf.append("sex=");
	_buf.append(sex);
	_buf.append(',');
	_buf.append("refDomain=");
	_buf.append(refDomain);
	_buf.append(',');
	_buf.append("mobile=");
	_buf.append(mobile);
	_buf.append(',');
	_buf.append("timezone=");
	_buf.appendUint(timezone);
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	_buf.append(',');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	_buf.append(',');
	_buf.append("clientFlags=");
	_buf.appendUint(clientFlags);
	_buf.append(',');
	_buf.append("clientExtra_ignored=");
	clientExtra_ignored.toTraceString(_buf);
	_buf.append(',');
	_buf.append("privileges=");
	privileges.toTraceString(_buf);
	_buf.append(',');
	_buf.append("regSiteId=");
	_buf.appendUint(regSiteId);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli_unauth::RegisterNewUserRequest::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("pwd", pwd, _buf);
	Atf::XmlElement::encodeAsXmlElement("fullName", fullName, _buf);
	Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	Atf::XmlElement::encodeAsXmlElement("addr_1", addr_1, _buf);
	Atf::XmlElement::encodeAsXmlElement("addr_2", addr_2, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("zipCode", zipCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("userInstallId", userInstallId, _buf);
	Atf::XmlElement::encodeAsXmlElement("imageType", imageType, _buf);
	Atf::XmlElement::encodeAsXmlElement("imageData", imageData, _buf);
	Atf::XmlElement::encodeAsXmlElement("_dummy", _dummy, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteIdShifted", siteIdShifted, _buf);
	Atf::XmlElement::encodeAsXmlElement("referenceType", referenceType, _buf);
	Atf::XmlElement::encodeAsXmlElement("referenceStr", referenceStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("_promisedFppDummy", _promisedFppDummy, _buf);
	Atf::AtfTempl<CommSrvDate>::ToXmlString(_buf, "dob", dob);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("tiVer", tiVer, _buf);
	Atf::XmlElement::encodeAsXmlElement("tiGUID", tiGUID, _buf);
	Atf::XmlElement::encodeAsXmlElement("tiManualPromo", tiManualPromo, _buf);
	Atf::XmlElement::encodeAsXmlElement("tiPromoCode", tiPromoCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("tiInfoFile", tiInfoFile, _buf);
	Atf::XmlElement::encodeAsXmlElement("ignoreInvalidManualPromo", ignoreInvalidManualPromo, _buf);
	Atf::XmlElement::encodeAsXmlElement("firstName", firstName, _buf);
	Atf::XmlElement::encodeAsXmlElement("lastName", lastName, _buf);
	Atf::XmlElement::encodeAsXmlElement("captchaData", captchaData, _buf);
	Atf::XmlElement::encodeAsXmlElement("captchaText", captchaText, _buf);
	Atf::XmlElement::encodeAsXmlElement("mailList", mailList, _buf);
	Atf::XmlElement::encodeAsXmlElement("sex", sex, _buf);
	Atf::XmlElement::encodeAsXmlElement("refDomain", refDomain, _buf);
	Atf::XmlElement::encodeAsXmlElement("mobile", mobile, _buf);
	Atf::XmlElement::encodeAsXmlElement("timezone", timezone, _buf);
	clientExtra.toXmlString("clientExtra", _buf);
	Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientFlags", clientFlags, _buf);
	clientExtra_ignored.toXmlString("clientExtra_ignored", _buf);
	privileges.toXmlString("privileges", _buf);
	Atf::XmlElement::encodeAsXmlElement("regSiteId", regSiteId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli_unauth::RegisterNewUserRequest::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("id"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, id)) return false;
		}
		else if (_element.equals("pwd"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, pwd)) return false;
		}
		else if (_element.equals("fullName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, fullName)) return false;
		}
		else if (_element.equals("email"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
		}
		else if (_element.equals("addr_1"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, addr_1)) return false;
		}
		else if (_element.equals("addr_2"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, addr_2)) return false;
		}
		else if (_element.equals("city"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
		}
		else if (_element.equals("state"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("zipCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, zipCode)) return false;
		}
		else if (_element.equals("userInstallId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userInstallId)) return false;
		}
		else if (_element.equals("imageType"))
		{
			imageType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("imageData"))
		{
			Atf::XmlElement::_movePBlockWithNullStrip(_value, imageData);
		}
		else if (_element.equals("_dummy"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, _dummy)) return false;
		}
		else if (_element.equals("siteIdShifted"))
		{
			siteIdShifted = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("referenceType"))
		{
			referenceType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("referenceStr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, referenceStr)) return false;
		}
		else if (_element.equals("_promisedFppDummy"))
		{
			_promisedFppDummy = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("dob"))
		{
			Atf::AtfTempl<CommSrvDate>::FromXmlString(_value, dob);
		}
		else if (_element.equals("locale"))
		{
			locale = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tiVer"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tiVer)) return false;
		}
		else if (_element.equals("tiGUID"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tiGUID)) return false;
		}
		else if (_element.equals("tiManualPromo"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tiManualPromo)) return false;
		}
		else if (_element.equals("tiPromoCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tiPromoCode)) return false;
		}
		else if (_element.equals("tiInfoFile"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tiInfoFile)) return false;
		}
		else if (_element.equals("ignoreInvalidManualPromo"))
		{
			ignoreInvalidManualPromo = (*_value.ptr() == '1');
		}
		else if (_element.equals("firstName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, firstName)) return false;
		}
		else if (_element.equals("lastName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, lastName)) return false;
		}
		else if (_element.equals("captchaData"))
		{
			Atf::XmlElement::_movePBlockWithNullStrip(_value, captchaData);
		}
		else if (_element.equals("captchaText"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, captchaText)) return false;
		}
		else if (_element.equals("mailList"))
		{
			mailList = (*_value.ptr() == '1');
		}
		else if (_element.equals("sex"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, sex)) return false;
		}
		else if (_element.equals("refDomain"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, refDomain)) return false;
		}
		else if (_element.equals("mobile"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, mobile)) return false;
		}
		else if (_element.equals("timezone"))
		{
			timezone = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clientExtra"))
		{
			if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, clientExtra)) return false;
		}
		else if (_element.equals("imageId"))
		{
			imageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clientFlags"))
		{
			clientFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clientExtra_ignored"))
		{
			if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, clientExtra_ignored)) return false;
		}
		else if (_element.equals("privileges"))
		{
			if(!Atf::AtfTempl< RegisterNewUserPrivileges >::FromXmlString(_value, privileges)) return false;
		}
		else if (_element.equals("regSiteId"))
		{
			regSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli_unauth::RegisterNewUserRequest::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(id);
	_msg.composeString(pwd);
	_msg.composeString(fullName);
	_msg.composeString(email);
	_msg.composeString(addr_1);
	_msg.composeString(addr_2);
	_msg.composeString(city);
	_msg.composeString(state);
	_msg.composeString(country);
	_msg.composeString(zipCode);
	_msg.composeString(userInstallId);
	_msg.composeBYTE(imageType);
	_msg._composeVarBlock(imageData.ptr(), imageData.size());
	_msg.composeString(_dummy);
	_msg.composeUINT32(siteIdShifted);
	_msg.composeINT32(referenceType);
	_msg.composeString(referenceStr);
	_msg.composeINT32(_promisedFppDummy);
	_msg.composeSrvDate(dob);
	_msg.composeUINT32(locale);
	_msg.composeString(tiVer);
	_msg.composeString(tiGUID);
	_msg.composeString(tiManualPromo);
	_msg.composeString(tiPromoCode);
	_msg.composeString(tiInfoFile);
	_msg.composeBOOL(ignoreInvalidManualPromo);
	_msg.composeString(firstName);
	_msg.composeString(lastName);
	_msg._composeVarBlock(captchaData.ptr(), captchaData.size());
	_msg.composeString(captchaText);
	_msg.composeBOOL(mailList);
	_msg.composeString(sex);
	_msg.composeString(refDomain);
	_msg.composeString(mobile);
	_msg.composeUINT32(timezone);
	clientExtra.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(imageId);
	_msg.composeUINT32(clientFlags);
	clientExtra_ignored.composeMsg(_msg, _ignoreJSON);
	privileges.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(regSiteId);
}

void regulator::cli_unauth::RegisterNewUserRequest::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(id);
	_parser.parseStringP(pwd);
	_parser.parseStringP(fullName);
	_parser.parseStringP(email);
	_parser.parseStringP(addr_1);
	_parser.parseStringP(addr_2);
	_parser.parseStringP(city);
	_parser.parseStringP(state);
	_parser.parseStringP(country);
	_parser.parseStringP(zipCode);
	_parser.parseStringP(userInstallId);
	_parser.parseBYTE(imageType);
	_parser.parsePBlock(imageData);
	_parser.parseStringP(_dummy);
	_parser.parseUINT32(siteIdShifted);
	_parser.parseINT32(referenceType);
	_parser.parseStringP(referenceStr);
	_parser.parseINT32(_promisedFppDummy);
	_parser.parseSrvDate(dob);
	_parser.parseUINT32(locale);
	_parser.parseStringP(tiVer);
	_parser.parseStringP(tiGUID);
	_parser.parseStringP(tiManualPromo);
	_parser.parseStringP(tiPromoCode);
	_parser.parseStringP(tiInfoFile);
	_parser.parseBOOL(ignoreInvalidManualPromo);
	_parser.parseStringP(firstName);
	_parser.parseStringP(lastName);
	_parser.parsePBlock(captchaData);
	_parser.parseStringP(captchaText);
	_parser.parseBOOL(mailList);
	_parser.parseStringP(sex);
	_parser.parseStringP(refDomain);
	_parser.parseStringP(mobile);
	_parser.parseUINT32(timezone);
	if(_parser.parseEnded()) return;
	clientExtra.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(imageId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(clientFlags);
	if(_parser.parseEnded()) return;
	clientExtra_ignored.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	privileges.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(regSiteId);
}

const char *regulator::cli_unauth::RegisterNewUserRequest::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("pwd", pwd);
	_jsonstr.compose("fullName", fullName);
	_jsonstr.compose("email", email);
	_jsonstr.compose("addr_1", addr_1);
	_jsonstr.compose("addr_2", addr_2);
	_jsonstr.compose("city", city);
	_jsonstr.compose("state", state);
	_jsonstr.compose("country", country);
	_jsonstr.compose("zipCode", zipCode);
	_jsonstr.compose("userInstallId", userInstallId);
	_jsonstr.compose("imageType", imageType);
	_jsonstr.compose("imageData", imageData);
	_jsonstr.compose("_dummy", _dummy);
	_jsonstr.compose("siteIdShifted", siteIdShifted);
	_jsonstr.compose("referenceType", referenceType);
	_jsonstr.compose("referenceStr", referenceStr);
	_jsonstr.compose("_promisedFppDummy", _promisedFppDummy);
	_jsonstr.compose("dob", dob);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("tiVer", tiVer);
	_jsonstr.compose("tiGUID", tiGUID);
	_jsonstr.compose("tiManualPromo", tiManualPromo);
	_jsonstr.compose("tiPromoCode", tiPromoCode);
	_jsonstr.compose("tiInfoFile", tiInfoFile);
	_jsonstr.compose("ignoreInvalidManualPromo", ignoreInvalidManualPromo);
	_jsonstr.compose("firstName", firstName);
	_jsonstr.compose("lastName", lastName);
	_jsonstr.compose("captchaData", captchaData);
	_jsonstr.compose("captchaText", captchaText);
	_jsonstr.compose("mailList", mailList);
	_jsonstr.compose("sex", sex);
	_jsonstr.compose("refDomain", refDomain);
	_jsonstr.compose("mobile", mobile);
	_jsonstr.compose("timezone", timezone);
	_jsonstr.compose("clientExtra", clientExtra);
	_jsonstr.compose("imageId", imageId);
	_jsonstr.compose("clientFlags", clientFlags);
	_jsonstr.compose("clientExtra_ignored", clientExtra_ignored);
	_jsonstr.compose("privileges", privileges);
	_jsonstr.compose("regSiteId", regSiteId);
	return _buf.c_str();
}

void regulator::cli_unauth::RegisterNewUserRequest::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("pwd", pwd);
	_jparser.parseByNameThrow("fullName", fullName);
	_jparser.parseByNameThrow("email", email);
	_jparser.parseByNameThrow("addr_1", addr_1);
	_jparser.parseByNameThrow("addr_2", addr_2);
	_jparser.parseByNameThrow("city", city);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("zipCode", zipCode);
	_jparser.parseByNameThrow("userInstallId", userInstallId);
	_jparser.parseByNameThrow("imageType", imageType);
	_jparser.parseByNameThrow("imageData", imageData);
	_jparser.parseByNameThrow("_dummy", _dummy);
	_jparser.parseByNameThrow("siteIdShifted", siteIdShifted);
	_jparser.parseByNameThrow("referenceType", referenceType);
	_jparser.parseByNameThrow("referenceStr", referenceStr);
	_jparser.parseByNameThrow("_promisedFppDummy", _promisedFppDummy);
	_jparser.parseByNameThrow("dob", dob);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("tiVer", tiVer);
	_jparser.parseByNameThrow("tiGUID", tiGUID);
	_jparser.parseByNameThrow("tiManualPromo", tiManualPromo);
	_jparser.parseByNameThrow("tiPromoCode", tiPromoCode);
	_jparser.parseByNameThrow("tiInfoFile", tiInfoFile);
	_jparser.parseByNameThrow("ignoreInvalidManualPromo", ignoreInvalidManualPromo);
	_jparser.parseByNameThrow("firstName", firstName);
	_jparser.parseByNameThrow("lastName", lastName);
	_jparser.parseByNameThrow("captchaData", captchaData);
	_jparser.parseByNameThrow("captchaText", captchaText);
	_jparser.parseByNameThrow("mailList", mailList);
	_jparser.parseByNameThrow("sex", sex);
	_jparser.parseByNameThrow("refDomain", refDomain);
	_jparser.parseByNameThrow("mobile", mobile);
	_jparser.parseByNameThrow("timezone", timezone);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientExtra", clientExtra);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("imageId", imageId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientFlags", clientFlags);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientExtra_ignored", clientExtra_ignored);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("privileges", privileges);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("regSiteId", regSiteId);
}

/* static */ void regulator::cli_unauth::RegisterNewUserRequest::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateIntMax(_descr, "id", id.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString pwd; _jparser.validateByNameThrow("pwd", pwd);
	AtfValidator::validateIntMax(_descr, "pwd", pwd.length(), USER_PWD_LEN, _checker, __FILE__, __LINE__);
	PString fullName; _jparser.validateByNameThrow("fullName", fullName);
	AtfValidator::validateIntMax(_descr, "fullName", fullName.length(), USER_FULLNAME_LEN, _checker, __FILE__, __LINE__);
	PString email; _jparser.validateByNameThrow("email", email);
	AtfValidator::validateIntMax(_descr, "email", email.length(), USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	PString addr_1; _jparser.validateByNameThrow("addr_1", addr_1);
	AtfValidator::validateIntMax(_descr, "addr_1", addr_1.length(), USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	PString addr_2; _jparser.validateByNameThrow("addr_2", addr_2);
	AtfValidator::validateIntMax(_descr, "addr_2", addr_2.length(), USER_ADDR2_LEN, _checker, __FILE__, __LINE__);
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateIntMax(_descr, "city", city.length(), USER_CITY_LEN, _checker, __FILE__, __LINE__);
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateIntMax(_descr, "state", state.length(), USER_STATE_LEN, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	PString zipCode; _jparser.validateByNameThrow("zipCode", zipCode);
	AtfValidator::validateIntMax(_descr, "zipCode", zipCode.length(), USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	PString userInstallId; _jparser.validateByNameThrow("userInstallId", userInstallId);
	AtfValidator::validateIntMax(_descr, "userInstallId", userInstallId.length(), USER_INSTALLID_LEN, _checker, __FILE__, __LINE__);
	BYTE imageType; _jparser.validateByNameThrow("imageType", imageType);
	AtfValidator::validateIntRange(_descr, "imageType", imageType, IMAGE_TYPE_NONE, IMAGE_TYPE_LAST, _checker, __FILE__, __LINE__);
	PBlock imageData; _jparser.validateByNameThrow("imageData", imageData);
	AtfValidator::validateIntMax(_descr, "imageData", imageData.size(), IMAGE_LEN, _checker, __FILE__, __LINE__);
	PString _dummy; _jparser.validateByNameThrow("_dummy", _dummy);
	AtfValidator::validateIntMax(_descr, "_dummy", _dummy.length(), 1000, _checker, __FILE__, __LINE__);
	UINT32 siteIdShifted; _jparser.validateByNameThrow("siteIdShifted", siteIdShifted);
	AtfValidator::validateIntRange(_descr, "siteIdShifted", siteIdShifted, (UINT32(PokerStars_SiteUnknown)>>1), (UINT32(PokerStars_Last)>>1), _checker, __FILE__, __LINE__);
	INT32 referenceType; _jparser.validateByNameThrow("referenceType", referenceType);
	AtfValidator::validateInt(_descr, "referenceType", referenceType, _checker, __FILE__, __LINE__);
	PString referenceStr; _jparser.validateByNameThrow("referenceStr", referenceStr);
	AtfValidator::validateIntMax(_descr, "referenceStr", referenceStr.length(), 1000, _checker, __FILE__, __LINE__);
	INT32 _promisedFppDummy; _jparser.validateByNameThrow("_promisedFppDummy", _promisedFppDummy);
	AtfValidator::validateInt(_descr, "_promisedFppDummy", _promisedFppDummy, _checker, __FILE__, __LINE__);
	CommSrvDate dob; _jparser.validateByNameThrow("dob", dob);
	AtfValidator::validateSrvDateTime(_descr, "dob", dob, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	PString tiVer; _jparser.validateByNameThrow("tiVer", tiVer);
	AtfValidator::validateIntMax(_descr, "tiVer", tiVer.length(), TINFO_VERSION_LEN, _checker, __FILE__, __LINE__);
	PString tiGUID; _jparser.validateByNameThrow("tiGUID", tiGUID);
	AtfValidator::validateIntMax(_descr, "tiGUID", tiGUID.length(), TINFO_GUID_LEN, _checker, __FILE__, __LINE__);
	PString tiManualPromo; _jparser.validateByNameThrow("tiManualPromo", tiManualPromo);
	AtfValidator::validateIntMax(_descr, "tiManualPromo", tiManualPromo.length(), 300, _checker, __FILE__, __LINE__);
	PString tiPromoCode; _jparser.validateByNameThrow("tiPromoCode", tiPromoCode);
	AtfValidator::validateIntMax(_descr, "tiPromoCode", tiPromoCode.length(), PROMO_NAME_LEN, _checker, __FILE__, __LINE__);
	PString tiInfoFile; _jparser.validateByNameThrow("tiInfoFile", tiInfoFile);
	AtfValidator::validateIntMax(_descr, "tiInfoFile", tiInfoFile.length(), 1000, _checker, __FILE__, __LINE__);
	bool ignoreInvalidManualPromo; _jparser.validateByNameThrow("ignoreInvalidManualPromo", ignoreInvalidManualPromo);
	AtfValidator::validateInt(_descr, "ignoreInvalidManualPromo", ignoreInvalidManualPromo, _checker, __FILE__, __LINE__);
	PString firstName; _jparser.validateByNameThrow("firstName", firstName);
	AtfValidator::validateIntMax(_descr, "firstName", firstName.length(), USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	PString lastName; _jparser.validateByNameThrow("lastName", lastName);
	AtfValidator::validateIntMax(_descr, "lastName", lastName.length(), USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
	PBlock captchaData; _jparser.validateByNameThrow("captchaData", captchaData);
	AtfValidator::validateIntMax(_descr, "captchaData", captchaData.size(), 10000, _checker, __FILE__, __LINE__);
	PString captchaText; _jparser.validateByNameThrow("captchaText", captchaText);
	AtfValidator::validateIntMax(_descr, "captchaText", captchaText.length(), 100, _checker, __FILE__, __LINE__);
	bool mailList; _jparser.validateByNameThrow("mailList", mailList);
	AtfValidator::validateInt(_descr, "mailList", mailList, _checker, __FILE__, __LINE__);
	PString sex; _jparser.validateByNameThrow("sex", sex);
	AtfValidator::validateIntMax(_descr, "sex", sex.length(), USER_SEX_LEN, _checker, __FILE__, __LINE__);
	PString refDomain; _jparser.validateByNameThrow("refDomain", refDomain);
	AtfValidator::validateIntMax(_descr, "refDomain", refDomain.length(), TINFO_TINFO_RDN_LEN, _checker, __FILE__, __LINE__);
	PString mobile; _jparser.validateByNameThrow("mobile", mobile);
	AtfValidator::validateIntMax(_descr, "mobile", mobile.length(), USER_MOBILE_LEN, _checker, __FILE__, __LINE__);
	UINT32 timezone; _jparser.validateByNameThrow("timezone", timezone);
	AtfValidator::validateIntRange(_descr, "timezone", timezone, eTzUTC, (eTzNumber-1), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Common::AtfShared::LoginExtra clientExtra; _jparser.validateByNameThrow("clientExtra", clientExtra);
	if(_jparser.parseEnded()) return;
	UINT32 imageId; _jparser.validateByNameThrow("imageId", imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 clientFlags; _jparser.validateByNameThrow("clientFlags", clientFlags);
	AtfValidator::validateIntMax(_descr, "clientFlags", clientFlags, ((UINT32(eRegisterNewUserFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Common::AtfShared::LoginExtra clientExtra_ignored; _jparser.validateByNameThrow("clientExtra_ignored", clientExtra_ignored);
	if(_jparser.parseEnded()) return;
	RegisterNewUserPrivileges privileges; _jparser.validateByNameThrow("privileges", privileges);
	if(_jparser.parseEnded()) return;
	UINT32 regSiteId; _jparser.validateByNameThrow("regSiteId", regSiteId);
	AtfValidator::validateIntRange(_descr, "regSiteId", regSiteId, PokerStars_Com, PokerStars_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::RegisterNewUserRequest::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy0 = "";
	_parser.parseStringN(_dummy0, 0, "id"); size_t szId = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "id", szId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "pwd"); size_t szPwd = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "pwd", szPwd, USER_PWD_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "fullName"); size_t szFullName = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "fullName", szFullName, USER_FULLNAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "email"); size_t szEmail = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "addr_1"); size_t szAddr_1 = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "addr_1", szAddr_1, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "addr_2"); size_t szAddr_2 = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "addr_2", szAddr_2, USER_ADDR2_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "city"); size_t szCity = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "city", szCity, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "state"); size_t szState = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "state", szState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "country"); size_t szCountry = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "zipCode"); size_t szZipCode = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "zipCode", szZipCode, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "userInstallId"); size_t szUserInstallId = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "userInstallId", szUserInstallId, USER_INSTALLID_LEN, _checker, __FILE__, __LINE__);
	BYTE imageType; _parser.parseBYTE(imageType);
	AtfValidator::validateIntRange(_descr, "imageType", imageType, IMAGE_TYPE_NONE, IMAGE_TYPE_LAST, _checker, __FILE__, __LINE__);
	const BYTE* imageData; size_t szImageData; _parser._parseVarBlock(imageData, szImageData);  /*imageData*/
	AtfValidator::validateIntMax(_descr, "imageData", szImageData, IMAGE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "_dummy"); size_t sz_dummy = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "_dummy", sz_dummy, 1000, _checker, __FILE__, __LINE__);
	UINT32 siteIdShifted; _parser.parseUINT32(siteIdShifted);
	AtfValidator::validateIntRange(_descr, "siteIdShifted", siteIdShifted, (UINT32(PokerStars_SiteUnknown)>>1), (UINT32(PokerStars_Last)>>1), _checker, __FILE__, __LINE__);
	INT32 referenceType; _parser.parseINT32(referenceType);
	AtfValidator::validateInt(_descr, "referenceType", referenceType, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "referenceStr"); size_t szReferenceStr = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "referenceStr", szReferenceStr, 1000, _checker, __FILE__, __LINE__);
	INT32 _promisedFppDummy; _parser.parseINT32(_promisedFppDummy);
	AtfValidator::validateInt(_descr, "_promisedFppDummy", _promisedFppDummy, _checker, __FILE__, __LINE__);
	CommSrvDate dob; _parser.parseSrvDate(dob);
	AtfValidator::validateSrvDateTime(_descr, "dob", dob, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "tiVer"); size_t szTiVer = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "tiVer", szTiVer, TINFO_VERSION_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "tiGUID"); size_t szTiGUID = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "tiGUID", szTiGUID, TINFO_GUID_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "tiManualPromo"); size_t szTiManualPromo = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "tiManualPromo", szTiManualPromo, 300, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "tiPromoCode"); size_t szTiPromoCode = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "tiPromoCode", szTiPromoCode, PROMO_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "tiInfoFile"); size_t szTiInfoFile = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "tiInfoFile", szTiInfoFile, 1000, _checker, __FILE__, __LINE__);
	bool ignoreInvalidManualPromo; _parser.parseBOOL(ignoreInvalidManualPromo);
	AtfValidator::validateInt(_descr, "ignoreInvalidManualPromo", ignoreInvalidManualPromo, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "firstName"); size_t szFirstName = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "firstName", szFirstName, USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "lastName"); size_t szLastName = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "lastName", szLastName, USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
	const BYTE* captchaData; size_t szCaptchaData; _parser._parseVarBlock(captchaData, szCaptchaData);  /*captchaData*/
	AtfValidator::validateIntMax(_descr, "captchaData", szCaptchaData, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "captchaText"); size_t szCaptchaText = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "captchaText", szCaptchaText, 100, _checker, __FILE__, __LINE__);
	bool mailList; _parser.parseBOOL(mailList);
	AtfValidator::validateInt(_descr, "mailList", mailList, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "sex"); size_t szSex = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "sex", szSex, USER_SEX_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "refDomain"); size_t szRefDomain = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "refDomain", szRefDomain, TINFO_TINFO_RDN_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "mobile"); size_t szMobile = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "mobile", szMobile, USER_MOBILE_LEN, _checker, __FILE__, __LINE__);
	UINT32 timezone; _parser.parseUINT32(timezone);
	AtfValidator::validateIntRange(_descr, "timezone", timezone, eTzUTC, (eTzNumber-1), _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 imageId; _parser.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 clientFlags; _parser.parseUINT32(clientFlags);
	AtfValidator::validateIntMax(_descr, "clientFlags", clientFlags, ((UINT32(eRegisterNewUserFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra_ignored"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	RegisterNewUserPrivileges::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privileges"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 regSiteId; _parser.parseUINT32(regSiteId);
	AtfValidator::validateIntRange(_descr, "regSiteId", regSiteId, PokerStars_Com, PokerStars_Last, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_REGISTER_NEW_USER
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::Protocol_MSG_LOBBY_REGISTER_NEW_USER()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::clear()
{
	newUser.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::equals(const Protocol_MSG_LOBBY_REGISTER_NEW_USER& _o) const
{
	return newUser.equals(_o.newUser);
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_REGISTER_NEW_USER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_REGISTER_NEW_USER*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REGISTER_NEW_USER).append(")");
	_buf.append(',');
	_buf.append("newUser=");
	newUser.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_REGISTER_NEW_USER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	newUser.toXmlString("newUser", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("newUser"))
			{
				if(!Atf::AtfTempl< RegisterNewUserRequest >::FromXmlString(_value, newUser)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	newUser.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::parseMsg(CommMsgParser& _parser)
{
	newUser.parseMsg(_parser);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("newUser", newUser);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("newUser", newUser);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REGISTER_NEW_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	RegisterNewUserRequest newUser; _jparser.validateByNameThrow("newUser", newUser);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REGISTER_NEW_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	RegisterNewUserRequest::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("newUser"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	fppForQuestionnaire = 0;
	empty.clear();
	firstDepositBonusAmount = 0;
	firstDepositBonusCurrency.clear();
	fdbPrompt.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::equals(const Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		fppForQuestionnaire == _o.fppForQuestionnaire &&
		Atf::atfPStringEquals(empty, _o.empty) &&
		firstDepositBonusAmount == _o.firstDepositBonusAmount &&
		Atf::atfPStringEquals(firstDepositBonusCurrency, _o.firstDepositBonusCurrency) &&
		Atf::atfPStringEquals(fdbPrompt, _o.fdbPrompt);
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_REGISTER_NEW_USER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REGISTER_NEW_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("fppForQuestionnaire=");
		_buf.appendInt(fppForQuestionnaire);
		_buf.append(',');
		_buf.append("empty=");
		_buf.append(empty);
		_buf.append(',');
		_buf.append("firstDepositBonusAmount=");
		_buf.appendInt(firstDepositBonusAmount);
		_buf.append(',');
		_buf.append("firstDepositBonusCurrency=");
		_buf.append(firstDepositBonusCurrency);
		_buf.append(',');
		_buf.append("fdbPrompt=");
		_buf.append(fdbPrompt);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_REGISTER_NEW_USER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("fppForQuestionnaire", fppForQuestionnaire, _buf);
		Atf::XmlElement::encodeAsXmlElement("empty", empty, _buf);
		Atf::XmlElement::encodeAsXmlElement("firstDepositBonusAmount", firstDepositBonusAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("firstDepositBonusCurrency", firstDepositBonusCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("fdbPrompt", fdbPrompt, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("fppForQuestionnaire"))
			{
				fppForQuestionnaire = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("empty"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, empty)) return false;
			}
			else if (_element.equals("firstDepositBonusAmount"))
			{
				firstDepositBonusAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("firstDepositBonusCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, firstDepositBonusCurrency)) return false;
			}
			else if (_element.equals("fdbPrompt"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fdbPrompt)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(fppForQuestionnaire);
		_msg.composeString(empty);
		_msg.composeINT32(firstDepositBonusAmount);
		_msg.composeString(firstDepositBonusCurrency);
		_msg.composeString(fdbPrompt);
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(fppForQuestionnaire);
		_parser.parseStringP(empty);
		_parser.parseINT32(firstDepositBonusAmount);
		_parser.parseStringP(firstDepositBonusCurrency);
		_parser.parseStringP(fdbPrompt);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("fppForQuestionnaire", fppForQuestionnaire);
		_jsonstr.compose("empty", empty);
		_jsonstr.compose("firstDepositBonusAmount", firstDepositBonusAmount);
		_jsonstr.compose("firstDepositBonusCurrency", firstDepositBonusCurrency);
		_jsonstr.compose("fdbPrompt", fdbPrompt);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("fppForQuestionnaire", fppForQuestionnaire);
		_jparser.parseByNameThrow("empty", empty);
		_jparser.parseByNameThrow("firstDepositBonusAmount", firstDepositBonusAmount);
		_jparser.parseByNameThrow("firstDepositBonusCurrency", firstDepositBonusCurrency);
		_jparser.parseByNameThrow("fdbPrompt", fdbPrompt);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REGISTER_NEW_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 fppForQuestionnaire; _jparser.validateByNameThrow("fppForQuestionnaire", fppForQuestionnaire);
		AtfValidator::validateInt(_descr, "fppForQuestionnaire", fppForQuestionnaire, _checker, __FILE__, __LINE__);
		PString empty; _jparser.validateByNameThrow("empty", empty);
		AtfValidator::validateInt(_descr, "empty", empty.length(), _checker, __FILE__, __LINE__);
		INT32 firstDepositBonusAmount; _jparser.validateByNameThrow("firstDepositBonusAmount", firstDepositBonusAmount);
		AtfValidator::validateInt(_descr, "firstDepositBonusAmount", firstDepositBonusAmount, _checker, __FILE__, __LINE__);
		PString firstDepositBonusCurrency; _jparser.validateByNameThrow("firstDepositBonusCurrency", firstDepositBonusCurrency);
		AtfValidator::validateInt(_descr, "firstDepositBonusCurrency", firstDepositBonusCurrency.length(), _checker, __FILE__, __LINE__);
		PString fdbPrompt; _jparser.validateByNameThrow("fdbPrompt", fdbPrompt);
		AtfValidator::validateInt(_descr, "fdbPrompt", fdbPrompt.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REGISTER_NEW_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 fppForQuestionnaire; _parser.parseINT32(fppForQuestionnaire);
		AtfValidator::validateInt(_descr, "fppForQuestionnaire", fppForQuestionnaire, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "empty"); size_t szEmpty = strlen(_dummy);
		AtfValidator::validateInt(_descr, "empty", szEmpty, _checker, __FILE__, __LINE__);
		INT32 firstDepositBonusAmount; _parser.parseINT32(firstDepositBonusAmount);
		AtfValidator::validateInt(_descr, "firstDepositBonusAmount", firstDepositBonusAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "firstDepositBonusCurrency"); size_t szFirstDepositBonusCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "firstDepositBonusCurrency", szFirstDepositBonusCurrency, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fdbPrompt"); size_t szFdbPrompt = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fdbPrompt", szFdbPrompt, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::clear()
{
	userId.clear();
	email.clear();
	installId.clear();
	locale = 0;
	siteId = 0;
	platformId = 0;
	clientExtra.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::equals(const Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(email, _o.email) &&
		Atf::atfPStringEquals(installId, _o.installId) &&
		locale == _o.locale &&
		siteId == _o.siteId &&
		platformId == _o.platformId &&
		clientExtra.equals(_o.clientExtra);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("platformId=");
	_buf.appendUint(platformId);
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	Atf::XmlElement::encodeAsXmlElement("installId", installId, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("platformId", platformId, _buf);
	clientExtra.toXmlString("clientExtra", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else if (_element.equals("installId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, installId)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("siteId"))
			{
				siteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("platformId"))
			{
				platformId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientExtra"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, clientExtra)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeString(email);
	_msg.composeString(installId);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(siteId);
	_msg.composeUINT32(platformId);
	clientExtra.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseStringP(email);
	_parser.parseStringP(installId);
	_parser.parseUINT32(locale);
	_parser.parseUINT32(siteId);
	_parser.parseUINT32(platformId);
	if(_parser.parseEnded()) return;
	clientExtra.parseMsg(_parser);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("email", email);
	_jsonstr.compose("installId", installId);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("platformId", platformId);
	_jsonstr.compose("clientExtra", clientExtra);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("email", email);
	_jparser.parseByNameThrow("installId", installId);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("platformId", platformId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientExtra", clientExtra);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString email; _jparser.validateByNameThrow("email", email);
	AtfValidator::validateIntMax(_descr, "email", email.length(), USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	PString installId; _jparser.validateByNameThrow("installId", installId);
	AtfValidator::validateIntMax(_descr, "installId", installId.length(), USER_INSTALLID_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 platformId; _jparser.validateByNameThrow("platformId", platformId);
	AtfValidator::validateIntRange(_descr, "platformId", platformId, Client_UnknownPlatform, Client_Last, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Common::AtfShared::LoginExtra clientExtra; _jparser.validateByNameThrow("clientExtra", clientExtra);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, USER_INSTALLID_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 platformId; _parser.parseUINT32(platformId);
	AtfValidator::validateIntRange(_descr, "platformId", platformId, Client_UnknownPlatform, Client_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::equals(const Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_EMAIL_AVAILABLE
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::clear()
{
	email.clear();
	locale = 0;
	clientExtra.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::equals(const Protocol_MSG_REGULATOR_EMAIL_AVAILABLE& _o) const
{
	return Atf::atfPStringEquals(email, _o.email) &&
		locale == _o.locale &&
		clientExtra.equals(_o.clientExtra);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_EMAIL_AVAILABLE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_EMAIL_AVAILABLE*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_EMAIL_AVAILABLE).append(")");
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_EMAIL_AVAILABLE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	clientExtra.toXmlString("clientExtra", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientExtra"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, clientExtra)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(email);
	_msg.composeUINT32(locale);
	clientExtra.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(email);
	_parser.parseUINT32(locale);
	clientExtra.parseMsg(_parser);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("email", email);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("clientExtra", clientExtra);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("email", email);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("clientExtra", clientExtra);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_EMAIL_AVAILABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString email; _jparser.validateByNameThrow("email", email);
	AtfValidator::validateIntMax(_descr, "email", email.length(), USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	Common::AtfShared::LoginExtra clientExtra; _jparser.validateByNameThrow("clientExtra", clientExtra);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_EMAIL_AVAILABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	PString _descbuf;
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	brandId = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::equals(const Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		brandId == _o.brandId;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_EMAIL_AVAILABLE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_EMAIL_AVAILABLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	if (errCode == DUPLICATE_NEW_USER_EMAIL)
	{
		_buf.append(',');
		_buf.append("brandId=");
		_buf.appendUint(brandId);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_EMAIL_AVAILABLE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	if (errCode == DUPLICATE_NEW_USER_EMAIL)
	{
		Atf::XmlElement::encodeAsXmlElement("brandId", brandId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("brandId"))
			{
				brandId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	if (errCode == DUPLICATE_NEW_USER_EMAIL)
	{
		_msg.composeUINT32(brandId);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	if (errCode == DUPLICATE_NEW_USER_EMAIL)
	{
		_parser.parseUINT32(brandId);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	if (errCode == DUPLICATE_NEW_USER_EMAIL)
	{
		_jsonstr.compose("brandId", brandId);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	if (errCode == DUPLICATE_NEW_USER_EMAIL)
	{
		_jparser.parseByNameThrow("brandId", brandId);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_EMAIL_AVAILABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	if (errCode == DUPLICATE_NEW_USER_EMAIL)
	{
		UINT32 brandId; _jparser.validateByNameThrow("brandId", brandId);
		AtfValidator::validateInt(_descr, "brandId", brandId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_EMAIL_AVAILABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if (errCode == DUPLICATE_NEW_USER_EMAIL)
	{
		UINT32 brandId; _parser.parseUINT32(brandId);
		AtfValidator::validateInt(_descr, "brandId", brandId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_RESET_PWD
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::Protocol_MSG_REGULATOR_RESET_PWD()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::clear()
{
	resetPwd.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::equals(const Protocol_MSG_REGULATOR_RESET_PWD& _o) const
{
	return resetPwd.equals(_o.resetPwd);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_RESET_PWD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_RESET_PWD*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_RESET_PWD).append(")");
	_buf.append(',');
	_buf.append("resetPwd=");
	resetPwd.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_RESET_PWD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	resetPwd.toXmlString("resetPwd", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("resetPwd"))
			{
				if(!Atf::AtfTempl< common_structs::ResetPwdMessageStruct >::FromXmlString(_value, resetPwd)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	resetPwd.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::parseMsg(CommMsgParser& _parser)
{
	resetPwd.parseMsg(_parser);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("resetPwd", resetPwd);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("resetPwd", resetPwd);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RESET_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::ResetPwdMessageStruct resetPwd; _jparser.validateByNameThrow("resetPwd", resetPwd);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RESET_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::ResetPwdMessageStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("resetPwd"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_RESET_PWD_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::Protocol_MSG_REGULATOR_RESET_PWD_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::equals(const Protocol_MSG_REGULATOR_RESET_PWD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_RESET_PWD_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_RESET_PWD_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_RESET_PWD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_RESET_PWD_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RESET_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RESET_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RETRIEVE_USERID
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::Protocol_MSG_LOBBY_RETRIEVE_USERID()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::clear()
{
	email.clear();
	locale = LOCALE_DEFAULT;
	clientSiteId = PokerStars_SiteUnknown;
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::equals(const Protocol_MSG_LOBBY_RETRIEVE_USERID& _o) const
{
	return Atf::atfPStringEquals(email, _o.email) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId;
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_RETRIEVE_USERID != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_RETRIEVE_USERID*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RETRIEVE_USERID).append(")");
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_RETRIEVE_USERID).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientSiteId", clientSiteId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientSiteId"))
			{
				clientSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(email);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(email);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(locale);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(clientSiteId);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("email", email);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("clientSiteId", clientSiteId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("email", email);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("locale", locale);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientSiteId", clientSiteId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RETRIEVE_USERID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString email; _jparser.validateByNameThrow("email", email);
	AtfValidator::validateIntMax(_descr, "email", email.length(), USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 clientSiteId; _jparser.validateByNameThrow("clientSiteId", clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RETRIEVE_USERID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	emptyStr.clear();
	licenseId = 0;
	challengeQuestions.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::equals(const Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(emptyStr, _o.emptyStr) &&
		licenseId == _o.licenseId &&
		challengeQuestions.equals(_o.challengeQuestions);
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_RETRIEVE_USERID_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RETRIEVE_USERID_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("emptyStr=");
		_buf.append(emptyStr);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		_buf.append(',');
		_buf.append("licenseId=");
		_buf.appendUint(licenseId);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		_buf.append(',');
		_buf.append("challengeQuestions=");
		challengeQuestions.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_RETRIEVE_USERID_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("emptyStr", emptyStr, _buf);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		Atf::XmlElement::encodeAsXmlElement("licenseId", licenseId, _buf);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		challengeQuestions.toXmlString("challengeQuestions", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("emptyStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, emptyStr)) return false;
			}
			else if (_element.equals("licenseId"))
			{
				licenseId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("challengeQuestions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< common_structs::ChallengeQuestion, 2 > >::FromXmlString(_value, challengeQuestions)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(emptyStr);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		_msg.composeUINT32(licenseId);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		challengeQuestions.composeMsg(_msg, _ignoreJSON);
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(emptyStr);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		_parser.parseUINT32(licenseId);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		challengeQuestions.parseMsg(_parser);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("emptyStr", emptyStr);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		_jsonstr.compose("licenseId", licenseId);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		_jsonstr.compose("challengeQuestions", challengeQuestions);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("emptyStr", emptyStr);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		_jparser.parseByNameThrow("licenseId", licenseId);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		_jparser.parseByNameThrow("challengeQuestions", challengeQuestions);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RETRIEVE_USERID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString emptyStr; _jparser.validateByNameThrow("emptyStr", emptyStr);
		AtfValidator::validateInt(_descr, "emptyStr", emptyStr.length(), _checker, __FILE__, __LINE__);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		UINT32 licenseId; _jparser.validateByNameThrow("licenseId", licenseId);
		AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		Atf::AtfVectorBase< common_structs::ChallengeQuestion > challengeQuestions; _jparser.validateByNameThrow("challengeQuestions", challengeQuestions);
		AtfValidator::validateInt(_descr, "challengeQuestions", challengeQuestions.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RETRIEVE_USERID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "emptyStr"); size_t szEmptyStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "emptyStr", szEmptyStr, _checker, __FILE__, __LINE__);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		UINT32 licenseId; _parser.parseUINT32(licenseId);
		AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		PString _descbuf;
		int szChallengeQuestions = Atf::LAtfVector< common_structs::ChallengeQuestion, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("challengeQuestions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "challengeQuestions", szChallengeQuestions, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SMS_RESET_PWD
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::Protocol_MSG_REGULATOR_SMS_RESET_PWD()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::clear()
{
	user.clear();
	email.clear();
	mobile.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::equals(const Protocol_MSG_REGULATOR_SMS_RESET_PWD& _o) const
{
	return Atf::atfPStringEquals(user, _o.user) &&
		Atf::atfPStringEquals(email, _o.email) &&
		Atf::atfPStringEquals(mobile, _o.mobile);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SMS_RESET_PWD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SMS_RESET_PWD*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SMS_RESET_PWD).append(")");
	_buf.append(',');
	_buf.append("user=");
	_buf.append(user);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("mobile=");
	_buf.append(mobile);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SMS_RESET_PWD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("user", user, _buf);
	Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	Atf::XmlElement::encodeAsXmlElement("mobile", mobile, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("user"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, user)) return false;
			}
			else if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else if (_element.equals("mobile"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, mobile)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(user);
	_msg.composeString(email);
	_msg.composeString(mobile);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(user);
	_parser.parseStringP(email);
	_parser.parseStringP(mobile);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("user", user);
	_jsonstr.compose("email", email);
	_jsonstr.compose("mobile", mobile);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("user", user);
	_jparser.parseByNameThrow("email", email);
	_jparser.parseByNameThrow("mobile", mobile);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SMS_RESET_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString user; _jparser.validateByNameThrow("user", user);
	AtfValidator::validateIntMax(_descr, "user", user.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString email; _jparser.validateByNameThrow("email", email);
	AtfValidator::validateIntMax(_descr, "email", email.length(), USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	PString mobile; _jparser.validateByNameThrow("mobile", mobile);
	AtfValidator::validateIntMax(_descr, "mobile", mobile.length(), USER_MOBILE_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SMS_RESET_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "user"); size_t szUser = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "user", szUser, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "mobile"); size_t szMobile = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "mobile", szMobile, USER_MOBILE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::equals(const Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SMS_RESET_PWD_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SMS_RESET_PWD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SMS_RESET_PWD_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SMS_RESET_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SMS_RESET_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::clear()
{
	userId.clear();
	email.clear();
	locale = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::equals(const Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(email, _o.email) &&
		locale == _o.locale;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_PWD_RESET_QUESTIONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_PWD_RESET_QUESTIONS).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_PWD_RESET_QUESTIONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeString(email);
	_msg.composeUINT32(locale);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseStringP(email);
	_parser.parseUINT32(locale);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("email", email);
	_jsonstr.compose("locale", locale);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("email", email);
	_jparser.parseByNameThrow("locale", locale);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_PWD_RESET_QUESTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 100, _checker, __FILE__, __LINE__);
	PString email; _jparser.validateByNameThrow("email", email);
	AtfValidator::validateIntMax(_descr, "email", email.length(), USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_PWD_RESET_QUESTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	isRM = false;
	challengeQuestions.clear();
	allowSMSReset = false;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::equals(const Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		isRM == _o.isRM &&
		challengeQuestions.equals(_o.challengeQuestions) &&
		allowSMSReset == _o.allowSMSReset;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("isRM=");
		_buf.appendUint(isRM);
		_buf.append(',');
		_buf.append("challengeQuestions=");
		challengeQuestions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("allowSMSReset=");
		_buf.appendUint(allowSMSReset);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("isRM", isRM, _buf);
		challengeQuestions.toXmlString("challengeQuestions", _buf);
		Atf::XmlElement::encodeAsXmlElement("allowSMSReset", allowSMSReset, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("isRM"))
			{
				isRM = (*_value.ptr() == '1');
			}
			else if (_element.equals("challengeQuestions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< common_structs::ChallengeQuestion, 2 > >::FromXmlString(_value, challengeQuestions)) return false;
			}
			else if (_element.equals("allowSMSReset"))
			{
				allowSMSReset = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(isRM);
		challengeQuestions.composeMsg(_msg, _ignoreJSON);
		_msg.composeBOOL(allowSMSReset);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(isRM);
		challengeQuestions.parseMsg(_parser);
		_parser.parseBOOL(allowSMSReset);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("isRM", isRM);
		_jsonstr.compose("challengeQuestions", challengeQuestions);
		_jsonstr.compose("allowSMSReset", allowSMSReset);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("isRM", isRM);
		_jparser.parseByNameThrow("challengeQuestions", challengeQuestions);
		_jparser.parseByNameThrow("allowSMSReset", allowSMSReset);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool isRM; _jparser.validateByNameThrow("isRM", isRM);
		AtfValidator::validateInt(_descr, "isRM", isRM, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< common_structs::ChallengeQuestion > challengeQuestions; _jparser.validateByNameThrow("challengeQuestions", challengeQuestions);
		AtfValidator::validateInt(_descr, "challengeQuestions", challengeQuestions.size(), _checker, __FILE__, __LINE__);
		bool allowSMSReset; _jparser.validateByNameThrow("allowSMSReset", allowSMSReset);
		AtfValidator::validateInt(_descr, "allowSMSReset", allowSMSReset, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool isRM; _parser.parseBOOL(isRM);
		AtfValidator::validateInt(_descr, "isRM", isRM, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szChallengeQuestions = Atf::LAtfVector< common_structs::ChallengeQuestion, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("challengeQuestions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "challengeQuestions", szChallengeQuestions, _checker, __FILE__, __LINE__);
		bool allowSMSReset; _parser.parseBOOL(allowSMSReset);
		AtfValidator::validateInt(_descr, "allowSMSReset", allowSMSReset, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::clear()
{
	userId.clear();
	locale = 0;
	userIntId = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::equals(const Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		locale == _o.locale &&
		userIntId == _o.userIntId;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_PWD_RESET_QUESTIONS2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_PWD_RESET_QUESTIONS2).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_PWD_RESET_QUESTIONS2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(userIntId);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(locale);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(userIntId);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("userIntId", userIntId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("locale", locale);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("userIntId", userIntId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_PWD_RESET_QUESTIONS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 100, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_PWD_RESET_QUESTIONS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 100, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	challengeQuestions.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::equals(const Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		challengeQuestions.equals(_o.challengeQuestions);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("challengeQuestions=");
		challengeQuestions.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		challengeQuestions.toXmlString("challengeQuestions", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("challengeQuestions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< common_structs::ChallengeQuestion, 2 > >::FromXmlString(_value, challengeQuestions)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		challengeQuestions.composeMsg(_msg, _ignoreJSON);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		challengeQuestions.parseMsg(_parser);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("challengeQuestions", challengeQuestions);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("challengeQuestions", challengeQuestions);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< common_structs::ChallengeQuestion > challengeQuestions; _jparser.validateByNameThrow("challengeQuestions", challengeQuestions);
		AtfValidator::validateInt(_descr, "challengeQuestions", challengeQuestions.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szChallengeQuestions = Atf::LAtfVector< common_structs::ChallengeQuestion, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("challengeQuestions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "challengeQuestions", szChallengeQuestions, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::clear()
{
	user.clear();
	answer1.clear();
	answer2.clear();
	ssn4.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::equals(const Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD& _o) const
{
	return Atf::atfPStringEquals(user, _o.user) &&
		Atf::atfPStringEquals(answer1, _o.answer1) &&
		Atf::atfPStringEquals(answer2, _o.answer2) &&
		Atf::atfPStringEquals(ssn4, _o.ssn4);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD).append(")");
	_buf.append(',');
	_buf.append("user=");
	_buf.append(user);
	_buf.append(',');
	_buf.append("answer1=");
	_buf.append(answer1);
	_buf.append(',');
	_buf.append("answer2=");
	_buf.append(answer2);
	_buf.append(',');
	_buf.append("ssn4=");
	_buf.append(ssn4);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("user", user, _buf);
	Atf::XmlElement::encodeAsXmlElement("answer1", answer1, _buf);
	Atf::XmlElement::encodeAsXmlElement("answer2", answer2, _buf);
	Atf::XmlElement::encodeAsXmlElement("ssn4", ssn4, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("user"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, user)) return false;
			}
			else if (_element.equals("answer1"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, answer1)) return false;
			}
			else if (_element.equals("answer2"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, answer2)) return false;
			}
			else if (_element.equals("ssn4"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, ssn4)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(user);
	_msg.composeString(answer1);
	_msg.composeString(answer2);
	_msg.composeString(ssn4);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(user);
	_parser.parseStringP(answer1);
	_parser.parseStringP(answer2);
	_parser.parseStringP(ssn4);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("user", user);
	_jsonstr.compose("answer1", answer1);
	_jsonstr.compose("answer2", answer2);
	_jsonstr.compose("ssn4", ssn4);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("user", user);
	_jparser.parseByNameThrow("answer1", answer1);
	_jparser.parseByNameThrow("answer2", answer2);
	_jparser.parseByNameThrow("ssn4", ssn4);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString user; _jparser.validateByNameThrow("user", user);
	AtfValidator::validateIntMax(_descr, "user", user.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString answer1; _jparser.validateByNameThrow("answer1", answer1);
	AtfValidator::validateIntMax(_descr, "answer1", answer1.length(), 10000, _checker, __FILE__, __LINE__);
	PString answer2; _jparser.validateByNameThrow("answer2", answer2);
	AtfValidator::validateIntMax(_descr, "answer2", answer2.length(), 10000, _checker, __FILE__, __LINE__);
	PString ssn4; _jparser.validateByNameThrow("ssn4", ssn4);
	AtfValidator::validateIntMax(_descr, "ssn4", ssn4.length(), SSN_4_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "user"); size_t szUser = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "user", szUser, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "answer1"); size_t szAnswer1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer1", szAnswer1, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "answer2"); size_t szAnswer2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer2", szAnswer2, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ssn4"); size_t szSsn4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "ssn4", szSsn4, SSN_4_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::equals(const Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_RETRIEVE_USERID2
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::Protocol_MSG_REGULATOR_RETRIEVE_USERID2()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::clear()
{
	eMail.clear();
	answer1.clear();
	answer2.clear();
	ssn4.clear();
	locale = LOCALE_DEFAULT;
	clientSiteId = PokerStars_SiteUnknown;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::equals(const Protocol_MSG_REGULATOR_RETRIEVE_USERID2& _o) const
{
	return Atf::atfPStringEquals(eMail, _o.eMail) &&
		Atf::atfPStringEquals(answer1, _o.answer1) &&
		Atf::atfPStringEquals(answer2, _o.answer2) &&
		Atf::atfPStringEquals(ssn4, _o.ssn4) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_RETRIEVE_USERID2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_RETRIEVE_USERID2*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_RETRIEVE_USERID2).append(")");
	_buf.append(',');
	_buf.append("eMail=");
	_buf.append(eMail);
	_buf.append(',');
	_buf.append("answer1=");
	_buf.append(answer1);
	_buf.append(',');
	_buf.append("answer2=");
	_buf.append(answer2);
	_buf.append(',');
	_buf.append("ssn4=");
	_buf.append(ssn4);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_RETRIEVE_USERID2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("eMail", eMail, _buf);
	Atf::XmlElement::encodeAsXmlElement("answer1", answer1, _buf);
	Atf::XmlElement::encodeAsXmlElement("answer2", answer2, _buf);
	Atf::XmlElement::encodeAsXmlElement("ssn4", ssn4, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientSiteId", clientSiteId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("eMail"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, eMail)) return false;
			}
			else if (_element.equals("answer1"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, answer1)) return false;
			}
			else if (_element.equals("answer2"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, answer2)) return false;
			}
			else if (_element.equals("ssn4"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, ssn4)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientSiteId"))
			{
				clientSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(eMail);
	_msg.composeString(answer1);
	_msg.composeString(answer2);
	_msg.composeString(ssn4);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(eMail);
	_parser.parseStringP(answer1);
	_parser.parseStringP(answer2);
	_parser.parseStringP(ssn4);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(locale);
	_parser.parseUINT32(clientSiteId);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("eMail", eMail);
	_jsonstr.compose("answer1", answer1);
	_jsonstr.compose("answer2", answer2);
	_jsonstr.compose("ssn4", ssn4);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("clientSiteId", clientSiteId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("eMail", eMail);
	_jparser.parseByNameThrow("answer1", answer1);
	_jparser.parseByNameThrow("answer2", answer2);
	_jparser.parseByNameThrow("ssn4", ssn4);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("clientSiteId", clientSiteId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RETRIEVE_USERID2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString eMail; _jparser.validateByNameThrow("eMail", eMail);
	AtfValidator::validateIntMax(_descr, "eMail", eMail.length(), USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	PString answer1; _jparser.validateByNameThrow("answer1", answer1);
	AtfValidator::validateIntMax(_descr, "answer1", answer1.length(), 10000, _checker, __FILE__, __LINE__);
	PString answer2; _jparser.validateByNameThrow("answer2", answer2);
	AtfValidator::validateIntMax(_descr, "answer2", answer2.length(), 10000, _checker, __FILE__, __LINE__);
	PString ssn4; _jparser.validateByNameThrow("ssn4", ssn4);
	AtfValidator::validateIntMax(_descr, "ssn4", ssn4.length(), SSN_4_LEN, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _jparser.validateByNameThrow("clientSiteId", clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RETRIEVE_USERID2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "eMail"); size_t szEMail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "eMail", szEMail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "answer1"); size_t szAnswer1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer1", szAnswer1, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "answer2"); size_t szAnswer2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer2", szAnswer2, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ssn4"); size_t szSsn4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "ssn4", szSsn4, SSN_4_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	emptyStr.clear();
	licenseId = 0;
	challengeQuestions.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::equals(const Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(emptyStr, _o.emptyStr) &&
		licenseId == _o.licenseId &&
		challengeQuestions.equals(_o.challengeQuestions);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_RETRIEVE_USERID2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_RETRIEVE_USERID2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("emptyStr=");
		_buf.append(emptyStr);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		_buf.append(',');
		_buf.append("licenseId=");
		_buf.appendUint(licenseId);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		_buf.append(',');
		_buf.append("challengeQuestions=");
		challengeQuestions.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_RETRIEVE_USERID2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("emptyStr", emptyStr, _buf);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		Atf::XmlElement::encodeAsXmlElement("licenseId", licenseId, _buf);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		challengeQuestions.toXmlString("challengeQuestions", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("emptyStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, emptyStr)) return false;
			}
			else if (_element.equals("licenseId"))
			{
				licenseId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("challengeQuestions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< common_structs::ChallengeQuestion, 2 > >::FromXmlString(_value, challengeQuestions)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(emptyStr);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		_msg.composeUINT32(licenseId);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		challengeQuestions.composeMsg(_msg, _ignoreJSON);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(emptyStr);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		_parser.parseUINT32(licenseId);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		challengeQuestions.parseMsg(_parser);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("emptyStr", emptyStr);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		_jsonstr.compose("licenseId", licenseId);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		_jsonstr.compose("challengeQuestions", challengeQuestions);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("emptyStr", emptyStr);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		_jparser.parseByNameThrow("licenseId", licenseId);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		_jparser.parseByNameThrow("challengeQuestions", challengeQuestions);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RETRIEVE_USERID2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString emptyStr; _jparser.validateByNameThrow("emptyStr", emptyStr);
		AtfValidator::validateInt(_descr, "emptyStr", emptyStr.length(), _checker, __FILE__, __LINE__);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		UINT32 licenseId; _jparser.validateByNameThrow("licenseId", licenseId);
		AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		Atf::AtfVectorBase< common_structs::ChallengeQuestion > challengeQuestions; _jparser.validateByNameThrow("challengeQuestions", challengeQuestions);
		AtfValidator::validateInt(_descr, "challengeQuestions", challengeQuestions.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RETRIEVE_USERID2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "emptyStr"); size_t szEmptyStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "emptyStr", szEmptyStr, _checker, __FILE__, __LINE__);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		UINT32 licenseId; _parser.parseUINT32(licenseId);
		AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		PString _descbuf;
		int szChallengeQuestions = Atf::LAtfVector< common_structs::ChallengeQuestion, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("challengeQuestions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "challengeQuestions", szChallengeQuestions, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::clear()
{
	userId.clear();
	locale = 0;
	clientSiteId = 0;
	userIntId = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::equals(const Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId &&
		userIntId == _o.userIntId;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientSiteId", clientSiteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientSiteId"))
			{
				clientSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
	_msg.composeUINT32(userIntId);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(locale);
	_parser.parseUINT32(clientSiteId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(userIntId);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("clientSiteId", clientSiteId);
	_jsonstr.compose("userIntId", userIntId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("clientSiteId", clientSiteId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("userIntId", userIntId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _jparser.validateByNameThrow("clientSiteId", clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	revalidationMethods = 0;
	phoneNumber.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::equals(const Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		revalidationMethods == _o.revalidationMethods &&
		Atf::atfPStringEquals(phoneNumber, _o.phoneNumber);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("revalidationMethods=");
		_buf.appendUint(revalidationMethods);
		_buf.append(',');
		_buf.append("phoneNumber=");
		_buf.append(phoneNumber);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("revalidationMethods", revalidationMethods, _buf);
		Atf::XmlElement::encodeAsXmlElement("phoneNumber", phoneNumber, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("revalidationMethods"))
			{
				revalidationMethods = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("phoneNumber"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, phoneNumber)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(revalidationMethods);
		_msg.composeString(phoneNumber);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(revalidationMethods);
		_parser.parseStringP(phoneNumber);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("revalidationMethods", revalidationMethods);
		_jsonstr.compose("phoneNumber", phoneNumber);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("revalidationMethods", revalidationMethods);
		_jparser.parseByNameThrow("phoneNumber", phoneNumber);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 revalidationMethods; _jparser.validateByNameThrow("revalidationMethods", revalidationMethods);
		AtfValidator::validateInt(_descr, "revalidationMethods", revalidationMethods, _checker, __FILE__, __LINE__);
		PString phoneNumber; _jparser.validateByNameThrow("phoneNumber", phoneNumber);
		AtfValidator::validateInt(_descr, "phoneNumber", phoneNumber.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 revalidationMethods; _parser.parseUINT32(revalidationMethods);
		AtfValidator::validateInt(_descr, "revalidationMethods", revalidationMethods, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "phoneNumber"); size_t szPhoneNumber = strlen(_dummy);
		AtfValidator::validateInt(_descr, "phoneNumber", szPhoneNumber, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::clear()
{
	userId.clear();
	locale = 0;
	clientSiteId = 0;
	revalidationMethod = 0;
	answer1.clear();
	answer2.clear();
	userIntId = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::equals(const Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId &&
		revalidationMethod == _o.revalidationMethod &&
		Atf::atfPStringEquals(answer1, _o.answer1) &&
		Atf::atfPStringEquals(answer2, _o.answer2) &&
		userIntId == _o.userIntId;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("revalidationMethod=");
	_buf.appendInt(revalidationMethod);
	_buf.append(',');
	_buf.append("answer1=");
	_buf.append(answer1);
	_buf.append(',');
	_buf.append("answer2=");
	_buf.append(answer2);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientSiteId", clientSiteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("revalidationMethod", revalidationMethod, _buf);
	Atf::XmlElement::encodeAsXmlElement("answer1", answer1, _buf);
	Atf::XmlElement::encodeAsXmlElement("answer2", answer2, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientSiteId"))
			{
				clientSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("revalidationMethod"))
			{
				revalidationMethod = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("answer1"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, answer1)) return false;
			}
			else if (_element.equals("answer2"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, answer2)) return false;
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
	_msg.composeINT32(revalidationMethod);
	_msg.composeString(answer1);
	_msg.composeString(answer2);
	_msg.composeUINT32(userIntId);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(locale);
	_parser.parseUINT32(clientSiteId);
	_parser.parseINT32(revalidationMethod);
	_parser.parseStringP(answer1);
	_parser.parseStringP(answer2);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(userIntId);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("clientSiteId", clientSiteId);
	_jsonstr.compose("revalidationMethod", revalidationMethod);
	_jsonstr.compose("answer1", answer1);
	_jsonstr.compose("answer2", answer2);
	_jsonstr.compose("userIntId", userIntId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("clientSiteId", clientSiteId);
	_jparser.parseByNameThrow("revalidationMethod", revalidationMethod);
	_jparser.parseByNameThrow("answer1", answer1);
	_jparser.parseByNameThrow("answer2", answer2);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("userIntId", userIntId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _jparser.validateByNameThrow("clientSiteId", clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	INT32 revalidationMethod; _jparser.validateByNameThrow("revalidationMethod", revalidationMethod);
	AtfValidator::validateIntRange(_descr, "revalidationMethod", revalidationMethod, eRegulatorRevalidationMethods_None, eRegulatorRevalidationMethods_Last, _checker, __FILE__, __LINE__);
	PString answer1; _jparser.validateByNameThrow("answer1", answer1);
	AtfValidator::validateIntMax(_descr, "answer1", answer1.length(), 10000, _checker, __FILE__, __LINE__);
	PString answer2; _jparser.validateByNameThrow("answer2", answer2);
	AtfValidator::validateIntMax(_descr, "answer2", answer2.length(), 10000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	INT32 revalidationMethod; _parser.parseINT32(revalidationMethod);
	AtfValidator::validateIntRange(_descr, "revalidationMethod", revalidationMethod, eRegulatorRevalidationMethods_None, eRegulatorRevalidationMethods_Last, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "answer1"); size_t szAnswer1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer1", szAnswer1, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "answer2"); size_t szAnswer2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer2", szAnswer2, 10000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::equals(const Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::clear()
{
	userId.clear();
	locale = 0;
	clientSiteId = 0;
	userIntId = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::equals(const Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId &&
		userIntId == _o.userIntId;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientSiteId", clientSiteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientSiteId"))
			{
				clientSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
	_msg.composeUINT32(userIntId);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(locale);
	_parser.parseUINT32(clientSiteId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(userIntId);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("clientSiteId", clientSiteId);
	_jsonstr.compose("userIntId", userIntId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("clientSiteId", clientSiteId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("userIntId", userIntId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _jparser.validateByNameThrow("clientSiteId", clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::equals(const Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::clear()
{
	userId.clear();
	locale = 0;
	clientSiteId = 0;
	userIntId = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::equals(const Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId &&
		userIntId == _o.userIntId;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientSiteId", clientSiteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientSiteId"))
			{
				clientSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
	_msg.composeUINT32(userIntId);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(locale);
	_parser.parseUINT32(clientSiteId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(userIntId);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("clientSiteId", clientSiteId);
	_jsonstr.compose("userIntId", userIntId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("clientSiteId", clientSiteId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("userIntId", userIntId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _jparser.validateByNameThrow("clientSiteId", clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::equals(const Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::clear()
{
	userId.clear();
	locale = 0;
	clientSiteId = 0;
	userIntId = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::equals(const Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId &&
		userIntId == _o.userIntId;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientSiteId", clientSiteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientSiteId"))
			{
				clientSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
	_msg.composeUINT32(userIntId);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(locale);
	_parser.parseUINT32(clientSiteId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(userIntId);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("clientSiteId", clientSiteId);
	_jsonstr.compose("userIntId", userIntId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("clientSiteId", clientSiteId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("userIntId", userIntId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _jparser.validateByNameThrow("clientSiteId", clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    MaskedCardNum
//=================================================================

regulator::cli_unauth::MaskedCardNum::MaskedCardNum()
{
	clear();
}

void regulator::cli_unauth::MaskedCardNum::clear()
{
	paysystem.clear();
	maskedNum.clear();
	whenUsed.setNull();
}

bool regulator::cli_unauth::MaskedCardNum::equals(const MaskedCardNum& _o) const
{
	return Atf::atfPStringEquals(paysystem, _o.paysystem) &&
		Atf::atfPStringEquals(maskedNum, _o.maskedNum) &&
		whenUsed.equals(_o.whenUsed);
}

const char *regulator::cli_unauth::MaskedCardNum::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("paysystem=");
	_buf.append(paysystem);
	_buf.append(',');
	_buf.append("maskedNum=");
	_buf.append(maskedNum);
	_buf.append(',');
	_buf.append("whenUsed=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenUsed);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::cli_unauth::MaskedCardNum::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("paysystem", paysystem, _buf);
	Atf::XmlElement::encodeAsXmlElement("maskedNum", maskedNum, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenUsed", whenUsed);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::cli_unauth::MaskedCardNum::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("paysystem"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, paysystem)) return false;
		}
		else if (_element.equals("maskedNum"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, maskedNum)) return false;
		}
		else if (_element.equals("whenUsed"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenUsed);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::cli_unauth::MaskedCardNum::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(paysystem);
	_msg.composeString(maskedNum);
	_msg.composeSrvTime(whenUsed);
}

void regulator::cli_unauth::MaskedCardNum::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(paysystem);
	_parser.parseStringP(maskedNum);
	_parser.parseSrvTime(whenUsed);
}

const char *regulator::cli_unauth::MaskedCardNum::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paysystem", paysystem);
	_jsonstr.compose("maskedNum", maskedNum);
	_jsonstr.compose("whenUsed", whenUsed);
	return _buf.c_str();
}

void regulator::cli_unauth::MaskedCardNum::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paysystem", paysystem);
	_jparser.parseByNameThrow("maskedNum", maskedNum);
	_jparser.parseByNameThrow("whenUsed", whenUsed);
}

/* static */ void regulator::cli_unauth::MaskedCardNum::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString paysystem; _jparser.validateByNameThrow("paysystem", paysystem);
	AtfValidator::validateInt(_descr, "paysystem", paysystem.length(), _checker, __FILE__, __LINE__);
	PString maskedNum; _jparser.validateByNameThrow("maskedNum", maskedNum);
	AtfValidator::validateInt(_descr, "maskedNum", maskedNum.length(), _checker, __FILE__, __LINE__);
	SrvTime whenUsed; _jparser.validateByNameThrow("whenUsed", whenUsed);
	AtfValidator::validateSrvDateTime(_descr, "whenUsed", whenUsed, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::MaskedCardNum::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "paysystem"); size_t szPaysystem = strlen(_dummy);
	AtfValidator::validateInt(_descr, "paysystem", szPaysystem, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "maskedNum"); size_t szMaskedNum = strlen(_dummy);
	AtfValidator::validateInt(_descr, "maskedNum", szMaskedNum, _checker, __FILE__, __LINE__);
	SrvTime whenUsed; _parser.parseSrvTime(whenUsed);
	AtfValidator::validateSrvDateTime(_descr, "whenUsed", whenUsed, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	userMaskedCreditCards.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::equals(const Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		userMaskedCreditCards.equals(_o.userMaskedCreditCards);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userMaskedCreditCards=");
		userMaskedCreditCards.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		userMaskedCreditCards.toXmlString("userMaskedCreditCards", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("userMaskedCreditCards"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MaskedCardNum, 4 > >::FromXmlString(_value, userMaskedCreditCards)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		userMaskedCreditCards.composeMsg(_msg, _ignoreJSON);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		userMaskedCreditCards.parseMsg(_parser);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("userMaskedCreditCards", userMaskedCreditCards);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("userMaskedCreditCards", userMaskedCreditCards);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< MaskedCardNum > userMaskedCreditCards; _jparser.validateByNameThrow("userMaskedCreditCards", userMaskedCreditCards);
		AtfValidator::validateInt(_descr, "userMaskedCreditCards", userMaskedCreditCards.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szUserMaskedCreditCards = Atf::LAtfVector< MaskedCardNum, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userMaskedCreditCards"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "userMaskedCreditCards", szUserMaskedCreditCards, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::clear()
{
	userId.clear();
	locale = 0;
	clientSiteId = 0;
	answers.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::equals(const Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId &&
		answers.equals(_o.answers);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("answers=");
	answers.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientSiteId", clientSiteId, _buf);
	answers.toXmlString("answers", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientSiteId"))
			{
				clientSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("answers"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< common_structs::ChallengeAnswer, 4 > >::FromXmlString(_value, answers)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
	answers.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(locale);
	_parser.parseUINT32(clientSiteId);
	answers.parseMsg(_parser);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("clientSiteId", clientSiteId);
	_jsonstr.compose("answers", answers);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("clientSiteId", clientSiteId);
	_jparser.parseByNameThrow("answers", answers);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _jparser.validateByNameThrow("clientSiteId", clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< common_structs::ChallengeAnswer > answers; _jparser.validateByNameThrow("answers", answers);
	AtfValidator::validateIntRange(_descr, "answers", answers.size(), CHALLENGE_ANSWERS_SIZE, CHALLENGE_ANSWERS_SIZE, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAnswers = Atf::LAtfVector< common_structs::ChallengeAnswer, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("answers"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntRange(_descr, "answers", szAnswers, CHALLENGE_ANSWERS_SIZE, CHALLENGE_ANSWERS_SIZE, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	match = false;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::equals(const Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		match == _o.match;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("match=");
		_buf.appendUint(match);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("match", match, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("match"))
			{
				match = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(match);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(match);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("match", match);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("match", match);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool match; _jparser.validateByNameThrow("match", match);
		AtfValidator::validateInt(_descr, "match", match, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool match; _parser.parseBOOL(match);
		AtfValidator::validateInt(_descr, "match", match, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_REMIND_SID
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::Protocol_MSG_LOBBY_REMIND_SID()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::clear()
{
	userId.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::equals(const Protocol_MSG_LOBBY_REMIND_SID& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId);
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_REMIND_SID != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_REMIND_SID*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REMIND_SID).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_REMIND_SID).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REMIND_SID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 100, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REMIND_SID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_REMIND_SID_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::Protocol_MSG_LOBBY_REMIND_SID_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	mobileOrEmail.clear();
	viaSMS = false;
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::equals(const Protocol_MSG_LOBBY_REMIND_SID_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(mobileOrEmail, _o.mobileOrEmail) &&
		viaSMS == _o.viaSMS;
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_REMIND_SID_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_REMIND_SID_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REMIND_SID_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("mobileOrEmail=");
		_buf.append(mobileOrEmail);
		_buf.append(',');
		_buf.append("viaSMS=");
		_buf.appendUint(viaSMS);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_REMIND_SID_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("mobileOrEmail", mobileOrEmail, _buf);
		Atf::XmlElement::encodeAsXmlElement("viaSMS", viaSMS, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("mobileOrEmail"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, mobileOrEmail)) return false;
			}
			else if (_element.equals("viaSMS"))
			{
				viaSMS = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(mobileOrEmail);
		_msg.composeBOOL(viaSMS);
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(mobileOrEmail);
		_parser.parseBOOL(viaSMS);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("mobileOrEmail", mobileOrEmail);
		_jsonstr.compose("viaSMS", viaSMS);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("mobileOrEmail", mobileOrEmail);
		_jparser.parseByNameThrow("viaSMS", viaSMS);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REMIND_SID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString mobileOrEmail; _jparser.validateByNameThrow("mobileOrEmail", mobileOrEmail);
		AtfValidator::validateInt(_descr, "mobileOrEmail", mobileOrEmail.length(), _checker, __FILE__, __LINE__);
		bool viaSMS; _jparser.validateByNameThrow("viaSMS", viaSMS);
		AtfValidator::validateInt(_descr, "viaSMS", viaSMS, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REMIND_SID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "mobileOrEmail"); size_t szMobileOrEmail = strlen(_dummy);
		AtfValidator::validateInt(_descr, "mobileOrEmail", szMobileOrEmail, _checker, __FILE__, __LINE__);
		bool viaSMS; _parser.parseBOOL(viaSMS);
		AtfValidator::validateInt(_descr, "viaSMS", viaSMS, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::clear()
{
	userIdOrEmail.clear();
	locale = 0;
	clientSiteId = 0;
	installId.clear();
	brandId = 0;
	clientExtra.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::equals(const Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL& _o) const
{
	return Atf::atfPStringEquals(userIdOrEmail, _o.userIdOrEmail) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId &&
		Atf::atfPStringEquals(installId, _o.installId) &&
		brandId == _o.brandId &&
		clientExtra.equals(_o.clientExtra);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL).append(")");
	_buf.append(',');
	_buf.append("userIdOrEmail=");
	_buf.append(userIdOrEmail);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendInt(brandId);
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userIdOrEmail", userIdOrEmail, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientSiteId", clientSiteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("installId", installId, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandId", brandId, _buf);
	clientExtra.toXmlString("clientExtra", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userIdOrEmail"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userIdOrEmail)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientSiteId"))
			{
				clientSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("installId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, installId)) return false;
			}
			else if (_element.equals("brandId"))
			{
				brandId = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientExtra"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, clientExtra)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userIdOrEmail);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
	_msg.composeString(installId);
	_msg.composeINT32(brandId);
	clientExtra.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userIdOrEmail);
	_parser.parseUINT32(locale);
	_parser.parseUINT32(clientSiteId);
	_parser.parseStringP(installId);
	_parser.parseINT32(brandId);
	if(_parser.parseEnded()) return;
	clientExtra.parseMsg(_parser);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIdOrEmail", userIdOrEmail);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("clientSiteId", clientSiteId);
	_jsonstr.compose("installId", installId);
	_jsonstr.compose("brandId", brandId);
	_jsonstr.compose("clientExtra", clientExtra);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIdOrEmail", userIdOrEmail);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("clientSiteId", clientSiteId);
	_jparser.parseByNameThrow("installId", installId);
	_jparser.parseByNameThrow("brandId", brandId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientExtra", clientExtra);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userIdOrEmail; _jparser.validateByNameThrow("userIdOrEmail", userIdOrEmail);
	AtfValidator::validateIntMax(_descr, "userIdOrEmail", userIdOrEmail.length(), 1000, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _jparser.validateByNameThrow("clientSiteId", clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	PString installId; _jparser.validateByNameThrow("installId", installId);
	AtfValidator::validateIntMax(_descr, "installId", installId.length(), USER_INSTALLID_LEN, _checker, __FILE__, __LINE__);
	INT32 brandId; _jparser.validateByNameThrow("brandId", brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, BrandType_Last, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Common::AtfShared::LoginExtra clientExtra; _jparser.validateByNameThrow("clientExtra", clientExtra);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userIdOrEmail"); size_t szUserIdOrEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userIdOrEmail", szUserIdOrEmail, 1000, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, USER_INSTALLID_LEN, _checker, __FILE__, __LINE__);
	INT32 brandId; _parser.parseINT32(brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, BrandType_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	inputFormat = 0;
	eMailMask.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::equals(const Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		inputFormat == _o.inputFormat &&
		Atf::atfPStringEquals(eMailMask, _o.eMailMask);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("inputFormat=");
		_buf.appendInt(inputFormat);
		_buf.append(',');
		_buf.append("eMailMask=");
		_buf.append(eMailMask);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("inputFormat", inputFormat, _buf);
		Atf::XmlElement::encodeAsXmlElement("eMailMask", eMailMask, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("inputFormat"))
			{
				inputFormat = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("eMailMask"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, eMailMask)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(inputFormat);
		_msg.composeString(eMailMask);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(inputFormat);
		_parser.parseStringP(eMailMask);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("inputFormat", inputFormat);
		_jsonstr.compose("eMailMask", eMailMask);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("inputFormat", inputFormat);
		_jparser.parseByNameThrow("eMailMask", eMailMask);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 inputFormat; _jparser.validateByNameThrow("inputFormat", inputFormat);
		AtfValidator::validateInt(_descr, "inputFormat", inputFormat, _checker, __FILE__, __LINE__);
		PString eMailMask; _jparser.validateByNameThrow("eMailMask", eMailMask);
		AtfValidator::validateInt(_descr, "eMailMask", eMailMask.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 inputFormat; _parser.parseINT32(inputFormat);
		AtfValidator::validateInt(_descr, "inputFormat", inputFormat, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "eMailMask"); size_t szEMailMask = strlen(_dummy);
		AtfValidator::validateInt(_descr, "eMailMask", szEMailMask, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::clear()
{
	encryptedData.clear();
	newPwd.clear();
	ipAddr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::equals(const Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD& _o) const
{
	return Atf::atfPStringEquals(encryptedData, _o.encryptedData) &&
		Atf::atfPStringEquals(newPwd, _o.newPwd) &&
		Atf::atfPStringEquals(ipAddr, _o.ipAddr);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_WEB_PWD_SET_NEW_PWD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_WEB_PWD_SET_NEW_PWD).append(")");
	_buf.append(',');
	_buf.append("encryptedData=");
	_buf.append(encryptedData);
	_buf.append(',');
	_buf.append("newPwd=");
	_buf.append(newPwd);
	_buf.append(',');
	_buf.append("ipAddr=");
	_buf.append(ipAddr);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_WEB_PWD_SET_NEW_PWD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("encryptedData", encryptedData, _buf);
	Atf::XmlElement::encodeAsXmlElement("newPwd", newPwd, _buf);
	Atf::XmlElement::encodeAsXmlElement("ipAddr", ipAddr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("encryptedData"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, encryptedData)) return false;
			}
			else if (_element.equals("newPwd"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, newPwd)) return false;
			}
			else if (_element.equals("ipAddr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, ipAddr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(encryptedData);
	_msg.composeString(newPwd);
	_msg.composeString(ipAddr);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(encryptedData);
	_parser.parseStringP(newPwd);
	_parser.parseStringP(ipAddr);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("encryptedData", encryptedData);
	_jsonstr.compose("newPwd", newPwd);
	_jsonstr.compose("ipAddr", ipAddr);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("encryptedData", encryptedData);
	_jparser.parseByNameThrow("newPwd", newPwd);
	_jparser.parseByNameThrow("ipAddr", ipAddr);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_WEB_PWD_SET_NEW_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString encryptedData; _jparser.validateByNameThrow("encryptedData", encryptedData);
	AtfValidator::validateIntMax(_descr, "encryptedData", encryptedData.length(), 10000, _checker, __FILE__, __LINE__);
	PString newPwd; _jparser.validateByNameThrow("newPwd", newPwd);
	AtfValidator::validateIntMax(_descr, "newPwd", newPwd.length(), 100, _checker, __FILE__, __LINE__);
	PString ipAddr; _jparser.validateByNameThrow("ipAddr", ipAddr);
	AtfValidator::validateIntMax(_descr, "ipAddr", ipAddr.length(), IP_ADDR_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_WEB_PWD_SET_NEW_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "encryptedData"); size_t szEncryptedData = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "encryptedData", szEncryptedData, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "newPwd"); size_t szNewPwd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "newPwd", szNewPwd, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ipAddr"); size_t szIpAddr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "ipAddr", szIpAddr, IP_ADDR_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::equals(const Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::clear()
{
	encryptedData.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::equals(const Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO& _o) const
{
	return Atf::atfPStringEquals(encryptedData, _o.encryptedData);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO).append(")");
	_buf.append(',');
	_buf.append("encryptedData=");
	_buf.append(encryptedData);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("encryptedData", encryptedData, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("encryptedData"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, encryptedData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(encryptedData);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(encryptedData);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("encryptedData", encryptedData);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("encryptedData", encryptedData);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString encryptedData; _jparser.validateByNameThrow("encryptedData", encryptedData);
	AtfValidator::validateIntMax(_descr, "encryptedData", encryptedData.length(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "encryptedData"); size_t szEncryptedData = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "encryptedData", szEncryptedData, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	userId.clear();
	isRMOK = false;
	userFirstName.clear();
	userLastName.clear();
	userLicenseId = 0;
	tokenExpiry.setNull();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::equals(const Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		isRMOK == _o.isRMOK &&
		Atf::atfPStringEquals(userFirstName, _o.userFirstName) &&
		Atf::atfPStringEquals(userLastName, _o.userLastName) &&
		userLicenseId == _o.userLicenseId &&
		tokenExpiry.equals(_o.tokenExpiry);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
		_buf.append(',');
		_buf.append("isRMOK=");
		_buf.appendUint(isRMOK);
		_buf.append(',');
		_buf.append("userFirstName=");
		_buf.append(userFirstName);
		_buf.append(',');
		_buf.append("userLastName=");
		_buf.append(userLastName);
		_buf.append(',');
		_buf.append("userLicenseId=");
		_buf.appendUint(userLicenseId);
		_buf.append(',');
		_buf.append("tokenExpiry=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, tokenExpiry);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
		Atf::XmlElement::encodeAsXmlElement("isRMOK", isRMOK, _buf);
		Atf::XmlElement::encodeAsXmlElement("userFirstName", userFirstName, _buf);
		Atf::XmlElement::encodeAsXmlElement("userLastName", userLastName, _buf);
		Atf::XmlElement::encodeAsXmlElement("userLicenseId", userLicenseId, _buf);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "tokenExpiry", tokenExpiry);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("isRMOK"))
			{
				isRMOK = (*_value.ptr() == '1');
			}
			else if (_element.equals("userFirstName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userFirstName)) return false;
			}
			else if (_element.equals("userLastName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userLastName)) return false;
			}
			else if (_element.equals("userLicenseId"))
			{
				userLicenseId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tokenExpiry"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, tokenExpiry);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(userId);
		_msg.composeBOOL(isRMOK);
		_msg.composeString(userFirstName);
		_msg.composeString(userLastName);
		_msg.composeUINT32(userLicenseId);
		_msg.composeSrvTime(tokenExpiry);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(userId);
		_parser.parseBOOL(isRMOK);
		_parser.parseStringP(userFirstName);
		_parser.parseStringP(userLastName);
		_parser.parseUINT32(userLicenseId);
		_parser.parseSrvTime(tokenExpiry);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("userId", userId);
		_jsonstr.compose("isRMOK", isRMOK);
		_jsonstr.compose("userFirstName", userFirstName);
		_jsonstr.compose("userLastName", userLastName);
		_jsonstr.compose("userLicenseId", userLicenseId);
		_jsonstr.compose("tokenExpiry", tokenExpiry);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("userId", userId);
		_jparser.parseByNameThrow("isRMOK", isRMOK);
		_jparser.parseByNameThrow("userFirstName", userFirstName);
		_jparser.parseByNameThrow("userLastName", userLastName);
		_jparser.parseByNameThrow("userLicenseId", userLicenseId);
		_jparser.parseByNameThrow("tokenExpiry", tokenExpiry);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString userId; _jparser.validateByNameThrow("userId", userId);
		AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
		bool isRMOK; _jparser.validateByNameThrow("isRMOK", isRMOK);
		AtfValidator::validateInt(_descr, "isRMOK", isRMOK, _checker, __FILE__, __LINE__);
		PString userFirstName; _jparser.validateByNameThrow("userFirstName", userFirstName);
		AtfValidator::validateInt(_descr, "userFirstName", userFirstName.length(), _checker, __FILE__, __LINE__);
		PString userLastName; _jparser.validateByNameThrow("userLastName", userLastName);
		AtfValidator::validateInt(_descr, "userLastName", userLastName.length(), _checker, __FILE__, __LINE__);
		UINT32 userLicenseId; _jparser.validateByNameThrow("userLicenseId", userLicenseId);
		AtfValidator::validateInt(_descr, "userLicenseId", userLicenseId, _checker, __FILE__, __LINE__);
		SrvTime tokenExpiry; _jparser.validateByNameThrow("tokenExpiry", tokenExpiry);
		AtfValidator::validateSrvDateTime(_descr, "tokenExpiry", tokenExpiry, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
		bool isRMOK; _parser.parseBOOL(isRMOK);
		AtfValidator::validateInt(_descr, "isRMOK", isRMOK, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userFirstName"); size_t szUserFirstName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userFirstName", szUserFirstName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userLastName"); size_t szUserLastName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userLastName", szUserLastName, _checker, __FILE__, __LINE__);
		UINT32 userLicenseId; _parser.parseUINT32(userLicenseId);
		AtfValidator::validateInt(_descr, "userLicenseId", userLicenseId, _checker, __FILE__, __LINE__);
		SrvTime tokenExpiry; _parser.parseSrvTime(tokenExpiry);
		AtfValidator::validateSrvDateTime(_descr, "tokenExpiry", tokenExpiry, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::clear()
{
	encryptedData.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::equals(const Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY& _o) const
{
	return Atf::atfPStringEquals(encryptedData, _o.encryptedData);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SET_PRIV_NO_SURVEY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_PRIV_NO_SURVEY).append(")");
	_buf.append(',');
	_buf.append("encryptedData=");
	_buf.append(encryptedData);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SET_PRIV_NO_SURVEY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("encryptedData", encryptedData, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("encryptedData"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, encryptedData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(encryptedData);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(encryptedData);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("encryptedData", encryptedData);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("encryptedData", encryptedData);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PRIV_NO_SURVEY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString encryptedData; _jparser.validateByNameThrow("encryptedData", encryptedData);
	AtfValidator::validateIntMax(_descr, "encryptedData", encryptedData.length(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PRIV_NO_SURVEY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "encryptedData"); size_t szEncryptedData = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "encryptedData", szEncryptedData, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::equals(const Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::clear()
{
	userId_ignore.clear();
	elements.clear();
	locale = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::equals(const Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE& _o) const
{
	return Atf::atfPStringEquals(userId_ignore, _o.userId_ignore) &&
		elements.equals(_o.elements) &&
		locale == _o.locale;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_VALIDATE_USER_UPDATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_USER_UPDATE).append(")");
	_buf.append(',');
	_buf.append("userId_ignore=");
	_buf.append(userId_ignore);
	_buf.append(',');
	_buf.append("elements=");
	elements.toTraceString(_buf);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_VALIDATE_USER_UPDATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId_ignore", userId_ignore, _buf);
	elements.toXmlString("elements", _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId_ignore"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId_ignore)) return false;
			}
			else if (_element.equals("elements"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< common_structs::UserUpdateElement, 4 > >::FromXmlString(_value, elements)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId_ignore);
	elements.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(locale);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId_ignore);
	elements.parseMsg(_parser);
	_parser.parseUINT32(locale);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId_ignore", userId_ignore);
	_jsonstr.compose("elements", elements);
	_jsonstr.compose("locale", locale);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId_ignore", userId_ignore);
	_jparser.parseByNameThrow("elements", elements);
	_jparser.parseByNameThrow("locale", locale);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_USER_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId_ignore; _jparser.validateByNameThrow("userId_ignore", userId_ignore);
	AtfValidator::validateIntMax(_descr, "userId_ignore", userId_ignore.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< common_structs::UserUpdateElement > elements; _jparser.validateByNameThrow("elements", elements);
	AtfValidator::validateIntMax(_descr, "elements", elements.size(), 1000, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_USER_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId_ignore"); size_t szUserId_ignore = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId_ignore", szUserId_ignore, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szElements = Atf::LAtfVector< common_structs::UserUpdateElement, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("elements"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "elements", szElements, 1000, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::clear()
{
	errCode = 0;
	validationResults.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::equals(const Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		validationResults.equals(_o.validationResults);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("validationResults=");
		validationResults.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		validationResults.toXmlString("validationResults", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("validationResults"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< common_structs::UserUpdateValidationResult, 4 > >::FromXmlString(_value, validationResults)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		validationResults.composeMsg(_msg, _ignoreJSON);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		validationResults.parseMsg(_parser);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("validationResults", validationResults);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("validationResults", validationResults);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		Atf::AtfVectorBase< common_structs::UserUpdateValidationResult > validationResults; _jparser.validateByNameThrow("validationResults", validationResults);
		AtfValidator::validateInt(_descr, "validationResults", validationResults.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString _descbuf;
		int szValidationResults = Atf::LAtfVector< common_structs::UserUpdateValidationResult, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("validationResults"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "validationResults", szValidationResults, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_SWISS_URL
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::Protocol_MSG_REGULATOR_GET_SWISS_URL()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::clear()
{
	loginExtra.clear();
	commonRequest.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::equals(const Protocol_MSG_REGULATOR_GET_SWISS_URL& _o) const
{
	return loginExtra.equals(_o.loginExtra) &&
		commonRequest.equals(_o.commonRequest);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_SWISS_URL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_SWISS_URL*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_SWISS_URL).append(")");
	_buf.append(',');
	_buf.append("loginExtra=");
	loginExtra.toTraceString(_buf);
	_buf.append(',');
	_buf.append("commonRequest=");
	commonRequest.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_SWISS_URL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	loginExtra.toXmlString("loginExtra", _buf);
	commonRequest.toXmlString("commonRequest", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("loginExtra"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, loginExtra)) return false;
			}
			else if (_element.equals("commonRequest"))
			{
				if(!Atf::AtfTempl< common_structs::SwissUrlRequest >::FromXmlString(_value, commonRequest)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	loginExtra.composeMsg(_msg, _ignoreJSON);
	commonRequest.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::parseMsg(CommMsgParser& _parser)
{
	loginExtra.parseMsg(_parser);
	commonRequest.parseMsg(_parser);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("loginExtra", loginExtra);
	_jsonstr.compose("commonRequest", commonRequest);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("loginExtra", loginExtra);
	_jparser.parseByNameThrow("commonRequest", commonRequest);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_SWISS_URL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Common::AtfShared::LoginExtra loginExtra; _jparser.validateByNameThrow("loginExtra", loginExtra);
	common_structs::SwissUrlRequest commonRequest; _jparser.validateByNameThrow("commonRequest", commonRequest);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_SWISS_URL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtra"), _fieldsWithUnparsedContent);
	common_structs::SwissUrlRequest::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("commonRequest"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	url.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::equals(const Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(url, _o.url);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_SWISS_URL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_SWISS_URL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("url=");
		_buf.append(url);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_SWISS_URL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("url", url, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("url"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, url)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(url);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(url);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("url", url);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("url", url);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_SWISS_URL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString url; _jparser.validateByNameThrow("url", url);
		AtfValidator::validateInt(_descr, "url", url.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_SWISS_URL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::clear()
{
	clientExtra.clear();
	country.clear();
	localeId = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::equals(const Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY& _o) const
{
	return clientExtra.equals(_o.clientExtra) &&
		country.equals(_o.country) &&
		localeId == _o.localeId;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY).append(")");
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("localeId=");
	_buf.appendUint(localeId);
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	clientExtra.toXmlString("clientExtra", _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("localeId", localeId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clientExtra"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, clientExtra)) return false;
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("localeId"))
			{
				localeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	clientExtra.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(country);
	_msg.composeUINT32(localeId);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::parseMsg(CommMsgParser& _parser)
{
	clientExtra.parseMsg(_parser);
	_parser.parseStringP(country);
	_parser.parseUINT32(localeId);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clientExtra", clientExtra);
	_jsonstr.compose("country", country);
	_jsonstr.compose("localeId", localeId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clientExtra", clientExtra);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("localeId", localeId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Common::AtfShared::LoginExtra clientExtra; _jparser.validateByNameThrow("clientExtra", clientExtra);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), COUNTRY_CODE_LEN, _checker, __FILE__, __LINE__);
	UINT32 localeId; _jparser.validateByNameThrow("localeId", localeId);
	AtfValidator::validateIntMax(_descr, "localeId", localeId, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	PString _descbuf;
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, COUNTRY_CODE_LEN, _checker, __FILE__, __LINE__);
	UINT32 localeId; _parser.parseUINT32(localeId);
	AtfValidator::validateIntMax(_descr, "localeId", localeId, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY()
{
	clear();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::equals(const Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY*)_other));
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_NAME_AVAILABLE
//=================================================================

regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::Protocol_MSG_LOBBY_NAME_AVAILABLE()
{
	clear();
}

void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::clear()
{
	reqId = 0;
	body.clear();
}

bool regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::equals(const Protocol_MSG_LOBBY_NAME_AVAILABLE& _o) const
{
	return reqId == _o.reqId &&
		body.equals(_o.body);
}

bool regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_NAME_AVAILABLE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_NAME_AVAILABLE*)_other));
}

const char *regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_NAME_AVAILABLE).append(")");
	_buf.append(',');
	_buf.append("reqId=");
	_buf.appendUint(reqId);
	_buf.append(',');
	_buf.append("body=");
	body.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_NAME_AVAILABLE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("reqId", reqId, _buf);
	body.toXmlString("body", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reqId"))
			{
				reqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("body"))
			{
				if(!Atf::AtfTempl< common_structs::LobbyNameAvailableStruct >::FromXmlString(_value, body)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(reqId);
	body.composeMsg(_msg, _ignoreJSON);
}

void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqId);
	body.parseMsg(_parser);
}

const char *regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reqId", reqId);
	_jsonstr.compose("body", body);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reqId", reqId);
	_jparser.parseByNameThrow("body", body);
}

/*static*/ void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_NAME_AVAILABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 reqId; _jparser.validateByNameThrow("reqId", reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	common_structs::LobbyNameAvailableStruct body; _jparser.validateByNameThrow("body", body);
}

/*static*/ void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_NAME_AVAILABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 reqId; _parser.parseUINT32(reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	common_structs::LobbyNameAvailableStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("body"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY
//=================================================================

regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY()
{
	clear();
}

void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::clear()
{
	reqId = 0;
	replyBody.clear();
}

bool regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::equals(const Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY& _o) const
{
	return reqId == _o.reqId &&
		replyBody.equals(_o.replyBody);
}

bool regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_NAME_AVAILABLE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY*)_other));
}

const char *regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_NAME_AVAILABLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("reqId=");
	_buf.appendUint(reqId);
	_buf.append(',');
	_buf.append("replyBody=");
	replyBody.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_NAME_AVAILABLE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("reqId", reqId, _buf);
	replyBody.toXmlString("replyBody", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reqId"))
			{
				reqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("replyBody"))
			{
				if(!Atf::AtfTempl< common_structs::LobbyNameAvailableReplyStruct >::FromXmlString(_value, replyBody)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(reqId);
	replyBody.composeMsg(_msg, _ignoreJSON);
}

void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqId);
	replyBody.parseMsg(_parser);
}

const char *regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reqId", reqId);
	_jsonstr.compose("replyBody", replyBody);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reqId", reqId);
	_jparser.parseByNameThrow("replyBody", replyBody);
}

/*static*/ void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_NAME_AVAILABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 reqId; _jparser.validateByNameThrow("reqId", reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	common_structs::LobbyNameAvailableReplyStruct replyBody; _jparser.validateByNameThrow("replyBody", replyBody);
}

/*static*/ void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_NAME_AVAILABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 reqId; _parser.parseUINT32(reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	common_structs::LobbyNameAvailableReplyStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("replyBody"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    AppTypeEssentials
//=================================================================

regulator::core::AppTypeEssentials::AppTypeEssentials()
{
	clear();
}

void regulator::core::AppTypeEssentials::clear()
{
	brandId = BrandType_PokerStars;
	osId = OSId_Unknown;
	appTypeId = AppTypeId_Unknown;
	productId = ProductId_Unknown;
}

bool regulator::core::AppTypeEssentials::equals(const AppTypeEssentials& _o) const
{
	return brandId == _o.brandId &&
		osId == _o.osId &&
		appTypeId == _o.appTypeId &&
		productId == _o.productId;
}

const char *regulator::core::AppTypeEssentials::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("osId=");
	_buf.appendUint(osId);
	_buf.append(',');
	_buf.append("appTypeId=");
	_buf.appendUint(appTypeId);
	_buf.append(',');
	_buf.append("productId=");
	_buf.appendUint(productId);
	_buf.append('}');
	return _buf.c_str();
}

const char *regulator::core::AppTypeEssentials::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("brandId", brandId, _buf);
	Atf::XmlElement::encodeAsXmlElement("osId", osId, _buf);
	Atf::XmlElement::encodeAsXmlElement("appTypeId", appTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("productId", productId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool regulator::core::AppTypeEssentials::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("brandId"))
		{
			brandId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("osId"))
		{
			osId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("appTypeId"))
		{
			appTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("productId"))
		{
			productId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void regulator::core::AppTypeEssentials::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(brandId);
	_msg.composeUINT32(osId);
	_msg.composeUINT32(appTypeId);
	_msg.composeUINT32(productId);
}

void regulator::core::AppTypeEssentials::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(brandId);
	_parser.parseUINT32(osId);
	_parser.parseUINT32(appTypeId);
	_parser.parseUINT32(productId);
}

const char *regulator::core::AppTypeEssentials::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("brandId", brandId);
	_jsonstr.compose("osId", osId);
	_jsonstr.compose("appTypeId", appTypeId);
	_jsonstr.compose("productId", productId);
	return _buf.c_str();
}

void regulator::core::AppTypeEssentials::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("brandId", brandId);
	_jparser.parseByNameThrow("osId", osId);
	_jparser.parseByNameThrow("appTypeId", appTypeId);
	_jparser.parseByNameThrow("productId", productId);
}

/* static */ void regulator::core::AppTypeEssentials::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 brandId; _jparser.validateByNameThrow("brandId", brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, BrandType_Last, _checker, __FILE__, __LINE__);
	UINT32 osId; _jparser.validateByNameThrow("osId", osId);
	AtfValidator::validateIntRange(_descr, "osId", osId, OSId_Unknown, OsId_Last, _checker, __FILE__, __LINE__);
	UINT32 appTypeId; _jparser.validateByNameThrow("appTypeId", appTypeId);
	AtfValidator::validateIntRange(_descr, "appTypeId", appTypeId, AppTypeId_Unknown, AppTypeId_Last, _checker, __FILE__, __LINE__);
	UINT32 productId; _jparser.validateByNameThrow("productId", productId);
	AtfValidator::validateIntRange(_descr, "productId", productId, ProductId_Unknown, ProductId_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::core::AppTypeEssentials::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 brandId; _parser.parseUINT32(brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, BrandType_Last, _checker, __FILE__, __LINE__);
	UINT32 osId; _parser.parseUINT32(osId);
	AtfValidator::validateIntRange(_descr, "osId", osId, OSId_Unknown, OsId_Last, _checker, __FILE__, __LINE__);
	UINT32 appTypeId; _parser.parseUINT32(appTypeId);
	AtfValidator::validateIntRange(_descr, "appTypeId", appTypeId, AppTypeId_Unknown, AppTypeId_Last, _checker, __FILE__, __LINE__);
	UINT32 productId; _parser.parseUINT32(productId);
	AtfValidator::validateIntRange(_descr, "productId", productId, ProductId_Unknown, ProductId_Last, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_REGULATOR_REGISTER_NEW_USER2
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2()
{
	clear();
}

void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::clear()
{
	reqId = 0;
	ipAddr.clear();
	id.clear();
	facebookIntId = 0;
	email.clear();
	userInstallId.clear();
	addr_1.clear();
	city.clear();
	state.clear();
	country.clear();
	zipCode.clear();
	dob.setNull();
	locale = 0;
	firstName.clear();
	lastName.clear();
	sex.clear();
	timezone_ = 0;
	clientPlatform = 0;
	clientType = 0;
	clientDevice = 0;
	appTypeEssentials.clear();
	phone.clear();
}

bool regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::equals(const Protocol_MSG_REGULATOR_REGISTER_NEW_USER2& _o) const
{
	return reqId == _o.reqId &&
		Atf::atfPStringEquals(ipAddr, _o.ipAddr) &&
		Atf::atfPStringEquals(id, _o.id) &&
		facebookIntId == _o.facebookIntId &&
		Atf::atfPStringEquals(email, _o.email) &&
		Atf::atfPStringEquals(userInstallId, _o.userInstallId) &&
		Atf::atfPStringEquals(addr_1, _o.addr_1) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(country, _o.country) &&
		Atf::atfPStringEquals(zipCode, _o.zipCode) &&
		dob.equals(_o.dob) &&
		locale == _o.locale &&
		Atf::atfPStringEquals(firstName, _o.firstName) &&
		Atf::atfPStringEquals(lastName, _o.lastName) &&
		Atf::atfPStringEquals(sex, _o.sex) &&
		timezone_ == _o.timezone_ &&
		clientPlatform == _o.clientPlatform &&
		clientType == _o.clientType &&
		clientDevice == _o.clientDevice &&
		appTypeEssentials.equals(_o.appTypeEssentials) &&
		Atf::atfPStringEquals(phone, _o.phone);
}

bool regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_REGISTER_NEW_USER2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_REGISTER_NEW_USER2*)_other));
}

const char *regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_REGISTER_NEW_USER2).append(")");
	_buf.append(',');
	_buf.append("reqId=");
	_buf.appendUint(reqId);
	_buf.append(',');
	_buf.append("ipAddr=");
	_buf.append(ipAddr);
	_buf.append(',');
	_buf.append("id=");
	_buf.append(id);
	_buf.append(',');
	_buf.append("facebookIntId=");
	_buf.appendUint64(facebookIntId);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("userInstallId=");
	_buf.append(userInstallId);
	_buf.append(',');
	_buf.append("addr_1=");
	_buf.append(addr_1);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("zipCode=");
	_buf.append(zipCode);
	_buf.append(',');
	_buf.append("dob=");
	Atf::AtfTempl<CommSrvDate>::ToTraceString(_buf, dob);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("firstName=");
	_buf.append(firstName);
	_buf.append(',');
	_buf.append("lastName=");
	_buf.append(lastName);
	_buf.append(',');
	_buf.append("sex=");
	_buf.append(sex);
	_buf.append(',');
	_buf.append("timezone_=");
	_buf.appendUint(timezone_);
	_buf.append(',');
	_buf.append("clientPlatform=");
	_buf.appendUint(clientPlatform);
	_buf.append(',');
	_buf.append("clientType=");
	_buf.appendUint(clientType);
	_buf.append(',');
	_buf.append("clientDevice=");
	_buf.appendUint(clientDevice);
	_buf.append(',');
	_buf.append("appTypeEssentials=");
	appTypeEssentials.toTraceString(_buf);
	_buf.append(',');
	_buf.append("phone=");
	_buf.append(phone);
	return _buf.c_str();
}

const char *regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_REGISTER_NEW_USER2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("reqId", reqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("ipAddr", ipAddr, _buf);
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("facebookIntId", facebookIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	Atf::XmlElement::encodeAsXmlElement("userInstallId", userInstallId, _buf);
	Atf::XmlElement::encodeAsXmlElement("addr_1", addr_1, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("zipCode", zipCode, _buf);
	Atf::AtfTempl<CommSrvDate>::ToXmlString(_buf, "dob", dob);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("firstName", firstName, _buf);
	Atf::XmlElement::encodeAsXmlElement("lastName", lastName, _buf);
	Atf::XmlElement::encodeAsXmlElement("sex", sex, _buf);
	Atf::XmlElement::encodeAsXmlElement("timezone_", timezone_, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientPlatform", clientPlatform, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientType", clientType, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientDevice", clientDevice, _buf);
	appTypeEssentials.toXmlString("appTypeEssentials", _buf);
	Atf::XmlElement::encodeAsXmlElement("phone", phone, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reqId"))
			{
				reqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ipAddr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, ipAddr)) return false;
			}
			else if (_element.equals("id"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, id)) return false;
			}
			else if (_element.equals("facebookIntId"))
			{
				facebookIntId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else if (_element.equals("userInstallId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userInstallId)) return false;
			}
			else if (_element.equals("addr_1"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, addr_1)) return false;
			}
			else if (_element.equals("city"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
			}
			else if (_element.equals("state"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("zipCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, zipCode)) return false;
			}
			else if (_element.equals("dob"))
			{
				Atf::AtfTempl<CommSrvDate>::FromXmlString(_value, dob);
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("firstName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, firstName)) return false;
			}
			else if (_element.equals("lastName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, lastName)) return false;
			}
			else if (_element.equals("sex"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, sex)) return false;
			}
			else if (_element.equals("timezone_"))
			{
				timezone_ = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientPlatform"))
			{
				clientPlatform = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientType"))
			{
				clientType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientDevice"))
			{
				clientDevice = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("appTypeEssentials"))
			{
				if(!Atf::AtfTempl< AppTypeEssentials >::FromXmlString(_value, appTypeEssentials)) return false;
			}
			else if (_element.equals("phone"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, phone)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(reqId);
	_msg.composeString(ipAddr);
	_msg.composeString(id);
	_msg.composeUINT64(facebookIntId);
	_msg.composeString(email);
	_msg.composeString(userInstallId);
	_msg.composeString(addr_1);
	_msg.composeString(city);
	_msg.composeString(state);
	_msg.composeString(country);
	_msg.composeString(zipCode);
	_msg.composeSrvDate(dob);
	_msg.composeUINT32(locale);
	_msg.composeString(firstName);
	_msg.composeString(lastName);
	_msg.composeString(sex);
	_msg.composeUINT32(timezone_);
	_msg.composeUINT32(clientPlatform);
	_msg.composeUINT32(clientType);
	_msg.composeUINT32(clientDevice);
	appTypeEssentials.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(phone);
}

void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqId);
	_parser.parseStringP(ipAddr);
	_parser.parseStringP(id);
	_parser.parseUINT64(facebookIntId);
	_parser.parseStringP(email);
	_parser.parseStringP(userInstallId);
	_parser.parseStringP(addr_1);
	_parser.parseStringP(city);
	_parser.parseStringP(state);
	_parser.parseStringP(country);
	_parser.parseStringP(zipCode);
	_parser.parseSrvDate(dob);
	_parser.parseUINT32(locale);
	_parser.parseStringP(firstName);
	_parser.parseStringP(lastName);
	_parser.parseStringP(sex);
	_parser.parseUINT32(timezone_);
	_parser.parseUINT32(clientPlatform);
	_parser.parseUINT32(clientType);
	_parser.parseUINT32(clientDevice);
	if(_parser.parseEnded()) return;
	appTypeEssentials.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(phone);
}

const char *regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reqId", reqId);
	_jsonstr.compose("ipAddr", ipAddr);
	_jsonstr.compose("id", id);
	_jsonstr.compose("facebookIntId", facebookIntId);
	_jsonstr.compose("email", email);
	_jsonstr.compose("userInstallId", userInstallId);
	_jsonstr.compose("addr_1", addr_1);
	_jsonstr.compose("city", city);
	_jsonstr.compose("state", state);
	_jsonstr.compose("country", country);
	_jsonstr.compose("zipCode", zipCode);
	_jsonstr.compose("dob", dob);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("firstName", firstName);
	_jsonstr.compose("lastName", lastName);
	_jsonstr.compose("sex", sex);
	_jsonstr.compose("timezone_", timezone_);
	_jsonstr.compose("clientPlatform", clientPlatform);
	_jsonstr.compose("clientType", clientType);
	_jsonstr.compose("clientDevice", clientDevice);
	_jsonstr.compose("appTypeEssentials", appTypeEssentials);
	_jsonstr.compose("phone", phone);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reqId", reqId);
	_jparser.parseByNameThrow("ipAddr", ipAddr);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("facebookIntId", facebookIntId);
	_jparser.parseByNameThrow("email", email);
	_jparser.parseByNameThrow("userInstallId", userInstallId);
	_jparser.parseByNameThrow("addr_1", addr_1);
	_jparser.parseByNameThrow("city", city);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("zipCode", zipCode);
	_jparser.parseByNameThrow("dob", dob);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("firstName", firstName);
	_jparser.parseByNameThrow("lastName", lastName);
	_jparser.parseByNameThrow("sex", sex);
	_jparser.parseByNameThrow("timezone_", timezone_);
	_jparser.parseByNameThrow("clientPlatform", clientPlatform);
	_jparser.parseByNameThrow("clientType", clientType);
	_jparser.parseByNameThrow("clientDevice", clientDevice);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("appTypeEssentials", appTypeEssentials);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("phone", phone);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REGISTER_NEW_USER2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 reqId; _jparser.validateByNameThrow("reqId", reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	PString ipAddr; _jparser.validateByNameThrow("ipAddr", ipAddr);
	AtfValidator::validateIntMax(_descr, "ipAddr", ipAddr.length(), IP_ADDR_LEN, _checker, __FILE__, __LINE__);
	PString id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateIntMax(_descr, "id", id.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT64 facebookIntId; _jparser.validateByNameThrow("facebookIntId", facebookIntId);
	AtfValidator::validateUint(_descr, "facebookIntId", facebookIntId, _checker, __FILE__, __LINE__);
	PString email; _jparser.validateByNameThrow("email", email);
	AtfValidator::validateIntMax(_descr, "email", email.length(), USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	PString userInstallId; _jparser.validateByNameThrow("userInstallId", userInstallId);
	AtfValidator::validateIntMax(_descr, "userInstallId", userInstallId.length(), USER_INSTALLID_LEN, _checker, __FILE__, __LINE__);
	PString addr_1; _jparser.validateByNameThrow("addr_1", addr_1);
	AtfValidator::validateIntMax(_descr, "addr_1", addr_1.length(), USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateIntMax(_descr, "city", city.length(), USER_CITY_LEN, _checker, __FILE__, __LINE__);
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateIntMax(_descr, "state", state.length(), USER_STATE_LEN, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	PString zipCode; _jparser.validateByNameThrow("zipCode", zipCode);
	AtfValidator::validateIntMax(_descr, "zipCode", zipCode.length(), USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	CommSrvDate dob; _jparser.validateByNameThrow("dob", dob);
	AtfValidator::validateSrvDateTime(_descr, "dob", dob, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	PString firstName; _jparser.validateByNameThrow("firstName", firstName);
	AtfValidator::validateIntMax(_descr, "firstName", firstName.length(), USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	PString lastName; _jparser.validateByNameThrow("lastName", lastName);
	AtfValidator::validateIntMax(_descr, "lastName", lastName.length(), USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
	PString sex; _jparser.validateByNameThrow("sex", sex);
	AtfValidator::validateIntMax(_descr, "sex", sex.length(), USER_SEX_LEN, _checker, __FILE__, __LINE__);
	UINT32 timezone_; _jparser.validateByNameThrow("timezone_", timezone_);
	AtfValidator::validateIntRange(_descr, "timezone_", timezone_, eTzUTC, eTzNumber, _checker, __FILE__, __LINE__);
	UINT32 clientPlatform; _jparser.validateByNameThrow("clientPlatform", clientPlatform);
	AtfValidator::validateIntRange(_descr, "clientPlatform", clientPlatform, Client_UnknownPlatform, Client_Last, _checker, __FILE__, __LINE__);
	UINT32 clientType; _jparser.validateByNameThrow("clientType", clientType);
	AtfValidator::validateIntRange(_descr, "clientType", clientType, ClientType_Unknown, ClientType_Last, _checker, __FILE__, __LINE__);
	UINT32 clientDevice; _jparser.validateByNameThrow("clientDevice", clientDevice);
	AtfValidator::validateIntRange(_descr, "clientDevice", clientDevice, ClientDevice_Unknown, ClientDevice_Last, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	AppTypeEssentials appTypeEssentials; _jparser.validateByNameThrow("appTypeEssentials", appTypeEssentials);
	if(_jparser.parseEnded()) return;
	PString phone; _jparser.validateByNameThrow("phone", phone);
	AtfValidator::validateIntMax(_descr, "phone", phone.length(), USER_PHONE_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REGISTER_NEW_USER2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 reqId; _parser.parseUINT32(reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ipAddr"); size_t szIpAddr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "ipAddr", szIpAddr, IP_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "id"); size_t szId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "id", szId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT64 facebookIntId; _parser.parseUINT64(facebookIntId);
	AtfValidator::validateUint(_descr, "facebookIntId", facebookIntId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userInstallId"); size_t szUserInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userInstallId", szUserInstallId, USER_INSTALLID_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "addr_1"); size_t szAddr_1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "addr_1", szAddr_1, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "zipCode"); size_t szZipCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zipCode", szZipCode, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	CommSrvDate dob; _parser.parseSrvDate(dob);
	AtfValidator::validateSrvDateTime(_descr, "dob", dob, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "firstName", szFirstName, USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "lastName"); size_t szLastName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "lastName", szLastName, USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "sex"); size_t szSex = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "sex", szSex, USER_SEX_LEN, _checker, __FILE__, __LINE__);
	UINT32 timezone_; _parser.parseUINT32(timezone_);
	AtfValidator::validateIntRange(_descr, "timezone_", timezone_, eTzUTC, eTzNumber, _checker, __FILE__, __LINE__);
	UINT32 clientPlatform; _parser.parseUINT32(clientPlatform);
	AtfValidator::validateIntRange(_descr, "clientPlatform", clientPlatform, Client_UnknownPlatform, Client_Last, _checker, __FILE__, __LINE__);
	UINT32 clientType; _parser.parseUINT32(clientType);
	AtfValidator::validateIntRange(_descr, "clientType", clientType, ClientType_Unknown, ClientType_Last, _checker, __FILE__, __LINE__);
	UINT32 clientDevice; _parser.parseUINT32(clientDevice);
	AtfValidator::validateIntRange(_descr, "clientDevice", clientDevice, ClientDevice_Unknown, ClientDevice_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	AppTypeEssentials::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("appTypeEssentials"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phone", szPhone, USER_PHONE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY()
{
	clear();
}

void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::clear()
{
	reqId = 0;
	errCode = 0;
	errDescr.clear();
	userIntId = 0;
}

bool regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::equals(const Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY& _o) const
{
	return reqId == _o.reqId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		userIntId == _o.userIntId;
}

bool regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_REGISTER_NEW_USER2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY*)_other));
}

const char *regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_REGISTER_NEW_USER2_REPLY).append(")");
	_buf.append(',');
	_buf.append("reqId=");
	_buf.appendUint(reqId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userIntId=");
		_buf.appendUint(userIntId);
	}
	return _buf.c_str();
}

const char *regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_REGISTER_NEW_USER2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("reqId", reqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reqId"))
			{
				reqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(reqId);
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(userIntId);
	}
}

void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqId);
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(userIntId);
	}
}

const char *regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reqId", reqId);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("userIntId", userIntId);
	}
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reqId", reqId);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("userIntId", userIntId);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REGISTER_NEW_USER2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	UINT32 reqId; _jparser.validateByNameThrow("reqId", reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REGISTER_NEW_USER2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	UINT32 reqId; _parser.parseUINT32(reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 userIntId; _parser.parseUINT32(userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE()
{
	clear();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::clear()
{
	reqId = 0;
	userId.clear();
	email.clear();
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::equals(const Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE& _o) const
{
	return reqId == _o.reqId &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(email, _o.email);
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_FACEBOOK_LINK_CODE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE*)_other));
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_FACEBOOK_LINK_CODE).append(")");
	_buf.append(',');
	_buf.append("reqId=");
	_buf.appendUint(reqId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	return _buf.c_str();
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_FACEBOOK_LINK_CODE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("reqId", reqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reqId"))
			{
				reqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(reqId);
	_msg.composeString(userId);
	_msg.composeString(email);
}

void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqId);
	_parser.parseStringP(userId);
	_parser.parseStringP(email);
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reqId", reqId);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("email", email);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reqId", reqId);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("email", email);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FACEBOOK_LINK_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 reqId; _jparser.validateByNameThrow("reqId", reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString email; _jparser.validateByNameThrow("email", email);
	AtfValidator::validateIntMax(_descr, "email", email.length(), USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FACEBOOK_LINK_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 reqId; _parser.parseUINT32(reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY()
{
	clear();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::clear()
{
	reqId = 0;
	errCode = 0;
	errDescr.clear();
	facebookLinkCode = 0;
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::equals(const Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY& _o) const
{
	return reqId == _o.reqId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		facebookLinkCode == _o.facebookLinkCode;
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY*)_other));
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("reqId=");
	_buf.appendUint(reqId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("facebookLinkCode=");
		_buf.appendUint(facebookLinkCode);
	}
	return _buf.c_str();
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("reqId", reqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("facebookLinkCode", facebookLinkCode, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reqId"))
			{
				reqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("facebookLinkCode"))
			{
				facebookLinkCode = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(reqId);
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(facebookLinkCode);
	}
}

void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqId);
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(facebookLinkCode);
	}
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reqId", reqId);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("facebookLinkCode", facebookLinkCode);
	}
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reqId", reqId);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("facebookLinkCode", facebookLinkCode);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	UINT32 reqId; _jparser.validateByNameThrow("reqId", reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 facebookLinkCode; _jparser.validateByNameThrow("facebookLinkCode", facebookLinkCode);
		AtfValidator::validateInt(_descr, "facebookLinkCode", facebookLinkCode, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	UINT32 reqId; _parser.parseUINT32(reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 facebookLinkCode; _parser.parseUINT32(facebookLinkCode);
		AtfValidator::validateInt(_descr, "facebookLinkCode", facebookLinkCode, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK()
{
	clear();
}

void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::clear()
{
	reqId = 0;
	userId.clear();
	facebookIntId = 0;
	linkCode = 0;
}

bool regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::equals(const Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK& _o) const
{
	return reqId == _o.reqId &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		facebookIntId == _o.facebookIntId &&
		linkCode == _o.linkCode;
}

bool regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CREATE_FACEBOOK_LINK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK*)_other));
}

const char *regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CREATE_FACEBOOK_LINK).append(")");
	_buf.append(',');
	_buf.append("reqId=");
	_buf.appendUint(reqId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("facebookIntId=");
	_buf.appendUint64(facebookIntId);
	_buf.append(',');
	_buf.append("linkCode=");
	_buf.appendUint(linkCode);
	return _buf.c_str();
}

const char *regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CREATE_FACEBOOK_LINK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("reqId", reqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("facebookIntId", facebookIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("linkCode", linkCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reqId"))
			{
				reqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("facebookIntId"))
			{
				facebookIntId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("linkCode"))
			{
				linkCode = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(reqId);
	_msg.composeString(userId);
	_msg.composeUINT64(facebookIntId);
	_msg.composeUINT32(linkCode);
}

void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqId);
	_parser.parseStringP(userId);
	_parser.parseUINT64(facebookIntId);
	_parser.parseUINT32(linkCode);
}

const char *regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reqId", reqId);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("facebookIntId", facebookIntId);
	_jsonstr.compose("linkCode", linkCode);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reqId", reqId);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("facebookIntId", facebookIntId);
	_jparser.parseByNameThrow("linkCode", linkCode);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CREATE_FACEBOOK_LINK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 reqId; _jparser.validateByNameThrow("reqId", reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT64 facebookIntId; _jparser.validateByNameThrow("facebookIntId", facebookIntId);
	AtfValidator::validateUint(_descr, "facebookIntId", facebookIntId, _checker, __FILE__, __LINE__);
	UINT32 linkCode; _jparser.validateByNameThrow("linkCode", linkCode);
	AtfValidator::validateInt(_descr, "linkCode", linkCode, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CREATE_FACEBOOK_LINK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 reqId; _parser.parseUINT32(reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT64 facebookIntId; _parser.parseUINT64(facebookIntId);
	AtfValidator::validateUint(_descr, "facebookIntId", facebookIntId, _checker, __FILE__, __LINE__);
	UINT32 linkCode; _parser.parseUINT32(linkCode);
	AtfValidator::validateInt(_descr, "linkCode", linkCode, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY()
{
	clear();
}

void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::clear()
{
	reqId = 0;
	errCode = 0;
	errDescr.clear();
	userIntId = 0;
	userId.clear();
}

bool regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::equals(const Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY& _o) const
{
	return reqId == _o.reqId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		userIntId == _o.userIntId &&
		Atf::atfPStringEquals(userId, _o.userId);
}

bool regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY*)_other));
}

const char *regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY).append(")");
	_buf.append(',');
	_buf.append("reqId=");
	_buf.appendUint(reqId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userIntId=");
		_buf.appendUint(userIntId);
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
	}
	return _buf.c_str();
}

const char *regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("reqId", reqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
		Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reqId"))
			{
				reqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(reqId);
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(userIntId);
		_msg.composeString(userId);
	}
}

void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqId);
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(userIntId);
		_parser.parseStringP(userId);
	}
}

const char *regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reqId", reqId);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("userIntId", userIntId);
		_jsonstr.compose("userId", userId);
	}
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reqId", reqId);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("userIntId", userIntId);
		_jparser.parseByNameThrow("userId", userId);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	UINT32 reqId; _jparser.validateByNameThrow("reqId", reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
		PString userId; _jparser.validateByNameThrow("userId", userId);
		AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	UINT32 reqId; _parser.parseUINT32(reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 userIntId; _parser.parseUINT32(userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_COMM_PREFS
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::Protocol_MSG_REGULATOR_SET_COMM_PREFS()
{
	clear();
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::clear()
{
	token.clear();
	poker = false;
	casino = false;
	sports = false;
}

bool regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::equals(const Protocol_MSG_REGULATOR_SET_COMM_PREFS& _o) const
{
	return Atf::atfPStringEquals(token, _o.token) &&
		poker == _o.poker &&
		casino == _o.casino &&
		sports == _o.sports;
}

bool regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SET_COMM_PREFS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SET_COMM_PREFS*)_other));
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_COMM_PREFS).append(")");
	_buf.append(',');
	_buf.append("token=");
	_buf.append(token);
	_buf.append(',');
	_buf.append("poker=");
	_buf.appendUint(poker);
	_buf.append(',');
	_buf.append("casino=");
	_buf.appendUint(casino);
	_buf.append(',');
	_buf.append("sports=");
	_buf.appendUint(sports);
	return _buf.c_str();
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SET_COMM_PREFS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("token", token, _buf);
	Atf::XmlElement::encodeAsXmlElement("poker", poker, _buf);
	Atf::XmlElement::encodeAsXmlElement("casino", casino, _buf);
	Atf::XmlElement::encodeAsXmlElement("sports", sports, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("token"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, token)) return false;
			}
			else if (_element.equals("poker"))
			{
				poker = (*_value.ptr() == '1');
			}
			else if (_element.equals("casino"))
			{
				casino = (*_value.ptr() == '1');
			}
			else if (_element.equals("sports"))
			{
				sports = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(token);
	_msg.composeBOOL(poker);
	_msg.composeBOOL(casino);
	_msg.composeBOOL(sports);
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(token);
	_parser.parseBOOL(poker);
	_parser.parseBOOL(casino);
	_parser.parseBOOL(sports);
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("token", token);
	_jsonstr.compose("poker", poker);
	_jsonstr.compose("casino", casino);
	_jsonstr.compose("sports", sports);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("token", token);
	_jparser.parseByNameThrow("poker", poker);
	_jparser.parseByNameThrow("casino", casino);
	_jparser.parseByNameThrow("sports", sports);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_COMM_PREFS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString token; _jparser.validateByNameThrow("token", token);
	AtfValidator::validateIntMax(_descr, "token", token.length(), 4096, _checker, __FILE__, __LINE__);
	bool poker; _jparser.validateByNameThrow("poker", poker);
	AtfValidator::validateInt(_descr, "poker", poker, _checker, __FILE__, __LINE__);
	bool casino; _jparser.validateByNameThrow("casino", casino);
	AtfValidator::validateInt(_descr, "casino", casino, _checker, __FILE__, __LINE__);
	bool sports; _jparser.validateByNameThrow("sports", sports);
	AtfValidator::validateInt(_descr, "sports", sports, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_COMM_PREFS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "token"); size_t szToken = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "token", szToken, 4096, _checker, __FILE__, __LINE__);
	bool poker; _parser.parseBOOL(poker);
	AtfValidator::validateInt(_descr, "poker", poker, _checker, __FILE__, __LINE__);
	bool casino; _parser.parseBOOL(casino);
	AtfValidator::validateInt(_descr, "casino", casino, _checker, __FILE__, __LINE__);
	bool sports; _parser.parseBOOL(sports);
	AtfValidator::validateInt(_descr, "sports", sports, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY()
{
	clear();
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::equals(const Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SET_COMM_PREFS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY*)_other));
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_COMM_PREFS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SET_COMM_PREFS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_COMM_PREFS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_COMM_PREFS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_COMM_PREFS
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::Protocol_MSG_REGULATOR_GET_COMM_PREFS()
{
	clear();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::clear()
{
	token.clear();
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::equals(const Protocol_MSG_REGULATOR_GET_COMM_PREFS& _o) const
{
	return Atf::atfPStringEquals(token, _o.token);
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_COMM_PREFS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_COMM_PREFS*)_other));
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_COMM_PREFS).append(")");
	_buf.append(',');
	_buf.append("token=");
	_buf.append(token);
	return _buf.c_str();
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_COMM_PREFS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("token", token, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("token"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, token)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(token);
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(token);
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("token", token);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("token", token);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_COMM_PREFS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString token; _jparser.validateByNameThrow("token", token);
	AtfValidator::validateIntMax(_descr, "token", token.length(), 4096, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_COMM_PREFS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "token"); size_t szToken = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "token", szToken, 4096, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY()
{
	clear();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	userId.clear();
	poker = false;
	casino = false;
	sports = false;
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::equals(const Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		poker == _o.poker &&
		casino == _o.casino &&
		sports == _o.sports;
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_COMM_PREFS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY*)_other));
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_COMM_PREFS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
		_buf.append(',');
		_buf.append("poker=");
		_buf.appendUint(poker);
		_buf.append(',');
		_buf.append("casino=");
		_buf.appendUint(casino);
		_buf.append(',');
		_buf.append("sports=");
		_buf.appendUint(sports);
	}
	return _buf.c_str();
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_COMM_PREFS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
		Atf::XmlElement::encodeAsXmlElement("poker", poker, _buf);
		Atf::XmlElement::encodeAsXmlElement("casino", casino, _buf);
		Atf::XmlElement::encodeAsXmlElement("sports", sports, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("poker"))
			{
				poker = (*_value.ptr() == '1');
			}
			else if (_element.equals("casino"))
			{
				casino = (*_value.ptr() == '1');
			}
			else if (_element.equals("sports"))
			{
				sports = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(userId);
		_msg.composeBOOL(poker);
		_msg.composeBOOL(casino);
		_msg.composeBOOL(sports);
	}
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(userId);
		_parser.parseBOOL(poker);
		_parser.parseBOOL(casino);
		_parser.parseBOOL(sports);
	}
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("userId", userId);
		_jsonstr.compose("poker", poker);
		_jsonstr.compose("casino", casino);
		_jsonstr.compose("sports", sports);
	}
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("userId", userId);
		_jparser.parseByNameThrow("poker", poker);
		_jparser.parseByNameThrow("casino", casino);
		_jparser.parseByNameThrow("sports", sports);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_COMM_PREFS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString userId; _jparser.validateByNameThrow("userId", userId);
		AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
		bool poker; _jparser.validateByNameThrow("poker", poker);
		AtfValidator::validateInt(_descr, "poker", poker, _checker, __FILE__, __LINE__);
		bool casino; _jparser.validateByNameThrow("casino", casino);
		AtfValidator::validateInt(_descr, "casino", casino, _checker, __FILE__, __LINE__);
		bool sports; _jparser.validateByNameThrow("sports", sports);
		AtfValidator::validateInt(_descr, "sports", sports, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_COMM_PREFS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
		bool poker; _parser.parseBOOL(poker);
		AtfValidator::validateInt(_descr, "poker", poker, _checker, __FILE__, __LINE__);
		bool casino; _parser.parseBOOL(casino);
		AtfValidator::validateInt(_descr, "casino", casino, _checker, __FILE__, __LINE__);
		bool sports; _parser.parseBOOL(sports);
		AtfValidator::validateInt(_descr, "sports", sports, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV()
{
	clear();
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::clear()
{
	userId.clear();
	poker = false;
	casino = false;
	sports = false;
}

bool regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::equals(const Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		poker == _o.poker &&
		casino == _o.casino &&
		sports == _o.sports;
}

bool regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SET_COMM_PREFS_SV != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV*)_other));
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_COMM_PREFS_SV).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("poker=");
	_buf.appendUint(poker);
	_buf.append(',');
	_buf.append("casino=");
	_buf.appendUint(casino);
	_buf.append(',');
	_buf.append("sports=");
	_buf.appendUint(sports);
	return _buf.c_str();
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SET_COMM_PREFS_SV).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("poker", poker, _buf);
	Atf::XmlElement::encodeAsXmlElement("casino", casino, _buf);
	Atf::XmlElement::encodeAsXmlElement("sports", sports, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("poker"))
			{
				poker = (*_value.ptr() == '1');
			}
			else if (_element.equals("casino"))
			{
				casino = (*_value.ptr() == '1');
			}
			else if (_element.equals("sports"))
			{
				sports = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeBOOL(poker);
	_msg.composeBOOL(casino);
	_msg.composeBOOL(sports);
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseBOOL(poker);
	_parser.parseBOOL(casino);
	_parser.parseBOOL(sports);
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("poker", poker);
	_jsonstr.compose("casino", casino);
	_jsonstr.compose("sports", sports);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("poker", poker);
	_jparser.parseByNameThrow("casino", casino);
	_jparser.parseByNameThrow("sports", sports);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_COMM_PREFS_SV";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	bool poker; _jparser.validateByNameThrow("poker", poker);
	AtfValidator::validateInt(_descr, "poker", poker, _checker, __FILE__, __LINE__);
	bool casino; _jparser.validateByNameThrow("casino", casino);
	AtfValidator::validateInt(_descr, "casino", casino, _checker, __FILE__, __LINE__);
	bool sports; _jparser.validateByNameThrow("sports", sports);
	AtfValidator::validateInt(_descr, "sports", sports, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_COMM_PREFS_SV";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	bool poker; _parser.parseBOOL(poker);
	AtfValidator::validateInt(_descr, "poker", poker, _checker, __FILE__, __LINE__);
	bool casino; _parser.parseBOOL(casino);
	AtfValidator::validateInt(_descr, "casino", casino, _checker, __FILE__, __LINE__);
	bool sports; _parser.parseBOOL(sports);
	AtfValidator::validateInt(_descr, "sports", sports, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY()
{
	clear();
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::equals(const Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY*)_other));
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV()
{
	clear();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::clear()
{
	userIntId = 0;
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::equals(const Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV& _o) const
{
	return userIntId == _o.userIntId;
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_COMM_PREFS_SV != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV*)_other));
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_COMM_PREFS_SV).append(")");
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	return _buf.c_str();
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_COMM_PREFS_SV).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(userIntId);
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(userIntId);
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntId", userIntId);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntId", userIntId);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_COMM_PREFS_SV";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_COMM_PREFS_SV";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY()
{
	clear();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	userId.clear();
	poker = false;
	casino = false;
	sports = false;
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::equals(const Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		poker == _o.poker &&
		casino == _o.casino &&
		sports == _o.sports;
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY*)_other));
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
		_buf.append(',');
		_buf.append("poker=");
		_buf.appendUint(poker);
		_buf.append(',');
		_buf.append("casino=");
		_buf.appendUint(casino);
		_buf.append(',');
		_buf.append("sports=");
		_buf.appendUint(sports);
	}
	return _buf.c_str();
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
		Atf::XmlElement::encodeAsXmlElement("poker", poker, _buf);
		Atf::XmlElement::encodeAsXmlElement("casino", casino, _buf);
		Atf::XmlElement::encodeAsXmlElement("sports", sports, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("poker"))
			{
				poker = (*_value.ptr() == '1');
			}
			else if (_element.equals("casino"))
			{
				casino = (*_value.ptr() == '1');
			}
			else if (_element.equals("sports"))
			{
				sports = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(userId);
		_msg.composeBOOL(poker);
		_msg.composeBOOL(casino);
		_msg.composeBOOL(sports);
	}
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(userId);
		_parser.parseBOOL(poker);
		_parser.parseBOOL(casino);
		_parser.parseBOOL(sports);
	}
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("userId", userId);
		_jsonstr.compose("poker", poker);
		_jsonstr.compose("casino", casino);
		_jsonstr.compose("sports", sports);
	}
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("userId", userId);
		_jparser.parseByNameThrow("poker", poker);
		_jparser.parseByNameThrow("casino", casino);
		_jparser.parseByNameThrow("sports", sports);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString userId; _jparser.validateByNameThrow("userId", userId);
		AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
		bool poker; _jparser.validateByNameThrow("poker", poker);
		AtfValidator::validateInt(_descr, "poker", poker, _checker, __FILE__, __LINE__);
		bool casino; _jparser.validateByNameThrow("casino", casino);
		AtfValidator::validateInt(_descr, "casino", casino, _checker, __FILE__, __LINE__);
		bool sports; _jparser.validateByNameThrow("sports", sports);
		AtfValidator::validateInt(_descr, "sports", sports, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
		bool poker; _parser.parseBOOL(poker);
		AtfValidator::validateInt(_descr, "poker", poker, _checker, __FILE__, __LINE__);
		bool casino; _parser.parseBOOL(casino);
		AtfValidator::validateInt(_descr, "casino", casino, _checker, __FILE__, __LINE__);
		bool sports; _parser.parseBOOL(sports);
		AtfValidator::validateInt(_descr, "sports", sports, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN
//=================================================================

regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN()
{
	clear();
}

void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::clear()
{
}

bool regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::equals(const Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN& _o) const
{
	return true;
}

bool regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN*)_other));
}

const char *regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN).append(")");
	return _buf.c_str();
}

const char *regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::parseMsg(CommMsgParser& _parser)
{
}

const char *regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY
//=================================================================

regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY()
{
	clear();
}

void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	token.clear();
	tokenSignature.clear();
	userIntId = 0;
}

bool regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::equals(const Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(token, _o.token) &&
		Atf::atfPStringEquals(tokenSignature, _o.tokenSignature) &&
		userIntId == _o.userIntId;
}

bool regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY*)_other));
}

const char *regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("token=");
		_buf.append(token);
		_buf.append(',');
		_buf.append("tokenSignature=");
		_buf.append(tokenSignature);
		_buf.append(',');
		_buf.append("userIntId=");
		_buf.appendUint(userIntId);
	}
	return _buf.c_str();
}

const char *regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("token", token, _buf);
		Atf::XmlElement::encodeAsXmlElement("tokenSignature", tokenSignature, _buf);
		Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("token"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, token)) return false;
			}
			else if (_element.equals("tokenSignature"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tokenSignature)) return false;
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(token);
		_msg.composeString(tokenSignature);
		_msg.composeUINT32(userIntId);
	}
}

void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(token);
		_parser.parseStringP(tokenSignature);
		_parser.parseUINT32(userIntId);
	}
}

const char *regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("token", token);
		_jsonstr.compose("tokenSignature", tokenSignature);
		_jsonstr.compose("userIntId", userIntId);
	}
	return _buf.c_str();
}

void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("token", token);
		_jparser.parseByNameThrow("tokenSignature", tokenSignature);
		_jparser.parseByNameThrow("userIntId", userIntId);
	}
}

/*static*/ void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString token; _jparser.validateByNameThrow("token", token);
		AtfValidator::validateInt(_descr, "token", token.length(), _checker, __FILE__, __LINE__);
		PString tokenSignature; _jparser.validateByNameThrow("tokenSignature", tokenSignature);
		AtfValidator::validateInt(_descr, "tokenSignature", tokenSignature.length(), _checker, __FILE__, __LINE__);
		UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "token"); size_t szToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "token", szToken, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tokenSignature"); size_t szTokenSignature = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tokenSignature", szTokenSignature, _checker, __FILE__, __LINE__);
		UINT32 userIntId; _parser.parseUINT32(userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY
//=================================================================

regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY()
{
	clear();
}

void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::clear()
{
	userIdNotUsed.clear();
}

bool regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::equals(const Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY& _o) const
{
	return Atf::atfPStringEquals(userIdNotUsed, _o.userIdNotUsed);
}

bool regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SUPPORT_EMAIL_READY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY*)_other));
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SUPPORT_EMAIL_READY).append(")");
	_buf.append(',');
	_buf.append("userIdNotUsed=");
	_buf.append(userIdNotUsed);
	return _buf.c_str();
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SUPPORT_EMAIL_READY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userIdNotUsed", userIdNotUsed, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userIdNotUsed"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userIdNotUsed)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userIdNotUsed);
}

void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(userIdNotUsed);
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIdNotUsed", userIdNotUsed);
	return _buf.c_str();
}

void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("userIdNotUsed", userIdNotUsed);
}

/*static*/ void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUPPORT_EMAIL_READY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString userIdNotUsed; _jparser.validateByNameThrow("userIdNotUsed", userIdNotUsed);
	AtfValidator::validateIntMax(_descr, "userIdNotUsed", userIdNotUsed.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUPPORT_EMAIL_READY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "userIdNotUsed"); size_t szUserIdNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userIdNotUsed", szUserIdNotUsed, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY
//=================================================================

regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY()
{
	clear();
}

void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::equals(const Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY*)_other));
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL
//=================================================================

regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL()
{
	clear();
}

void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::clear()
{
	body.clear();
}

bool regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::equals(const Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL& _o) const
{
	return body.equals(_o.body);
}

bool regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL*)_other));
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL).append(")");
	_buf.append(',');
	_buf.append("body=");
	body.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	body.toXmlString("body", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("body"))
			{
				if(!Atf::AtfTempl< common_structs::LobbyClientToSupportEmailStruct >::FromXmlString(_value, body)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	body.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::parseMsg(CommMsgParser& _parser)
{
	body.parseMsg(_parser);
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("body", body);
	return _buf.c_str();
}

void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("body", body);
}

/*static*/ void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::LobbyClientToSupportEmailStruct body; _jparser.validateByNameThrow("body", body);
}

/*static*/ void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::LobbyClientToSupportEmailStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("body"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY
//=================================================================

regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY()
{
	clear();
}

void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::clear()
{
	replyBody.clear();
}

bool regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::equals(const Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY& _o) const
{
	return replyBody.equals(_o.replyBody);
}

bool regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY*)_other));
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY).append(")");
	_buf.append(',');
	_buf.append("replyBody=");
	replyBody.toTraceString(_buf);
	return _buf.c_str();
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	replyBody.toXmlString("replyBody", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("replyBody"))
			{
				if(!Atf::AtfTempl< common_structs::LobbyClientToSupportEmailReplyStruct >::FromXmlString(_value, replyBody)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	replyBody.composeMsg(_msg, _ignoreJSON);
}

void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::parseMsg(CommMsgParser& _parser)
{
	replyBody.parseMsg(_parser);
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("replyBody", replyBody);
	return _buf.c_str();
}

void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("replyBody", replyBody);
}

/*static*/ void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::LobbyClientToSupportEmailReplyStruct replyBody; _jparser.validateByNameThrow("replyBody", replyBody);
}

/*static*/ void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::LobbyClientToSupportEmailReplyStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("replyBody"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* regulator::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "Asia"))
	{
		switch(_msgId)
		{
			case MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN: _obj = new Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN(); break;
			case MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY: _obj = new Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY(); break;
		}
	}
	else if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED: _obj = new cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED(); break;
			case MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY: _obj = new cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY(); break;
			case MSG_CASHIER_LOOKUP_FISCAL_CODE: _obj = new cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE(); break;
			case MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY: _obj = new cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY(); break;
			case MSG_CASHIER_SET_RMF_BANKACCOUNT: _obj = new cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT(); break;
			case MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY(); break;
			case MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL: _obj = new cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL(); break;
			case MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY: _obj = new cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY(); break;
			case MSG_LOBBY_SAVE_CONSENT: _obj = new cli::Protocol_MSG_LOBBY_SAVE_CONSENT(); break;
			case MSG_LOBBY_SAVE_CONSENT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY(); break;
			case MSG_LOBBY_SUPPORT_EMAIL_READY: _obj = new cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY(); break;
			case MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY: _obj = new cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY(); break;
			case MSG_LOBBY_UPDATE_USER2: _obj = new cli::Protocol_MSG_LOBBY_UPDATE_USER2(); break;
			case MSG_LOBBY_UPDATE_USER2_REPLY: _obj = new cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY(); break;
			case MSG_REGULATOR_CHALLENGE_QUESTION: _obj = new cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION(); break;
			case MSG_REGULATOR_CHALLENGE_QUESTION_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY(); break;
			case MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED: _obj = new cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED(); break;
			case MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY(); break;
			case MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE: _obj = new cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE(); break;
			case MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY(); break;
			case MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE: _obj = new cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE(); break;
			case MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY(); break;
			case MSG_REGULATOR_CLIENT_FTPLAUNCHER: _obj = new cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER(); break;
			case MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY(); break;
			case MSG_REGULATOR_CONFIRMED_USER_LIMITS: _obj = new cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS(); break;
			case MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY(); break;
			case MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR: _obj = new cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR(); break;
			case MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY(); break;
			case MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION: _obj = new cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION(); break;
			case MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY(); break;
			case MSG_REGULATOR_EULA_TERMS_SIGNED: _obj = new cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED(); break;
			case MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY(); break;
			case MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION: _obj = new cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION(); break;
			case MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY(); break;
			case MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM: _obj = new cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM(); break;
			case MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY(); break;
			case MSG_REGULATOR_GET_ASIA_GAMING_URL: _obj = new cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL(); break;
			case MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY(); break;
			case MSG_REGULATOR_GET_CONFIG_INFO: _obj = new cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO(); break;
			case MSG_REGULATOR_GET_CONFIG_INFO_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY(); break;
			case MSG_REGULATOR_GET_FACEBOOK_LINK_CODE: _obj = new cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE(); break;
			case MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY(); break;
			case MSG_REGULATOR_GET_FTP_PAIRING_CODE: _obj = new cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE(); break;
			case MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY(); break;
			case MSG_REGULATOR_GET_LAST_LOGIN_DETAILS: _obj = new cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS(); break;
			case MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY(); break;
			case MSG_REGULATOR_GET_SWISS_URL: _obj = new cli::Protocol_MSG_REGULATOR_GET_SWISS_URL(); break;
			case MSG_REGULATOR_GET_SWISS_URL_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY(); break;
			case MSG_REGULATOR_GET_USER_BLACKLIST_INFO: _obj = new cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO(); break;
			case MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY(); break;
			case MSG_REGULATOR_GET_USER_SESSION_WINNINGS: _obj = new cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS(); break;
			case MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY(); break;
			case MSG_REGULATOR_GET_USER_WINNINGS: _obj = new cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS(); break;
			case MSG_REGULATOR_GET_USER_WINNINGS_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY(); break;
			case MSG_REGULATOR_MATCH_ZIP_CODE: _obj = new cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE(); break;
			case MSG_REGULATOR_MATCH_ZIP_CODE_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY(); break;
			case MSG_REGULATOR_MIGRATION_CHECK_ONLY: _obj = new cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY(); break;
			case MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY(); break;
			case MSG_REGULATOR_MIGRATION_GET_INFO: _obj = new cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO(); break;
			case MSG_REGULATOR_MIGRATION_GET_INFO_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY(); break;
			case MSG_REGULATOR_MIGRATION_PERFORM: _obj = new cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM(); break;
			case MSG_REGULATOR_MIGRATION_PERFORM_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY(); break;
			case MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT: _obj = new cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT(); break;
			case MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY(); break;
			case MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS: _obj = new cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS(); break;
			case MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY(); break;
			case MSG_REGULATOR_REQUEST_USER_BLACKLISTED: _obj = new cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED(); break;
			case MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY(); break;
			case MSG_REGULATOR_RESET_PWD: _obj = new cli::Protocol_MSG_REGULATOR_RESET_PWD(); break;
			case MSG_REGULATOR_RESET_PWD_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY(); break;
			case MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER: _obj = new cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER(); break;
			case MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY(); break;
			case MSG_REGULATOR_SET_PROMO_CODE: _obj = new cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE(); break;
			case MSG_REGULATOR_SET_PROMO_CODE_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY(); break;
			case MSG_REGULATOR_SET_PWD_REMINDER: _obj = new cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER(); break;
			case MSG_REGULATOR_SET_PWD_REMINDER_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY(); break;
			case MSG_REGULATOR_SET_RATE_MOBILE_FLAG: _obj = new cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG(); break;
			case MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY(); break;
			case MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG: _obj = new cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG(); break;
			case MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY(); break;
			case MSG_REGULATOR_SE_BANKID_COLLECT: _obj = new cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT(); break;
			case MSG_REGULATOR_SE_BANKID_COLLECT_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY(); break;
			case MSG_REGULATOR_SE_BANKID_VERIFY: _obj = new cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY(); break;
			case MSG_REGULATOR_SE_BANKID_VERIFY_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY(); break;
			case MSG_REGULATOR_USER_GET_INFO: _obj = new cli::Protocol_MSG_REGULATOR_USER_GET_INFO(); break;
			case MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS: _obj = new cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS(); break;
			case MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY(); break;
			case MSG_REGULATOR_USER_GET_INFO_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY(); break;
			case MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS: _obj = new cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS(); break;
			case MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY(); break;
			case MSG_REGULATOR_VALIDATE_USER_UPDATE: _obj = new cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE(); break;
			case MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY: _obj = new cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY(); break;
		}
	}
	else if(!strcmp(_nameSpace, "cli_docs"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL: _obj = new cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL(); break;
			case MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY: _obj = new cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY(); break;
			case MSG_LOBBY_SUPPORT_EMAIL_READY: _obj = new cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY(); break;
			case MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY: _obj = new cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY(); break;
		}
	}
	else if(!strcmp(_nameSpace, "cli_unauth"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_COMPARE_SITE_FOR_IP: _obj = new cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP(); break;
			case MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY: _obj = new cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY(); break;
			case MSG_LOBBY_NAME_AVAILABLE: _obj = new cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE(); break;
			case MSG_LOBBY_NAME_AVAILABLE_REPLY: _obj = new cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY(); break;
			case MSG_LOBBY_REGISTER_NEW_USER: _obj = new cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER(); break;
			case MSG_LOBBY_REGISTER_NEW_USER_REPLY: _obj = new cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY(); break;
			case MSG_LOBBY_REMIND_SID: _obj = new cli_unauth::Protocol_MSG_LOBBY_REMIND_SID(); break;
			case MSG_LOBBY_REMIND_SID_REPLY: _obj = new cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY(); break;
			case MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP: _obj = new cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP(); break;
			case MSG_LOBBY_RETRIEVE_USERID: _obj = new cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID(); break;
			case MSG_LOBBY_RETRIEVE_USERID_REPLY: _obj = new cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY(); break;
			case MSG_LOBBY_SIGNUP_QUESTIONNAIRE: _obj = new cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE(); break;
			case MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY: _obj = new cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY(); break;
			case MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN: _obj = new cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN(); break;
			case MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY(); break;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED: _obj = new cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED(); break;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY(); break;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC: _obj = new cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC(); break;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY(); break;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS: _obj = new cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS(); break;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY(); break;
			case MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION: _obj = new cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION(); break;
			case MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY(); break;
			case MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD: _obj = new cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD(); break;
			case MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY(); break;
			case MSG_REGULATOR_EMAIL_AVAILABLE: _obj = new cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE(); break;
			case MSG_REGULATOR_EMAIL_AVAILABLE_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY(); break;
			case MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS: _obj = new cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS(); break;
			case MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY(); break;
			case MSG_REGULATOR_GET_SWISS_URL: _obj = new cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL(); break;
			case MSG_REGULATOR_GET_SWISS_URL_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY(); break;
			case MSG_REGULATOR_PWD_RESET_QUESTIONS: _obj = new cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS(); break;
			case MSG_REGULATOR_PWD_RESET_QUESTIONS2: _obj = new cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2(); break;
			case MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY(); break;
			case MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY(); break;
			case MSG_REGULATOR_RESET_PWD: _obj = new cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD(); break;
			case MSG_REGULATOR_RESET_PWD_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY(); break;
			case MSG_REGULATOR_RETRIEVE_USERID2: _obj = new cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2(); break;
			case MSG_REGULATOR_RETRIEVE_USERID2_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY(); break;
			case MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL: _obj = new cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL(); break;
			case MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY(); break;
			case MSG_REGULATOR_SET_PRIV_NO_SURVEY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY(); break;
			case MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY(); break;
			case MSG_REGULATOR_SMS_RESET_PWD: _obj = new cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD(); break;
			case MSG_REGULATOR_SMS_RESET_PWD_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY(); break;
			case MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2: _obj = new cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2(); break;
			case MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY(); break;
			case MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY(); break;
			case MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY(); break;
			case MSG_REGULATOR_VALIDATE_USER_UPDATE: _obj = new cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE(); break;
			case MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY(); break;
			case MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO: _obj = new cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO(); break;
			case MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY(); break;
			case MSG_REGULATOR_WEB_PWD_SET_NEW_PWD: _obj = new cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD(); break;
			case MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY: _obj = new cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY(); break;
		}
	}
	else if(!strcmp(_nameSpace, "core"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_NAME_AVAILABLE: _obj = new core::Protocol_MSG_LOBBY_NAME_AVAILABLE(); break;
			case MSG_LOBBY_NAME_AVAILABLE_REPLY: _obj = new core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY(); break;
			case MSG_REGULATOR_CREATE_FACEBOOK_LINK: _obj = new core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK(); break;
			case MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY: _obj = new core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY(); break;
			case MSG_REGULATOR_GET_COMM_PREFS: _obj = new core::Protocol_MSG_REGULATOR_GET_COMM_PREFS(); break;
			case MSG_REGULATOR_GET_COMM_PREFS_REPLY: _obj = new core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY(); break;
			case MSG_REGULATOR_GET_COMM_PREFS_SV: _obj = new core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV(); break;
			case MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY: _obj = new core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY(); break;
			case MSG_REGULATOR_GET_FACEBOOK_LINK_CODE: _obj = new core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE(); break;
			case MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY: _obj = new core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY(); break;
			case MSG_REGULATOR_REGISTER_NEW_USER2: _obj = new core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2(); break;
			case MSG_REGULATOR_REGISTER_NEW_USER2_REPLY: _obj = new core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY(); break;
			case MSG_REGULATOR_SET_COMM_PREFS: _obj = new core::Protocol_MSG_REGULATOR_SET_COMM_PREFS(); break;
			case MSG_REGULATOR_SET_COMM_PREFS_REPLY: _obj = new core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY(); break;
			case MSG_REGULATOR_SET_COMM_PREFS_SV: _obj = new core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV(); break;
			case MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY: _obj = new core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool regulator::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "Asia"))
	{
		switch(_msgId)
		{
			case MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN: Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY: Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED: cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY: cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_LOOKUP_FISCAL_CODE: cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY: cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_RMF_BANKACCOUNT: cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL: cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY: cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SAVE_CONSENT: cli::Protocol_MSG_LOBBY_SAVE_CONSENT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SAVE_CONSENT_REPLY: cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUPPORT_EMAIL_READY: cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY: cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_USER2: cli::Protocol_MSG_LOBBY_UPDATE_USER2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_USER2_REPLY: cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHALLENGE_QUESTION: cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHALLENGE_QUESTION_REPLY: cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED: cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY: cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE: cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY: cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE: cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY: cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLIENT_FTPLAUNCHER: cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY: cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CONFIRMED_USER_LIMITS: cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY: cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR: cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY: cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION: cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY: cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_EULA_TERMS_SIGNED: cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY: cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION: cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY: cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM: cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY: cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_ASIA_GAMING_URL: cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY: cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_CONFIG_INFO: cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_CONFIG_INFO_REPLY: cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FACEBOOK_LINK_CODE: cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY: cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FTP_PAIRING_CODE: cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY: cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_LAST_LOGIN_DETAILS: cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY: cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_SWISS_URL: cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_SWISS_URL_REPLY: cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_BLACKLIST_INFO: cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY: cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_SESSION_WINNINGS: cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY: cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_WINNINGS: cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_WINNINGS_REPLY: cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MATCH_ZIP_CODE: cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MATCH_ZIP_CODE_REPLY: cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_CHECK_ONLY: cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY: cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_GET_INFO: cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_GET_INFO_REPLY: cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_PERFORM: cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_PERFORM_REPLY: cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT: cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY: cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS: cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY: cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REQUEST_USER_BLACKLISTED: cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY: cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RESET_PWD: cli::Protocol_MSG_REGULATOR_RESET_PWD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RESET_PWD_REPLY: cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER: cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY: cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PROMO_CODE: cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PROMO_CODE_REPLY: cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PWD_REMINDER: cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PWD_REMINDER_REPLY: cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_RATE_MOBILE_FLAG: cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY: cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG: cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY: cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SE_BANKID_COLLECT: cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SE_BANKID_COLLECT_REPLY: cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SE_BANKID_VERIFY: cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SE_BANKID_VERIFY_REPLY: cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_USER_GET_INFO: cli::Protocol_MSG_REGULATOR_USER_GET_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS: cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY: cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_USER_GET_INFO_REPLY: cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS: cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY: cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_USER_UPDATE: cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY: cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli_docs"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL: cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY: cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUPPORT_EMAIL_READY: cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY: cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli_unauth"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_COMPARE_SITE_FOR_IP: cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY: cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_NAME_AVAILABLE: cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_NAME_AVAILABLE_REPLY: cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REGISTER_NEW_USER: cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REGISTER_NEW_USER_REPLY: cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REMIND_SID: cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REMIND_SID_REPLY: cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP: cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RETRIEVE_USERID: cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RETRIEVE_USERID_REPLY: cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SIGNUP_QUESTIONNAIRE: cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY: cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN: cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY: cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION: cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY: cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD: cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY: cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_EMAIL_AVAILABLE: cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_EMAIL_AVAILABLE_REPLY: cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS: cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY: cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_SWISS_URL: cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_SWISS_URL_REPLY: cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_PWD_RESET_QUESTIONS: cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_PWD_RESET_QUESTIONS2: cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY: cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY: cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RESET_PWD: cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RESET_PWD_REPLY: cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RETRIEVE_USERID2: cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RETRIEVE_USERID2_REPLY: cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL: cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY: cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PRIV_NO_SURVEY: cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY: cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SMS_RESET_PWD: cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SMS_RESET_PWD_REPLY: cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_USER_UPDATE: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO: cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY: cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_WEB_PWD_SET_NEW_PWD: cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY: cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "core"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_NAME_AVAILABLE: core::Protocol_MSG_LOBBY_NAME_AVAILABLE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_NAME_AVAILABLE_REPLY: core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CREATE_FACEBOOK_LINK: core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY: core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_COMM_PREFS: core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_COMM_PREFS_REPLY: core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_COMM_PREFS_SV: core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY: core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FACEBOOK_LINK_CODE: core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY: core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REGISTER_NEW_USER2: core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REGISTER_NEW_USER2_REPLY: core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_COMM_PREFS: core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_COMM_PREFS_REPLY: core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_COMM_PREFS_SV: core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY: core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool regulator::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "Asia"))
	{
		switch(_msgId)
		{
			case MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN: Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY: Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED: cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY: cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_LOOKUP_FISCAL_CODE: cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY: cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_RMF_BANKACCOUNT: cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL: cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY: cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SAVE_CONSENT: cli::Protocol_MSG_LOBBY_SAVE_CONSENT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SAVE_CONSENT_REPLY: cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUPPORT_EMAIL_READY: cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY: cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_USER2: cli::Protocol_MSG_LOBBY_UPDATE_USER2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_USER2_REPLY: cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHALLENGE_QUESTION: cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHALLENGE_QUESTION_REPLY: cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED: cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY: cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE: cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY: cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE: cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY: cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLIENT_FTPLAUNCHER: cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY: cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CONFIRMED_USER_LIMITS: cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY: cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR: cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY: cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION: cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY: cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_EULA_TERMS_SIGNED: cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY: cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION: cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY: cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM: cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY: cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_ASIA_GAMING_URL: cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY: cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_CONFIG_INFO: cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_CONFIG_INFO_REPLY: cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FACEBOOK_LINK_CODE: cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY: cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FTP_PAIRING_CODE: cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY: cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_LAST_LOGIN_DETAILS: cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY: cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_SWISS_URL: cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_SWISS_URL_REPLY: cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_BLACKLIST_INFO: cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY: cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_SESSION_WINNINGS: cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY: cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_WINNINGS: cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_WINNINGS_REPLY: cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MATCH_ZIP_CODE: cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MATCH_ZIP_CODE_REPLY: cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_CHECK_ONLY: cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY: cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_GET_INFO: cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_GET_INFO_REPLY: cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_PERFORM: cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_PERFORM_REPLY: cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT: cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY: cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS: cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY: cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REQUEST_USER_BLACKLISTED: cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY: cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RESET_PWD: cli::Protocol_MSG_REGULATOR_RESET_PWD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RESET_PWD_REPLY: cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER: cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY: cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PROMO_CODE: cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PROMO_CODE_REPLY: cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PWD_REMINDER: cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PWD_REMINDER_REPLY: cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_RATE_MOBILE_FLAG: cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY: cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG: cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY: cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SE_BANKID_COLLECT: cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SE_BANKID_COLLECT_REPLY: cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SE_BANKID_VERIFY: cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SE_BANKID_VERIFY_REPLY: cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_USER_GET_INFO: cli::Protocol_MSG_REGULATOR_USER_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS: cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY: cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_USER_GET_INFO_REPLY: cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS: cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY: cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_USER_UPDATE: cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY: cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli_docs"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL: cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY: cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUPPORT_EMAIL_READY: cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY: cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli_unauth"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_COMPARE_SITE_FOR_IP: cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY: cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_NAME_AVAILABLE: cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_NAME_AVAILABLE_REPLY: cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REGISTER_NEW_USER: cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REGISTER_NEW_USER_REPLY: cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REMIND_SID: cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REMIND_SID_REPLY: cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP: cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RETRIEVE_USERID: cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RETRIEVE_USERID_REPLY: cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SIGNUP_QUESTIONNAIRE: cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY: cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN: cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY: cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION: cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY: cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD: cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY: cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_EMAIL_AVAILABLE: cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_EMAIL_AVAILABLE_REPLY: cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS: cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY: cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_SWISS_URL: cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_SWISS_URL_REPLY: cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_PWD_RESET_QUESTIONS: cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_PWD_RESET_QUESTIONS2: cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY: cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY: cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RESET_PWD: cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RESET_PWD_REPLY: cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RETRIEVE_USERID2: cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RETRIEVE_USERID2_REPLY: cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL: cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY: cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PRIV_NO_SURVEY: cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY: cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SMS_RESET_PWD: cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SMS_RESET_PWD_REPLY: cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_USER_UPDATE: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO: cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY: cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_WEB_PWD_SET_NEW_PWD: cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY: cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "core"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_NAME_AVAILABLE: core::Protocol_MSG_LOBBY_NAME_AVAILABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_NAME_AVAILABLE_REPLY: core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CREATE_FACEBOOK_LINK: core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY: core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_COMM_PREFS: core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_COMM_PREFS_REPLY: core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_COMM_PREFS_SV: core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY: core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FACEBOOK_LINK_CODE: core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY: core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REGISTER_NEW_USER2: core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REGISTER_NEW_USER2_REPLY: core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_COMM_PREFS: core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_COMM_PREFS_REPLY: core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_COMM_PREFS_SV: core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY: core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

