/**
 * TemplateServer_atf_thin.cpp
 *
 * This file was auto-generated from TemplateServer_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin TemplateServer_atf.txt
 */
 
#include "TemplateServer_atf_thin.h"

//=================================================================
//                    ContentDataSectionStruct
//=================================================================

TemplateServerATF::ContentDataSectionStruct::ContentDataSectionStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::ContentDataSectionStruct::ContentDataSectionStruct(ContentDataSectionStruct&& _o)
	: locale(std::move(_o.locale))
	, text(std::move(_o.text))
{
}

TemplateServerATF::ContentDataSectionStruct& TemplateServerATF::ContentDataSectionStruct::operator=(ContentDataSectionStruct&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		text = std::move(_o.text);
	}
	return *this;
}

#endif

void TemplateServerATF::ContentDataSectionStruct::clear()
{
	locale = 0;
	text.clear();
}

bool TemplateServerATF::ContentDataSectionStruct::equals(const ContentDataSectionStruct& _o) const
{
	return locale == _o.locale &&
		text.equals(_o.text);
}

const char *TemplateServerATF::ContentDataSectionStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("text=");
	_buf.append(text);
	_buf.append('}');
	return _buf.c_str();
}

void TemplateServerATF::ContentDataSectionStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ContentDataSectionStruct())) // not empty
	{
		_body.composeUINT32(locale);
		_body.composeString(text);
	}

	_msg.composeMsgBody(_body);
}

void TemplateServerATF::ContentDataSectionStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	_parser0.parseStringP(text);
}

/*static*/ void TemplateServerATF::ContentDataSectionStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "text"); size_t szText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "text", szText, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ContentDataStruct
//=================================================================

TemplateServerATF::ContentDataStruct::ContentDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::ContentDataStruct::ContentDataStruct(ContentDataStruct&& _o)
	: sectionCode(std::move(_o.sectionCode))
	, sections(std::move(_o.sections))
{
}

TemplateServerATF::ContentDataStruct& TemplateServerATF::ContentDataStruct::operator=(ContentDataStruct&& _o)
{
	if(this != &_o)
	{
		sectionCode = std::move(_o.sectionCode);
		sections = std::move(_o.sections);
	}
	return *this;
}

#endif

void TemplateServerATF::ContentDataStruct::clear()
{
	sectionCode = 0;
	sections.clear();
}

bool TemplateServerATF::ContentDataStruct::equals(const ContentDataStruct& _o) const
{
	return sectionCode == _o.sectionCode &&
		sections.equals(_o.sections);
}

const char *TemplateServerATF::ContentDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sectionCode=");
	_buf.appendUint(sectionCode);
	_buf.append(',');
	_buf.append("sections=");
	sections.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TemplateServerATF::ContentDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ContentDataStruct())) // not empty
	{
		_body.composeUINT32(sectionCode);
		sections.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void TemplateServerATF::ContentDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(sectionCode);
	sections.parseMsg(_parser0);
}

/*static*/ void TemplateServerATF::ContentDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 sectionCode; _parser0.parseUINT32(sectionCode);
	AtfValidator::validateInt(_descr, "sectionCode", sectionCode, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSections = ThinAtf::LAtfVector< ContentDataSectionStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sections"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sections", szSections, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ContentStruct
//=================================================================

TemplateServerATF::ContentStruct::ContentStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::ContentStruct::ContentStruct(ContentStruct&& _o)
	: contentId(std::move(_o.contentId))
	, criteria(std::move(_o.criteria))
	, from(std::move(_o.from))
	, until(std::move(_o.until))
	, contentDatas(std::move(_o.contentDatas))
{
}

TemplateServerATF::ContentStruct& TemplateServerATF::ContentStruct::operator=(ContentStruct&& _o)
{
	if(this != &_o)
	{
		contentId = std::move(_o.contentId);
		criteria = std::move(_o.criteria);
		from = std::move(_o.from);
		until = std::move(_o.until);
		contentDatas = std::move(_o.contentDatas);
	}
	return *this;
}

#endif

void TemplateServerATF::ContentStruct::clear()
{
	contentId = 0;
	criteria.clear();
	from.setNull();
	until.setNull();
	contentDatas.clear();
}

bool TemplateServerATF::ContentStruct::equals(const ContentStruct& _o) const
{
	return contentId == _o.contentId &&
		criteria.equals(_o.criteria) &&
		from.equals(_o.from) &&
		until.equals(_o.until) &&
		contentDatas.equals(_o.contentDatas);
}

const char *TemplateServerATF::ContentStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("contentId=");
	_buf.appendUint(contentId);
	_buf.append(',');
	_buf.append("criteria=");
	_buf.append(criteria);
	_buf.append(',');
	_buf.append("from=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, from);
	_buf.append(',');
	_buf.append("until=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, until);
	_buf.append(',');
	_buf.append("contentDatas=");
	contentDatas.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TemplateServerATF::ContentStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ContentStruct())) // not empty
	{
		_body.composeUINT32(contentId);
		_body.composeString(criteria);
		_body.composeSrvTime(from);
		_body.composeSrvTime(until);
		contentDatas.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void TemplateServerATF::ContentStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(contentId);
	_parser0.parseStringP(criteria);
	_parser0.parseSrvTime(from);
	_parser0.parseSrvTime(until);
	contentDatas.parseMsg(_parser0);
}

/*static*/ void TemplateServerATF::ContentStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 contentId; _parser0.parseUINT32(contentId);
	AtfValidator::validateInt(_descr, "contentId", contentId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "criteria"); size_t szCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "criteria", szCriteria, _checker, __FILE__, __LINE__);
	SrvTime from; _parser0.parseSrvTime(from);
	AtfValidator::validateSrvDateTime(_descr, "from", from, _checker, __FILE__, __LINE__);
	SrvTime until; _parser0.parseSrvTime(until);
	AtfValidator::validateSrvDateTime(_descr, "until", until, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szContentDatas = ThinAtf::LAtfVector< ContentDataStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("contentDatas"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "contentDatas", szContentDatas, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TemplateStruct
//=================================================================

TemplateServerATF::TemplateStruct::TemplateStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::TemplateStruct::TemplateStruct(TemplateStruct&& _o)
	: saveTemplateMask(std::move(_o.saveTemplateMask))
	, templateId(std::move(_o.templateId))
	, type(std::move(_o.type))
	, name(std::move(_o.name))
	, templateCode(std::move(_o.templateCode))
	, description(std::move(_o.description))
	, status(std::move(_o.status))
	, content(std::move(_o.content))
{
}

TemplateServerATF::TemplateStruct& TemplateServerATF::TemplateStruct::operator=(TemplateStruct&& _o)
{
	if(this != &_o)
	{
		saveTemplateMask = std::move(_o.saveTemplateMask);
		templateId = std::move(_o.templateId);
		type = std::move(_o.type);
		name = std::move(_o.name);
		templateCode = std::move(_o.templateCode);
		description = std::move(_o.description);
		status = std::move(_o.status);
		content = std::move(_o.content);
	}
	return *this;
}

#endif

void TemplateServerATF::TemplateStruct::clear()
{
	saveTemplateMask = 0;
	templateId = 0;
	type = 0;
	name.clear();
	templateCode.clear();
	description.clear();
	status = 0;
	content.clear();
}

bool TemplateServerATF::TemplateStruct::equals(const TemplateStruct& _o) const
{
	return saveTemplateMask == _o.saveTemplateMask &&
		templateId == _o.templateId &&
		type == _o.type &&
		name.equals(_o.name) &&
		templateCode.equals(_o.templateCode) &&
		description.equals(_o.description) &&
		status == _o.status &&
		content.equals(_o.content);
}

const char *TemplateServerATF::TemplateStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("saveTemplateMask=");
	_buf.appendUint(saveTemplateMask);
	_buf.append(',');
	_buf.append("templateId=");
	_buf.appendUint(templateId);
	_buf.append(',');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("templateCode=");
	_buf.append(templateCode);
	_buf.append(',');
	_buf.append("description=");
	_buf.append(description);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("content=");
	content.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TemplateServerATF::TemplateStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TemplateStruct())) // not empty
	{
		_body.composeUINT32(saveTemplateMask);
		_body.composeUINT32(templateId);
		_body.composeUINT32(type);
		_body.composeString(name);
		_body.composeString(templateCode);
		_body.composeString(description);
		_body.composeUINT32(status);
		content.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void TemplateServerATF::TemplateStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(saveTemplateMask);
	_parser0.parseUINT32(templateId);
	_parser0.parseUINT32(type);
	_parser0.parseStringP(name);
	_parser0.parseStringP(templateCode);
	_parser0.parseStringP(description);
	_parser0.parseUINT32(status);
	content.parseMsg(_parser0);
}

/*static*/ void TemplateServerATF::TemplateStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 saveTemplateMask; _parser0.parseUINT32(saveTemplateMask);
	AtfValidator::validateInt(_descr, "saveTemplateMask", saveTemplateMask, _checker, __FILE__, __LINE__);
	UINT32 templateId; _parser0.parseUINT32(templateId);
	AtfValidator::validateInt(_descr, "templateId", templateId, _checker, __FILE__, __LINE__);
	UINT32 type; _parser0.parseUINT32(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "templateCode"); size_t szTemplateCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "templateCode", szTemplateCode, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "description"); size_t szDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "description", szDescription, _checker, __FILE__, __LINE__);
	UINT32 status; _parser0.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szContent = ThinAtf::LAtfVector< ContentStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("content"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "content", szContent, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES
//=================================================================

TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES(Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES&& _o)
	: templates(std::move(_o.templates))
{
}

TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES& TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::operator=(Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES&& _o)
{
	if(this != &_o)
	{
		templates = std::move(_o.templates);
	}
	return *this;
}

#endif

void TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::clear()
{
	templates.clear();
}

bool TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::equals(const Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES& _o) const
{
	return templates.equals(_o.templates);
}

const char *TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(TS_Q_ADMIN_SAVE_BRANDED_LOBBIES).append(")");
	_buf.append(',');
	_buf.append("templates=");
	templates.toTraceString(_buf);
	return _buf.c_str();
}

void TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::composeMsg(CommMsgBody& _msg) const
{
	templates.composeMsg(_msg);
}

void TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::parseMsg(CommMsgParser& _parser)
{
	templates.parseMsg(_parser);
}

/*static*/ void TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_Q_ADMIN_SAVE_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTemplates = ThinAtf::LAtfVector< TemplateStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("templates"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "templates", szTemplates, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES
//=================================================================

TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES(Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES&& _o)
	: errCode(std::move(_o.errCode))
	, msg(std::move(_o.msg))
{
}

TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES& TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::operator=(Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		msg = std::move(_o.msg);
	}
	return *this;
}

#endif

void TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::clear()
{
	errCode = 0;
	msg.clear();
}

bool TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::equals(const Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES& _o) const
{
	return errCode == _o.errCode &&
		msg.equals(_o.msg);
}

const char *TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(TS_A_ADMIN_SAVE_BRANDED_LOBBIES).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("msg=");
	_buf.append(msg);
	return _buf.c_str();
}

void TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(msg);
}

void TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(msg);
}

/*static*/ void TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_A_ADMIN_SAVE_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "msg"); size_t szMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "msg", szMsg, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_TS_Q_PS_NEED_DATA
//=================================================================

TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::Protocol_TS_Q_PS_NEED_DATA()
{
	clear();
}

void TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::clear()
{
	templateType = 0;
}

bool TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::equals(const Protocol_TS_Q_PS_NEED_DATA& _o) const
{
	return templateType == _o.templateType;
}

const char *TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(TS_Q_PS_NEED_DATA).append(")");
	_buf.append(',');
	_buf.append("templateType=");
	_buf.appendInt(templateType);
	return _buf.c_str();
}

void TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(templateType);
}

void TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(templateType);
}

/*static*/ void TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_Q_PS_NEED_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 templateType; _parser.parseINT32(templateType);
	AtfValidator::validateInt(_descr, "templateType", templateType, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_TS_A_PS_NEED_DATA
//=================================================================

TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::Protocol_TS_A_PS_NEED_DATA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::Protocol_TS_A_PS_NEED_DATA(Protocol_TS_A_PS_NEED_DATA&& _o)
	: errCode(std::move(_o.errCode))
	, sqlErr(std::move(_o.sqlErr))
	, templates(std::move(_o.templates))
{
}

TemplateServerATF::Protocol_TS_A_PS_NEED_DATA& TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::operator=(Protocol_TS_A_PS_NEED_DATA&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		sqlErr = std::move(_o.sqlErr);
		templates = std::move(_o.templates);
	}
	return *this;
}

#endif

void TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::clear()
{
	errCode = 0;
	sqlErr.clear();
	templates.clear();
}

bool TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::equals(const Protocol_TS_A_PS_NEED_DATA& _o) const
{
	return errCode == _o.errCode &&
		sqlErr.equals(_o.sqlErr) &&
		templates.equals(_o.templates);
}

const char *TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(TS_A_PS_NEED_DATA).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("sqlErr=");
		_buf.append(sqlErr);
	}
	else
	{
		_buf.append(',');
		_buf.append("templates=");
		templates.toTraceString(_buf);
	}
	return _buf.c_str();
}

void TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(sqlErr);
	}
	else
	{
		templates.composeMsg(_msg);
	}
}

void TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(sqlErr);
	}
	else
	{
		templates.parseMsg(_parser);
	}
}

/*static*/ void TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_A_PS_NEED_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "sqlErr"); size_t szSqlErr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "sqlErr", szSqlErr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTemplates = ThinAtf::LAtfVector< TemplateStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("templates"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "templates", szTemplates, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_TS_Q_HFS_NEED_DATA
//=================================================================

TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::Protocol_TS_Q_HFS_NEED_DATA()
{
	clear();
}

void TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::clear()
{
	templateType = 0;
}

bool TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::equals(const Protocol_TS_Q_HFS_NEED_DATA& _o) const
{
	return templateType == _o.templateType;
}

const char *TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(TS_Q_HFS_NEED_DATA).append(")");
	_buf.append(',');
	_buf.append("templateType=");
	_buf.appendInt(templateType);
	return _buf.c_str();
}

void TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(templateType);
}

void TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(templateType);
}

/*static*/ void TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_Q_HFS_NEED_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 templateType; _parser.parseINT32(templateType);
	AtfValidator::validateInt(_descr, "templateType", templateType, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_TS_A_HFS_NEED_DATA
//=================================================================

TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::Protocol_TS_A_HFS_NEED_DATA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::Protocol_TS_A_HFS_NEED_DATA(Protocol_TS_A_HFS_NEED_DATA&& _o)
	: errCode(std::move(_o.errCode))
	, sqlErr(std::move(_o.sqlErr))
	, templates(std::move(_o.templates))
{
}

TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA& TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::operator=(Protocol_TS_A_HFS_NEED_DATA&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		sqlErr = std::move(_o.sqlErr);
		templates = std::move(_o.templates);
	}
	return *this;
}

#endif

void TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::clear()
{
	errCode = 0;
	sqlErr.clear();
	templates.clear();
}

bool TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::equals(const Protocol_TS_A_HFS_NEED_DATA& _o) const
{
	return errCode == _o.errCode &&
		sqlErr.equals(_o.sqlErr) &&
		templates.equals(_o.templates);
}

const char *TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(TS_A_HFS_NEED_DATA).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("sqlErr=");
		_buf.append(sqlErr);
	}
	else
	{
		_buf.append(',');
		_buf.append("templates=");
		templates.toTraceString(_buf);
	}
	return _buf.c_str();
}

void TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(sqlErr);
	}
	else
	{
		templates.composeMsg(_msg);
	}
}

void TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(sqlErr);
	}
	else
	{
		templates.parseMsg(_parser);
	}
}

/*static*/ void TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_A_HFS_NEED_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "sqlErr"); size_t szSqlErr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "sqlErr", szSqlErr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTemplates = ThinAtf::LAtfVector< TemplateStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("templates"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "templates", szTemplates, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_TS_Q_HFS_GET_TEMPLATE_DATA
//=================================================================

TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA()
{
	clear();
}

void TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::clear()
{
	templateId = 0;
}

bool TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::equals(const Protocol_TS_Q_HFS_GET_TEMPLATE_DATA& _o) const
{
	return templateId == _o.templateId;
}

const char *TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(TS_Q_HFS_GET_TEMPLATE_DATA).append(")");
	_buf.append(',');
	_buf.append("templateId=");
	_buf.appendInt(templateId);
	return _buf.c_str();
}

void TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(templateId);
}

void TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(templateId);
}

/*static*/ void TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_Q_HFS_GET_TEMPLATE_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 templateId; _parser.parseINT32(templateId);
	AtfValidator::validateInt(_descr, "templateId", templateId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_TS_A_HFS_GET_TEMPLATE_DATA
//=================================================================

TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::Protocol_TS_A_HFS_GET_TEMPLATE_DATA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::Protocol_TS_A_HFS_GET_TEMPLATE_DATA(Protocol_TS_A_HFS_GET_TEMPLATE_DATA&& _o)
	: errCode(std::move(_o.errCode))
	, sqlErr(std::move(_o.sqlErr))
	, templates(std::move(_o.templates))
{
}

TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA& TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::operator=(Protocol_TS_A_HFS_GET_TEMPLATE_DATA&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		sqlErr = std::move(_o.sqlErr);
		templates = std::move(_o.templates);
	}
	return *this;
}

#endif

void TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::clear()
{
	errCode = 0;
	sqlErr.clear();
	templates.clear();
}

bool TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::equals(const Protocol_TS_A_HFS_GET_TEMPLATE_DATA& _o) const
{
	return errCode == _o.errCode &&
		sqlErr.equals(_o.sqlErr) &&
		templates.equals(_o.templates);
}

const char *TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(TS_A_HFS_GET_TEMPLATE_DATA).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("sqlErr=");
		_buf.append(sqlErr);
	}
	else
	{
		_buf.append(',');
		_buf.append("templates=");
		templates.toTraceString(_buf);
	}
	return _buf.c_str();
}

void TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(sqlErr);
	}
	else
	{
		templates.composeMsg(_msg);
	}
}

void TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(sqlErr);
	}
	else
	{
		templates.parseMsg(_parser);
	}
}

/*static*/ void TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_A_HFS_GET_TEMPLATE_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "sqlErr"); size_t szSqlErr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "sqlErr", szSqlErr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTemplates = ThinAtf::LAtfVector< TemplateStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("templates"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "templates", szTemplates, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool TemplateServerATF::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case TS_A_ADMIN_SAVE_BRANDED_LOBBIES: Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case TS_A_HFS_GET_TEMPLATE_DATA: Protocol_TS_A_HFS_GET_TEMPLATE_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case TS_A_HFS_NEED_DATA: Protocol_TS_A_HFS_NEED_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case TS_A_PS_NEED_DATA: Protocol_TS_A_PS_NEED_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case TS_Q_ADMIN_SAVE_BRANDED_LOBBIES: Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case TS_Q_HFS_GET_TEMPLATE_DATA: Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case TS_Q_HFS_NEED_DATA: Protocol_TS_Q_HFS_NEED_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case TS_Q_PS_NEED_DATA: Protocol_TS_Q_PS_NEED_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

