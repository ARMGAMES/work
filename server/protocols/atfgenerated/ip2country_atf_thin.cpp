/**
 * ip2country_atf_thin.cpp
 *
 * This file was auto-generated from ip2country_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin ip2country_atf.txt
 */
 
#include "ip2country_atf_thin.h"

//=================================================================
//                Protocol_MSG_REDIRECTOR_URL
//=================================================================

ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::Protocol_MSG_REDIRECTOR_URL()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::Protocol_MSG_REDIRECTOR_URL(Protocol_MSG_REDIRECTOR_URL&& _o)
	: siteId(std::move(_o.siteId))
	, clientExtra(std::move(_o.clientExtra))
	, userId(std::move(_o.userId))
	, licenseId(std::move(_o.licenseId))
{
}

ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL& ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::operator=(Protocol_MSG_REDIRECTOR_URL&& _o)
{
	if(this != &_o)
	{
		siteId = std::move(_o.siteId);
		clientExtra = std::move(_o.clientExtra);
		userId = std::move(_o.userId);
		licenseId = std::move(_o.licenseId);
	}
	return *this;
}

#endif

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::clear()
{
	siteId = 0;
	clientExtra.clear();
	userId = "";
	licenseId = 0;
}

bool ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::equals(const Protocol_MSG_REDIRECTOR_URL& _o) const
{
	return siteId == _o.siteId &&
		clientExtra.equals(_o.clientExtra) &&
		userId.equals(_o.userId) &&
		licenseId == _o.licenseId;
}

const char *ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REDIRECTOR_URL).append(")");
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(siteId);
	clientExtra.composeMsg(_msg);
	_msg.composeString(userId);
	_msg.composeUINT32(licenseId);
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(siteId);
	if(_parser.parseEnded()) return;
	clientExtra.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(userId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REDIRECTOR_URL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY
//=================================================================

ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY()
{
	clear();
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::clear()
{
	errCode = 0;
}

bool ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::equals(const Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY& _o) const
{
	return errCode == _o.errCode;
}

const char *ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REDIRECTOR_URL_ERROR_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	return _buf.c_str();
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT16(errCode);
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REDIRECTOR_URL_ERROR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REDIRECTOR_URL_REPLY
//=================================================================

ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::Protocol_MSG_REDIRECTOR_URL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::Protocol_MSG_REDIRECTOR_URL_REPLY(Protocol_MSG_REDIRECTOR_URL_REPLY&& _o)
	: url(std::move(_o.url))
	, country(std::move(_o.country))
	, ipAddr(std::move(_o.ipAddr))
	, region(std::move(_o.region))
	, redirectorTemplate(std::move(_o.redirectorTemplate))
{
}

ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY& ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::operator=(Protocol_MSG_REDIRECTOR_URL_REPLY&& _o)
{
	if(this != &_o)
	{
		url = std::move(_o.url);
		country = std::move(_o.country);
		ipAddr = std::move(_o.ipAddr);
		region = std::move(_o.region);
		redirectorTemplate = std::move(_o.redirectorTemplate);
	}
	return *this;
}

#endif

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::clear()
{
	url.clear();
	country.clear();
	ipAddr.clear();
	region.clear();
	redirectorTemplate.clear();
}

bool ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::equals(const Protocol_MSG_REDIRECTOR_URL_REPLY& _o) const
{
	return url.equals(_o.url) &&
		country.equals(_o.country) &&
		ipAddr.equals(_o.ipAddr) &&
		region.equals(_o.region) &&
		redirectorTemplate.equals(_o.redirectorTemplate);
}

const char *ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REDIRECTOR_URL_REPLY).append(")");
	_buf.append(',');
	_buf.append("url=");
	_buf.append(url);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("ipAddr=");
	_buf.append(ipAddr);
	_buf.append(',');
	_buf.append("region=");
	_buf.append(region);
	_buf.append(',');
	_buf.append("redirectorTemplate=");
	_buf.append(redirectorTemplate);
	return _buf.c_str();
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(url);
	_msg.composeString(country);
	_msg.composeString(ipAddr);
	_msg.composeString(region);
	CommMsgBody _msg0;
	_msg0.composeString(redirectorTemplate);
	_msg.composeMsgBody(_msg0);
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(url);
	_parser.parseStringP(country);
	_parser.parseStringP(ipAddr);
	_parser.parseStringP(region);
	parseAnonymousMsgBody0(_parser);
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REDIRECTOR_URL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
	AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ipAddr"); size_t szIpAddr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ipAddr", szIpAddr, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "region"); size_t szRegion = strlen(_dummy);
	AtfValidator::validateInt(_descr, "region", szRegion, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(redirectorTemplate);
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "redirectorTemplate"); size_t szRedirectorTemplate = strlen(_dummy);
	AtfValidator::validateInt(_descr, "redirectorTemplate", szRedirectorTemplate, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    NameValuePair
//=================================================================

ip2country::cli_unauth::NameValuePair::NameValuePair()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ip2country::cli_unauth::NameValuePair::NameValuePair(NameValuePair&& _o)
	: name(std::move(_o.name))
	, value(std::move(_o.value))
{
}

ip2country::cli_unauth::NameValuePair& ip2country::cli_unauth::NameValuePair::operator=(NameValuePair&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		value = std::move(_o.value);
	}
	return *this;
}

#endif

void ip2country::cli_unauth::NameValuePair::clear()
{
	name.clear();
	value.clear();
}

bool ip2country::cli_unauth::NameValuePair::equals(const NameValuePair& _o) const
{
	return name.equals(_o.name) &&
		value.equals(_o.value);
}

const char *ip2country::cli_unauth::NameValuePair::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("value=");
	_buf.append(value);
	_buf.append('}');
	return _buf.c_str();
}

void ip2country::cli_unauth::NameValuePair::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(NameValuePair())) // not empty
	{
		_body.composeString(name);
		_body.composeString(value);
	}

	_msg.composeMsgBody(_body);
}

void ip2country::cli_unauth::NameValuePair::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(name);
	_parser0.parseStringP(value);
}

/*static*/ void ip2country::cli_unauth::NameValuePair::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, 128, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "value"); size_t szValue = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "value", szValue, 2000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    Params
//=================================================================

ip2country::cli_unauth::Params::Params()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ip2country::cli_unauth::Params::Params(Params&& _o)
	: pairs(std::move(_o.pairs))
{
}

ip2country::cli_unauth::Params& ip2country::cli_unauth::Params::operator=(Params&& _o)
{
	if(this != &_o)
	{
		pairs = std::move(_o.pairs);
	}
	return *this;
}

#endif

void ip2country::cli_unauth::Params::clear()
{
	pairs.clear();
}

bool ip2country::cli_unauth::Params::equals(const Params& _o) const
{
	return pairs.equals(_o.pairs);
}

const char *ip2country::cli_unauth::Params::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("pairs=");
	pairs.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void ip2country::cli_unauth::Params::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(Params())) // not empty
	{
		pairs.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void ip2country::cli_unauth::Params::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	pairs.parseMsg(_parser0);
}

/*static*/ void ip2country::cli_unauth::Params::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szPairs = ThinAtf::LAtfVector< NameValuePair, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("pairs"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "pairs", szPairs, 500, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_RESOLVER_TAG
//=================================================================

ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::Protocol_MSG_RESOLVER_TAG()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::Protocol_MSG_RESOLVER_TAG(Protocol_MSG_RESOLVER_TAG&& _o)
	: tag(std::move(_o.tag))
	, siteId(std::move(_o.siteId))
	, country(std::move(_o.country))
	, localeId(std::move(_o.localeId))
	, clientExtra(std::move(_o.clientExtra))
	, urlParamStr(std::move(_o.urlParamStr))
	, isForceTest(std::move(_o.isForceTest))
	, appUserIntId(std::move(_o.appUserIntId))
	, appTimeUtc(std::move(_o.appTimeUtc))
	, params(std::move(_o.params))
	, state(std::move(_o.state))
	, licenseId(std::move(_o.licenseId))
{
}

ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG& ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::operator=(Protocol_MSG_RESOLVER_TAG&& _o)
{
	if(this != &_o)
	{
		tag = std::move(_o.tag);
		siteId = std::move(_o.siteId);
		country = std::move(_o.country);
		localeId = std::move(_o.localeId);
		clientExtra = std::move(_o.clientExtra);
		urlParamStr = std::move(_o.urlParamStr);
		isForceTest = std::move(_o.isForceTest);
		appUserIntId = std::move(_o.appUserIntId);
		appTimeUtc = std::move(_o.appTimeUtc);
		params = std::move(_o.params);
		state = std::move(_o.state);
		licenseId = std::move(_o.licenseId);
	}
	return *this;
}

#endif

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::clear()
{
	tag.clear();
	siteId = 0;
	country.clear();
	localeId = 0;
	clientExtra.clear();
	urlParamStr.clear();
	isForceTest = false;
	appUserIntId = 0;
	appTimeUtc.setNull();
	params.clear();
	state.clear();
	licenseId = 0;
}

bool ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::equals(const Protocol_MSG_RESOLVER_TAG& _o) const
{
	return tag.equals(_o.tag) &&
		siteId == _o.siteId &&
		country.equals(_o.country) &&
		localeId == _o.localeId &&
		clientExtra.equals(_o.clientExtra) &&
		urlParamStr.equals(_o.urlParamStr) &&
		isForceTest == _o.isForceTest &&
		appUserIntId == _o.appUserIntId &&
		appTimeUtc.equals(_o.appTimeUtc) &&
		params.equals(_o.params) &&
		state.equals(_o.state) &&
		licenseId == _o.licenseId;
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_RESOLVER_TAG).append(")");
	_buf.append(',');
	_buf.append("tag=");
	_buf.append(tag);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("localeId=");
	_buf.appendUint(localeId);
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	_buf.append(',');
	_buf.append("urlParamStr=");
	_buf.append(urlParamStr);
	_buf.append(',');
	_buf.append("isForceTest=");
	_buf.appendUint(isForceTest);
	_buf.append(',');
	_buf.append("appUserIntId=");
	_buf.appendUint(appUserIntId);
	_buf.append(',');
	_buf.append("appTimeUtc=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, appTimeUtc);
	_buf.append(',');
	_buf.append("params=");
	params.toTraceString(_buf);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(tag);
	_msg.composeUINT32(siteId);
	_msg.composeString(country);
	_msg.composeUINT32(localeId);
	clientExtra.composeMsg(_msg);
	_msg.composeString(urlParamStr);
	_msg.composeBOOL(isForceTest);
	_msg.composeUINT32(appUserIntId);
	_msg.composeSrvTime(appTimeUtc);
	params.composeMsg(_msg);
	_msg.composeString(state);
	_msg.composeUINT32(licenseId);
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(tag);
	_parser.parseUINT32(siteId);
	_parser.parseStringP(country);
	_parser.parseUINT32(localeId);
	clientExtra.parseMsg(_parser);
	_parser.parseStringP(urlParamStr);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isForceTest);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(appUserIntId);
	if(_parser.parseEnded()) return;
	_parser.parseSrvTime(appTimeUtc);
	if(_parser.parseEnded()) return;
	params.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(state);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_RESOLVER_TAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "tag"); size_t szTag = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tag", szTag, 128, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, Sites::PokerStars_Last, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 100, _checker, __FILE__, __LINE__);
	UINT32 localeId; _parser.parseUINT32(localeId);
	AtfValidator::validateIntMax(_descr, "localeId", localeId, MAX_LOCALES, _checker, __FILE__, __LINE__);
	PString _descbuf;
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	_parser.parseStringN(_dummy, 0, "urlParamStr"); size_t szUrlParamStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "urlParamStr", szUrlParamStr, 10000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool isForceTest; _parser.parseBOOL(isForceTest);
	AtfValidator::validateInt(_descr, "isForceTest", isForceTest, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 appUserIntId; _parser.parseUINT32(appUserIntId);
	AtfValidator::validateInt(_descr, "appUserIntId", appUserIntId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	SrvTime appTimeUtc; _parser.parseSrvTime(appTimeUtc);
	AtfValidator::validateSrvDateTime(_descr, "appTimeUtc", appTimeUtc, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	Params::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("params"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_RESOLVER_TAG_REPLY
//=================================================================

ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::Protocol_MSG_RESOLVER_TAG_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::Protocol_MSG_RESOLVER_TAG_REPLY(Protocol_MSG_RESOLVER_TAG_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, url(std::move(_o.url))
	, errDescr(std::move(_o.errDescr))
{
}

ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY& ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::operator=(Protocol_MSG_RESOLVER_TAG_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		url = std::move(_o.url);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::clear()
{
	errCode = 0;
	url.clear();
	errDescr.clear();
}

bool ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::equals(const Protocol_MSG_RESOLVER_TAG_REPLY& _o) const
{
	return errCode == _o.errCode &&
		url.equals(_o.url) &&
		errDescr.equals(_o.errDescr);
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_RESOLVER_TAG_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode == 0 )
	{
		_buf.append(',');
		_buf.append("url=");
		_buf.append(url);
	}
	else
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode == 0 )
	{
		_msg.composeString(url);
	}
	else
	{
		_msg.composeString(errDescr);
	}
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode == 0 )
	{
		_parser.parseStringP(url);
	}
	else
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_RESOLVER_TAG_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode == 0 )
	{
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_RESOLVER_GET_VERSION
//=================================================================

ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::Protocol_MSG_RESOLVER_GET_VERSION()
{
	clear();
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::clear()
{
}

bool ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::equals(const Protocol_MSG_RESOLVER_GET_VERSION& _o) const
{
	return true;
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_RESOLVER_GET_VERSION).append(")");
	return _buf.c_str();
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::composeMsg(CommMsgBody& _msg) const
{
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_RESOLVER_GET_VERSION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_RESOLVER_GET_VERSION_REPLY
//=================================================================

ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::Protocol_MSG_RESOLVER_GET_VERSION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::Protocol_MSG_RESOLVER_GET_VERSION_REPLY(Protocol_MSG_RESOLVER_GET_VERSION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, version(std::move(_o.version))
	, errDescr(std::move(_o.errDescr))
{
}

ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY& ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::operator=(Protocol_MSG_RESOLVER_GET_VERSION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		version = std::move(_o.version);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::clear()
{
	errCode = 0;
	version.clear();
	errDescr.clear();
}

bool ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::equals(const Protocol_MSG_RESOLVER_GET_VERSION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		version.equals(_o.version) &&
		errDescr.equals(_o.errDescr);
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_RESOLVER_GET_VERSION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode == 0 )
	{
		_buf.append(',');
		_buf.append("version=");
		_buf.append(version);
	}
	else
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode == 0 )
	{
		_msg.composeString(version);
	}
	else
	{
		_msg.composeString(errDescr);
	}
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode == 0 )
	{
		_parser.parseStringP(version);
	}
	else
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_RESOLVER_GET_VERSION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode == 0 )
	{
		_parser.parseStringN(_dummy, 0, "version"); size_t szVersion = strlen(_dummy);
		AtfValidator::validateInt(_descr, "version", szVersion, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool ip2country::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli_unauth"))
	{
		switch(_msgId)
		{
			case MSG_REDIRECTOR_URL: cli_unauth::Protocol_MSG_REDIRECTOR_URL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REDIRECTOR_URL_ERROR_REPLY: cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REDIRECTOR_URL_REPLY: cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_RESOLVER_GET_VERSION: cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_RESOLVER_GET_VERSION_REPLY: cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_RESOLVER_TAG: cli_unauth::Protocol_MSG_RESOLVER_TAG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_RESOLVER_TAG_REPLY: cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

