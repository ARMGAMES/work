/**
 * mlobbyNG_atf.cpp
 *
 * This file was auto-generated from mlobbyNG_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor mlobbyNG_atf.txt
 */
 
#include "mlobbyNG_atf.h"

//=================================================================
//                    TournSelectionFilter
//=================================================================

MLobbyNG::cli::TournSelectionFilter::TournSelectionFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TournSelectionFilter::TournSelectionFilter(TournSelectionFilter&& _o)
	: locale(std::move(_o.locale))
	, gameMask(std::move(_o.gameMask))
	, buyInMask(std::move(_o.buyInMask))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, speedMask(std::move(_o.speedMask))
	, tournTypeMask(std::move(_o.tournTypeMask))
	, currencyMask(std::move(_o.currencyMask))
	, tableSizeMask(std::move(_o.tableSizeMask))
	, tournVariantMask(std::move(_o.tournVariantMask))
	, tournStateMask(std::move(_o.tournStateMask))
	, startingWithin(std::move(_o.startingWithin))
	, country(std::move(_o.country))
	, isPM(std::move(_o.isPM))
	, tournGroups(std::move(_o.tournGroups))
	, lateRegCutoff(std::move(_o.lateRegCutoff))
	, genderRestrictMask(std::move(_o.genderRestrictMask))
	, tournDisplayMask(std::move(_o.tournDisplayMask))
	, negateTournVariantMask(std::move(_o.negateTournVariantMask))
{
}

MLobbyNG::cli::TournSelectionFilter& MLobbyNG::cli::TournSelectionFilter::operator=(TournSelectionFilter&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		gameMask = std::move(_o.gameMask);
		buyInMask = std::move(_o.buyInMask);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		speedMask = std::move(_o.speedMask);
		tournTypeMask = std::move(_o.tournTypeMask);
		currencyMask = std::move(_o.currencyMask);
		tableSizeMask = std::move(_o.tableSizeMask);
		tournVariantMask = std::move(_o.tournVariantMask);
		tournStateMask = std::move(_o.tournStateMask);
		startingWithin = std::move(_o.startingWithin);
		country = std::move(_o.country);
		isPM = std::move(_o.isPM);
		tournGroups = std::move(_o.tournGroups);
		lateRegCutoff = std::move(_o.lateRegCutoff);
		genderRestrictMask = std::move(_o.genderRestrictMask);
		tournDisplayMask = std::move(_o.tournDisplayMask);
		negateTournVariantMask = std::move(_o.negateTournVariantMask);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TournSelectionFilter::clear()
{
	locale = 0;
	gameMask = 0;
	buyInMask = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	speedMask = 0;
	tournTypeMask = 0;
	currencyMask = 0;
	tableSizeMask = 0;
	tournVariantMask = 0;
	tournStateMask = 0;
	startingWithin = 0;
	country.clear();
	isPM = false;
	tournGroups.clear();
	lateRegCutoff = 0;
	genderRestrictMask = 0;
	tournDisplayMask = 0;
	negateTournVariantMask = 0;
}

bool MLobbyNG::cli::TournSelectionFilter::equals(const TournSelectionFilter& _o) const
{
	return locale == _o.locale &&
		gameMask == _o.gameMask &&
		buyInMask == _o.buyInMask &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		speedMask == _o.speedMask &&
		tournTypeMask == _o.tournTypeMask &&
		currencyMask == _o.currencyMask &&
		tableSizeMask == _o.tableSizeMask &&
		tournVariantMask == _o.tournVariantMask &&
		tournStateMask == _o.tournStateMask &&
		startingWithin == _o.startingWithin &&
		Atf::atfPStringEquals(country, _o.country) &&
		isPM == _o.isPM &&
		tournGroups.equals(_o.tournGroups) &&
		lateRegCutoff == _o.lateRegCutoff &&
		genderRestrictMask == _o.genderRestrictMask &&
		tournDisplayMask == _o.tournDisplayMask &&
		negateTournVariantMask == _o.negateTournVariantMask;
}

const char *MLobbyNG::cli::TournSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append(',');
	_buf.append("buyInMask=");
	_buf.appendUint(buyInMask);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint64(maxBuyIn);
	_buf.append(',');
	_buf.append("speedMask=");
	_buf.appendUint(speedMask);
	_buf.append(',');
	_buf.append("tournTypeMask=");
	_buf.appendUint(tournTypeMask);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("tableSizeMask=");
	_buf.appendUint(tableSizeMask);
	_buf.append(',');
	_buf.append("tournVariantMask=");
	_buf.appendUint(tournVariantMask);
	_buf.append(',');
	_buf.append("tournStateMask=");
	_buf.appendUint(tournStateMask);
	_buf.append(',');
	_buf.append("startingWithin=");
	_buf.appendUint(startingWithin);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("tournGroups=");
	tournGroups.toTraceString(_buf);
	_buf.append(',');
	_buf.append("lateRegCutoff=");
	_buf.appendInt(lateRegCutoff);
	_buf.append(',');
	_buf.append("genderRestrictMask=");
	_buf.appendUint(genderRestrictMask);
	_buf.append(',');
	_buf.append("tournDisplayMask=");
	_buf.appendUint(tournDisplayMask);
	_buf.append(',');
	_buf.append("negateTournVariantMask=");
	_buf.appendUint(negateTournVariantMask);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::TournSelectionFilter::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameMask", gameMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInMask", buyInMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("speedMask", speedMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournTypeMask", tournTypeMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyMask", currencyMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableSizeMask", tableSizeMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournVariantMask", tournVariantMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournStateMask", tournStateMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("startingWithin", startingWithin, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPM", isPM, _buf);
	tournGroups.toXmlString("tournGroups", _buf);
	Atf::XmlElement::encodeAsXmlElement("lateRegCutoff", lateRegCutoff, _buf);
	Atf::XmlElement::encodeAsXmlElement("genderRestrictMask", genderRestrictMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournDisplayMask", tournDisplayMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("negateTournVariantMask", negateTournVariantMask, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::TournSelectionFilter::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("locale"))
		{
			locale = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameMask"))
		{
			gameMask = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyInMask"))
		{
			buyInMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minBuyIn"))
		{
			minBuyIn = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("speedMask"))
		{
			speedMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournTypeMask"))
		{
			tournTypeMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currencyMask"))
		{
			currencyMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableSizeMask"))
		{
			tableSizeMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournVariantMask"))
		{
			tournVariantMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournStateMask"))
		{
			tournStateMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("startingWithin"))
		{
			startingWithin = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("isPM"))
		{
			isPM = (*_value.ptr() == '1');
		}
		else if (_element.equals("tournGroups"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, tournGroups)) return false;
		}
		else if (_element.equals("lateRegCutoff"))
		{
			lateRegCutoff = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("genderRestrictMask"))
		{
			genderRestrictMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournDisplayMask"))
		{
			tournDisplayMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("negateTournVariantMask"))
		{
			negateTournVariantMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::TournSelectionFilter::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournSelectionFilter())) // not empty
	{
		_body.composeUINT32(locale);
		_body.composeUINT64(gameMask);
		_body.composeUINT32(buyInMask);
		_body.composeUINT64(minBuyIn);
		_body.composeUINT64(maxBuyIn);
		_body.composeUINT32(speedMask);
		_body.composeUINT32(tournTypeMask);
		_body.composeUINT32(currencyMask);
		_body.composeUINT32(tableSizeMask);
		_body.composeUINT32(tournVariantMask);
		_body.composeUINT32(tournStateMask);
		_body.composeUINT32(startingWithin);
		_body.composeString(country);
		_body.composeBOOL(isPM);
		tournGroups.composeMsg(_body, _ignoreJSON);
		_body.composeINT32(lateRegCutoff);
		_body.composeUINT32(genderRestrictMask);
		_body.composeUINT32(tournDisplayMask);
		_body.composeUINT32(negateTournVariantMask);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TournSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	_parser0.parseUINT64(gameMask);
	_parser0.parseUINT32(buyInMask);
	_parser0.parseUINT64(minBuyIn);
	_parser0.parseUINT64(maxBuyIn);
	_parser0.parseUINT32(speedMask);
	_parser0.parseUINT32(tournTypeMask);
	_parser0.parseUINT32(currencyMask);
	_parser0.parseUINT32(tableSizeMask);
	_parser0.parseUINT32(tournVariantMask);
	_parser0.parseUINT32(tournStateMask);
	_parser0.parseUINT32(startingWithin);
	_parser0.parseStringP(country);
	_parser0.parseBOOL(isPM);
	tournGroups.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(lateRegCutoff);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(genderRestrictMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(tournDisplayMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(negateTournVariantMask);
}

const char *MLobbyNG::cli::TournSelectionFilter::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("gameMask", gameMask);
	_jsonstr.compose("buyInMask", buyInMask);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("speedMask", speedMask);
	_jsonstr.compose("tournTypeMask", tournTypeMask);
	_jsonstr.compose("currencyMask", currencyMask);
	_jsonstr.compose("tableSizeMask", tableSizeMask);
	_jsonstr.compose("tournVariantMask", tournVariantMask);
	_jsonstr.compose("tournStateMask", tournStateMask);
	_jsonstr.compose("startingWithin", startingWithin);
	_jsonstr.compose("country", country);
	_jsonstr.compose("isPM", isPM);
	_jsonstr.compose("tournGroups", tournGroups);
	_jsonstr.compose("lateRegCutoff", lateRegCutoff);
	_jsonstr.compose("genderRestrictMask", genderRestrictMask);
	_jsonstr.compose("tournDisplayMask", tournDisplayMask);
	_jsonstr.compose("negateTournVariantMask", negateTournVariantMask);
	return _buf.c_str();
}

void MLobbyNG::cli::TournSelectionFilter::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("gameMask", gameMask);
	_jparser.parseByNameThrow("buyInMask", buyInMask);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("speedMask", speedMask);
	_jparser.parseByNameThrow("tournTypeMask", tournTypeMask);
	_jparser.parseByNameThrow("currencyMask", currencyMask);
	_jparser.parseByNameThrow("tableSizeMask", tableSizeMask);
	_jparser.parseByNameThrow("tournVariantMask", tournVariantMask);
	_jparser.parseByNameThrow("tournStateMask", tournStateMask);
	_jparser.parseByNameThrow("startingWithin", startingWithin);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("isPM", isPM);
	_jparser.parseByNameThrow("tournGroups", tournGroups);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("lateRegCutoff", lateRegCutoff);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("genderRestrictMask", genderRestrictMask);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tournDisplayMask", tournDisplayMask);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("negateTournVariantMask", negateTournVariantMask);
}

/* static */ void MLobbyNG::cli::TournSelectionFilter::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT64 gameMask; _jparser.validateByNameThrow("gameMask", gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _jparser.validateByNameThrow("buyInMask", buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*NGBuyIn_Last-1), _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateUint(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateUint(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 speedMask; _jparser.validateByNameThrow("speedMask", speedMask);
	AtfValidator::validateIntMax(_descr, "speedMask", speedMask, (2*NGTournSpeed_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tournTypeMask; _jparser.validateByNameThrow("tournTypeMask", tournTypeMask);
	AtfValidator::validateIntMax(_descr, "tournTypeMask", tournTypeMask, (2*NGTournType_Last-1), _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _jparser.validateByNameThrow("currencyMask", currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*NGCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tableSizeMask; _jparser.validateByNameThrow("tableSizeMask", tableSizeMask);
	AtfValidator::validateIntMax(_descr, "tableSizeMask", tableSizeMask, (2*NGMaxTableSize_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tournVariantMask; _jparser.validateByNameThrow("tournVariantMask", tournVariantMask);
	AtfValidator::validateIntMax(_descr, "tournVariantMask", tournVariantMask, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tournStateMask; _jparser.validateByNameThrow("tournStateMask", tournStateMask);
	AtfValidator::validateIntMax(_descr, "tournStateMask", tournStateMask, (2*NGTournState_Last-1), _checker, __FILE__, __LINE__);
	UINT32 startingWithin; _jparser.validateByNameThrow("startingWithin", startingWithin);
	AtfValidator::validateIntMax(_descr, "startingWithin", startingWithin, 1440, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), 3, _checker, __FILE__, __LINE__);
	bool isPM; _jparser.validateByNameThrow("isPM", isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > tournGroups; _jparser.validateByNameThrow("tournGroups", tournGroups);
	AtfValidator::validateIntMax(_descr, "tournGroups", tournGroups.size(), TournGroup_Last, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 lateRegCutoff; _jparser.validateByNameThrow("lateRegCutoff", lateRegCutoff);
	AtfValidator::validateInt(_descr, "lateRegCutoff", lateRegCutoff, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 genderRestrictMask; _jparser.validateByNameThrow("genderRestrictMask", genderRestrictMask);
	AtfValidator::validateIntMax(_descr, "genderRestrictMask", genderRestrictMask, (2*RestrictedTo_Last-1), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 tournDisplayMask; _jparser.validateByNameThrow("tournDisplayMask", tournDisplayMask);
	AtfValidator::validateIntMax(_descr, "tournDisplayMask", tournDisplayMask, (2*NGTournDisplay_Last-1), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 negateTournVariantMask; _jparser.validateByNameThrow("negateTournVariantMask", negateTournVariantMask);
	AtfValidator::validateIntMax(_descr, "negateTournVariantMask", negateTournVariantMask, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::TournSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _parser0.parseUINT32(buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*NGBuyIn_Last-1), _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _parser0.parseUINT64(minBuyIn);
	AtfValidator::validateUint(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _parser0.parseUINT64(maxBuyIn);
	AtfValidator::validateUint(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 speedMask; _parser0.parseUINT32(speedMask);
	AtfValidator::validateIntMax(_descr, "speedMask", speedMask, (2*NGTournSpeed_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tournTypeMask; _parser0.parseUINT32(tournTypeMask);
	AtfValidator::validateIntMax(_descr, "tournTypeMask", tournTypeMask, (2*NGTournType_Last-1), _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _parser0.parseUINT32(currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*NGCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tableSizeMask; _parser0.parseUINT32(tableSizeMask);
	AtfValidator::validateIntMax(_descr, "tableSizeMask", tableSizeMask, (2*NGMaxTableSize_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tournVariantMask; _parser0.parseUINT32(tournVariantMask);
	AtfValidator::validateIntMax(_descr, "tournVariantMask", tournVariantMask, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tournStateMask; _parser0.parseUINT32(tournStateMask);
	AtfValidator::validateIntMax(_descr, "tournStateMask", tournStateMask, (2*NGTournState_Last-1), _checker, __FILE__, __LINE__);
	UINT32 startingWithin; _parser0.parseUINT32(startingWithin);
	AtfValidator::validateIntMax(_descr, "startingWithin", startingWithin, 1440, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournGroups = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournGroups"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tournGroups", szTournGroups, TournGroup_Last, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 lateRegCutoff; _parser0.parseINT32(lateRegCutoff);
	AtfValidator::validateInt(_descr, "lateRegCutoff", lateRegCutoff, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 genderRestrictMask; _parser0.parseUINT32(genderRestrictMask);
	AtfValidator::validateIntMax(_descr, "genderRestrictMask", genderRestrictMask, (2*RestrictedTo_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 tournDisplayMask; _parser0.parseUINT32(tournDisplayMask);
	AtfValidator::validateIntMax(_descr, "tournDisplayMask", tournDisplayMask, (2*NGTournDisplay_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 negateTournVariantMask; _parser0.parseUINT32(negateTournVariantMask);
	AtfValidator::validateIntMax(_descr, "negateTournVariantMask", negateTournVariantMask, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournResultCriteria
//=================================================================

MLobbyNG::cli::TournResultCriteria::TournResultCriteria()
{
	clear();
}

void MLobbyNG::cli::TournResultCriteria::clear()
{
	sortOrder = 0;
	maxItems = 0;
}

bool MLobbyNG::cli::TournResultCriteria::equals(const TournResultCriteria& _o) const
{
	return sortOrder == _o.sortOrder &&
		maxItems == _o.maxItems;
}

const char *MLobbyNG::cli::TournResultCriteria::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sortOrder=");
	_buf.appendUint(sortOrder);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::TournResultCriteria::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("sortOrder", sortOrder, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxItems", maxItems, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::TournResultCriteria::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("sortOrder"))
		{
			sortOrder = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxItems"))
		{
			maxItems = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::TournResultCriteria::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournResultCriteria())) // not empty
	{
		_body.composeUINT32(sortOrder);
		_body.composeUINT32(maxItems);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TournResultCriteria::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(sortOrder);
	_parser0.parseUINT32(maxItems);
}

const char *MLobbyNG::cli::TournResultCriteria::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sortOrder", sortOrder);
	_jsonstr.compose("maxItems", maxItems);
	return _buf.c_str();
}

void MLobbyNG::cli::TournResultCriteria::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sortOrder", sortOrder);
	_jparser.parseByNameThrow("maxItems", maxItems);
}

/* static */ void MLobbyNG::cli::TournResultCriteria::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 sortOrder; _jparser.validateByNameThrow("sortOrder", sortOrder);
	AtfValidator::validateIntRange(_descr, "sortOrder", sortOrder, NGTournSort_BuyInAsc, NGTournSort_Last, _checker, __FILE__, __LINE__);
	UINT32 maxItems; _jparser.validateByNameThrow("maxItems", maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::TournResultCriteria::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 sortOrder; _parser0.parseUINT32(sortOrder);
	AtfValidator::validateIntRange(_descr, "sortOrder", sortOrder, NGTournSort_BuyInAsc, NGTournSort_Last, _checker, __FILE__, __LINE__);
	UINT32 maxItems; _parser0.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ClientMarkers
//=================================================================

MLobbyNG::cli::ClientMarkers::ClientMarkers()
{
	clear();
}

void MLobbyNG::cli::ClientMarkers::clear()
{
	context = 0;
}

bool MLobbyNG::cli::ClientMarkers::equals(const ClientMarkers& _o) const
{
	return context == _o.context;
}

const char *MLobbyNG::cli::ClientMarkers::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("context=");
	_buf.appendUint(context);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::ClientMarkers::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("context", context, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::ClientMarkers::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("context"))
		{
			context = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::ClientMarkers::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ClientMarkers())) // not empty
	{
		_body.composeUINT32(context);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::ClientMarkers::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(context);
}

const char *MLobbyNG::cli::ClientMarkers::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("context", context);
	return _buf.c_str();
}

void MLobbyNG::cli::ClientMarkers::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("context", context);
}

/* static */ void MLobbyNG::cli::ClientMarkers::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 context; _jparser.validateByNameThrow("context", context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::ClientMarkers::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 context; _parser0.parseUINT32(context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FppFactorStruct
//=================================================================

MLobbyNG::cli::FppFactorStruct::FppFactorStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::FppFactorStruct::FppFactorStruct(FppFactorStruct&& _o)
	: fppFactor(std::move(_o.fppFactor))
	, sites(std::move(_o.sites))
	, gameCategory(std::move(_o.gameCategory))
	, number(std::move(_o.number))
	, endT(std::move(_o.endT))
	, sitesEx(std::move(_o.sitesEx))
{
}

MLobbyNG::cli::FppFactorStruct& MLobbyNG::cli::FppFactorStruct::operator=(FppFactorStruct&& _o)
{
	if(this != &_o)
	{
		fppFactor = std::move(_o.fppFactor);
		sites = std::move(_o.sites);
		gameCategory = std::move(_o.gameCategory);
		number = std::move(_o.number);
		endT = std::move(_o.endT);
		sitesEx = std::move(_o.sitesEx);
	}
	return *this;
}

#endif

void MLobbyNG::cli::FppFactorStruct::clear()
{
	fppFactor = 0;
	sites = 0;
	gameCategory = 0;
	number = 0;
	endT.setNull();
	sitesEx.clear();
}

bool MLobbyNG::cli::FppFactorStruct::equals(const FppFactorStruct& _o) const
{
	return fppFactor == _o.fppFactor &&
		sites == _o.sites &&
		gameCategory == _o.gameCategory &&
		number == _o.number &&
		endT.equals(_o.endT) &&
		sitesEx.equals(_o.sitesEx);
}

const char *MLobbyNG::cli::FppFactorStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fppFactor=");
	_buf.appendUint(fppFactor);
	_buf.append(',');
	_buf.append("sites=");
	_buf.appendUint(sites);
	_buf.append(',');
	_buf.append("gameCategory=");
	_buf.appendUint(gameCategory);
	_buf.append(',');
	_buf.append("number=");
	_buf.appendUint(number);
	_buf.append(',');
	_buf.append("endT=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, endT);
	_buf.append(',');
	_buf.append("sitesEx=");
	sitesEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::FppFactorStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("fppFactor", fppFactor, _buf);
	Atf::XmlElement::encodeAsXmlElement("sites", sites, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameCategory", gameCategory, _buf);
	Atf::XmlElement::encodeAsXmlElement("number", number, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "endT", endT);
	sitesEx.toXmlString("sitesEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::FppFactorStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("fppFactor"))
		{
			fppFactor = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sites"))
		{
			sites = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameCategory"))
		{
			gameCategory = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("number"))
		{
			number = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("endT"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, endT);
		}
		else if (_element.equals("sitesEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, sitesEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::FppFactorStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FppFactorStruct())) // not empty
	{
		_body.composeUINT16(fppFactor);
		_body.composeUINT32(sites);
		_body.composeUINT32(gameCategory);
		_body.composeUINT32(number);
		_body.composeSrvTime(endT);
		sitesEx.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::FppFactorStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT16(fppFactor);
	_parser0.parseUINT32(sites);
	_parser0.parseUINT32(gameCategory);
	_parser0.parseUINT32(number);
	_parser0.parseSrvTime(endT);
	if(_parser0.parseEnded()) return;
	sitesEx.parseMsg(_parser0);
}

const char *MLobbyNG::cli::FppFactorStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("fppFactor", fppFactor);
	_jsonstr.compose("sites", sites);
	_jsonstr.compose("gameCategory", gameCategory);
	_jsonstr.compose("number", number);
	_jsonstr.compose("endT", endT);
	_jsonstr.compose("sitesEx", sitesEx);
	return _buf.c_str();
}

void MLobbyNG::cli::FppFactorStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("fppFactor", fppFactor);
	_jparser.parseByNameThrow("sites", sites);
	_jparser.parseByNameThrow("gameCategory", gameCategory);
	_jparser.parseByNameThrow("number", number);
	_jparser.parseByNameThrow("endT", endT);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("sitesEx", sitesEx);
}

/* static */ void MLobbyNG::cli::FppFactorStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 fppFactor; _jparser.validateByNameThrow("fppFactor", fppFactor);
	AtfValidator::validateInt(_descr, "fppFactor", fppFactor, _checker, __FILE__, __LINE__);
	UINT32 sites; _jparser.validateByNameThrow("sites", sites);
	AtfValidator::validateInt(_descr, "sites", sites, _checker, __FILE__, __LINE__);
	UINT32 gameCategory; _jparser.validateByNameThrow("gameCategory", gameCategory);
	AtfValidator::validateInt(_descr, "gameCategory", gameCategory, _checker, __FILE__, __LINE__);
	UINT32 number; _jparser.validateByNameThrow("number", number);
	AtfValidator::validateInt(_descr, "number", number, _checker, __FILE__, __LINE__);
	SrvTime endT; _jparser.validateByNameThrow("endT", endT);
	AtfValidator::validateSrvDateTime(_descr, "endT", endT, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask sitesEx; _jparser.validateByNameThrow("sitesEx", sitesEx);
}

/*static*/ void MLobbyNG::cli::FppFactorStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT16 fppFactor; _parser0.parseUINT16(fppFactor);
	AtfValidator::validateInt(_descr, "fppFactor", fppFactor, _checker, __FILE__, __LINE__);
	UINT32 sites; _parser0.parseUINT32(sites);
	AtfValidator::validateInt(_descr, "sites", sites, _checker, __FILE__, __LINE__);
	UINT32 gameCategory; _parser0.parseUINT32(gameCategory);
	AtfValidator::validateInt(_descr, "gameCategory", gameCategory, _checker, __FILE__, __LINE__);
	UINT32 number; _parser0.parseUINT32(number);
	AtfValidator::validateInt(_descr, "number", number, _checker, __FILE__, __LINE__);
	SrvTime endT; _parser0.parseSrvTime(endT);
	AtfValidator::validateSrvDateTime(_descr, "endT", endT, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sitesEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournStaticData
//=================================================================

MLobbyNG::cli::TournStaticData::TournStaticData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TournStaticData::TournStaticData(TournStaticData&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, targetServer(std::move(_o.targetServer))
	, hasSatellite(std::move(_o.hasSatellite))
	, whenStart(std::move(_o.whenStart))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, isRestricted(std::move(_o.isRestricted))
	, isPwdProtected(std::move(_o.isPwdProtected))
	, name(std::move(_o.name))
	, admissionId(std::move(_o.admissionId))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, satelliteTarget(std::move(_o.satelliteTarget))
	, minPlayers(std::move(_o.minPlayers))
	, tournFlags(std::move(_o.tournFlags))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, tournMask(std::move(_o.tournMask))
	, tournSites(std::move(_o.tournSites))
	, whenStartInt(std::move(_o.whenStartInt))
	, tournMask2(std::move(_o.tournMask2))
	, targetWhenStart(std::move(_o.targetWhenStart))
	, tournMask3(std::move(_o.tournMask3))
	, tournMask4(std::move(_o.tournMask4))
	, maxPerTable(std::move(_o.maxPerTable))
	, countryRestrictionInverted(std::move(_o.countryRestrictionInverted))
	, restrictedCountries(std::move(_o.restrictedCountries))
	, hasDayTwoStart(std::move(_o.hasDayTwoStart))
	, dayTwoStartSec(std::move(_o.dayTwoStartSec))
	, dayTwoStart(std::move(_o.dayTwoStart))
	, shortText(std::move(_o.shortText))
	, chatLang(std::move(_o.chatLang))
	, currency(std::move(_o.currency))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, knockout(std::move(_o.knockout))
	, satelliteTargetReference(std::move(_o.satelliteTargetReference))
	, satelliteTargetReferenceLock(std::move(_o.satelliteTargetReferenceLock))
	, maxPlayers(std::move(_o.maxPlayers))
	, speedDisplay(std::move(_o.speedDisplay))
	, nameSnG(std::move(_o.nameSnG))
	, step(std::move(_o.step))
	, timedTournType(std::move(_o.timedTournType))
	, timedTournTime(std::move(_o.timedTournTime))
	, timedTournPayout(std::move(_o.timedTournPayout))
	, isFlightTourn(std::move(_o.isFlightTourn))
	, tournBrand(std::move(_o.tournBrand))
	, scalePM(std::move(_o.scalePM))
	, progressiveKnockout(std::move(_o.progressiveKnockout))
	, awardScheme(std::move(_o.awardScheme))
	, numReentries(std::move(_o.numReentries))
	, internalReference(std::move(_o.internalReference))
	, favReference(std::move(_o.favReference))
	, satelliteTargetName(std::move(_o.satelliteTargetName))
	, admissionPrice(std::move(_o.admissionPrice))
	, tournFlags2(std::move(_o.tournFlags2))
	, regEndAbs(std::move(_o.regEndAbs))
	, regEndAbsInt(std::move(_o.regEndAbsInt))
	, doNotAllowToUnreg(std::move(_o.doNotAllowToUnreg))
	, nStackInfo(std::move(_o.nStackInfo))
	, tournMask5(std::move(_o.tournMask5))
	, tournMask6(std::move(_o.tournMask6))
	, satelliteTargetNameMTT(std::move(_o.satelliteTargetNameMTT))
	, liveEventMask(std::move(_o.liveEventMask))
	, timedTournPlayersPercent(std::move(_o.timedTournPlayersPercent))
	, dummy1(std::move(_o.dummy1))
	, rmPmLobby(std::move(_o.rmPmLobby))
	, brandAccessMask(std::move(_o.brandAccessMask))
	, activeFlags(std::move(_o.activeFlags))
	, sngScriptId(std::move(_o.sngScriptId))
	, customSpeedDisplayName(std::move(_o.customSpeedDisplayName))
	, mobileName(std::move(_o.mobileName))
	, tournGroup(std::move(_o.tournGroup))
	, guaranteedPrizePool(std::move(_o.guaranteedPrizePool))
	, admissions(std::move(_o.admissions))
	, serverObj(std::move(_o.serverObj))
	, tournGroupRef(std::move(_o.tournGroupRef))
	, maxPayoutSag(std::move(_o.maxPayoutSag))
	, tournSitesEx(std::move(_o.tournSitesEx))
{
}

MLobbyNG::cli::TournStaticData& MLobbyNG::cli::TournStaticData::operator=(TournStaticData&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		targetServer = std::move(_o.targetServer);
		hasSatellite = std::move(_o.hasSatellite);
		whenStart = std::move(_o.whenStart);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		fppBuyIn = std::move(_o.fppBuyIn);
		isRestricted = std::move(_o.isRestricted);
		isPwdProtected = std::move(_o.isPwdProtected);
		name = std::move(_o.name);
		admissionId = std::move(_o.admissionId);
		isPlayMoney = std::move(_o.isPlayMoney);
		satelliteTarget = std::move(_o.satelliteTarget);
		minPlayers = std::move(_o.minPlayers);
		tournFlags = std::move(_o.tournFlags);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		tournMask = std::move(_o.tournMask);
		tournSites = std::move(_o.tournSites);
		whenStartInt = std::move(_o.whenStartInt);
		tournMask2 = std::move(_o.tournMask2);
		targetWhenStart = std::move(_o.targetWhenStart);
		tournMask3 = std::move(_o.tournMask3);
		tournMask4 = std::move(_o.tournMask4);
		maxPerTable = std::move(_o.maxPerTable);
		countryRestrictionInverted = std::move(_o.countryRestrictionInverted);
		restrictedCountries = std::move(_o.restrictedCountries);
		hasDayTwoStart = std::move(_o.hasDayTwoStart);
		dayTwoStartSec = std::move(_o.dayTwoStartSec);
		dayTwoStart = std::move(_o.dayTwoStart);
		shortText = std::move(_o.shortText);
		chatLang = std::move(_o.chatLang);
		currency = std::move(_o.currency);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		knockout = std::move(_o.knockout);
		satelliteTargetReference = std::move(_o.satelliteTargetReference);
		satelliteTargetReferenceLock = std::move(_o.satelliteTargetReferenceLock);
		maxPlayers = std::move(_o.maxPlayers);
		speedDisplay = std::move(_o.speedDisplay);
		nameSnG = std::move(_o.nameSnG);
		step = std::move(_o.step);
		timedTournType = std::move(_o.timedTournType);
		timedTournTime = std::move(_o.timedTournTime);
		timedTournPayout = std::move(_o.timedTournPayout);
		isFlightTourn = std::move(_o.isFlightTourn);
		tournBrand = std::move(_o.tournBrand);
		scalePM = std::move(_o.scalePM);
		progressiveKnockout = std::move(_o.progressiveKnockout);
		awardScheme = std::move(_o.awardScheme);
		numReentries = std::move(_o.numReentries);
		internalReference = std::move(_o.internalReference);
		favReference = std::move(_o.favReference);
		satelliteTargetName = std::move(_o.satelliteTargetName);
		admissionPrice = std::move(_o.admissionPrice);
		tournFlags2 = std::move(_o.tournFlags2);
		regEndAbs = std::move(_o.regEndAbs);
		regEndAbsInt = std::move(_o.regEndAbsInt);
		doNotAllowToUnreg = std::move(_o.doNotAllowToUnreg);
		nStackInfo = std::move(_o.nStackInfo);
		tournMask5 = std::move(_o.tournMask5);
		tournMask6 = std::move(_o.tournMask6);
		satelliteTargetNameMTT = std::move(_o.satelliteTargetNameMTT);
		liveEventMask = std::move(_o.liveEventMask);
		timedTournPlayersPercent = std::move(_o.timedTournPlayersPercent);
		dummy1 = std::move(_o.dummy1);
		rmPmLobby = std::move(_o.rmPmLobby);
		brandAccessMask = std::move(_o.brandAccessMask);
		activeFlags = std::move(_o.activeFlags);
		sngScriptId = std::move(_o.sngScriptId);
		customSpeedDisplayName = std::move(_o.customSpeedDisplayName);
		mobileName = std::move(_o.mobileName);
		tournGroup = std::move(_o.tournGroup);
		guaranteedPrizePool = std::move(_o.guaranteedPrizePool);
		admissions = std::move(_o.admissions);
		serverObj = std::move(_o.serverObj);
		tournGroupRef = std::move(_o.tournGroupRef);
		maxPayoutSag = std::move(_o.maxPayoutSag);
		tournSitesEx = std::move(_o.tournSitesEx);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TournStaticData::clear()
{
	tournamentId = 0;
	server.clear();
	targetServer.clear();
	hasSatellite.clear();
	whenStart.setNull();
	buyIn = 0;
	rake = 0;
	fppBuyIn = 0;
	isRestricted = 0;
	isPwdProtected = 0;
	name.clear();
	admissionId.clear();
	isPlayMoney = 0;
	satelliteTarget = 0;
	minPlayers = 0;
	tournFlags = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	tournMask = 0;
	tournSites = 0;
	whenStartInt = 0;
	tournMask2 = 0;
	targetWhenStart.setNull();
	tournMask3 = 0;
	tournMask4 = 0;
	maxPerTable = 0;
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	hasDayTwoStart = 0;
	dayTwoStartSec = 0;
	dayTwoStart.setNull();
	shortText.clear();
	chatLang = 0;
	currency.clear();
	tournFlagsServInt = 0;
	knockout = 0;
	satelliteTargetReference.clear();
	satelliteTargetReferenceLock = 0;
	maxPlayers = 0;
	speedDisplay = 0;
	nameSnG.clear();
	step = 0;
	timedTournType = 0;
	timedTournTime = 0;
	timedTournPayout = 0;
	isFlightTourn = false;
	tournBrand.clear();
	scalePM = 0;
	progressiveKnockout = 0;
	awardScheme = 0;
	numReentries = 0;
	internalReference.clear();
	favReference.clear();
	satelliteTargetName.clear();
	admissionPrice = 0;
	tournFlags2 = 0;
	regEndAbs.setNull();
	regEndAbsInt = 0;
	doNotAllowToUnreg = false;
	nStackInfo.clear();
	tournMask5 = 0;
	tournMask6 = 0;
	satelliteTargetNameMTT.clear();
	liveEventMask = 0;
	timedTournPlayersPercent = 0;
	dummy1 = 0;
	rmPmLobby = 0;
	brandAccessMask = 0;
	activeFlags = 0;
	sngScriptId = 0;
	customSpeedDisplayName.clear();
	mobileName.clear();
	tournGroup = 0;
	guaranteedPrizePool = 0;
	admissions.clear();
	serverObj.clear();
	tournGroupRef.clear();
	maxPayoutSag = 0;
	tournSitesEx.clear();
}

bool MLobbyNG::cli::TournStaticData::equals(const TournStaticData& _o) const
{
	return tournamentId == _o.tournamentId &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(targetServer, _o.targetServer) &&
		Atf::atfPStringEquals(hasSatellite, _o.hasSatellite) &&
		whenStart.equals(_o.whenStart) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		fppBuyIn == _o.fppBuyIn &&
		isRestricted == _o.isRestricted &&
		isPwdProtected == _o.isPwdProtected &&
		Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(admissionId, _o.admissionId) &&
		isPlayMoney == _o.isPlayMoney &&
		satelliteTarget == _o.satelliteTarget &&
		minPlayers == _o.minPlayers &&
		tournFlags == _o.tournFlags &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		tournMask == _o.tournMask &&
		tournSites == _o.tournSites &&
		whenStartInt == _o.whenStartInt &&
		tournMask2 == _o.tournMask2 &&
		targetWhenStart.equals(_o.targetWhenStart) &&
		tournMask3 == _o.tournMask3 &&
		tournMask4 == _o.tournMask4 &&
		maxPerTable == _o.maxPerTable &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		hasDayTwoStart == _o.hasDayTwoStart &&
		dayTwoStartSec == _o.dayTwoStartSec &&
		dayTwoStart.equals(_o.dayTwoStart) &&
		Atf::atfPStringEquals(shortText, _o.shortText) &&
		chatLang == _o.chatLang &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		knockout == _o.knockout &&
		Atf::atfPStringEquals(satelliteTargetReference, _o.satelliteTargetReference) &&
		satelliteTargetReferenceLock == _o.satelliteTargetReferenceLock &&
		maxPlayers == _o.maxPlayers &&
		speedDisplay == _o.speedDisplay &&
		Atf::atfPStringEquals(nameSnG, _o.nameSnG) &&
		step == _o.step &&
		timedTournType == _o.timedTournType &&
		timedTournTime == _o.timedTournTime &&
		timedTournPayout == _o.timedTournPayout &&
		isFlightTourn == _o.isFlightTourn &&
		Atf::atfPStringEquals(tournBrand, _o.tournBrand) &&
		scalePM == _o.scalePM &&
		progressiveKnockout == _o.progressiveKnockout &&
		awardScheme == _o.awardScheme &&
		numReentries == _o.numReentries &&
		Atf::atfPStringEquals(internalReference, _o.internalReference) &&
		Atf::atfPStringEquals(favReference, _o.favReference) &&
		Atf::atfPStringEquals(satelliteTargetName, _o.satelliteTargetName) &&
		admissionPrice == _o.admissionPrice &&
		tournFlags2 == _o.tournFlags2 &&
		regEndAbs.equals(_o.regEndAbs) &&
		regEndAbsInt == _o.regEndAbsInt &&
		doNotAllowToUnreg == _o.doNotAllowToUnreg &&
		nStackInfo.equals(_o.nStackInfo) &&
		tournMask5 == _o.tournMask5 &&
		tournMask6 == _o.tournMask6 &&
		Atf::atfPStringEquals(satelliteTargetNameMTT, _o.satelliteTargetNameMTT) &&
		liveEventMask == _o.liveEventMask &&
		timedTournPlayersPercent == _o.timedTournPlayersPercent &&
		dummy1 == _o.dummy1 &&
		rmPmLobby == _o.rmPmLobby &&
		brandAccessMask == _o.brandAccessMask &&
		activeFlags == _o.activeFlags &&
		sngScriptId == _o.sngScriptId &&
		Atf::atfPStringEquals(customSpeedDisplayName, _o.customSpeedDisplayName) &&
		Atf::atfPStringEquals(mobileName, _o.mobileName) &&
		tournGroup == _o.tournGroup &&
		guaranteedPrizePool == _o.guaranteedPrizePool &&
		admissions.equals(_o.admissions) &&
		Atf::atfPStringEquals(serverObj, _o.serverObj) &&
		Atf::atfPStringEquals(tournGroupRef, _o.tournGroupRef) &&
		maxPayoutSag == _o.maxPayoutSag &&
		tournSitesEx.equals(_o.tournSitesEx);
}

const char *MLobbyNG::cli::TournStaticData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint64(tournamentId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("targetServer=");
	_buf.append(targetServer);
	_buf.append(',');
	_buf.append("hasSatellite=");
	_buf.append(hasSatellite);
	_buf.append(',');
	_buf.append("whenStart=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("isRestricted=");
	_buf.appendUint(isRestricted);
	_buf.append(',');
	_buf.append("isPwdProtected=");
	_buf.appendUint(isPwdProtected);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("satelliteTarget=");
	_buf.appendUint(satelliteTarget);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("tournMask=");
	_buf.appendUint(tournMask);
	_buf.append(',');
	_buf.append("tournSites=");
	_buf.appendUint(tournSites);
	_buf.append(',');
	_buf.append("whenStartInt=");
	_buf.appendUint(whenStartInt);
	_buf.append(',');
	_buf.append("tournMask2=");
	_buf.appendUint(tournMask2);
	_buf.append(',');
	_buf.append("targetWhenStart=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, targetWhenStart);
	_buf.append(',');
	_buf.append("tournMask3=");
	_buf.appendUint(tournMask3);
	_buf.append(',');
	_buf.append("tournMask4=");
	_buf.appendUint(tournMask4);
	_buf.append(',');
	_buf.append("maxPerTable=");
	_buf.appendUint(maxPerTable);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("hasDayTwoStart=");
	_buf.appendUint(hasDayTwoStart);
	_buf.append(',');
	_buf.append("dayTwoStartSec=");
	_buf.appendUint(dayTwoStartSec);
	_buf.append(',');
	_buf.append("dayTwoStart=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, dayTwoStart);
	_buf.append(',');
	_buf.append("shortText=");
	_buf.append(shortText);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("tournFlagsServInt=");
	_buf.appendUint(tournFlagsServInt);
	_buf.append(',');
	_buf.append("knockout=");
	_buf.appendUint(knockout);
	_buf.append(',');
	_buf.append("satelliteTargetReference=");
	_buf.append(satelliteTargetReference);
	_buf.append(',');
	_buf.append("satelliteTargetReferenceLock=");
	_buf.appendUint(satelliteTargetReferenceLock);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("speedDisplay=");
	_buf.appendUint(speedDisplay);
	_buf.append(',');
	_buf.append("nameSnG=");
	_buf.append(nameSnG);
	_buf.append(',');
	_buf.append("step=");
	_buf.appendUint(step);
	_buf.append(',');
	_buf.append("timedTournType=");
	_buf.appendUint(timedTournType);
	_buf.append(',');
	_buf.append("timedTournTime=");
	_buf.appendUint(timedTournTime);
	_buf.append(',');
	_buf.append("timedTournPayout=");
	_buf.appendUint(timedTournPayout);
	_buf.append(',');
	_buf.append("isFlightTourn=");
	_buf.appendUint(isFlightTourn);
	_buf.append(',');
	_buf.append("tournBrand=");
	_buf.append(tournBrand);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("progressiveKnockout=");
	_buf.appendUint(progressiveKnockout);
	_buf.append(',');
	_buf.append("awardScheme=");
	_buf.appendUint(awardScheme);
	_buf.append(',');
	_buf.append("numReentries=");
	_buf.appendUint(numReentries);
	_buf.append(',');
	_buf.append("internalReference=");
	_buf.append(internalReference);
	_buf.append(',');
	_buf.append("favReference=");
	_buf.append(favReference);
	_buf.append(',');
	_buf.append("satelliteTargetName=");
	_buf.append(satelliteTargetName);
	_buf.append(',');
	_buf.append("admissionPrice=");
	_buf.appendInt64(admissionPrice);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append(',');
	_buf.append("regEndAbs=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, regEndAbs);
	_buf.append(',');
	_buf.append("regEndAbsInt=");
	_buf.appendUint(regEndAbsInt);
	_buf.append(',');
	_buf.append("doNotAllowToUnreg=");
	_buf.appendUint(doNotAllowToUnreg);
	_buf.append(',');
	_buf.append("nStackInfo=");
	nStackInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournMask5=");
	_buf.appendUint(tournMask5);
	_buf.append(',');
	_buf.append("tournMask6=");
	_buf.appendUint(tournMask6);
	_buf.append(',');
	_buf.append("satelliteTargetNameMTT=");
	_buf.append(satelliteTargetNameMTT);
	_buf.append(',');
	_buf.append("liveEventMask=");
	_buf.appendUint(liveEventMask);
	_buf.append(',');
	_buf.append("timedTournPlayersPercent=");
	_buf.appendUint(timedTournPlayersPercent);
	_buf.append(',');
	_buf.append("dummy1=");
	_buf.appendUint(dummy1);
	_buf.append(',');
	_buf.append("rmPmLobby=");
	_buf.appendUint(rmPmLobby);
	_buf.append(',');
	_buf.append("brandAccessMask=");
	_buf.appendUint(brandAccessMask);
	_buf.append(',');
	_buf.append("activeFlags=");
	_buf.appendUint(activeFlags);
	_buf.append(',');
	_buf.append("sngScriptId=");
	_buf.appendUint(sngScriptId);
	_buf.append(',');
	_buf.append("customSpeedDisplayName=");
	_buf.append(customSpeedDisplayName);
	_buf.append(',');
	_buf.append("mobileName=");
	_buf.append(mobileName);
	_buf.append(',');
	_buf.append("tournGroup=");
	_buf.appendUint(tournGroup);
	_buf.append(',');
	_buf.append("guaranteedPrizePool=");
	_buf.appendInt(guaranteedPrizePool);
	_buf.append(',');
	_buf.append("admissions=");
	admissions.toTraceString(_buf);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append(',');
	_buf.append("tournGroupRef=");
	_buf.append(tournGroupRef);
	_buf.append(',');
	_buf.append("maxPayoutSag=");
	_buf.appendInt(maxPayoutSag);
	_buf.append(',');
	_buf.append("tournSitesEx=");
	tournSitesEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::TournStaticData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournamentId", tournamentId, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("targetServer", targetServer, _buf);
	Atf::XmlElement::encodeAsXmlElement("hasSatellite", hasSatellite, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenStart", whenStart);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBuyIn", fppBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("isRestricted", isRestricted, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPwdProtected", isPwdProtected, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("admissionId", admissionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTarget", satelliteTarget, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask", tournMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournSites", tournSites, _buf);
	Atf::XmlElement::encodeAsXmlElement("whenStartInt", whenStartInt, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask2", tournMask2, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "targetWhenStart", targetWhenStart);
	Atf::XmlElement::encodeAsXmlElement("tournMask3", tournMask3, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask4", tournMask4, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPerTable", maxPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryRestrictionInverted", countryRestrictionInverted, _buf);
	restrictedCountries.toXmlString("restrictedCountries", _buf);
	Atf::XmlElement::encodeAsXmlElement("hasDayTwoStart", hasDayTwoStart, _buf);
	Atf::XmlElement::encodeAsXmlElement("dayTwoStartSec", dayTwoStartSec, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "dayTwoStart", dayTwoStart);
	Atf::XmlElement::encodeAsXmlElement("shortText", shortText, _buf);
	Atf::XmlElement::encodeAsXmlElement("chatLang", chatLang, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlagsServInt", tournFlagsServInt, _buf);
	Atf::XmlElement::encodeAsXmlElement("knockout", knockout, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTargetReference", satelliteTargetReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTargetReferenceLock", satelliteTargetReferenceLock, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("speedDisplay", speedDisplay, _buf);
	Atf::XmlElement::encodeAsXmlElement("nameSnG", nameSnG, _buf);
	Atf::XmlElement::encodeAsXmlElement("step", step, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournType", timedTournType, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournTime", timedTournTime, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournPayout", timedTournPayout, _buf);
	Atf::XmlElement::encodeAsXmlElement("isFlightTourn", isFlightTourn, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournBrand", tournBrand, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("progressiveKnockout", progressiveKnockout, _buf);
	Atf::XmlElement::encodeAsXmlElement("awardScheme", awardScheme, _buf);
	Atf::XmlElement::encodeAsXmlElement("numReentries", numReentries, _buf);
	Atf::XmlElement::encodeAsXmlElement("internalReference", internalReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("favReference", favReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTargetName", satelliteTargetName, _buf);
	Atf::XmlElement::encodeAsXmlElement("admissionPrice", admissionPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "regEndAbs", regEndAbs);
	Atf::XmlElement::encodeAsXmlElement("regEndAbsInt", regEndAbsInt, _buf);
	Atf::XmlElement::encodeAsXmlElement("doNotAllowToUnreg", doNotAllowToUnreg, _buf);
	nStackInfo.toXmlString("nStackInfo", _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask5", tournMask5, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask6", tournMask6, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTargetNameMTT", satelliteTargetNameMTT, _buf);
	Atf::XmlElement::encodeAsXmlElement("liveEventMask", liveEventMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournPlayersPercent", timedTournPlayersPercent, _buf);
	Atf::XmlElement::encodeAsXmlElement("dummy1", dummy1, _buf);
	Atf::XmlElement::encodeAsXmlElement("rmPmLobby", rmPmLobby, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandAccessMask", brandAccessMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("activeFlags", activeFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("sngScriptId", sngScriptId, _buf);
	Atf::XmlElement::encodeAsXmlElement("customSpeedDisplayName", customSpeedDisplayName, _buf);
	Atf::XmlElement::encodeAsXmlElement("mobileName", mobileName, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournGroup", tournGroup, _buf);
	Atf::XmlElement::encodeAsXmlElement("guaranteedPrizePool", guaranteedPrizePool, _buf);
	admissions.toXmlString("admissions", _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObj", serverObj, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournGroupRef", tournGroupRef, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPayoutSag", maxPayoutSag, _buf);
	tournSitesEx.toXmlString("tournSitesEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::TournStaticData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		switch((BYTE)*_element)
		{
		case 'a':
			if (_element.equals("admissionId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, admissionId)) return false;
			}
			else if (_element.equals("awardScheme"))
			{
				awardScheme = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("admissionPrice"))
			{
				admissionPrice = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("activeFlags"))
			{
				activeFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("admissions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, admissions)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'b':
			if (_element.equals("buyIn"))
			{
				buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("brandAccessMask"))
			{
				brandAccessMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'c':
			if (_element.equals("countryRestrictionInverted"))
			{
				countryRestrictionInverted = (*_value.ptr() == '1');
			}
			else if (_element.equals("chatLang"))
			{
				chatLang = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("customSpeedDisplayName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, customSpeedDisplayName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'd':
			if (_element.equals("dayTwoStartSec"))
			{
				dayTwoStartSec = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("dayTwoStart"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, dayTwoStart);
			}
			else if (_element.equals("doNotAllowToUnreg"))
			{
				doNotAllowToUnreg = (*_value.ptr() == '1');
			}
			else if (_element.equals("dummy1"))
			{
				dummy1 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'f':
			if (_element.equals("fppBuyIn"))
			{
				fppBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("favReference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, favReference)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'g':
			if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("guaranteedPrizePool"))
			{
				guaranteedPrizePool = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'h':
			if (_element.equals("hasSatellite"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, hasSatellite)) return false;
			}
			else if (_element.equals("hasDayTwoStart"))
			{
				hasDayTwoStart = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'i':
			if (_element.equals("isRestricted"))
			{
				isRestricted = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPwdProtected"))
			{
				isPwdProtected = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isHiLo"))
			{
				isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isFlightTourn"))
			{
				isFlightTourn = (*_value.ptr() == '1');
			}
			else if (_element.equals("internalReference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, internalReference)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'k':
			if (_element.equals("knockout"))
			{
				knockout = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'l':
			if (_element.equals("liveEventMask"))
			{
				liveEventMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'm':
			if (_element.equals("minPlayers"))
			{
				minPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPerTable"))
			{
				maxPerTable = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPlayers"))
			{
				maxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("mobileName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, mobileName)) return false;
			}
			else if (_element.equals("maxPayoutSag"))
			{
				maxPayoutSag = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'n':
			if (_element.equals("name"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
			}
			else if (_element.equals("nameSnG"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, nameSnG)) return false;
			}
			else if (_element.equals("numReentries"))
			{
				numReentries = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("nStackInfo"))
			{
				if(!Atf::AtfTempl< TournClient::NStackTournInfoStruct >::FromXmlString(_value, nStackInfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'p':
			if (_element.equals("progressiveKnockout"))
			{
				progressiveKnockout = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'r':
			if (_element.equals("rake"))
			{
				rake = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("restrictedCountries"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PString , 4 > >::FromXmlString(_value, restrictedCountries)) return false;
			}
			else if (_element.equals("regEndAbs"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, regEndAbs);
			}
			else if (_element.equals("regEndAbsInt"))
			{
				regEndAbsInt = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rmPmLobby"))
			{
				rmPmLobby = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 's':
			if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else if (_element.equals("satelliteTarget"))
			{
				satelliteTarget = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("shortText"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, shortText)) return false;
			}
			else if (_element.equals("satelliteTargetReference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, satelliteTargetReference)) return false;
			}
			else if (_element.equals("satelliteTargetReferenceLock"))
			{
				satelliteTargetReferenceLock = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("speedDisplay"))
			{
				speedDisplay = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("step"))
			{
				step = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("scalePM"))
			{
				scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("satelliteTargetName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, satelliteTargetName)) return false;
			}
			else if (_element.equals("satelliteTargetNameMTT"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, satelliteTargetNameMTT)) return false;
			}
			else if (_element.equals("sngScriptId"))
			{
				sngScriptId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("serverObj"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, serverObj)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 't':
			if (_element.equals("tournamentId"))
			{
				tournamentId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("targetServer"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, targetServer)) return false;
			}
			else if (_element.equals("tournFlags"))
			{
				tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask"))
			{
				tournMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournSites"))
			{
				tournSites = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask2"))
			{
				tournMask2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("targetWhenStart"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, targetWhenStart);
			}
			else if (_element.equals("tournMask3"))
			{
				tournMask3 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask4"))
			{
				tournMask4 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlagsServInt"))
			{
				tournFlagsServInt = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timedTournType"))
			{
				timedTournType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timedTournTime"))
			{
				timedTournTime = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timedTournPayout"))
			{
				timedTournPayout = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournBrand"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournBrand)) return false;
			}
			else if (_element.equals("tournFlags2"))
			{
				tournFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask5"))
			{
				tournMask5 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask6"))
			{
				tournMask6 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timedTournPlayersPercent"))
			{
				timedTournPlayersPercent = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournGroup"))
			{
				tournGroup = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournGroupRef"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournGroupRef)) return false;
			}
			else if (_element.equals("tournSitesEx"))
			{
				if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, tournSitesEx)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'w':
			if (_element.equals("whenStart"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenStart);
			}
			else if (_element.equals("whenStartInt"))
			{
				whenStartInt = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		default:
			return false;
		}
	}
	return true;
}

void MLobbyNG::cli::TournStaticData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournStaticData())) // not empty
	{
		_body.composeUINT64(tournamentId);
		_body.composeString(server);
		_body.composeString(targetServer);
		_body.composeString(hasSatellite);
		_body.composeSrvTime(whenStart);
		_body.composeUINT32(buyIn);
		_body.composeUINT32(rake);
		_body.composeUINT32(fppBuyIn);
		_body.composeBYTE(isRestricted);
		_body.composeBYTE(isPwdProtected);
		_body.composeString(name);
		_body.composeString(admissionId);
		_body.composeBYTE(isPlayMoney);
		_body.composeUINT32(satelliteTarget);
		_body.composeUINT32(minPlayers);
		_body.composeUINT32(tournFlags);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(structure);
		_body.composeUINT32(tournMask);
		_body.composeUINT32(tournSites);
		_body.composeUINT32(whenStartInt);
		_body.composeUINT32(tournMask2);
		_body.composeSrvTime(targetWhenStart);
		_body.composeUINT32(tournMask3);
		_body.composeUINT32(tournMask4);
		_body.composeUINT32(maxPerTable);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body, _ignoreJSON);
		_body.composeBYTE(hasDayTwoStart);
		_body.composeUINT32(dayTwoStartSec);
		_body.composeSrvTime(dayTwoStart);
		_body.composeString(shortText);
		_body.composeUINT16(chatLang);
		_body.composeString(currency);
		_body.composeUINT32(tournFlagsServInt);
		_body.composeUINT32(knockout);
		_body.composeString(satelliteTargetReference);
		_body.composeUINT16(satelliteTargetReferenceLock);
		_body.composeUINT32(maxPlayers);
		_body.composeBYTE(speedDisplay);
		_body.composeString(nameSnG);
		_body.composeBYTE(step);
		_body.composeBYTE(timedTournType);
		_body.composeUINT16(timedTournTime);
		_body.composeBYTE(timedTournPayout);
		_body.composeBOOL(isFlightTourn);
		_body.composeString(tournBrand);
		_body.composeUINT32(scalePM);
		_body.composeBYTE(progressiveKnockout);
		_body.composeBYTE(awardScheme);
		_body.composeUINT16(numReentries);
		_body.composeString(internalReference);
		_body.composeString(favReference);
		_body.composeString(satelliteTargetName);
		_body.composeINT64(admissionPrice);
		_body.composeUINT64(tournFlags2);
		_body.composeSrvTime(regEndAbs);
		_body.composeUINT32(regEndAbsInt);
		_body.composeBOOL(doNotAllowToUnreg);
		CommMsgBody _body0;
		nStackInfo.composeMsg(_body0, _ignoreJSON);
		_body.composeMsgBody(_body0);
		_body.composeUINT32(tournMask5);
		_body.composeUINT32(tournMask6);
		_body.composeString(satelliteTargetNameMTT);
		_body.composeUINT32(liveEventMask);
		_body.composeBYTE(timedTournPlayersPercent);
		_body.composeUINT32(dummy1);
		_body.composeBYTE(rmPmLobby);
		_body.composeUINT32(brandAccessMask);
		_body.composeUINT32(activeFlags);
		_body.composeUINT32(sngScriptId);
		_body.composeString(customSpeedDisplayName);
		_body.composeString(mobileName);
		_body.composeUINT32(tournGroup);
		_body.composeINT32(guaranteedPrizePool);
		admissions.composeMsg(_body, _ignoreJSON);
		_body.composeString(serverObj);
		_body.composeString(tournGroupRef);
		_body.composeINT32(maxPayoutSag);
		tournSitesEx.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TournStaticData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(tournamentId);
	_parser0.parseStringP(server);
	_parser0.parseStringP(targetServer);
	_parser0.parseStringP(hasSatellite);
	_parser0.parseSrvTime(whenStart);
	_parser0.parseUINT32(buyIn);
	_parser0.parseUINT32(rake);
	_parser0.parseUINT32(fppBuyIn);
	_parser0.parseBYTE(isRestricted);
	_parser0.parseBYTE(isPwdProtected);
	_parser0.parseStringP(name);
	_parser0.parseStringP(admissionId);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseUINT32(satelliteTarget);
	_parser0.parseUINT32(minPlayers);
	_parser0.parseUINT32(tournFlags);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(structure);
	_parser0.parseUINT32(tournMask);
	_parser0.parseUINT32(tournSites);
	_parser0.parseUINT32(whenStartInt);
	_parser0.parseUINT32(tournMask2);
	_parser0.parseSrvTime(targetWhenStart);
	_parser0.parseUINT32(tournMask3);
	_parser0.parseUINT32(tournMask4);
	_parser0.parseUINT32(maxPerTable);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseBYTE(hasDayTwoStart);
	_parser0.parseUINT32(dayTwoStartSec);
	_parser0.parseSrvTime(dayTwoStart);
	_parser0.parseStringP(shortText);
	_parser0.parseUINT16(chatLang);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(tournFlagsServInt);
	_parser0.parseUINT32(knockout);
	_parser0.parseStringP(satelliteTargetReference);
	_parser0.parseUINT16(satelliteTargetReferenceLock);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseBYTE(speedDisplay);
	_parser0.parseStringP(nameSnG);
	_parser0.parseBYTE(step);
	_parser0.parseBYTE(timedTournType);
	_parser0.parseUINT16(timedTournTime);
	_parser0.parseBYTE(timedTournPayout);
	_parser0.parseBOOL(isFlightTourn);
	_parser0.parseStringP(tournBrand);
	_parser0.parseUINT32(scalePM);
	_parser0.parseBYTE(progressiveKnockout);
	_parser0.parseBYTE(awardScheme);
	_parser0.parseUINT16(numReentries);
	_parser0.parseStringP(internalReference);
	_parser0.parseStringP(favReference);
	_parser0.parseStringP(satelliteTargetName);
	_parser0.parseINT64(admissionPrice);
	_parser0.parseUINT64(tournFlags2);
	_parser0.parseSrvTime(regEndAbs);
	_parser0.parseUINT32(regEndAbsInt);
	_parser0.parseBOOL(doNotAllowToUnreg);
	parseAnonymousMsgBody0(_parser0);
	_parser0.parseUINT32(tournMask5);
	_parser0.parseUINT32(tournMask6);
	_parser0.parseStringP(satelliteTargetNameMTT);
	_parser0.parseUINT32(liveEventMask);
	_parser0.parseBYTE(timedTournPlayersPercent);
	_parser0.parseUINT32(dummy1);
	_parser0.parseBYTE(rmPmLobby);
	_parser0.parseUINT32(brandAccessMask);
	_parser0.parseUINT32(activeFlags);
	_parser0.parseUINT32(sngScriptId);
	_parser0.parseStringP(customSpeedDisplayName);
	_parser0.parseStringP(mobileName);
	_parser0.parseUINT32(tournGroup);
	_parser0.parseINT32(guaranteedPrizePool);
	admissions.parseMsg(_parser0);
	_parser0.parseStringP(serverObj);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(tournGroupRef);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(maxPayoutSag);
	if(_parser0.parseEnded()) return;
	tournSitesEx.parseMsg(_parser0);
}

const char *MLobbyNG::cli::TournStaticData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournamentId", tournamentId);
	_jsonstr.compose("server", server);
	_jsonstr.compose("targetServer", targetServer);
	_jsonstr.compose("hasSatellite", hasSatellite);
	_jsonstr.compose("whenStart", whenStart);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("fppBuyIn", fppBuyIn);
	_jsonstr.compose("isRestricted", isRestricted);
	_jsonstr.compose("isPwdProtected", isPwdProtected);
	_jsonstr.compose("name", name);
	_jsonstr.compose("admissionId", admissionId);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("satelliteTarget", satelliteTarget);
	_jsonstr.compose("minPlayers", minPlayers);
	_jsonstr.compose("tournFlags", tournFlags);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("tournMask", tournMask);
	_jsonstr.compose("tournSites", tournSites);
	_jsonstr.compose("whenStartInt", whenStartInt);
	_jsonstr.compose("tournMask2", tournMask2);
	_jsonstr.compose("targetWhenStart", targetWhenStart);
	_jsonstr.compose("tournMask3", tournMask3);
	_jsonstr.compose("tournMask4", tournMask4);
	_jsonstr.compose("maxPerTable", maxPerTable);
	_jsonstr.compose("countryRestrictionInverted", countryRestrictionInverted);
	_jsonstr.compose("restrictedCountries", restrictedCountries);
	_jsonstr.compose("hasDayTwoStart", hasDayTwoStart);
	_jsonstr.compose("dayTwoStartSec", dayTwoStartSec);
	_jsonstr.compose("dayTwoStart", dayTwoStart);
	_jsonstr.compose("shortText", shortText);
	_jsonstr.compose("chatLang", chatLang);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("tournFlagsServInt", tournFlagsServInt);
	_jsonstr.compose("knockout", knockout);
	_jsonstr.compose("satelliteTargetReference", satelliteTargetReference);
	_jsonstr.compose("satelliteTargetReferenceLock", satelliteTargetReferenceLock);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("speedDisplay", speedDisplay);
	_jsonstr.compose("nameSnG", nameSnG);
	_jsonstr.compose("step", step);
	_jsonstr.compose("timedTournType", timedTournType);
	_jsonstr.compose("timedTournTime", timedTournTime);
	_jsonstr.compose("timedTournPayout", timedTournPayout);
	_jsonstr.compose("isFlightTourn", isFlightTourn);
	_jsonstr.compose("tournBrand", tournBrand);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("progressiveKnockout", progressiveKnockout);
	_jsonstr.compose("awardScheme", awardScheme);
	_jsonstr.compose("numReentries", numReentries);
	_jsonstr.compose("internalReference", internalReference);
	_jsonstr.compose("favReference", favReference);
	_jsonstr.compose("satelliteTargetName", satelliteTargetName);
	_jsonstr.compose("admissionPrice", admissionPrice);
	_jsonstr.compose("tournFlags2", tournFlags2);
	_jsonstr.compose("regEndAbs", regEndAbs);
	_jsonstr.compose("regEndAbsInt", regEndAbsInt);
	_jsonstr.compose("doNotAllowToUnreg", doNotAllowToUnreg);
	_jsonstr.compose("nStackInfo", nStackInfo);
	_jsonstr.compose("tournMask5", tournMask5);
	_jsonstr.compose("tournMask6", tournMask6);
	_jsonstr.compose("satelliteTargetNameMTT", satelliteTargetNameMTT);
	_jsonstr.compose("liveEventMask", liveEventMask);
	_jsonstr.compose("timedTournPlayersPercent", timedTournPlayersPercent);
	_jsonstr.compose("dummy1", dummy1);
	_jsonstr.compose("rmPmLobby", rmPmLobby);
	_jsonstr.compose("brandAccessMask", brandAccessMask);
	_jsonstr.compose("activeFlags", activeFlags);
	_jsonstr.compose("sngScriptId", sngScriptId);
	_jsonstr.compose("customSpeedDisplayName", customSpeedDisplayName);
	_jsonstr.compose("mobileName", mobileName);
	_jsonstr.compose("tournGroup", tournGroup);
	_jsonstr.compose("guaranteedPrizePool", guaranteedPrizePool);
	_jsonstr.compose("admissions", admissions);
	_jsonstr.compose("serverObj", serverObj);
	_jsonstr.compose("tournGroupRef", tournGroupRef);
	_jsonstr.compose("maxPayoutSag", maxPayoutSag);
	_jsonstr.compose("tournSitesEx", tournSitesEx);
	return _buf.c_str();
}

void MLobbyNG::cli::TournStaticData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournamentId", tournamentId);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("targetServer", targetServer);
	_jparser.parseByNameThrow("hasSatellite", hasSatellite);
	_jparser.parseByNameThrow("whenStart", whenStart);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("fppBuyIn", fppBuyIn);
	_jparser.parseByNameThrow("isRestricted", isRestricted);
	_jparser.parseByNameThrow("isPwdProtected", isPwdProtected);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("admissionId", admissionId);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("satelliteTarget", satelliteTarget);
	_jparser.parseByNameThrow("minPlayers", minPlayers);
	_jparser.parseByNameThrow("tournFlags", tournFlags);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("tournMask", tournMask);
	_jparser.parseByNameThrow("tournSites", tournSites);
	_jparser.parseByNameThrow("whenStartInt", whenStartInt);
	_jparser.parseByNameThrow("tournMask2", tournMask2);
	_jparser.parseByNameThrow("targetWhenStart", targetWhenStart);
	_jparser.parseByNameThrow("tournMask3", tournMask3);
	_jparser.parseByNameThrow("tournMask4", tournMask4);
	_jparser.parseByNameThrow("maxPerTable", maxPerTable);
	_jparser.parseByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	_jparser.parseByNameThrow("restrictedCountries", restrictedCountries);
	_jparser.parseByNameThrow("hasDayTwoStart", hasDayTwoStart);
	_jparser.parseByNameThrow("dayTwoStartSec", dayTwoStartSec);
	_jparser.parseByNameThrow("dayTwoStart", dayTwoStart);
	_jparser.parseByNameThrow("shortText", shortText);
	_jparser.parseByNameThrow("chatLang", chatLang);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("tournFlagsServInt", tournFlagsServInt);
	_jparser.parseByNameThrow("knockout", knockout);
	_jparser.parseByNameThrow("satelliteTargetReference", satelliteTargetReference);
	_jparser.parseByNameThrow("satelliteTargetReferenceLock", satelliteTargetReferenceLock);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("speedDisplay", speedDisplay);
	_jparser.parseByNameThrow("nameSnG", nameSnG);
	_jparser.parseByNameThrow("step", step);
	_jparser.parseByNameThrow("timedTournType", timedTournType);
	_jparser.parseByNameThrow("timedTournTime", timedTournTime);
	_jparser.parseByNameThrow("timedTournPayout", timedTournPayout);
	_jparser.parseByNameThrow("isFlightTourn", isFlightTourn);
	_jparser.parseByNameThrow("tournBrand", tournBrand);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("progressiveKnockout", progressiveKnockout);
	_jparser.parseByNameThrow("awardScheme", awardScheme);
	_jparser.parseByNameThrow("numReentries", numReentries);
	_jparser.parseByNameThrow("internalReference", internalReference);
	_jparser.parseByNameThrow("favReference", favReference);
	_jparser.parseByNameThrow("satelliteTargetName", satelliteTargetName);
	_jparser.parseByNameThrow("admissionPrice", admissionPrice);
	_jparser.parseByNameThrow("tournFlags2", tournFlags2);
	_jparser.parseByNameThrow("regEndAbs", regEndAbs);
	_jparser.parseByNameThrow("regEndAbsInt", regEndAbsInt);
	_jparser.parseByNameThrow("doNotAllowToUnreg", doNotAllowToUnreg);
	_jparser.parseByNameThrow("nStackInfo", nStackInfo);
	_jparser.parseByNameThrow("tournMask5", tournMask5);
	_jparser.parseByNameThrow("tournMask6", tournMask6);
	_jparser.parseByNameThrow("satelliteTargetNameMTT", satelliteTargetNameMTT);
	_jparser.parseByNameThrow("liveEventMask", liveEventMask);
	_jparser.parseByNameThrow("timedTournPlayersPercent", timedTournPlayersPercent);
	_jparser.parseByNameThrow("dummy1", dummy1);
	_jparser.parseByNameThrow("rmPmLobby", rmPmLobby);
	_jparser.parseByNameThrow("brandAccessMask", brandAccessMask);
	_jparser.parseByNameThrow("activeFlags", activeFlags);
	_jparser.parseByNameThrow("sngScriptId", sngScriptId);
	_jparser.parseByNameThrow("customSpeedDisplayName", customSpeedDisplayName);
	_jparser.parseByNameThrow("mobileName", mobileName);
	_jparser.parseByNameThrow("tournGroup", tournGroup);
	_jparser.parseByNameThrow("guaranteedPrizePool", guaranteedPrizePool);
	_jparser.parseByNameThrow("admissions", admissions);
	_jparser.parseByNameThrow("serverObj", serverObj);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tournGroupRef", tournGroupRef);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("maxPayoutSag", maxPayoutSag);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tournSitesEx", tournSitesEx);
}

/* static */ void MLobbyNG::cli::TournStaticData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 tournamentId; _jparser.validateByNameThrow("tournamentId", tournamentId);
	AtfValidator::validateUint(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString targetServer; _jparser.validateByNameThrow("targetServer", targetServer);
	AtfValidator::validateInt(_descr, "targetServer", targetServer.length(), _checker, __FILE__, __LINE__);
	PString hasSatellite; _jparser.validateByNameThrow("hasSatellite", hasSatellite);
	AtfValidator::validateInt(_descr, "hasSatellite", hasSatellite.length(), _checker, __FILE__, __LINE__);
	SrvTime whenStart; _jparser.validateByNameThrow("whenStart", whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _jparser.validateByNameThrow("fppBuyIn", fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _jparser.validateByNameThrow("isRestricted", isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPwdProtected; _jparser.validateByNameThrow("isPwdProtected", isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString admissionId; _jparser.validateByNameThrow("admissionId", admissionId);
	AtfValidator::validateInt(_descr, "admissionId", admissionId.length(), _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _jparser.validateByNameThrow("satelliteTarget", satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _jparser.validateByNameThrow("tournMask", tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournSites; _jparser.validateByNameThrow("tournSites", tournSites);
	AtfValidator::validateInt(_descr, "tournSites", tournSites, _checker, __FILE__, __LINE__);
	UINT32 whenStartInt; _jparser.validateByNameThrow("whenStartInt", whenStartInt);
	AtfValidator::validateInt(_descr, "whenStartInt", whenStartInt, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _jparser.validateByNameThrow("tournMask2", tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	SrvTime targetWhenStart; _jparser.validateByNameThrow("targetWhenStart", targetWhenStart);
	AtfValidator::validateSrvDateTime(_descr, "targetWhenStart", targetWhenStart, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _jparser.validateByNameThrow("tournMask3", tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _jparser.validateByNameThrow("tournMask4", tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	UINT32 maxPerTable; _jparser.validateByNameThrow("maxPerTable", maxPerTable);
	AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _jparser.validateByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > restrictedCountries; _jparser.validateByNameThrow("restrictedCountries", restrictedCountries);
	AtfValidator::validateInt(_descr, "restrictedCountries", restrictedCountries.size(), _checker, __FILE__, __LINE__);
	BYTE hasDayTwoStart; _jparser.validateByNameThrow("hasDayTwoStart", hasDayTwoStart);
	AtfValidator::validateInt(_descr, "hasDayTwoStart", hasDayTwoStart, _checker, __FILE__, __LINE__);
	UINT32 dayTwoStartSec; _jparser.validateByNameThrow("dayTwoStartSec", dayTwoStartSec);
	AtfValidator::validateInt(_descr, "dayTwoStartSec", dayTwoStartSec, _checker, __FILE__, __LINE__);
	SrvTime dayTwoStart; _jparser.validateByNameThrow("dayTwoStart", dayTwoStart);
	AtfValidator::validateSrvDateTime(_descr, "dayTwoStart", dayTwoStart, _checker, __FILE__, __LINE__);
	PString shortText; _jparser.validateByNameThrow("shortText", shortText);
	AtfValidator::validateInt(_descr, "shortText", shortText.length(), _checker, __FILE__, __LINE__);
	UINT16 chatLang; _jparser.validateByNameThrow("chatLang", chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _jparser.validateByNameThrow("tournFlagsServInt", tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT32 knockout; _jparser.validateByNameThrow("knockout", knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	PString satelliteTargetReference; _jparser.validateByNameThrow("satelliteTargetReference", satelliteTargetReference);
	AtfValidator::validateInt(_descr, "satelliteTargetReference", satelliteTargetReference.length(), _checker, __FILE__, __LINE__);
	UINT16 satelliteTargetReferenceLock; _jparser.validateByNameThrow("satelliteTargetReferenceLock", satelliteTargetReferenceLock);
	AtfValidator::validateInt(_descr, "satelliteTargetReferenceLock", satelliteTargetReferenceLock, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _jparser.validateByNameThrow("speedDisplay", speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	PString nameSnG; _jparser.validateByNameThrow("nameSnG", nameSnG);
	AtfValidator::validateInt(_descr, "nameSnG", nameSnG.length(), _checker, __FILE__, __LINE__);
	BYTE step; _jparser.validateByNameThrow("step", step);
	AtfValidator::validateInt(_descr, "step", step, _checker, __FILE__, __LINE__);
	BYTE timedTournType; _jparser.validateByNameThrow("timedTournType", timedTournType);
	AtfValidator::validateInt(_descr, "timedTournType", timedTournType, _checker, __FILE__, __LINE__);
	UINT16 timedTournTime; _jparser.validateByNameThrow("timedTournTime", timedTournTime);
	AtfValidator::validateInt(_descr, "timedTournTime", timedTournTime, _checker, __FILE__, __LINE__);
	BYTE timedTournPayout; _jparser.validateByNameThrow("timedTournPayout", timedTournPayout);
	AtfValidator::validateInt(_descr, "timedTournPayout", timedTournPayout, _checker, __FILE__, __LINE__);
	bool isFlightTourn; _jparser.validateByNameThrow("isFlightTourn", isFlightTourn);
	AtfValidator::validateInt(_descr, "isFlightTourn", isFlightTourn, _checker, __FILE__, __LINE__);
	PString tournBrand; _jparser.validateByNameThrow("tournBrand", tournBrand);
	AtfValidator::validateInt(_descr, "tournBrand", tournBrand.length(), _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	BYTE progressiveKnockout; _jparser.validateByNameThrow("progressiveKnockout", progressiveKnockout);
	AtfValidator::validateInt(_descr, "progressiveKnockout", progressiveKnockout, _checker, __FILE__, __LINE__);
	BYTE awardScheme; _jparser.validateByNameThrow("awardScheme", awardScheme);
	AtfValidator::validateInt(_descr, "awardScheme", awardScheme, _checker, __FILE__, __LINE__);
	UINT16 numReentries; _jparser.validateByNameThrow("numReentries", numReentries);
	AtfValidator::validateInt(_descr, "numReentries", numReentries, _checker, __FILE__, __LINE__);
	PString internalReference; _jparser.validateByNameThrow("internalReference", internalReference);
	AtfValidator::validateInt(_descr, "internalReference", internalReference.length(), _checker, __FILE__, __LINE__);
	PString favReference; _jparser.validateByNameThrow("favReference", favReference);
	AtfValidator::validateInt(_descr, "favReference", favReference.length(), _checker, __FILE__, __LINE__);
	PString satelliteTargetName; _jparser.validateByNameThrow("satelliteTargetName", satelliteTargetName);
	AtfValidator::validateInt(_descr, "satelliteTargetName", satelliteTargetName.length(), _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _jparser.validateByNameThrow("admissionPrice", admissionPrice);
	AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	SrvTime regEndAbs; _jparser.validateByNameThrow("regEndAbs", regEndAbs);
	AtfValidator::validateSrvDateTime(_descr, "regEndAbs", regEndAbs, _checker, __FILE__, __LINE__);
	UINT32 regEndAbsInt; _jparser.validateByNameThrow("regEndAbsInt", regEndAbsInt);
	AtfValidator::validateInt(_descr, "regEndAbsInt", regEndAbsInt, _checker, __FILE__, __LINE__);
	bool doNotAllowToUnreg; _jparser.validateByNameThrow("doNotAllowToUnreg", doNotAllowToUnreg);
	AtfValidator::validateInt(_descr, "doNotAllowToUnreg", doNotAllowToUnreg, _checker, __FILE__, __LINE__);
	TournClient::NStackTournInfoStruct nStackInfo; _jparser.validateByNameThrow("nStackInfo", nStackInfo);
	UINT32 tournMask5; _jparser.validateByNameThrow("tournMask5", tournMask5);
	AtfValidator::validateInt(_descr, "tournMask5", tournMask5, _checker, __FILE__, __LINE__);
	UINT32 tournMask6; _jparser.validateByNameThrow("tournMask6", tournMask6);
	AtfValidator::validateInt(_descr, "tournMask6", tournMask6, _checker, __FILE__, __LINE__);
	PString satelliteTargetNameMTT; _jparser.validateByNameThrow("satelliteTargetNameMTT", satelliteTargetNameMTT);
	AtfValidator::validateInt(_descr, "satelliteTargetNameMTT", satelliteTargetNameMTT.length(), _checker, __FILE__, __LINE__);
	UINT32 liveEventMask; _jparser.validateByNameThrow("liveEventMask", liveEventMask);
	AtfValidator::validateInt(_descr, "liveEventMask", liveEventMask, _checker, __FILE__, __LINE__);
	BYTE timedTournPlayersPercent; _jparser.validateByNameThrow("timedTournPlayersPercent", timedTournPlayersPercent);
	AtfValidator::validateInt(_descr, "timedTournPlayersPercent", timedTournPlayersPercent, _checker, __FILE__, __LINE__);
	UINT32 dummy1; _jparser.validateByNameThrow("dummy1", dummy1);
	AtfValidator::validateInt(_descr, "dummy1", dummy1, _checker, __FILE__, __LINE__);
	BYTE rmPmLobby; _jparser.validateByNameThrow("rmPmLobby", rmPmLobby);
	AtfValidator::validateInt(_descr, "rmPmLobby", rmPmLobby, _checker, __FILE__, __LINE__);
	UINT32 brandAccessMask; _jparser.validateByNameThrow("brandAccessMask", brandAccessMask);
	AtfValidator::validateInt(_descr, "brandAccessMask", brandAccessMask, _checker, __FILE__, __LINE__);
	UINT32 activeFlags; _jparser.validateByNameThrow("activeFlags", activeFlags);
	AtfValidator::validateInt(_descr, "activeFlags", activeFlags, _checker, __FILE__, __LINE__);
	UINT32 sngScriptId; _jparser.validateByNameThrow("sngScriptId", sngScriptId);
	AtfValidator::validateInt(_descr, "sngScriptId", sngScriptId, _checker, __FILE__, __LINE__);
	PString customSpeedDisplayName; _jparser.validateByNameThrow("customSpeedDisplayName", customSpeedDisplayName);
	AtfValidator::validateInt(_descr, "customSpeedDisplayName", customSpeedDisplayName.length(), _checker, __FILE__, __LINE__);
	PString mobileName; _jparser.validateByNameThrow("mobileName", mobileName);
	AtfValidator::validateInt(_descr, "mobileName", mobileName.length(), _checker, __FILE__, __LINE__);
	UINT32 tournGroup; _jparser.validateByNameThrow("tournGroup", tournGroup);
	AtfValidator::validateInt(_descr, "tournGroup", tournGroup, _checker, __FILE__, __LINE__);
	INT32 guaranteedPrizePool; _jparser.validateByNameThrow("guaranteedPrizePool", guaranteedPrizePool);
	AtfValidator::validateInt(_descr, "guaranteedPrizePool", guaranteedPrizePool, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > admissions; _jparser.validateByNameThrow("admissions", admissions);
	AtfValidator::validateInt(_descr, "admissions", admissions.size(), _checker, __FILE__, __LINE__);
	PString serverObj; _jparser.validateByNameThrow("serverObj", serverObj);
	AtfValidator::validateInt(_descr, "serverObj", serverObj.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString tournGroupRef; _jparser.validateByNameThrow("tournGroupRef", tournGroupRef);
	AtfValidator::validateInt(_descr, "tournGroupRef", tournGroupRef.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 maxPayoutSag; _jparser.validateByNameThrow("maxPayoutSag", maxPayoutSag);
	AtfValidator::validateInt(_descr, "maxPayoutSag", maxPayoutSag, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask tournSitesEx; _jparser.validateByNameThrow("tournSitesEx", tournSitesEx);
}

/*static*/ void MLobbyNG::cli::TournStaticData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT64 tournamentId; _parser0.parseUINT64(tournamentId);
	AtfValidator::validateUint(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "targetServer"); size_t szTargetServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "targetServer", szTargetServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "hasSatellite"); size_t szHasSatellite = strlen(_dummy);
	AtfValidator::validateInt(_descr, "hasSatellite", szHasSatellite, _checker, __FILE__, __LINE__);
	SrvTime whenStart; _parser0.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser0.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _parser0.parseBYTE(isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPwdProtected; _parser0.parseBYTE(isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _parser0.parseUINT32(satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser0.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser0.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _parser0.parseUINT32(tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournSites; _parser0.parseUINT32(tournSites);
	AtfValidator::validateInt(_descr, "tournSites", tournSites, _checker, __FILE__, __LINE__);
	UINT32 whenStartInt; _parser0.parseUINT32(whenStartInt);
	AtfValidator::validateInt(_descr, "whenStartInt", whenStartInt, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _parser0.parseUINT32(tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	SrvTime targetWhenStart; _parser0.parseSrvTime(targetWhenStart);
	AtfValidator::validateSrvDateTime(_descr, "targetWhenStart", targetWhenStart, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _parser0.parseUINT32(tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _parser0.parseUINT32(tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	UINT32 maxPerTable; _parser0.parseUINT32(maxPerTable);
	AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = Atf::LAtfVector< PString , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	BYTE hasDayTwoStart; _parser0.parseBYTE(hasDayTwoStart);
	AtfValidator::validateInt(_descr, "hasDayTwoStart", hasDayTwoStart, _checker, __FILE__, __LINE__);
	UINT32 dayTwoStartSec; _parser0.parseUINT32(dayTwoStartSec);
	AtfValidator::validateInt(_descr, "dayTwoStartSec", dayTwoStartSec, _checker, __FILE__, __LINE__);
	SrvTime dayTwoStart; _parser0.parseSrvTime(dayTwoStart);
	AtfValidator::validateSrvDateTime(_descr, "dayTwoStart", dayTwoStart, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "shortText"); size_t szShortText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "shortText", szShortText, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser0.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _parser0.parseUINT32(tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT32 knockout; _parser0.parseUINT32(knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "satelliteTargetReference"); size_t szSatelliteTargetReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetReference", szSatelliteTargetReference, _checker, __FILE__, __LINE__);
	UINT16 satelliteTargetReferenceLock; _parser0.parseUINT16(satelliteTargetReferenceLock);
	AtfValidator::validateInt(_descr, "satelliteTargetReferenceLock", satelliteTargetReferenceLock, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _parser0.parseBYTE(speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "nameSnG"); size_t szNameSnG = strlen(_dummy);
	AtfValidator::validateInt(_descr, "nameSnG", szNameSnG, _checker, __FILE__, __LINE__);
	BYTE step; _parser0.parseBYTE(step);
	AtfValidator::validateInt(_descr, "step", step, _checker, __FILE__, __LINE__);
	BYTE timedTournType; _parser0.parseBYTE(timedTournType);
	AtfValidator::validateInt(_descr, "timedTournType", timedTournType, _checker, __FILE__, __LINE__);
	UINT16 timedTournTime; _parser0.parseUINT16(timedTournTime);
	AtfValidator::validateInt(_descr, "timedTournTime", timedTournTime, _checker, __FILE__, __LINE__);
	BYTE timedTournPayout; _parser0.parseBYTE(timedTournPayout);
	AtfValidator::validateInt(_descr, "timedTournPayout", timedTournPayout, _checker, __FILE__, __LINE__);
	bool isFlightTourn; _parser0.parseBOOL(isFlightTourn);
	AtfValidator::validateInt(_descr, "isFlightTourn", isFlightTourn, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tournBrand"); size_t szTournBrand = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournBrand", szTournBrand, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	BYTE progressiveKnockout; _parser0.parseBYTE(progressiveKnockout);
	AtfValidator::validateInt(_descr, "progressiveKnockout", progressiveKnockout, _checker, __FILE__, __LINE__);
	BYTE awardScheme; _parser0.parseBYTE(awardScheme);
	AtfValidator::validateInt(_descr, "awardScheme", awardScheme, _checker, __FILE__, __LINE__);
	UINT16 numReentries; _parser0.parseUINT16(numReentries);
	AtfValidator::validateInt(_descr, "numReentries", numReentries, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "internalReference"); size_t szInternalReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "internalReference", szInternalReference, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "favReference"); size_t szFavReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "favReference", szFavReference, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "satelliteTargetName"); size_t szSatelliteTargetName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetName", szSatelliteTargetName, _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _parser0.parseINT64(admissionPrice);
	AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _parser0.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	SrvTime regEndAbs; _parser0.parseSrvTime(regEndAbs);
	AtfValidator::validateSrvDateTime(_descr, "regEndAbs", regEndAbs, _checker, __FILE__, __LINE__);
	UINT32 regEndAbsInt; _parser0.parseUINT32(regEndAbsInt);
	AtfValidator::validateInt(_descr, "regEndAbsInt", regEndAbsInt, _checker, __FILE__, __LINE__);
	bool doNotAllowToUnreg; _parser0.parseBOOL(doNotAllowToUnreg);
	AtfValidator::validateInt(_descr, "doNotAllowToUnreg", doNotAllowToUnreg, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournMask5; _parser0.parseUINT32(tournMask5);
	AtfValidator::validateInt(_descr, "tournMask5", tournMask5, _checker, __FILE__, __LINE__);
	UINT32 tournMask6; _parser0.parseUINT32(tournMask6);
	AtfValidator::validateInt(_descr, "tournMask6", tournMask6, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "satelliteTargetNameMTT"); size_t szSatelliteTargetNameMTT = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetNameMTT", szSatelliteTargetNameMTT, _checker, __FILE__, __LINE__);
	UINT32 liveEventMask; _parser0.parseUINT32(liveEventMask);
	AtfValidator::validateInt(_descr, "liveEventMask", liveEventMask, _checker, __FILE__, __LINE__);
	BYTE timedTournPlayersPercent; _parser0.parseBYTE(timedTournPlayersPercent);
	AtfValidator::validateInt(_descr, "timedTournPlayersPercent", timedTournPlayersPercent, _checker, __FILE__, __LINE__);
	UINT32 dummy1; _parser0.parseUINT32(dummy1);
	AtfValidator::validateInt(_descr, "dummy1", dummy1, _checker, __FILE__, __LINE__);
	BYTE rmPmLobby; _parser0.parseBYTE(rmPmLobby);
	AtfValidator::validateInt(_descr, "rmPmLobby", rmPmLobby, _checker, __FILE__, __LINE__);
	UINT32 brandAccessMask; _parser0.parseUINT32(brandAccessMask);
	AtfValidator::validateInt(_descr, "brandAccessMask", brandAccessMask, _checker, __FILE__, __LINE__);
	UINT32 activeFlags; _parser0.parseUINT32(activeFlags);
	AtfValidator::validateInt(_descr, "activeFlags", activeFlags, _checker, __FILE__, __LINE__);
	UINT32 sngScriptId; _parser0.parseUINT32(sngScriptId);
	AtfValidator::validateInt(_descr, "sngScriptId", sngScriptId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "customSpeedDisplayName"); size_t szCustomSpeedDisplayName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "customSpeedDisplayName", szCustomSpeedDisplayName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "mobileName"); size_t szMobileName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "mobileName", szMobileName, _checker, __FILE__, __LINE__);
	UINT32 tournGroup; _parser0.parseUINT32(tournGroup);
	AtfValidator::validateInt(_descr, "tournGroup", tournGroup, _checker, __FILE__, __LINE__);
	INT32 guaranteedPrizePool; _parser0.parseINT32(guaranteedPrizePool);
	AtfValidator::validateInt(_descr, "guaranteedPrizePool", guaranteedPrizePool, _checker, __FILE__, __LINE__);
	int szAdmissions = Atf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("admissions"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "admissions", szAdmissions, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "tournGroupRef"); size_t szTournGroupRef = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournGroupRef", szTournGroupRef, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 maxPayoutSag; _parser0.parseINT32(maxPayoutSag);
	AtfValidator::validateInt(_descr, "maxPayoutSag", maxPayoutSag, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournSitesEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MLobbyNG::cli::TournStaticData::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	nStackInfo.parseMsg(_parser0);
}

/*static*/ void MLobbyNG::cli::TournStaticData::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TournClient::NStackTournInfoStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("nStackInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournDynaData
//=================================================================

MLobbyNG::cli::TournDynaData::TournDynaData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TournDynaData::TournDynaData(TournDynaData&& _o)
	: fakeStatus(std::move(_o.fakeStatus))
	, entrants(std::move(_o.entrants))
	, publProp(std::move(_o.publProp))
	, prizePoolToPublish(std::move(_o.prizePoolToPublish))
	, prizePoolUnit(std::move(_o.prizePoolUnit))
	, happyHoursMultipliers(std::move(_o.happyHoursMultipliers))
	, goldenSnGMilestoneAwardStub(std::move(_o.goldenSnGMilestoneAwardStub))
	, dummy1(std::move(_o.dummy1))
	, goldenSnGEligibleStub(std::move(_o.goldenSnGEligibleStub))
	, goldenSnGTotalAddonStub(std::move(_o.goldenSnGTotalAddonStub))
	, prizePoolMoneyToPublish(std::move(_o.prizePoolMoneyToPublish))
	, timedTournPlayersThreshold(std::move(_o.timedTournPlayersThreshold))
	, mixTournSatellite(std::move(_o.mixTournSatellite))
{
}

MLobbyNG::cli::TournDynaData& MLobbyNG::cli::TournDynaData::operator=(TournDynaData&& _o)
{
	if(this != &_o)
	{
		fakeStatus = std::move(_o.fakeStatus);
		entrants = std::move(_o.entrants);
		publProp = std::move(_o.publProp);
		prizePoolToPublish = std::move(_o.prizePoolToPublish);
		prizePoolUnit = std::move(_o.prizePoolUnit);
		happyHoursMultipliers = std::move(_o.happyHoursMultipliers);
		goldenSnGMilestoneAwardStub = std::move(_o.goldenSnGMilestoneAwardStub);
		dummy1 = std::move(_o.dummy1);
		goldenSnGEligibleStub = std::move(_o.goldenSnGEligibleStub);
		goldenSnGTotalAddonStub = std::move(_o.goldenSnGTotalAddonStub);
		prizePoolMoneyToPublish = std::move(_o.prizePoolMoneyToPublish);
		timedTournPlayersThreshold = std::move(_o.timedTournPlayersThreshold);
		mixTournSatellite = std::move(_o.mixTournSatellite);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TournDynaData::clear()
{
	fakeStatus = 0;
	entrants = 0;
	publProp = 0;
	prizePoolToPublish = 0;
	prizePoolUnit = 0;
	happyHoursMultipliers.clear();
	goldenSnGMilestoneAwardStub = 0;
	dummy1 = 0;
	goldenSnGEligibleStub = false;
	goldenSnGTotalAddonStub = 0;
	prizePoolMoneyToPublish = 0;
	timedTournPlayersThreshold = 0;
	mixTournSatellite = 0;
}

bool MLobbyNG::cli::TournDynaData::equals(const TournDynaData& _o) const
{
	return fakeStatus == _o.fakeStatus &&
		entrants == _o.entrants &&
		publProp == _o.publProp &&
		prizePoolToPublish == _o.prizePoolToPublish &&
		prizePoolUnit == _o.prizePoolUnit &&
		happyHoursMultipliers.equals(_o.happyHoursMultipliers) &&
		goldenSnGMilestoneAwardStub == _o.goldenSnGMilestoneAwardStub &&
		dummy1 == _o.dummy1 &&
		goldenSnGEligibleStub == _o.goldenSnGEligibleStub &&
		goldenSnGTotalAddonStub == _o.goldenSnGTotalAddonStub &&
		prizePoolMoneyToPublish == _o.prizePoolMoneyToPublish &&
		timedTournPlayersThreshold == _o.timedTournPlayersThreshold &&
		mixTournSatellite == _o.mixTournSatellite;
}

const char *MLobbyNG::cli::TournDynaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fakeStatus=");
	_buf.appendUint(fakeStatus);
	_buf.append(',');
	_buf.append("entrants=");
	_buf.appendUint(entrants);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("prizePoolToPublish=");
	_buf.appendUint(prizePoolToPublish);
	_buf.append(',');
	_buf.append("prizePoolUnit=");
	_buf.appendUint(prizePoolUnit);
	_buf.append(',');
	_buf.append("happyHoursMultipliers=");
	happyHoursMultipliers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("goldenSnGMilestoneAwardStub=");
	_buf.appendUint(goldenSnGMilestoneAwardStub);
	_buf.append(',');
	_buf.append("dummy1=");
	_buf.appendUint(dummy1);
	_buf.append(',');
	_buf.append("goldenSnGEligibleStub=");
	_buf.appendUint(goldenSnGEligibleStub);
	_buf.append(',');
	_buf.append("goldenSnGTotalAddonStub=");
	_buf.appendUint(goldenSnGTotalAddonStub);
	_buf.append(',');
	_buf.append("prizePoolMoneyToPublish=");
	_buf.appendUint(prizePoolMoneyToPublish);
	_buf.append(',');
	_buf.append("timedTournPlayersThreshold=");
	_buf.appendUint(timedTournPlayersThreshold);
	_buf.append(',');
	_buf.append("mixTournSatellite=");
	_buf.appendInt(mixTournSatellite);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::TournDynaData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("fakeStatus", fakeStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("entrants", entrants, _buf);
	Atf::XmlElement::encodeAsXmlElement("publProp", publProp, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePoolToPublish", prizePoolToPublish, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePoolUnit", prizePoolUnit, _buf);
	happyHoursMultipliers.toXmlString("happyHoursMultipliers", _buf);
	Atf::XmlElement::encodeAsXmlElement("goldenSnGMilestoneAwardStub", goldenSnGMilestoneAwardStub, _buf);
	Atf::XmlElement::encodeAsXmlElement("dummy1", dummy1, _buf);
	Atf::XmlElement::encodeAsXmlElement("goldenSnGEligibleStub", goldenSnGEligibleStub, _buf);
	Atf::XmlElement::encodeAsXmlElement("goldenSnGTotalAddonStub", goldenSnGTotalAddonStub, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePoolMoneyToPublish", prizePoolMoneyToPublish, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournPlayersThreshold", timedTournPlayersThreshold, _buf);
	Atf::XmlElement::encodeAsXmlElement("mixTournSatellite", mixTournSatellite, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::TournDynaData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("fakeStatus"))
		{
			fakeStatus = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("entrants"))
		{
			entrants = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("publProp"))
		{
			publProp = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolToPublish"))
		{
			prizePoolToPublish = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolUnit"))
		{
			prizePoolUnit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("happyHoursMultipliers"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< FppFactorStruct, 4 > >::FromXmlString(_value, happyHoursMultipliers)) return false;
		}
		else if (_element.equals("goldenSnGMilestoneAwardStub"))
		{
			goldenSnGMilestoneAwardStub = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("dummy1"))
		{
			dummy1 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("goldenSnGEligibleStub"))
		{
			goldenSnGEligibleStub = (*_value.ptr() == '1');
		}
		else if (_element.equals("goldenSnGTotalAddonStub"))
		{
			goldenSnGTotalAddonStub = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolMoneyToPublish"))
		{
			prizePoolMoneyToPublish = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timedTournPlayersThreshold"))
		{
			timedTournPlayersThreshold = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("mixTournSatellite"))
		{
			mixTournSatellite = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::TournDynaData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournDynaData())) // not empty
	{
		_body.composeUINT32(fakeStatus);
		_body.composeUINT32(entrants);
		_body.composeBYTE(publProp);
		_body.composeUINT32(prizePoolToPublish);
		_body.composeBYTE(prizePoolUnit);
		happyHoursMultipliers.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(goldenSnGMilestoneAwardStub);
		_body.composeUINT32(dummy1);
		_body.composeBOOL(goldenSnGEligibleStub);
		_body.composeUINT32(goldenSnGTotalAddonStub);
		_body.composeUINT32(prizePoolMoneyToPublish);
		_body.composeUINT32(timedTournPlayersThreshold);
		_body.composeINT8(mixTournSatellite);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TournDynaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(fakeStatus);
	_parser0.parseUINT32(entrants);
	_parser0.parseBYTE(publProp);
	_parser0.parseUINT32(prizePoolToPublish);
	_parser0.parseBYTE(prizePoolUnit);
	happyHoursMultipliers.parseMsg(_parser0);
	_parser0.parseUINT32(goldenSnGMilestoneAwardStub);
	_parser0.parseUINT32(dummy1);
	_parser0.parseBOOL(goldenSnGEligibleStub);
	_parser0.parseUINT32(goldenSnGTotalAddonStub);
	_parser0.parseUINT32(prizePoolMoneyToPublish);
	_parser0.parseUINT32(timedTournPlayersThreshold);
	_parser0.parseINT8(mixTournSatellite);
}

const char *MLobbyNG::cli::TournDynaData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("fakeStatus", fakeStatus);
	_jsonstr.compose("entrants", entrants);
	_jsonstr.compose("publProp", publProp);
	_jsonstr.compose("prizePoolToPublish", prizePoolToPublish);
	_jsonstr.compose("prizePoolUnit", prizePoolUnit);
	_jsonstr.compose("happyHoursMultipliers", happyHoursMultipliers);
	_jsonstr.compose("goldenSnGMilestoneAwardStub", goldenSnGMilestoneAwardStub);
	_jsonstr.compose("dummy1", dummy1);
	_jsonstr.compose("goldenSnGEligibleStub", goldenSnGEligibleStub);
	_jsonstr.compose("goldenSnGTotalAddonStub", goldenSnGTotalAddonStub);
	_jsonstr.compose("prizePoolMoneyToPublish", prizePoolMoneyToPublish);
	_jsonstr.compose("timedTournPlayersThreshold", timedTournPlayersThreshold);
	_jsonstr.compose("mixTournSatellite", mixTournSatellite);
	return _buf.c_str();
}

void MLobbyNG::cli::TournDynaData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("fakeStatus", fakeStatus);
	_jparser.parseByNameThrow("entrants", entrants);
	_jparser.parseByNameThrow("publProp", publProp);
	_jparser.parseByNameThrow("prizePoolToPublish", prizePoolToPublish);
	_jparser.parseByNameThrow("prizePoolUnit", prizePoolUnit);
	_jparser.parseByNameThrow("happyHoursMultipliers", happyHoursMultipliers);
	_jparser.parseByNameThrow("goldenSnGMilestoneAwardStub", goldenSnGMilestoneAwardStub);
	_jparser.parseByNameThrow("dummy1", dummy1);
	_jparser.parseByNameThrow("goldenSnGEligibleStub", goldenSnGEligibleStub);
	_jparser.parseByNameThrow("goldenSnGTotalAddonStub", goldenSnGTotalAddonStub);
	_jparser.parseByNameThrow("prizePoolMoneyToPublish", prizePoolMoneyToPublish);
	_jparser.parseByNameThrow("timedTournPlayersThreshold", timedTournPlayersThreshold);
	_jparser.parseByNameThrow("mixTournSatellite", mixTournSatellite);
}

/* static */ void MLobbyNG::cli::TournDynaData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 fakeStatus; _jparser.validateByNameThrow("fakeStatus", fakeStatus);
	AtfValidator::validateInt(_descr, "fakeStatus", fakeStatus, _checker, __FILE__, __LINE__);
	UINT32 entrants; _jparser.validateByNameThrow("entrants", entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
	BYTE publProp; _jparser.validateByNameThrow("publProp", publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	UINT32 prizePoolToPublish; _jparser.validateByNameThrow("prizePoolToPublish", prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	BYTE prizePoolUnit; _jparser.validateByNameThrow("prizePoolUnit", prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< FppFactorStruct > happyHoursMultipliers; _jparser.validateByNameThrow("happyHoursMultipliers", happyHoursMultipliers);
	AtfValidator::validateInt(_descr, "happyHoursMultipliers", happyHoursMultipliers.size(), _checker, __FILE__, __LINE__);
	UINT32 goldenSnGMilestoneAwardStub; _jparser.validateByNameThrow("goldenSnGMilestoneAwardStub", goldenSnGMilestoneAwardStub);
	AtfValidator::validateInt(_descr, "goldenSnGMilestoneAwardStub", goldenSnGMilestoneAwardStub, _checker, __FILE__, __LINE__);
	UINT32 dummy1; _jparser.validateByNameThrow("dummy1", dummy1);
	AtfValidator::validateInt(_descr, "dummy1", dummy1, _checker, __FILE__, __LINE__);
	bool goldenSnGEligibleStub; _jparser.validateByNameThrow("goldenSnGEligibleStub", goldenSnGEligibleStub);
	AtfValidator::validateInt(_descr, "goldenSnGEligibleStub", goldenSnGEligibleStub, _checker, __FILE__, __LINE__);
	UINT32 goldenSnGTotalAddonStub; _jparser.validateByNameThrow("goldenSnGTotalAddonStub", goldenSnGTotalAddonStub);
	AtfValidator::validateInt(_descr, "goldenSnGTotalAddonStub", goldenSnGTotalAddonStub, _checker, __FILE__, __LINE__);
	UINT32 prizePoolMoneyToPublish; _jparser.validateByNameThrow("prizePoolMoneyToPublish", prizePoolMoneyToPublish);
	AtfValidator::validateInt(_descr, "prizePoolMoneyToPublish", prizePoolMoneyToPublish, _checker, __FILE__, __LINE__);
	UINT32 timedTournPlayersThreshold; _jparser.validateByNameThrow("timedTournPlayersThreshold", timedTournPlayersThreshold);
	AtfValidator::validateInt(_descr, "timedTournPlayersThreshold", timedTournPlayersThreshold, _checker, __FILE__, __LINE__);
	INT8 mixTournSatellite; _jparser.validateByNameThrow("mixTournSatellite", mixTournSatellite);
	AtfValidator::validateInt(_descr, "mixTournSatellite", mixTournSatellite, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::TournDynaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 fakeStatus; _parser0.parseUINT32(fakeStatus);
	AtfValidator::validateInt(_descr, "fakeStatus", fakeStatus, _checker, __FILE__, __LINE__);
	UINT32 entrants; _parser0.parseUINT32(entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser0.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	UINT32 prizePoolToPublish; _parser0.parseUINT32(prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	BYTE prizePoolUnit; _parser0.parseBYTE(prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szHappyHoursMultipliers = Atf::LAtfVector< FppFactorStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("happyHoursMultipliers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "happyHoursMultipliers", szHappyHoursMultipliers, _checker, __FILE__, __LINE__);
	UINT32 goldenSnGMilestoneAwardStub; _parser0.parseUINT32(goldenSnGMilestoneAwardStub);
	AtfValidator::validateInt(_descr, "goldenSnGMilestoneAwardStub", goldenSnGMilestoneAwardStub, _checker, __FILE__, __LINE__);
	UINT32 dummy1; _parser0.parseUINT32(dummy1);
	AtfValidator::validateInt(_descr, "dummy1", dummy1, _checker, __FILE__, __LINE__);
	bool goldenSnGEligibleStub; _parser0.parseBOOL(goldenSnGEligibleStub);
	AtfValidator::validateInt(_descr, "goldenSnGEligibleStub", goldenSnGEligibleStub, _checker, __FILE__, __LINE__);
	UINT32 goldenSnGTotalAddonStub; _parser0.parseUINT32(goldenSnGTotalAddonStub);
	AtfValidator::validateInt(_descr, "goldenSnGTotalAddonStub", goldenSnGTotalAddonStub, _checker, __FILE__, __LINE__);
	UINT32 prizePoolMoneyToPublish; _parser0.parseUINT32(prizePoolMoneyToPublish);
	AtfValidator::validateInt(_descr, "prizePoolMoneyToPublish", prizePoolMoneyToPublish, _checker, __FILE__, __LINE__);
	UINT32 timedTournPlayersThreshold; _parser0.parseUINT32(timedTournPlayersThreshold);
	AtfValidator::validateInt(_descr, "timedTournPlayersThreshold", timedTournPlayersThreshold, _checker, __FILE__, __LINE__);
	INT8 mixTournSatellite; _parser0.parseINT8(mixTournSatellite);
	AtfValidator::validateInt(_descr, "mixTournSatellite", mixTournSatellite, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournDataStruct
//=================================================================

MLobbyNG::cli::TournDataStruct::TournDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TournDataStruct::TournDataStruct(TournDataStruct&& _o)
	: staticData(std::move(_o.staticData))
	, dynamicData(std::move(_o.dynamicData))
	, lastEntry(std::move(_o.lastEntry))
	, userHasTicket(std::move(_o.userHasTicket))
{
}

MLobbyNG::cli::TournDataStruct& MLobbyNG::cli::TournDataStruct::operator=(TournDataStruct&& _o)
{
	if(this != &_o)
	{
		staticData = std::move(_o.staticData);
		dynamicData = std::move(_o.dynamicData);
		lastEntry = std::move(_o.lastEntry);
		userHasTicket = std::move(_o.userHasTicket);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TournDataStruct::clear()
{
	staticData.clear();
	dynamicData.clear();
	lastEntry.setNull();
	userHasTicket = false;
}

bool MLobbyNG::cli::TournDataStruct::equals(const TournDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		dynamicData.equals(_o.dynamicData) &&
		lastEntry.equals(_o.lastEntry) &&
		userHasTicket == _o.userHasTicket;
}

const char *MLobbyNG::cli::TournDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dynamicData=");
	dynamicData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("lastEntry=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, lastEntry);
	_buf.append(',');
	_buf.append("userHasTicket=");
	_buf.appendUint(userHasTicket);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::TournDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	staticData.toXmlString("staticData", _buf);
	dynamicData.toXmlString("dynamicData", _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "lastEntry", lastEntry);
	Atf::XmlElement::encodeAsXmlElement("userHasTicket", userHasTicket, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::TournDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("staticData"))
		{
			if(!Atf::AtfTempl< TournStaticData >::FromXmlString(_value, staticData)) return false;
		}
		else if (_element.equals("dynamicData"))
		{
			if(!Atf::AtfTempl< TournDynaData >::FromXmlString(_value, dynamicData)) return false;
		}
		else if (_element.equals("lastEntry"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, lastEntry);
		}
		else if (_element.equals("userHasTicket"))
		{
			userHasTicket = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::TournDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournDataStruct())) // not empty
	{
		staticData.composeMsg(_body, _ignoreJSON);
		dynamicData.composeMsg(_body, _ignoreJSON);
		_body.composeSrvTime(lastEntry);
		_body.composeBOOL(userHasTicket);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TournDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	dynamicData.parseMsg(_parser0);
	_parser0.parseSrvTime(lastEntry);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(userHasTicket);
}

const char *MLobbyNG::cli::TournDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("staticData", staticData);
	_jsonstr.compose("dynamicData", dynamicData);
	_jsonstr.compose("lastEntry", lastEntry);
	_jsonstr.compose("userHasTicket", userHasTicket);
	return _buf.c_str();
}

void MLobbyNG::cli::TournDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("staticData", staticData);
	_jparser.parseByNameThrow("dynamicData", dynamicData);
	_jparser.parseByNameThrow("lastEntry", lastEntry);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("userHasTicket", userHasTicket);
}

/* static */ void MLobbyNG::cli::TournDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TournStaticData staticData; _jparser.validateByNameThrow("staticData", staticData);
	TournDynaData dynamicData; _jparser.validateByNameThrow("dynamicData", dynamicData);
	SrvTime lastEntry; _jparser.validateByNameThrow("lastEntry", lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool userHasTicket; _jparser.validateByNameThrow("userHasTicket", userHasTicket);
	AtfValidator::validateInt(_descr, "userHasTicket", userHasTicket, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::TournDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TournStaticData::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	TournDynaData::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamicData"), _fieldsWithUnparsedContent);
	SrvTime lastEntry; _parser0.parseSrvTime(lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool userHasTicket; _parser0.parseBOOL(userHasTicket);
	AtfValidator::validateInt(_descr, "userHasTicket", userHasTicket, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SpinnerPrizeStruct
//=================================================================

MLobbyNG::cli::SpinnerPrizeStruct::SpinnerPrizeStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SpinnerPrizeStruct::SpinnerPrizeStruct(SpinnerPrizeStruct&& _o)
	: level(std::move(_o.level))
	, type(std::move(_o.type))
	, value(std::move(_o.value))
	, targetRef(std::move(_o.targetRef))
{
}

MLobbyNG::cli::SpinnerPrizeStruct& MLobbyNG::cli::SpinnerPrizeStruct::operator=(SpinnerPrizeStruct&& _o)
{
	if(this != &_o)
	{
		level = std::move(_o.level);
		type = std::move(_o.type);
		value = std::move(_o.value);
		targetRef = std::move(_o.targetRef);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SpinnerPrizeStruct::clear()
{
	level = 0;
	type = 0;
	value = 0;
	targetRef.clear();
}

bool MLobbyNG::cli::SpinnerPrizeStruct::equals(const SpinnerPrizeStruct& _o) const
{
	return level == _o.level &&
		type == _o.type &&
		value == _o.value &&
		Atf::atfPStringEquals(targetRef, _o.targetRef);
}

const char *MLobbyNG::cli::SpinnerPrizeStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("level=");
	_buf.appendUint(level);
	_buf.append(',');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("value=");
	_buf.appendUint(value);
	_buf.append(',');
	_buf.append("targetRef=");
	_buf.append(targetRef);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::SpinnerPrizeStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("level", level, _buf);
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("value", value, _buf);
	Atf::XmlElement::encodeAsXmlElement("targetRef", targetRef, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::SpinnerPrizeStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("level"))
		{
			level = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("type"))
		{
			type = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("value"))
		{
			value = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("targetRef"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, targetRef)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::SpinnerPrizeStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SpinnerPrizeStruct())) // not empty
	{
		_body.composeBYTE(level);
		_body.composeBYTE(type);
		_body.composeUINT32(value);
		_body.composeString(targetRef);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SpinnerPrizeStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(level);
	_parser0.parseBYTE(type);
	_parser0.parseUINT32(value);
	_parser0.parseStringP(targetRef);
}

const char *MLobbyNG::cli::SpinnerPrizeStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("level", level);
	_jsonstr.compose("type", type);
	_jsonstr.compose("value", value);
	_jsonstr.compose("targetRef", targetRef);
	return _buf.c_str();
}

void MLobbyNG::cli::SpinnerPrizeStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("level", level);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("value", value);
	_jparser.parseByNameThrow("targetRef", targetRef);
}

/* static */ void MLobbyNG::cli::SpinnerPrizeStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE level; _jparser.validateByNameThrow("level", level);
	AtfValidator::validateInt(_descr, "level", level, _checker, __FILE__, __LINE__);
	BYTE type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	UINT32 value; _jparser.validateByNameThrow("value", value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	PString targetRef; _jparser.validateByNameThrow("targetRef", targetRef);
	AtfValidator::validateInt(_descr, "targetRef", targetRef.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::SpinnerPrizeStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE level; _parser0.parseBYTE(level);
	AtfValidator::validateInt(_descr, "level", level, _checker, __FILE__, __LINE__);
	BYTE type; _parser0.parseBYTE(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	UINT32 value; _parser0.parseUINT32(value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "targetRef"); size_t szTargetRef = strlen(_dummy);
	AtfValidator::validateInt(_descr, "targetRef", szTargetRef, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SagMaxMods
//=================================================================

MLobbyNG::cli::SagMaxMods::SagMaxMods()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SagMaxMods::SagMaxMods(SagMaxMods&& _o)
	: numUsers(std::move(_o.numUsers))
	, spinnerPrizes(std::move(_o.spinnerPrizes))
{
}

MLobbyNG::cli::SagMaxMods& MLobbyNG::cli::SagMaxMods::operator=(SagMaxMods&& _o)
{
	if(this != &_o)
	{
		numUsers = std::move(_o.numUsers);
		spinnerPrizes = std::move(_o.spinnerPrizes);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SagMaxMods::clear()
{
	numUsers = 0;
	spinnerPrizes.clear();
}

bool MLobbyNG::cli::SagMaxMods::equals(const SagMaxMods& _o) const
{
	return numUsers == _o.numUsers &&
		spinnerPrizes.equals(_o.spinnerPrizes);
}

const char *MLobbyNG::cli::SagMaxMods::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numUsers=");
	_buf.appendUint(numUsers);
	_buf.append(',');
	_buf.append("spinnerPrizes=");
	spinnerPrizes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::SagMaxMods::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("numUsers", numUsers, _buf);
	spinnerPrizes.toXmlString("spinnerPrizes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::SagMaxMods::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numUsers"))
		{
			numUsers = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("spinnerPrizes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SpinnerPrizeStruct, 4 > >::FromXmlString(_value, spinnerPrizes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::SagMaxMods::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SagMaxMods())) // not empty
	{
		_body.composeBYTE(numUsers);
		spinnerPrizes.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SagMaxMods::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(numUsers);
	spinnerPrizes.parseMsg(_parser0);
}

const char *MLobbyNG::cli::SagMaxMods::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numUsers", numUsers);
	_jsonstr.compose("spinnerPrizes", spinnerPrizes);
	return _buf.c_str();
}

void MLobbyNG::cli::SagMaxMods::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numUsers", numUsers);
	_jparser.parseByNameThrow("spinnerPrizes", spinnerPrizes);
}

/* static */ void MLobbyNG::cli::SagMaxMods::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE numUsers; _jparser.validateByNameThrow("numUsers", numUsers);
	AtfValidator::validateInt(_descr, "numUsers", numUsers, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SpinnerPrizeStruct > spinnerPrizes; _jparser.validateByNameThrow("spinnerPrizes", spinnerPrizes);
	AtfValidator::validateInt(_descr, "spinnerPrizes", spinnerPrizes.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::SagMaxMods::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE numUsers; _parser0.parseBYTE(numUsers);
	AtfValidator::validateInt(_descr, "numUsers", numUsers, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSpinnerPrizes = Atf::LAtfVector< SpinnerPrizeStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("spinnerPrizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "spinnerPrizes", szSpinnerPrizes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    StatesByCountryStruct
//=================================================================

MLobbyNG::cli::StatesByCountryStruct::StatesByCountryStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::StatesByCountryStruct::StatesByCountryStruct(StatesByCountryStruct&& _o)
	: country(std::move(_o.country))
	, stateInversion(std::move(_o.stateInversion))
	, states(std::move(_o.states))
{
}

MLobbyNG::cli::StatesByCountryStruct& MLobbyNG::cli::StatesByCountryStruct::operator=(StatesByCountryStruct&& _o)
{
	if(this != &_o)
	{
		country = std::move(_o.country);
		stateInversion = std::move(_o.stateInversion);
		states = std::move(_o.states);
	}
	return *this;
}

#endif

void MLobbyNG::cli::StatesByCountryStruct::clear()
{
	country.clear();
	stateInversion = false;
	states.clear();
}

bool MLobbyNG::cli::StatesByCountryStruct::equals(const StatesByCountryStruct& _o) const
{
	return Atf::atfPStringEquals(country, _o.country) &&
		stateInversion == _o.stateInversion &&
		states.equals(_o.states);
}

const char *MLobbyNG::cli::StatesByCountryStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("stateInversion=");
	_buf.appendUint(stateInversion);
	_buf.append(',');
	_buf.append("states=");
	states.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::StatesByCountryStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("stateInversion", stateInversion, _buf);
	states.toXmlString("states", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::StatesByCountryStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("stateInversion"))
		{
			stateInversion = (*_value.ptr() == '1');
		}
		else if (_element.equals("states"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, states)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::StatesByCountryStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(country);
	_msg.composeBOOL(stateInversion);
	states.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::StatesByCountryStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(country);
	_parser.parseBOOL(stateInversion);
	states.parseMsg(_parser);
}

const char *MLobbyNG::cli::StatesByCountryStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("country", country);
	_jsonstr.compose("stateInversion", stateInversion);
	_jsonstr.compose("states", states);
	return _buf.c_str();
}

void MLobbyNG::cli::StatesByCountryStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("stateInversion", stateInversion);
	_jparser.parseByNameThrow("states", states);
}

/* static */ void MLobbyNG::cli::StatesByCountryStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	bool stateInversion; _jparser.validateByNameThrow("stateInversion", stateInversion);
	AtfValidator::validateInt(_descr, "stateInversion", stateInversion, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > states; _jparser.validateByNameThrow("states", states);
	AtfValidator::validateInt(_descr, "states", states.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::StatesByCountryStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	bool stateInversion; _parser.parseBOOL(stateInversion);
	AtfValidator::validateInt(_descr, "stateInversion", stateInversion, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szStates = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("states"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "states", szStates, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    MLobbyNGSagStaticDataStruct
//=================================================================

MLobbyNG::cli::MLobbyNGSagStaticDataStruct::MLobbyNGSagStaticDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::MLobbyNGSagStaticDataStruct::MLobbyNGSagStaticDataStruct(MLobbyNGSagStaticDataStruct&& _o)
	: active(std::move(_o.active))
	, scriptId(std::move(_o.scriptId))
	, flags(std::move(_o.flags))
	, brandMask(std::move(_o.brandMask))
	, siteMask(std::move(_o.siteMask))
	, buyin(std::move(_o.buyin))
	, rake(std::move(_o.rake))
	, currency(std::move(_o.currency))
	, scalePM(std::move(_o.scalePM))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, speedDisplay(std::move(_o.speedDisplay))
	, minPrizePool(std::move(_o.minPrizePool))
	, maxPrizePool(std::move(_o.maxPrizePool))
	, maxPayout(std::move(_o.maxPayout))
	, promoRef(std::move(_o.promoRef))
	, minClientVersion(std::move(_o.minClientVersion))
	, maxClientVersion(std::move(_o.maxClientVersion))
	, mods(std::move(_o.mods))
	, tickets(std::move(_o.tickets))
	, customSpeedDisplayName(std::move(_o.customSpeedDisplayName))
	, restrictCountryInversion(std::move(_o.restrictCountryInversion))
	, statesByCountry(std::move(_o.statesByCountry))
	, visibilityCriteria(std::move(_o.visibilityCriteria))
	, mobileName(std::move(_o.mobileName))
	, tournGroup(std::move(_o.tournGroup))
	, admissions(std::move(_o.admissions))
	, tournFlags(std::move(_o.tournFlags))
	, tournGroupName(std::move(_o.tournGroupName))
	, tournGroupRef(std::move(_o.tournGroupRef))
	, tournSites(std::move(_o.tournSites))
	, eligibleGroups(std::move(_o.eligibleGroups))
{
}

MLobbyNG::cli::MLobbyNGSagStaticDataStruct& MLobbyNG::cli::MLobbyNGSagStaticDataStruct::operator=(MLobbyNGSagStaticDataStruct&& _o)
{
	if(this != &_o)
	{
		active = std::move(_o.active);
		scriptId = std::move(_o.scriptId);
		flags = std::move(_o.flags);
		brandMask = std::move(_o.brandMask);
		siteMask = std::move(_o.siteMask);
		buyin = std::move(_o.buyin);
		rake = std::move(_o.rake);
		currency = std::move(_o.currency);
		scalePM = std::move(_o.scalePM);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		speedDisplay = std::move(_o.speedDisplay);
		minPrizePool = std::move(_o.minPrizePool);
		maxPrizePool = std::move(_o.maxPrizePool);
		maxPayout = std::move(_o.maxPayout);
		promoRef = std::move(_o.promoRef);
		minClientVersion = std::move(_o.minClientVersion);
		maxClientVersion = std::move(_o.maxClientVersion);
		mods = std::move(_o.mods);
		tickets = std::move(_o.tickets);
		customSpeedDisplayName = std::move(_o.customSpeedDisplayName);
		restrictCountryInversion = std::move(_o.restrictCountryInversion);
		statesByCountry = std::move(_o.statesByCountry);
		visibilityCriteria = std::move(_o.visibilityCriteria);
		mobileName = std::move(_o.mobileName);
		tournGroup = std::move(_o.tournGroup);
		admissions = std::move(_o.admissions);
		tournFlags = std::move(_o.tournFlags);
		tournGroupName = std::move(_o.tournGroupName);
		tournGroupRef = std::move(_o.tournGroupRef);
		tournSites = std::move(_o.tournSites);
		eligibleGroups = std::move(_o.eligibleGroups);
	}
	return *this;
}

#endif

void MLobbyNG::cli::MLobbyNGSagStaticDataStruct::clear()
{
	active = false;
	scriptId = 0;
	flags = 0;
	brandMask = 0;
	siteMask = 0;
	buyin = 0;
	rake = 0;
	currency = 0;
	scalePM = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	speedDisplay = 0;
	minPrizePool = 0;
	maxPrizePool = 0;
	maxPayout = 0;
	promoRef.clear();
	minClientVersion = 0;
	maxClientVersion = 0;
	mods.clear();
	tickets.clear();
	customSpeedDisplayName.clear();
	restrictCountryInversion = false;
	statesByCountry.clear();
	visibilityCriteria.clear();
	mobileName.clear();
	tournGroup = 0;
	admissions.clear();
	tournFlags = 0;
	tournGroupName.clear();
	tournGroupRef.clear();
	tournSites.clear();
	eligibleGroups.clear();
}

bool MLobbyNG::cli::MLobbyNGSagStaticDataStruct::equals(const MLobbyNGSagStaticDataStruct& _o) const
{
	return active == _o.active &&
		scriptId == _o.scriptId &&
		flags == _o.flags &&
		brandMask == _o.brandMask &&
		siteMask == _o.siteMask &&
		buyin == _o.buyin &&
		rake == _o.rake &&
		currency == _o.currency &&
		scalePM == _o.scalePM &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		speedDisplay == _o.speedDisplay &&
		minPrizePool == _o.minPrizePool &&
		maxPrizePool == _o.maxPrizePool &&
		maxPayout == _o.maxPayout &&
		Atf::atfPStringEquals(promoRef, _o.promoRef) &&
		minClientVersion == _o.minClientVersion &&
		maxClientVersion == _o.maxClientVersion &&
		mods.equals(_o.mods) &&
		tickets.equals(_o.tickets) &&
		customSpeedDisplayName.equals(_o.customSpeedDisplayName) &&
		restrictCountryInversion == _o.restrictCountryInversion &&
		statesByCountry.equals(_o.statesByCountry) &&
		Atf::atfPStringEquals(visibilityCriteria, _o.visibilityCriteria) &&
		mobileName.equals(_o.mobileName) &&
		tournGroup == _o.tournGroup &&
		admissions.equals(_o.admissions) &&
		tournFlags == _o.tournFlags &&
		Atf::atfPStringEquals(tournGroupName, _o.tournGroupName) &&
		Atf::atfPStringEquals(tournGroupRef, _o.tournGroupRef) &&
		tournSites.equals(_o.tournSites) &&
		eligibleGroups.equals(_o.eligibleGroups);
}

const char *MLobbyNG::cli::MLobbyNGSagStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("active=");
	_buf.appendUint(active);
	if( active )
	{
		_buf.append(',');
		_buf.append("scriptId=");
		_buf.appendUint(scriptId);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
		_buf.append(',');
		_buf.append("brandMask=");
		_buf.appendUint(brandMask);
		_buf.append(',');
		_buf.append("siteMask=");
		_buf.appendUint(siteMask);
		_buf.append(',');
		_buf.append("buyin=");
		_buf.appendInt(buyin);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendInt(rake);
		_buf.append(',');
		_buf.append("currency=");
		_buf.appendInt(currency);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendInt(scalePM);
		_buf.append(',');
		_buf.append("game=");
		_buf.appendUint(game);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("speedDisplay=");
		_buf.appendUint(speedDisplay);
		_buf.append(',');
		_buf.append("minPrizePool=");
		_buf.appendInt(minPrizePool);
		_buf.append(',');
		_buf.append("maxPrizePool=");
		_buf.appendInt(maxPrizePool);
		_buf.append(',');
		_buf.append("maxPayout=");
		_buf.appendInt(maxPayout);
		_buf.append(',');
		_buf.append("promoRef=");
		_buf.append(promoRef);
		_buf.append(',');
		_buf.append("minClientVersion=");
		_buf.appendInt(minClientVersion);
		_buf.append(',');
		_buf.append("maxClientVersion=");
		_buf.appendInt(maxClientVersion);
		_buf.append(',');
		_buf.append("mods=");
		mods.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tickets=");
		tickets.toTraceString(_buf);
		_buf.append(',');
		_buf.append("customSpeedDisplayName=");
		Atf::AtfTempl<I18nPString>::ToTraceString(_buf, customSpeedDisplayName);
		_buf.append(',');
		_buf.append("restrictCountryInversion=");
		_buf.appendUint(restrictCountryInversion);
		_buf.append(',');
		_buf.append("statesByCountry=");
		statesByCountry.toTraceString(_buf);
		_buf.append(',');
		_buf.append("visibilityCriteria=");
		_buf.append(visibilityCriteria);
		_buf.append(',');
		_buf.append("mobileName=");
		Atf::AtfTempl<I18nPString>::ToTraceString(_buf, mobileName);
		_buf.append(',');
		_buf.append("tournGroup=");
		_buf.appendUint(tournGroup);
		_buf.append(',');
		_buf.append("admissions=");
		admissions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournGroupName=");
		_buf.append(tournGroupName);
		_buf.append(',');
		_buf.append("tournGroupRef=");
		_buf.append(tournGroupRef);
		_buf.append(',');
		_buf.append("tournSites=");
		tournSites.toTraceString(_buf);
		_buf.append(',');
		_buf.append("eligibleGroups=");
		eligibleGroups.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::MLobbyNGSagStaticDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("active", active, _buf);
	if( active )
	{
		Atf::XmlElement::encodeAsXmlElement("scriptId", scriptId, _buf);
		Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
		Atf::XmlElement::encodeAsXmlElement("brandMask", brandMask, _buf);
		Atf::XmlElement::encodeAsXmlElement("siteMask", siteMask, _buf);
		Atf::XmlElement::encodeAsXmlElement("buyin", buyin, _buf);
		Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
		Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
		Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
		Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
		Atf::XmlElement::encodeAsXmlElement("speedDisplay", speedDisplay, _buf);
		Atf::XmlElement::encodeAsXmlElement("minPrizePool", minPrizePool, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxPrizePool", maxPrizePool, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxPayout", maxPayout, _buf);
		Atf::XmlElement::encodeAsXmlElement("promoRef", promoRef, _buf);
		Atf::XmlElement::encodeAsXmlElement("minClientVersion", minClientVersion, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxClientVersion", maxClientVersion, _buf);
		mods.toXmlString("mods", _buf);
		tickets.toXmlString("tickets", _buf);
		Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "customSpeedDisplayName", customSpeedDisplayName);
		Atf::XmlElement::encodeAsXmlElement("restrictCountryInversion", restrictCountryInversion, _buf);
		statesByCountry.toXmlString("statesByCountry", _buf);
		Atf::XmlElement::encodeAsXmlElement("visibilityCriteria", visibilityCriteria, _buf);
		Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "mobileName", mobileName);
		Atf::XmlElement::encodeAsXmlElement("tournGroup", tournGroup, _buf);
		admissions.toXmlString("admissions", _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournGroupName", tournGroupName, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournGroupRef", tournGroupRef, _buf);
		tournSites.toXmlString("tournSites", _buf);
		eligibleGroups.toXmlString("eligibleGroups", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::MLobbyNGSagStaticDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("active"))
		{
			active = (*_value.ptr() == '1');
		}
		else if (_element.equals("scriptId"))
		{
			scriptId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandMask"))
		{
			brandMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("siteMask"))
		{
			siteMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyin"))
		{
			buyin = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			currency = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("speedDisplay"))
		{
			speedDisplay = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minPrizePool"))
		{
			minPrizePool = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPrizePool"))
		{
			maxPrizePool = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPayout"))
		{
			maxPayout = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("promoRef"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, promoRef)) return false;
		}
		else if (_element.equals("minClientVersion"))
		{
			minClientVersion = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxClientVersion"))
		{
			maxClientVersion = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("mods"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SagMaxMods, 4 > >::FromXmlString(_value, mods)) return false;
		}
		else if (_element.equals("tickets"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, tickets)) return false;
		}
		else if (_element.equals("customSpeedDisplayName"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, customSpeedDisplayName);
		}
		else if (_element.equals("restrictCountryInversion"))
		{
			restrictCountryInversion = (*_value.ptr() == '1');
		}
		else if (_element.equals("statesByCountry"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< StatesByCountryStruct, 4 > >::FromXmlString(_value, statesByCountry)) return false;
		}
		else if (_element.equals("visibilityCriteria"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, visibilityCriteria)) return false;
		}
		else if (_element.equals("mobileName"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, mobileName);
		}
		else if (_element.equals("tournGroup"))
		{
			tournGroup = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("admissions"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, admissions)) return false;
		}
		else if (_element.equals("tournFlags"))
		{
			tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournGroupName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tournGroupName)) return false;
		}
		else if (_element.equals("tournGroupRef"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tournGroupRef)) return false;
		}
		else if (_element.equals("tournSites"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, tournSites)) return false;
		}
		else if (_element.equals("eligibleGroups"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, eligibleGroups)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::MLobbyNGSagStaticDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(active);
	if( active )
	{
		_msg.composeUINT32(scriptId);
		_msg.composeUINT32(flags);
		_msg.composeUINT32(brandMask);
		_msg.composeUINT32(siteMask);
		_msg.composeINT32(buyin);
		_msg.composeINT32(rake);
		_msg.composeINT32(currency);
		_msg.composeINT32(scalePM);
		_msg.composeBYTE(game);
		_msg.composeBYTE(isHiLo);
		_msg.composeBYTE(structure);
		_msg.composeBYTE(speedDisplay);
		_msg.composeINT32(minPrizePool);
		_msg.composeINT32(maxPrizePool);
		_msg.composeINT32(maxPayout);
		_msg.composeString(promoRef);
		_msg.composeINT32(minClientVersion);
		_msg.composeINT32(maxClientVersion);
		mods.composeMsg(_msg, _ignoreJSON);
		tickets.composeMsg(_msg, _ignoreJSON);
		customSpeedDisplayName.compose(_msg);
		_msg.composeBOOL(restrictCountryInversion);
		statesByCountry.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(visibilityCriteria);
		mobileName.compose(_msg);
		_msg.composeUINT32(tournGroup);
		admissions.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT32(tournFlags);
		_msg.composeString(tournGroupName);
		_msg.composeString(tournGroupRef);
		tournSites.composeMsg(_msg, _ignoreJSON);
		eligibleGroups.composeMsg(_msg, _ignoreJSON);
	}
}

void MLobbyNG::cli::MLobbyNGSagStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(active);
	if( active )
	{
		_parser.parseUINT32(scriptId);
		_parser.parseUINT32(flags);
		_parser.parseUINT32(brandMask);
		_parser.parseUINT32(siteMask);
		_parser.parseINT32(buyin);
		_parser.parseINT32(rake);
		_parser.parseINT32(currency);
		_parser.parseINT32(scalePM);
		_parser.parseBYTE(game);
		_parser.parseBYTE(isHiLo);
		_parser.parseBYTE(structure);
		_parser.parseBYTE(speedDisplay);
		_parser.parseINT32(minPrizePool);
		_parser.parseINT32(maxPrizePool);
		_parser.parseINT32(maxPayout);
		_parser.parseStringP(promoRef);
		_parser.parseINT32(minClientVersion);
		_parser.parseINT32(maxClientVersion);
		mods.parseMsg(_parser);
		tickets.parseMsg(_parser);
		customSpeedDisplayName.parse(_parser);
		_parser.parseBOOL(restrictCountryInversion);
		statesByCountry.parseMsg(_parser);
		_parser.parseStringP(visibilityCriteria);
		mobileName.parse(_parser);
		_parser.parseUINT32(tournGroup);
		admissions.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		_parser.parseUINT32(tournFlags);
		if(_parser.parseEnded()) return;
		_parser.parseStringP(tournGroupName);
		if(_parser.parseEnded()) return;
		_parser.parseStringP(tournGroupRef);
		if(_parser.parseEnded()) return;
		tournSites.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		eligibleGroups.parseMsg(_parser);
	}
}

const char *MLobbyNG::cli::MLobbyNGSagStaticDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("active", active);
	if( active )
	{
		_jsonstr.compose("scriptId", scriptId);
		_jsonstr.compose("flags", flags);
		_jsonstr.compose("brandMask", brandMask);
		_jsonstr.compose("siteMask", siteMask);
		_jsonstr.compose("buyin", buyin);
		_jsonstr.compose("rake", rake);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("scalePM", scalePM);
		_jsonstr.compose("game", game);
		_jsonstr.compose("isHiLo", isHiLo);
		_jsonstr.compose("structure", structure);
		_jsonstr.compose("speedDisplay", speedDisplay);
		_jsonstr.compose("minPrizePool", minPrizePool);
		_jsonstr.compose("maxPrizePool", maxPrizePool);
		_jsonstr.compose("maxPayout", maxPayout);
		_jsonstr.compose("promoRef", promoRef);
		_jsonstr.compose("minClientVersion", minClientVersion);
		_jsonstr.compose("maxClientVersion", maxClientVersion);
		_jsonstr.compose("mods", mods);
		_jsonstr.compose("tickets", tickets);
		_jsonstr.compose("customSpeedDisplayName", customSpeedDisplayName);
		_jsonstr.compose("restrictCountryInversion", restrictCountryInversion);
		_jsonstr.compose("statesByCountry", statesByCountry);
		_jsonstr.compose("visibilityCriteria", visibilityCriteria);
		_jsonstr.compose("mobileName", mobileName);
		_jsonstr.compose("tournGroup", tournGroup);
		_jsonstr.compose("admissions", admissions);
		_jsonstr.compose("tournFlags", tournFlags);
		_jsonstr.compose("tournGroupName", tournGroupName);
		_jsonstr.compose("tournGroupRef", tournGroupRef);
		_jsonstr.compose("tournSites", tournSites);
		_jsonstr.compose("eligibleGroups", eligibleGroups);
	}
	return _buf.c_str();
}

void MLobbyNG::cli::MLobbyNGSagStaticDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("active", active);
	if( active )
	{
		_jparser.parseByNameThrow("scriptId", scriptId);
		_jparser.parseByNameThrow("flags", flags);
		_jparser.parseByNameThrow("brandMask", brandMask);
		_jparser.parseByNameThrow("siteMask", siteMask);
		_jparser.parseByNameThrow("buyin", buyin);
		_jparser.parseByNameThrow("rake", rake);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("scalePM", scalePM);
		_jparser.parseByNameThrow("game", game);
		_jparser.parseByNameThrow("isHiLo", isHiLo);
		_jparser.parseByNameThrow("structure", structure);
		_jparser.parseByNameThrow("speedDisplay", speedDisplay);
		_jparser.parseByNameThrow("minPrizePool", minPrizePool);
		_jparser.parseByNameThrow("maxPrizePool", maxPrizePool);
		_jparser.parseByNameThrow("maxPayout", maxPayout);
		_jparser.parseByNameThrow("promoRef", promoRef);
		_jparser.parseByNameThrow("minClientVersion", minClientVersion);
		_jparser.parseByNameThrow("maxClientVersion", maxClientVersion);
		_jparser.parseByNameThrow("mods", mods);
		_jparser.parseByNameThrow("tickets", tickets);
		_jparser.parseByNameThrow("customSpeedDisplayName", customSpeedDisplayName);
		_jparser.parseByNameThrow("restrictCountryInversion", restrictCountryInversion);
		_jparser.parseByNameThrow("statesByCountry", statesByCountry);
		_jparser.parseByNameThrow("visibilityCriteria", visibilityCriteria);
		_jparser.parseByNameThrow("mobileName", mobileName);
		_jparser.parseByNameThrow("tournGroup", tournGroup);
		_jparser.parseByNameThrow("admissions", admissions);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("tournFlags", tournFlags);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("tournGroupName", tournGroupName);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("tournGroupRef", tournGroupRef);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("tournSites", tournSites);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("eligibleGroups", eligibleGroups);
	}
}

/* static */ void MLobbyNG::cli::MLobbyNGSagStaticDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool active = false;
	_jparser.validateByNameThrow("active", active);
	AtfValidator::validateInt(_descr, "active", active, _checker, __FILE__, __LINE__);
	if( active )
	{
		UINT32 scriptId; _jparser.validateByNameThrow("scriptId", scriptId);
		AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
		UINT32 flags; _jparser.validateByNameThrow("flags", flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		UINT32 brandMask; _jparser.validateByNameThrow("brandMask", brandMask);
		AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
		UINT32 siteMask; _jparser.validateByNameThrow("siteMask", siteMask);
		AtfValidator::validateInt(_descr, "siteMask", siteMask, _checker, __FILE__, __LINE__);
		INT32 buyin; _jparser.validateByNameThrow("buyin", buyin);
		AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
		INT32 rake; _jparser.validateByNameThrow("rake", rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		INT32 currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency, _checker, __FILE__, __LINE__);
		INT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE game; _jparser.validateByNameThrow("game", game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _jparser.validateByNameThrow("structure", structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		BYTE speedDisplay; _jparser.validateByNameThrow("speedDisplay", speedDisplay);
		AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
		INT32 minPrizePool; _jparser.validateByNameThrow("minPrizePool", minPrizePool);
		AtfValidator::validateInt(_descr, "minPrizePool", minPrizePool, _checker, __FILE__, __LINE__);
		INT32 maxPrizePool; _jparser.validateByNameThrow("maxPrizePool", maxPrizePool);
		AtfValidator::validateInt(_descr, "maxPrizePool", maxPrizePool, _checker, __FILE__, __LINE__);
		INT32 maxPayout; _jparser.validateByNameThrow("maxPayout", maxPayout);
		AtfValidator::validateInt(_descr, "maxPayout", maxPayout, _checker, __FILE__, __LINE__);
		PString promoRef; _jparser.validateByNameThrow("promoRef", promoRef);
		AtfValidator::validateInt(_descr, "promoRef", promoRef.length(), _checker, __FILE__, __LINE__);
		INT32 minClientVersion; _jparser.validateByNameThrow("minClientVersion", minClientVersion);
		AtfValidator::validateInt(_descr, "minClientVersion", minClientVersion, _checker, __FILE__, __LINE__);
		INT32 maxClientVersion; _jparser.validateByNameThrow("maxClientVersion", maxClientVersion);
		AtfValidator::validateInt(_descr, "maxClientVersion", maxClientVersion, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< SagMaxMods > mods; _jparser.validateByNameThrow("mods", mods);
		AtfValidator::validateInt(_descr, "mods", mods.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UINT32 > tickets; _jparser.validateByNameThrow("tickets", tickets);
		AtfValidator::validateInt(_descr, "tickets", tickets.size(), _checker, __FILE__, __LINE__);
		I18nPString customSpeedDisplayName; _jparser.validateByNameThrow("customSpeedDisplayName", customSpeedDisplayName);
		bool restrictCountryInversion; _jparser.validateByNameThrow("restrictCountryInversion", restrictCountryInversion);
		AtfValidator::validateInt(_descr, "restrictCountryInversion", restrictCountryInversion, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< StatesByCountryStruct > statesByCountry; _jparser.validateByNameThrow("statesByCountry", statesByCountry);
		AtfValidator::validateInt(_descr, "statesByCountry", statesByCountry.size(), _checker, __FILE__, __LINE__);
		PString visibilityCriteria; _jparser.validateByNameThrow("visibilityCriteria", visibilityCriteria);
		AtfValidator::validateInt(_descr, "visibilityCriteria", visibilityCriteria.length(), _checker, __FILE__, __LINE__);
		I18nPString mobileName; _jparser.validateByNameThrow("mobileName", mobileName);
		UINT32 tournGroup; _jparser.validateByNameThrow("tournGroup", tournGroup);
		AtfValidator::validateInt(_descr, "tournGroup", tournGroup, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< PString > admissions; _jparser.validateByNameThrow("admissions", admissions);
		AtfValidator::validateInt(_descr, "admissions", admissions.size(), _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		PString tournGroupName; _jparser.validateByNameThrow("tournGroupName", tournGroupName);
		AtfValidator::validateInt(_descr, "tournGroupName", tournGroupName.length(), _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		PString tournGroupRef; _jparser.validateByNameThrow("tournGroupRef", tournGroupRef);
		AtfValidator::validateInt(_descr, "tournGroupRef", tournGroupRef.length(), _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		PSiteMask tournSites; _jparser.validateByNameThrow("tournSites", tournSites);
		if(_jparser.parseEnded()) return;
		Atf::AtfVectorBase< UINT32 > eligibleGroups; _jparser.validateByNameThrow("eligibleGroups", eligibleGroups);
		AtfValidator::validateInt(_descr, "eligibleGroups", eligibleGroups.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MLobbyNG::cli::MLobbyNGSagStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	bool active = false;
	_parser.parseBOOL(active);
	AtfValidator::validateInt(_descr, "active", active, _checker, __FILE__, __LINE__);
	if( active )
	{
		UINT32 scriptId; _parser.parseUINT32(scriptId);
		AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
		UINT32 flags; _parser.parseUINT32(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		UINT32 brandMask; _parser.parseUINT32(brandMask);
		AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
		UINT32 siteMask; _parser.parseUINT32(siteMask);
		AtfValidator::validateInt(_descr, "siteMask", siteMask, _checker, __FILE__, __LINE__);
		INT32 buyin; _parser.parseINT32(buyin);
		AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
		INT32 rake; _parser.parseINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		INT32 currency; _parser.parseINT32(currency);
		AtfValidator::validateInt(_descr, "currency", currency, _checker, __FILE__, __LINE__);
		INT32 scalePM; _parser.parseINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE game; _parser.parseBYTE(game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _parser.parseBYTE(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		BYTE speedDisplay; _parser.parseBYTE(speedDisplay);
		AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
		INT32 minPrizePool; _parser.parseINT32(minPrizePool);
		AtfValidator::validateInt(_descr, "minPrizePool", minPrizePool, _checker, __FILE__, __LINE__);
		INT32 maxPrizePool; _parser.parseINT32(maxPrizePool);
		AtfValidator::validateInt(_descr, "maxPrizePool", maxPrizePool, _checker, __FILE__, __LINE__);
		INT32 maxPayout; _parser.parseINT32(maxPayout);
		AtfValidator::validateInt(_descr, "maxPayout", maxPayout, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "promoRef"); size_t szPromoRef = strlen(_dummy);
		AtfValidator::validateInt(_descr, "promoRef", szPromoRef, _checker, __FILE__, __LINE__);
		INT32 minClientVersion; _parser.parseINT32(minClientVersion);
		AtfValidator::validateInt(_descr, "minClientVersion", minClientVersion, _checker, __FILE__, __LINE__);
		INT32 maxClientVersion; _parser.parseINT32(maxClientVersion);
		AtfValidator::validateInt(_descr, "maxClientVersion", maxClientVersion, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szMods = Atf::LAtfVector< SagMaxMods, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("mods"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "mods", szMods, _checker, __FILE__, __LINE__);
		int szTickets = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
		I18nPString customSpeedDisplayName; customSpeedDisplayName.parse(_parser);
		bool restrictCountryInversion; _parser.parseBOOL(restrictCountryInversion);
		AtfValidator::validateInt(_descr, "restrictCountryInversion", restrictCountryInversion, _checker, __FILE__, __LINE__);
		int szStatesByCountry = Atf::LAtfVector< StatesByCountryStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("statesByCountry"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "statesByCountry", szStatesByCountry, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "visibilityCriteria"); size_t szVisibilityCriteria = strlen(_dummy);
		AtfValidator::validateInt(_descr, "visibilityCriteria", szVisibilityCriteria, _checker, __FILE__, __LINE__);
		I18nPString mobileName; mobileName.parse(_parser);
		UINT32 tournGroup; _parser.parseUINT32(tournGroup);
		AtfValidator::validateInt(_descr, "tournGroup", tournGroup, _checker, __FILE__, __LINE__);
		int szAdmissions = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("admissions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "admissions", szAdmissions, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		_parser.parseStringN(_dummy, 0, "tournGroupName"); size_t szTournGroupName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournGroupName", szTournGroupName, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		_parser.parseStringN(_dummy, 0, "tournGroupRef"); size_t szTournGroupRef = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournGroupRef", szTournGroupRef, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSites"), _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		int szEligibleGroups = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("eligibleGroups"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "eligibleGroups", szEligibleGroups, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    MLobbyNGSagLocalStaticDataStruct
//=================================================================

MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::MLobbyNGSagLocalStaticDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::MLobbyNGSagLocalStaticDataStruct(MLobbyNGSagLocalStaticDataStruct&& _o)
	: active(std::move(_o.active))
	, scriptId(std::move(_o.scriptId))
	, flags(std::move(_o.flags))
	, brandMask(std::move(_o.brandMask))
	, siteMask(std::move(_o.siteMask))
	, buyin(std::move(_o.buyin))
	, rake(std::move(_o.rake))
	, currency(std::move(_o.currency))
	, scalePM(std::move(_o.scalePM))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, speedDisplay(std::move(_o.speedDisplay))
	, minPrizePool(std::move(_o.minPrizePool))
	, maxPrizePool(std::move(_o.maxPrizePool))
	, maxPayout(std::move(_o.maxPayout))
	, promoRef(std::move(_o.promoRef))
	, minClientVersion(std::move(_o.minClientVersion))
	, maxClientVersion(std::move(_o.maxClientVersion))
	, mods(std::move(_o.mods))
	, tickets(std::move(_o.tickets))
	, customSpeedDisplayName(std::move(_o.customSpeedDisplayName))
	, restrictCountryInversion(std::move(_o.restrictCountryInversion))
	, statesByCountry(std::move(_o.statesByCountry))
	, visibilityCriteria(std::move(_o.visibilityCriteria))
	, mobileName(std::move(_o.mobileName))
	, tournGroup(std::move(_o.tournGroup))
	, admissions(std::move(_o.admissions))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, tournFlags(std::move(_o.tournFlags))
	, tournGroupName(std::move(_o.tournGroupName))
	, tournGroupRef(std::move(_o.tournGroupRef))
	, tournSites(std::move(_o.tournSites))
{
}

MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct& MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::operator=(MLobbyNGSagLocalStaticDataStruct&& _o)
{
	if(this != &_o)
	{
		active = std::move(_o.active);
		scriptId = std::move(_o.scriptId);
		flags = std::move(_o.flags);
		brandMask = std::move(_o.brandMask);
		siteMask = std::move(_o.siteMask);
		buyin = std::move(_o.buyin);
		rake = std::move(_o.rake);
		currency = std::move(_o.currency);
		scalePM = std::move(_o.scalePM);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		speedDisplay = std::move(_o.speedDisplay);
		minPrizePool = std::move(_o.minPrizePool);
		maxPrizePool = std::move(_o.maxPrizePool);
		maxPayout = std::move(_o.maxPayout);
		promoRef = std::move(_o.promoRef);
		minClientVersion = std::move(_o.minClientVersion);
		maxClientVersion = std::move(_o.maxClientVersion);
		mods = std::move(_o.mods);
		tickets = std::move(_o.tickets);
		customSpeedDisplayName = std::move(_o.customSpeedDisplayName);
		restrictCountryInversion = std::move(_o.restrictCountryInversion);
		statesByCountry = std::move(_o.statesByCountry);
		visibilityCriteria = std::move(_o.visibilityCriteria);
		mobileName = std::move(_o.mobileName);
		tournGroup = std::move(_o.tournGroup);
		admissions = std::move(_o.admissions);
		isPlayMoney = std::move(_o.isPlayMoney);
		tournFlags = std::move(_o.tournFlags);
		tournGroupName = std::move(_o.tournGroupName);
		tournGroupRef = std::move(_o.tournGroupRef);
		tournSites = std::move(_o.tournSites);
	}
	return *this;
}

#endif

void MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::clear()
{
	active = false;
	scriptId = 0;
	flags = 0;
	brandMask = 0;
	siteMask = 0;
	buyin = 0;
	rake = 0;
	currency = 0;
	scalePM = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	speedDisplay = 0;
	minPrizePool = 0;
	maxPrizePool = 0;
	maxPayout = 0;
	promoRef.clear();
	minClientVersion = 0;
	maxClientVersion = 0;
	mods.clear();
	tickets.clear();
	customSpeedDisplayName.clear();
	restrictCountryInversion = false;
	statesByCountry.clear();
	visibilityCriteria.clear();
	mobileName.clear();
	tournGroup = 0;
	admissions.clear();
	isPlayMoney = false;
	tournFlags = 0;
	tournGroupName.clear();
	tournGroupRef.clear();
	tournSites.clear();
}

bool MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::equals(const MLobbyNGSagLocalStaticDataStruct& _o) const
{
	return active == _o.active &&
		scriptId == _o.scriptId &&
		flags == _o.flags &&
		brandMask == _o.brandMask &&
		siteMask == _o.siteMask &&
		buyin == _o.buyin &&
		rake == _o.rake &&
		currency == _o.currency &&
		scalePM == _o.scalePM &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		speedDisplay == _o.speedDisplay &&
		minPrizePool == _o.minPrizePool &&
		maxPrizePool == _o.maxPrizePool &&
		maxPayout == _o.maxPayout &&
		Atf::atfPStringEquals(promoRef, _o.promoRef) &&
		minClientVersion == _o.minClientVersion &&
		maxClientVersion == _o.maxClientVersion &&
		mods.equals(_o.mods) &&
		tickets.equals(_o.tickets) &&
		Atf::atfPStringEquals(customSpeedDisplayName, _o.customSpeedDisplayName) &&
		restrictCountryInversion == _o.restrictCountryInversion &&
		statesByCountry.equals(_o.statesByCountry) &&
		Atf::atfPStringEquals(visibilityCriteria, _o.visibilityCriteria) &&
		Atf::atfPStringEquals(mobileName, _o.mobileName) &&
		tournGroup == _o.tournGroup &&
		admissions.equals(_o.admissions) &&
		isPlayMoney == _o.isPlayMoney &&
		tournFlags == _o.tournFlags &&
		Atf::atfPStringEquals(tournGroupName, _o.tournGroupName) &&
		Atf::atfPStringEquals(tournGroupRef, _o.tournGroupRef) &&
		tournSites.equals(_o.tournSites);
}

const char *MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("active=");
	_buf.appendUint(active);
	if( active )
	{
		_buf.append(',');
		_buf.append("scriptId=");
		_buf.appendUint(scriptId);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
		_buf.append(',');
		_buf.append("brandMask=");
		_buf.appendUint(brandMask);
		_buf.append(',');
		_buf.append("siteMask=");
		_buf.appendUint(siteMask);
		_buf.append(',');
		_buf.append("buyin=");
		_buf.appendInt(buyin);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendInt(rake);
		_buf.append(',');
		_buf.append("currency=");
		_buf.appendInt(currency);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendInt(scalePM);
		_buf.append(',');
		_buf.append("game=");
		_buf.appendUint(game);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("speedDisplay=");
		_buf.appendUint(speedDisplay);
		_buf.append(',');
		_buf.append("minPrizePool=");
		_buf.appendInt(minPrizePool);
		_buf.append(',');
		_buf.append("maxPrizePool=");
		_buf.appendInt(maxPrizePool);
		_buf.append(',');
		_buf.append("maxPayout=");
		_buf.appendInt(maxPayout);
		_buf.append(',');
		_buf.append("promoRef=");
		_buf.append(promoRef);
		_buf.append(',');
		_buf.append("minClientVersion=");
		_buf.appendInt(minClientVersion);
		_buf.append(',');
		_buf.append("maxClientVersion=");
		_buf.appendInt(maxClientVersion);
		_buf.append(',');
		_buf.append("mods=");
		mods.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tickets=");
		tickets.toTraceString(_buf);
		_buf.append(',');
		_buf.append("customSpeedDisplayName=");
		_buf.append(customSpeedDisplayName);
		_buf.append(',');
		_buf.append("restrictCountryInversion=");
		_buf.appendUint(restrictCountryInversion);
		_buf.append(',');
		_buf.append("statesByCountry=");
		statesByCountry.toTraceString(_buf);
		_buf.append(',');
		_buf.append("visibilityCriteria=");
		_buf.append(visibilityCriteria);
		_buf.append(',');
		_buf.append("mobileName=");
		_buf.append(mobileName);
		_buf.append(',');
		_buf.append("tournGroup=");
		_buf.appendUint(tournGroup);
		_buf.append(',');
		_buf.append("admissions=");
		admissions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournGroupName=");
		_buf.append(tournGroupName);
		_buf.append(',');
		_buf.append("tournGroupRef=");
		_buf.append(tournGroupRef);
		_buf.append(',');
		_buf.append("tournSites=");
		tournSites.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("active", active, _buf);
	if( active )
	{
		Atf::XmlElement::encodeAsXmlElement("scriptId", scriptId, _buf);
		Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
		Atf::XmlElement::encodeAsXmlElement("brandMask", brandMask, _buf);
		Atf::XmlElement::encodeAsXmlElement("siteMask", siteMask, _buf);
		Atf::XmlElement::encodeAsXmlElement("buyin", buyin, _buf);
		Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
		Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
		Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
		Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
		Atf::XmlElement::encodeAsXmlElement("speedDisplay", speedDisplay, _buf);
		Atf::XmlElement::encodeAsXmlElement("minPrizePool", minPrizePool, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxPrizePool", maxPrizePool, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxPayout", maxPayout, _buf);
		Atf::XmlElement::encodeAsXmlElement("promoRef", promoRef, _buf);
		Atf::XmlElement::encodeAsXmlElement("minClientVersion", minClientVersion, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxClientVersion", maxClientVersion, _buf);
		mods.toXmlString("mods", _buf);
		tickets.toXmlString("tickets", _buf);
		Atf::XmlElement::encodeAsXmlElement("customSpeedDisplayName", customSpeedDisplayName, _buf);
		Atf::XmlElement::encodeAsXmlElement("restrictCountryInversion", restrictCountryInversion, _buf);
		statesByCountry.toXmlString("statesByCountry", _buf);
		Atf::XmlElement::encodeAsXmlElement("visibilityCriteria", visibilityCriteria, _buf);
		Atf::XmlElement::encodeAsXmlElement("mobileName", mobileName, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournGroup", tournGroup, _buf);
		admissions.toXmlString("admissions", _buf);
		Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournGroupName", tournGroupName, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournGroupRef", tournGroupRef, _buf);
		tournSites.toXmlString("tournSites", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("active"))
		{
			active = (*_value.ptr() == '1');
		}
		else if (_element.equals("scriptId"))
		{
			scriptId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandMask"))
		{
			brandMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("siteMask"))
		{
			siteMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyin"))
		{
			buyin = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			currency = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("speedDisplay"))
		{
			speedDisplay = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minPrizePool"))
		{
			minPrizePool = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPrizePool"))
		{
			maxPrizePool = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPayout"))
		{
			maxPayout = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("promoRef"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, promoRef)) return false;
		}
		else if (_element.equals("minClientVersion"))
		{
			minClientVersion = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxClientVersion"))
		{
			maxClientVersion = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("mods"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SagMaxMods, 4 > >::FromXmlString(_value, mods)) return false;
		}
		else if (_element.equals("tickets"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, tickets)) return false;
		}
		else if (_element.equals("customSpeedDisplayName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, customSpeedDisplayName)) return false;
		}
		else if (_element.equals("restrictCountryInversion"))
		{
			restrictCountryInversion = (*_value.ptr() == '1');
		}
		else if (_element.equals("statesByCountry"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< StatesByCountryStruct, 4 > >::FromXmlString(_value, statesByCountry)) return false;
		}
		else if (_element.equals("visibilityCriteria"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, visibilityCriteria)) return false;
		}
		else if (_element.equals("mobileName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, mobileName)) return false;
		}
		else if (_element.equals("tournGroup"))
		{
			tournGroup = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("admissions"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, admissions)) return false;
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("tournFlags"))
		{
			tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournGroupName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tournGroupName)) return false;
		}
		else if (_element.equals("tournGroupRef"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tournGroupRef)) return false;
		}
		else if (_element.equals("tournSites"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, tournSites)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MLobbyNGSagLocalStaticDataStruct())) // not empty
	{
		_body.composeBOOL(active);
		if( active )
		{
			_body.composeUINT32(scriptId);
			_body.composeUINT32(flags);
			_body.composeUINT32(brandMask);
			_body.composeUINT32(siteMask);
			_body.composeINT32(buyin);
			_body.composeINT32(rake);
			_body.composeINT32(currency);
			_body.composeINT32(scalePM);
			_body.composeBYTE(game);
			_body.composeBYTE(isHiLo);
			_body.composeBYTE(structure);
			_body.composeBYTE(speedDisplay);
			_body.composeINT32(minPrizePool);
			_body.composeINT32(maxPrizePool);
			_body.composeINT32(maxPayout);
			_body.composeString(promoRef);
			_body.composeINT32(minClientVersion);
			_body.composeINT32(maxClientVersion);
			mods.composeMsg(_body, _ignoreJSON);
			tickets.composeMsg(_body, _ignoreJSON);
			_body.composeString(customSpeedDisplayName);
			_body.composeBOOL(restrictCountryInversion);
			statesByCountry.composeMsg(_body, _ignoreJSON);
			_body.composeString(visibilityCriteria);
			_body.composeString(mobileName);
			_body.composeUINT32(tournGroup);
			admissions.composeMsg(_body, _ignoreJSON);
			_body.composeBOOL(isPlayMoney);
			_body.composeUINT32(tournFlags);
			_body.composeString(tournGroupName);
			_body.composeString(tournGroupRef);
			tournSites.composeMsg(_body, _ignoreJSON);
		}
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(active);
	if( active )
	{
		_parser0.parseUINT32(scriptId);
		_parser0.parseUINT32(flags);
		_parser0.parseUINT32(brandMask);
		_parser0.parseUINT32(siteMask);
		_parser0.parseINT32(buyin);
		_parser0.parseINT32(rake);
		_parser0.parseINT32(currency);
		_parser0.parseINT32(scalePM);
		_parser0.parseBYTE(game);
		_parser0.parseBYTE(isHiLo);
		_parser0.parseBYTE(structure);
		_parser0.parseBYTE(speedDisplay);
		_parser0.parseINT32(minPrizePool);
		_parser0.parseINT32(maxPrizePool);
		_parser0.parseINT32(maxPayout);
		_parser0.parseStringP(promoRef);
		_parser0.parseINT32(minClientVersion);
		_parser0.parseINT32(maxClientVersion);
		mods.parseMsg(_parser0);
		tickets.parseMsg(_parser0);
		_parser0.parseStringP(customSpeedDisplayName);
		_parser0.parseBOOL(restrictCountryInversion);
		statesByCountry.parseMsg(_parser0);
		_parser0.parseStringP(visibilityCriteria);
		_parser0.parseStringP(mobileName);
		_parser0.parseUINT32(tournGroup);
		admissions.parseMsg(_parser0);
		_parser0.parseBOOL(isPlayMoney);
		if(_parser0.parseEnded()) return;
		_parser0.parseUINT32(tournFlags);
		if(_parser0.parseEnded()) return;
		_parser0.parseStringP(tournGroupName);
		if(_parser0.parseEnded()) return;
		_parser0.parseStringP(tournGroupRef);
		if(_parser0.parseEnded()) return;
		tournSites.parseMsg(_parser0);
	}
}

const char *MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("active", active);
	if( active )
	{
		_jsonstr.compose("scriptId", scriptId);
		_jsonstr.compose("flags", flags);
		_jsonstr.compose("brandMask", brandMask);
		_jsonstr.compose("siteMask", siteMask);
		_jsonstr.compose("buyin", buyin);
		_jsonstr.compose("rake", rake);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("scalePM", scalePM);
		_jsonstr.compose("game", game);
		_jsonstr.compose("isHiLo", isHiLo);
		_jsonstr.compose("structure", structure);
		_jsonstr.compose("speedDisplay", speedDisplay);
		_jsonstr.compose("minPrizePool", minPrizePool);
		_jsonstr.compose("maxPrizePool", maxPrizePool);
		_jsonstr.compose("maxPayout", maxPayout);
		_jsonstr.compose("promoRef", promoRef);
		_jsonstr.compose("minClientVersion", minClientVersion);
		_jsonstr.compose("maxClientVersion", maxClientVersion);
		_jsonstr.compose("mods", mods);
		_jsonstr.compose("tickets", tickets);
		_jsonstr.compose("customSpeedDisplayName", customSpeedDisplayName);
		_jsonstr.compose("restrictCountryInversion", restrictCountryInversion);
		_jsonstr.compose("statesByCountry", statesByCountry);
		_jsonstr.compose("visibilityCriteria", visibilityCriteria);
		_jsonstr.compose("mobileName", mobileName);
		_jsonstr.compose("tournGroup", tournGroup);
		_jsonstr.compose("admissions", admissions);
		_jsonstr.compose("isPlayMoney", isPlayMoney);
		_jsonstr.compose("tournFlags", tournFlags);
		_jsonstr.compose("tournGroupName", tournGroupName);
		_jsonstr.compose("tournGroupRef", tournGroupRef);
		_jsonstr.compose("tournSites", tournSites);
	}
	return _buf.c_str();
}

void MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("active", active);
	if( active )
	{
		_jparser.parseByNameThrow("scriptId", scriptId);
		_jparser.parseByNameThrow("flags", flags);
		_jparser.parseByNameThrow("brandMask", brandMask);
		_jparser.parseByNameThrow("siteMask", siteMask);
		_jparser.parseByNameThrow("buyin", buyin);
		_jparser.parseByNameThrow("rake", rake);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("scalePM", scalePM);
		_jparser.parseByNameThrow("game", game);
		_jparser.parseByNameThrow("isHiLo", isHiLo);
		_jparser.parseByNameThrow("structure", structure);
		_jparser.parseByNameThrow("speedDisplay", speedDisplay);
		_jparser.parseByNameThrow("minPrizePool", minPrizePool);
		_jparser.parseByNameThrow("maxPrizePool", maxPrizePool);
		_jparser.parseByNameThrow("maxPayout", maxPayout);
		_jparser.parseByNameThrow("promoRef", promoRef);
		_jparser.parseByNameThrow("minClientVersion", minClientVersion);
		_jparser.parseByNameThrow("maxClientVersion", maxClientVersion);
		_jparser.parseByNameThrow("mods", mods);
		_jparser.parseByNameThrow("tickets", tickets);
		_jparser.parseByNameThrow("customSpeedDisplayName", customSpeedDisplayName);
		_jparser.parseByNameThrow("restrictCountryInversion", restrictCountryInversion);
		_jparser.parseByNameThrow("statesByCountry", statesByCountry);
		_jparser.parseByNameThrow("visibilityCriteria", visibilityCriteria);
		_jparser.parseByNameThrow("mobileName", mobileName);
		_jparser.parseByNameThrow("tournGroup", tournGroup);
		_jparser.parseByNameThrow("admissions", admissions);
		_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("tournFlags", tournFlags);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("tournGroupName", tournGroupName);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("tournGroupRef", tournGroupRef);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("tournSites", tournSites);
	}
}

/* static */ void MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool active = false;
	_jparser.validateByNameThrow("active", active);
	AtfValidator::validateInt(_descr, "active", active, _checker, __FILE__, __LINE__);
	if( active )
	{
		UINT32 scriptId; _jparser.validateByNameThrow("scriptId", scriptId);
		AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
		UINT32 flags; _jparser.validateByNameThrow("flags", flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		UINT32 brandMask; _jparser.validateByNameThrow("brandMask", brandMask);
		AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
		UINT32 siteMask; _jparser.validateByNameThrow("siteMask", siteMask);
		AtfValidator::validateInt(_descr, "siteMask", siteMask, _checker, __FILE__, __LINE__);
		INT32 buyin; _jparser.validateByNameThrow("buyin", buyin);
		AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
		INT32 rake; _jparser.validateByNameThrow("rake", rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		INT32 currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency, _checker, __FILE__, __LINE__);
		INT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE game; _jparser.validateByNameThrow("game", game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _jparser.validateByNameThrow("structure", structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		BYTE speedDisplay; _jparser.validateByNameThrow("speedDisplay", speedDisplay);
		AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
		INT32 minPrizePool; _jparser.validateByNameThrow("minPrizePool", minPrizePool);
		AtfValidator::validateInt(_descr, "minPrizePool", minPrizePool, _checker, __FILE__, __LINE__);
		INT32 maxPrizePool; _jparser.validateByNameThrow("maxPrizePool", maxPrizePool);
		AtfValidator::validateInt(_descr, "maxPrizePool", maxPrizePool, _checker, __FILE__, __LINE__);
		INT32 maxPayout; _jparser.validateByNameThrow("maxPayout", maxPayout);
		AtfValidator::validateInt(_descr, "maxPayout", maxPayout, _checker, __FILE__, __LINE__);
		PString promoRef; _jparser.validateByNameThrow("promoRef", promoRef);
		AtfValidator::validateInt(_descr, "promoRef", promoRef.length(), _checker, __FILE__, __LINE__);
		INT32 minClientVersion; _jparser.validateByNameThrow("minClientVersion", minClientVersion);
		AtfValidator::validateInt(_descr, "minClientVersion", minClientVersion, _checker, __FILE__, __LINE__);
		INT32 maxClientVersion; _jparser.validateByNameThrow("maxClientVersion", maxClientVersion);
		AtfValidator::validateInt(_descr, "maxClientVersion", maxClientVersion, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< SagMaxMods > mods; _jparser.validateByNameThrow("mods", mods);
		AtfValidator::validateInt(_descr, "mods", mods.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UINT32 > tickets; _jparser.validateByNameThrow("tickets", tickets);
		AtfValidator::validateInt(_descr, "tickets", tickets.size(), _checker, __FILE__, __LINE__);
		PString customSpeedDisplayName; _jparser.validateByNameThrow("customSpeedDisplayName", customSpeedDisplayName);
		AtfValidator::validateInt(_descr, "customSpeedDisplayName", customSpeedDisplayName.length(), _checker, __FILE__, __LINE__);
		bool restrictCountryInversion; _jparser.validateByNameThrow("restrictCountryInversion", restrictCountryInversion);
		AtfValidator::validateInt(_descr, "restrictCountryInversion", restrictCountryInversion, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< StatesByCountryStruct > statesByCountry; _jparser.validateByNameThrow("statesByCountry", statesByCountry);
		AtfValidator::validateInt(_descr, "statesByCountry", statesByCountry.size(), _checker, __FILE__, __LINE__);
		PString visibilityCriteria; _jparser.validateByNameThrow("visibilityCriteria", visibilityCriteria);
		AtfValidator::validateInt(_descr, "visibilityCriteria", visibilityCriteria.length(), _checker, __FILE__, __LINE__);
		PString mobileName; _jparser.validateByNameThrow("mobileName", mobileName);
		AtfValidator::validateInt(_descr, "mobileName", mobileName.length(), _checker, __FILE__, __LINE__);
		UINT32 tournGroup; _jparser.validateByNameThrow("tournGroup", tournGroup);
		AtfValidator::validateInt(_descr, "tournGroup", tournGroup, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< PString > admissions; _jparser.validateByNameThrow("admissions", admissions);
		AtfValidator::validateInt(_descr, "admissions", admissions.size(), _checker, __FILE__, __LINE__);
		bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		PString tournGroupName; _jparser.validateByNameThrow("tournGroupName", tournGroupName);
		AtfValidator::validateInt(_descr, "tournGroupName", tournGroupName.length(), _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		PString tournGroupRef; _jparser.validateByNameThrow("tournGroupRef", tournGroupRef);
		AtfValidator::validateInt(_descr, "tournGroupRef", tournGroupRef.length(), _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		PSiteMask tournSites; _jparser.validateByNameThrow("tournSites", tournSites);
	}
}

/*static*/ void MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	bool active = false;
	_parser0.parseBOOL(active);
	AtfValidator::validateInt(_descr, "active", active, _checker, __FILE__, __LINE__);
	if( active )
	{
		UINT32 scriptId; _parser0.parseUINT32(scriptId);
		AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
		UINT32 flags; _parser0.parseUINT32(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		UINT32 brandMask; _parser0.parseUINT32(brandMask);
		AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
		UINT32 siteMask; _parser0.parseUINT32(siteMask);
		AtfValidator::validateInt(_descr, "siteMask", siteMask, _checker, __FILE__, __LINE__);
		INT32 buyin; _parser0.parseINT32(buyin);
		AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
		INT32 rake; _parser0.parseINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		INT32 currency; _parser0.parseINT32(currency);
		AtfValidator::validateInt(_descr, "currency", currency, _checker, __FILE__, __LINE__);
		INT32 scalePM; _parser0.parseINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE game; _parser0.parseBYTE(game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _parser0.parseBYTE(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _parser0.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		BYTE speedDisplay; _parser0.parseBYTE(speedDisplay);
		AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
		INT32 minPrizePool; _parser0.parseINT32(minPrizePool);
		AtfValidator::validateInt(_descr, "minPrizePool", minPrizePool, _checker, __FILE__, __LINE__);
		INT32 maxPrizePool; _parser0.parseINT32(maxPrizePool);
		AtfValidator::validateInt(_descr, "maxPrizePool", maxPrizePool, _checker, __FILE__, __LINE__);
		INT32 maxPayout; _parser0.parseINT32(maxPayout);
		AtfValidator::validateInt(_descr, "maxPayout", maxPayout, _checker, __FILE__, __LINE__);
		_parser0.parseStringN(_dummy, 0, "promoRef"); size_t szPromoRef = strlen(_dummy);
		AtfValidator::validateInt(_descr, "promoRef", szPromoRef, _checker, __FILE__, __LINE__);
		INT32 minClientVersion; _parser0.parseINT32(minClientVersion);
		AtfValidator::validateInt(_descr, "minClientVersion", minClientVersion, _checker, __FILE__, __LINE__);
		INT32 maxClientVersion; _parser0.parseINT32(maxClientVersion);
		AtfValidator::validateInt(_descr, "maxClientVersion", maxClientVersion, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szMods = Atf::LAtfVector< SagMaxMods, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("mods"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "mods", szMods, _checker, __FILE__, __LINE__);
		int szTickets = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
		_parser0.parseStringN(_dummy, 0, "customSpeedDisplayName"); size_t szCustomSpeedDisplayName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "customSpeedDisplayName", szCustomSpeedDisplayName, _checker, __FILE__, __LINE__);
		bool restrictCountryInversion; _parser0.parseBOOL(restrictCountryInversion);
		AtfValidator::validateInt(_descr, "restrictCountryInversion", restrictCountryInversion, _checker, __FILE__, __LINE__);
		int szStatesByCountry = Atf::LAtfVector< StatesByCountryStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("statesByCountry"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "statesByCountry", szStatesByCountry, _checker, __FILE__, __LINE__);
		_parser0.parseStringN(_dummy, 0, "visibilityCriteria"); size_t szVisibilityCriteria = strlen(_dummy);
		AtfValidator::validateInt(_descr, "visibilityCriteria", szVisibilityCriteria, _checker, __FILE__, __LINE__);
		_parser0.parseStringN(_dummy, 0, "mobileName"); size_t szMobileName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "mobileName", szMobileName, _checker, __FILE__, __LINE__);
		UINT32 tournGroup; _parser0.parseUINT32(tournGroup);
		AtfValidator::validateInt(_descr, "tournGroup", tournGroup, _checker, __FILE__, __LINE__);
		int szAdmissions = Atf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("admissions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "admissions", szAdmissions, _checker, __FILE__, __LINE__);
		bool isPlayMoney; _parser0.parseBOOL(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		if(_parser0.parseEnded()) return;
		UINT32 tournFlags; _parser0.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		if(_parser0.parseEnded()) return;
		_parser0.parseStringN(_dummy, 0, "tournGroupName"); size_t szTournGroupName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournGroupName", szTournGroupName, _checker, __FILE__, __LINE__);
		if(_parser0.parseEnded()) return;
		_parser0.parseStringN(_dummy, 0, "tournGroupRef"); size_t szTournGroupRef = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournGroupRef", szTournGroupRef, _checker, __FILE__, __LINE__);
		if(_parser0.parseEnded()) return;
		PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournSites"), _fieldsWithUnparsedContent);
	}
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SagDataStruct
//=================================================================

MLobbyNG::cli::SagDataStruct::SagDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SagDataStruct::SagDataStruct(SagDataStruct&& _o)
	: staticData(std::move(_o.staticData))
	, lastEntry(std::move(_o.lastEntry))
	, userHasTicket(std::move(_o.userHasTicket))
	, ngSagFlags(std::move(_o.ngSagFlags))
{
}

MLobbyNG::cli::SagDataStruct& MLobbyNG::cli::SagDataStruct::operator=(SagDataStruct&& _o)
{
	if(this != &_o)
	{
		staticData = std::move(_o.staticData);
		lastEntry = std::move(_o.lastEntry);
		userHasTicket = std::move(_o.userHasTicket);
		ngSagFlags = std::move(_o.ngSagFlags);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SagDataStruct::clear()
{
	staticData.clear();
	lastEntry.setNull();
	userHasTicket = false;
	ngSagFlags = 0;
}

bool MLobbyNG::cli::SagDataStruct::equals(const SagDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		lastEntry.equals(_o.lastEntry) &&
		userHasTicket == _o.userHasTicket &&
		ngSagFlags == _o.ngSagFlags;
}

const char *MLobbyNG::cli::SagDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("lastEntry=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, lastEntry);
	_buf.append(',');
	_buf.append("userHasTicket=");
	_buf.appendUint(userHasTicket);
	_buf.append(',');
	_buf.append("ngSagFlags=");
	_buf.appendUint(ngSagFlags);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::SagDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	staticData.toXmlString("staticData", _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "lastEntry", lastEntry);
	Atf::XmlElement::encodeAsXmlElement("userHasTicket", userHasTicket, _buf);
	Atf::XmlElement::encodeAsXmlElement("ngSagFlags", ngSagFlags, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::SagDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("staticData"))
		{
			if(!Atf::AtfTempl< MLobbyNGSagLocalStaticDataStruct >::FromXmlString(_value, staticData)) return false;
		}
		else if (_element.equals("lastEntry"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, lastEntry);
		}
		else if (_element.equals("userHasTicket"))
		{
			userHasTicket = (*_value.ptr() == '1');
		}
		else if (_element.equals("ngSagFlags"))
		{
			ngSagFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::SagDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SagDataStruct())) // not empty
	{
		staticData.composeMsg(_body, _ignoreJSON);
		_body.composeSrvTime(lastEntry);
		_body.composeBOOL(userHasTicket);
		_body.composeUINT32(ngSagFlags);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SagDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	_parser0.parseSrvTime(lastEntry);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(userHasTicket);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(ngSagFlags);
}

const char *MLobbyNG::cli::SagDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("staticData", staticData);
	_jsonstr.compose("lastEntry", lastEntry);
	_jsonstr.compose("userHasTicket", userHasTicket);
	_jsonstr.compose("ngSagFlags", ngSagFlags);
	return _buf.c_str();
}

void MLobbyNG::cli::SagDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("staticData", staticData);
	_jparser.parseByNameThrow("lastEntry", lastEntry);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("userHasTicket", userHasTicket);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("ngSagFlags", ngSagFlags);
}

/* static */ void MLobbyNG::cli::SagDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	MLobbyNGSagLocalStaticDataStruct staticData; _jparser.validateByNameThrow("staticData", staticData);
	SrvTime lastEntry; _jparser.validateByNameThrow("lastEntry", lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool userHasTicket; _jparser.validateByNameThrow("userHasTicket", userHasTicket);
	AtfValidator::validateInt(_descr, "userHasTicket", userHasTicket, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 ngSagFlags; _jparser.validateByNameThrow("ngSagFlags", ngSagFlags);
	AtfValidator::validateInt(_descr, "ngSagFlags", ngSagFlags, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::SagDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	MLobbyNGSagLocalStaticDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	SrvTime lastEntry; _parser0.parseSrvTime(lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool userHasTicket; _parser0.parseBOOL(userHasTicket);
	AtfValidator::validateInt(_descr, "userHasTicket", userHasTicket, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 ngSagFlags; _parser0.parseUINT32(ngSagFlags);
	AtfValidator::validateInt(_descr, "ngSagFlags", ngSagFlags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PPPDataStruct
//=================================================================

MLobbyNG::cli::PPPDataStruct::PPPDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::PPPDataStruct::PPPDataStruct(PPPDataStruct&& _o)
	: staticData(std::move(_o.staticData))
	, buyIn(std::move(_o.buyIn))
	, lastEntry(std::move(_o.lastEntry))
{
}

MLobbyNG::cli::PPPDataStruct& MLobbyNG::cli::PPPDataStruct::operator=(PPPDataStruct&& _o)
{
	if(this != &_o)
	{
		staticData = std::move(_o.staticData);
		buyIn = std::move(_o.buyIn);
		lastEntry = std::move(_o.lastEntry);
	}
	return *this;
}

#endif

void MLobbyNG::cli::PPPDataStruct::clear()
{
	staticData.clear();
	buyIn = 0;
	lastEntry.setNull();
}

bool MLobbyNG::cli::PPPDataStruct::equals(const PPPDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		buyIn == _o.buyIn &&
		lastEntry.equals(_o.lastEntry);
}

const char *MLobbyNG::cli::PPPDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt64(buyIn);
	_buf.append(',');
	_buf.append("lastEntry=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, lastEntry);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::PPPDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	staticData.toXmlString("staticData", _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "lastEntry", lastEntry);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::PPPDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("staticData"))
		{
			if(!Atf::AtfTempl< PPPClient::publication::PppStaticLeaf >::FromXmlString(_value, staticData)) return false;
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lastEntry"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, lastEntry);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::PPPDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PPPDataStruct())) // not empty
	{
		staticData.composeMsg(_body, _ignoreJSON);
		_body.composeINT64(buyIn);
		_body.composeSrvTime(lastEntry);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::PPPDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	_parser0.parseINT64(buyIn);
	_parser0.parseSrvTime(lastEntry);
}

const char *MLobbyNG::cli::PPPDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("staticData", staticData);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("lastEntry", lastEntry);
	return _buf.c_str();
}

void MLobbyNG::cli::PPPDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("staticData", staticData);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("lastEntry", lastEntry);
}

/* static */ void MLobbyNG::cli::PPPDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PPPClient::publication::PppStaticLeaf staticData; _jparser.validateByNameThrow("staticData", staticData);
	INT64 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	SrvTime lastEntry; _jparser.validateByNameThrow("lastEntry", lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::PPPDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	PPPClient::publication::PppStaticLeaf::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	INT64 buyIn; _parser0.parseINT64(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	SrvTime lastEntry; _parser0.parseSrvTime(lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableSelectionFilter
//=================================================================

MLobbyNG::cli::TableSelectionFilter::TableSelectionFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TableSelectionFilter::TableSelectionFilter(TableSelectionFilter&& _o)
	: locale(std::move(_o.locale))
	, gameMask(std::move(_o.gameMask))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, minStake(std::move(_o.minStake))
	, maxStake(std::move(_o.maxStake))
	, currencyMask(std::move(_o.currencyMask))
	, tableSizeMask(std::move(_o.tableSizeMask))
	, country(std::move(_o.country))
	, gameCategoryMask(std::move(_o.gameCategoryMask))
	, capMask(std::move(_o.capMask))
	, anteMask(std::move(_o.anteMask))
	, minDeepRatio(std::move(_o.minDeepRatio))
	, maxDeepRatio(std::move(_o.maxDeepRatio))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, variantMask(std::move(_o.variantMask))
{
}

MLobbyNG::cli::TableSelectionFilter& MLobbyNG::cli::TableSelectionFilter::operator=(TableSelectionFilter&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		gameMask = std::move(_o.gameMask);
		isPlayMoney = std::move(_o.isPlayMoney);
		minStake = std::move(_o.minStake);
		maxStake = std::move(_o.maxStake);
		currencyMask = std::move(_o.currencyMask);
		tableSizeMask = std::move(_o.tableSizeMask);
		country = std::move(_o.country);
		gameCategoryMask = std::move(_o.gameCategoryMask);
		capMask = std::move(_o.capMask);
		anteMask = std::move(_o.anteMask);
		minDeepRatio = std::move(_o.minDeepRatio);
		maxDeepRatio = std::move(_o.maxDeepRatio);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		variantMask = std::move(_o.variantMask);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TableSelectionFilter::clear()
{
	locale = 0;
	gameMask = 0;
	isPlayMoney = false;
	minStake = 0;
	maxStake = 0;
	currencyMask = 0;
	tableSizeMask = 0;
	country.clear();
	gameCategoryMask = 0;
	capMask = 0;
	anteMask = 0;
	minDeepRatio = 0;
	maxDeepRatio = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	variantMask = NGTableVariant_Regular;
}

bool MLobbyNG::cli::TableSelectionFilter::equals(const TableSelectionFilter& _o) const
{
	return locale == _o.locale &&
		gameMask == _o.gameMask &&
		isPlayMoney == _o.isPlayMoney &&
		minStake == _o.minStake &&
		maxStake == _o.maxStake &&
		currencyMask == _o.currencyMask &&
		tableSizeMask == _o.tableSizeMask &&
		Atf::atfPStringEquals(country, _o.country) &&
		gameCategoryMask == _o.gameCategoryMask &&
		capMask == _o.capMask &&
		anteMask == _o.anteMask &&
		minDeepRatio == _o.minDeepRatio &&
		maxDeepRatio == _o.maxDeepRatio &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		variantMask == _o.variantMask;
}

const char *MLobbyNG::cli::TableSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("minStake=");
	_buf.appendInt64(minStake);
	_buf.append(',');
	_buf.append("maxStake=");
	_buf.appendInt64(maxStake);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("tableSizeMask=");
	_buf.appendUint(tableSizeMask);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("gameCategoryMask=");
	_buf.appendUint(gameCategoryMask);
	_buf.append(',');
	_buf.append("capMask=");
	_buf.appendUint(capMask);
	_buf.append(',');
	_buf.append("anteMask=");
	_buf.appendUint(anteMask);
	_buf.append(',');
	_buf.append("minDeepRatio=");
	_buf.appendInt(minDeepRatio);
	_buf.append(',');
	_buf.append("maxDeepRatio=");
	_buf.appendInt(maxDeepRatio);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendInt64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt64(maxBuyIn);
	_buf.append(',');
	_buf.append("variantMask=");
	_buf.appendUint(variantMask);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::TableSelectionFilter::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameMask", gameMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("minStake", minStake, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxStake", maxStake, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyMask", currencyMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableSizeMask", tableSizeMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameCategoryMask", gameCategoryMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("capMask", capMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("anteMask", anteMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("minDeepRatio", minDeepRatio, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxDeepRatio", maxDeepRatio, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("variantMask", variantMask, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::TableSelectionFilter::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("locale"))
		{
			locale = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameMask"))
		{
			gameMask = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("minStake"))
		{
			minStake = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxStake"))
		{
			maxStake = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currencyMask"))
		{
			currencyMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableSizeMask"))
		{
			tableSizeMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("gameCategoryMask"))
		{
			gameCategoryMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("capMask"))
		{
			capMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("anteMask"))
		{
			anteMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minDeepRatio"))
		{
			minDeepRatio = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxDeepRatio"))
		{
			maxDeepRatio = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minBuyIn"))
		{
			minBuyIn = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("variantMask"))
		{
			variantMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::TableSelectionFilter::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TableSelectionFilter())) // not empty
	{
		_body.composeUINT32(locale);
		_body.composeUINT64(gameMask);
		_body.composeBOOL(isPlayMoney);
		_body.composeINT64(minStake);
		_body.composeINT64(maxStake);
		_body.composeUINT32(currencyMask);
		_body.composeUINT32(tableSizeMask);
		_body.composeString(country);
		_body.composeUINT32(gameCategoryMask);
		_body.composeUINT32(capMask);
		_body.composeUINT32(anteMask);
		_body.composeINT32(minDeepRatio);
		_body.composeINT32(maxDeepRatio);
		_body.composeINT64(minBuyIn);
		_body.composeINT64(maxBuyIn);
		_body.composeUINT32(variantMask);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TableSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	_parser0.parseUINT64(gameMask);
	_parser0.parseBOOL(isPlayMoney);
	_parser0.parseINT64(minStake);
	_parser0.parseINT64(maxStake);
	_parser0.parseUINT32(currencyMask);
	_parser0.parseUINT32(tableSizeMask);
	_parser0.parseStringP(country);
	_parser0.parseUINT32(gameCategoryMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(capMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(anteMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(minDeepRatio);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(maxDeepRatio);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT64(minBuyIn);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT64(maxBuyIn);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(variantMask);
}

const char *MLobbyNG::cli::TableSelectionFilter::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("gameMask", gameMask);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("minStake", minStake);
	_jsonstr.compose("maxStake", maxStake);
	_jsonstr.compose("currencyMask", currencyMask);
	_jsonstr.compose("tableSizeMask", tableSizeMask);
	_jsonstr.compose("country", country);
	_jsonstr.compose("gameCategoryMask", gameCategoryMask);
	_jsonstr.compose("capMask", capMask);
	_jsonstr.compose("anteMask", anteMask);
	_jsonstr.compose("minDeepRatio", minDeepRatio);
	_jsonstr.compose("maxDeepRatio", maxDeepRatio);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("variantMask", variantMask);
	return _buf.c_str();
}

void MLobbyNG::cli::TableSelectionFilter::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("gameMask", gameMask);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("minStake", minStake);
	_jparser.parseByNameThrow("maxStake", maxStake);
	_jparser.parseByNameThrow("currencyMask", currencyMask);
	_jparser.parseByNameThrow("tableSizeMask", tableSizeMask);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("gameCategoryMask", gameCategoryMask);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("capMask", capMask);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("anteMask", anteMask);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("minDeepRatio", minDeepRatio);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("maxDeepRatio", maxDeepRatio);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("variantMask", variantMask);
}

/* static */ void MLobbyNG::cli::TableSelectionFilter::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT64 gameMask; _jparser.validateByNameThrow("gameMask", gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	INT64 minStake; _jparser.validateByNameThrow("minStake", minStake);
	AtfValidator::validateIntMax(_descr, "minStake", minStake, 2000000000, _checker, __FILE__, __LINE__);
	INT64 maxStake; _jparser.validateByNameThrow("maxStake", maxStake);
	AtfValidator::validateIntMax(_descr, "maxStake", maxStake, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _jparser.validateByNameThrow("currencyMask", currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*NGCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tableSizeMask; _jparser.validateByNameThrow("tableSizeMask", tableSizeMask);
	AtfValidator::validateIntMax(_descr, "tableSizeMask", tableSizeMask, (2*NGMaxTableSize_Last-1), _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), 3, _checker, __FILE__, __LINE__);
	UINT32 gameCategoryMask; _jparser.validateByNameThrow("gameCategoryMask", gameCategoryMask);
	AtfValidator::validateIntMax(_descr, "gameCategoryMask", gameCategoryMask, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 capMask; _jparser.validateByNameThrow("capMask", capMask);
	AtfValidator::validateIntMax(_descr, "capMask", capMask, (2*NGTableHasCap_Last-1), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 anteMask; _jparser.validateByNameThrow("anteMask", anteMask);
	AtfValidator::validateIntMax(_descr, "anteMask", anteMask, (2*NGTableHasAnte_Last-1), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 minDeepRatio; _jparser.validateByNameThrow("minDeepRatio", minDeepRatio);
	AtfValidator::validateIntMax(_descr, "minDeepRatio", minDeepRatio, 2000000000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 maxDeepRatio; _jparser.validateByNameThrow("maxDeepRatio", maxDeepRatio);
	AtfValidator::validateIntMax(_descr, "maxDeepRatio", maxDeepRatio, 2000000000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT64 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT64 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 variantMask; _jparser.validateByNameThrow("variantMask", variantMask);
	AtfValidator::validateIntMax(_descr, "variantMask", variantMask, (2*NGTableVariant_Last-1), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::TableSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser0.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	INT64 minStake; _parser0.parseINT64(minStake);
	AtfValidator::validateIntMax(_descr, "minStake", minStake, 2000000000, _checker, __FILE__, __LINE__);
	INT64 maxStake; _parser0.parseINT64(maxStake);
	AtfValidator::validateIntMax(_descr, "maxStake", maxStake, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _parser0.parseUINT32(currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*NGCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tableSizeMask; _parser0.parseUINT32(tableSizeMask);
	AtfValidator::validateIntMax(_descr, "tableSizeMask", tableSizeMask, (2*NGMaxTableSize_Last-1), _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	UINT32 gameCategoryMask; _parser0.parseUINT32(gameCategoryMask);
	AtfValidator::validateIntMax(_descr, "gameCategoryMask", gameCategoryMask, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 capMask; _parser0.parseUINT32(capMask);
	AtfValidator::validateIntMax(_descr, "capMask", capMask, (2*NGTableHasCap_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 anteMask; _parser0.parseUINT32(anteMask);
	AtfValidator::validateIntMax(_descr, "anteMask", anteMask, (2*NGTableHasAnte_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 minDeepRatio; _parser0.parseINT32(minDeepRatio);
	AtfValidator::validateIntMax(_descr, "minDeepRatio", minDeepRatio, 2000000000, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 maxDeepRatio; _parser0.parseINT32(maxDeepRatio);
	AtfValidator::validateIntMax(_descr, "maxDeepRatio", maxDeepRatio, 2000000000, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT64 minBuyIn; _parser0.parseINT64(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT64 maxBuyIn; _parser0.parseINT64(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 variantMask; _parser0.parseUINT32(variantMask);
	AtfValidator::validateIntMax(_descr, "variantMask", variantMask, (2*NGTableVariant_Last-1), _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableResultCriteria
//=================================================================

MLobbyNG::cli::TableResultCriteria::TableResultCriteria()
{
	clear();
}

void MLobbyNG::cli::TableResultCriteria::clear()
{
	sortOrder = 0;
	maxItems = 0;
}

bool MLobbyNG::cli::TableResultCriteria::equals(const TableResultCriteria& _o) const
{
	return sortOrder == _o.sortOrder &&
		maxItems == _o.maxItems;
}

const char *MLobbyNG::cli::TableResultCriteria::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sortOrder=");
	_buf.appendUint(sortOrder);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::TableResultCriteria::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("sortOrder", sortOrder, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxItems", maxItems, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::TableResultCriteria::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("sortOrder"))
		{
			sortOrder = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxItems"))
		{
			maxItems = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::TableResultCriteria::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TableResultCriteria())) // not empty
	{
		_body.composeUINT32(sortOrder);
		_body.composeUINT32(maxItems);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TableResultCriteria::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(sortOrder);
	_parser0.parseUINT32(maxItems);
}

const char *MLobbyNG::cli::TableResultCriteria::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sortOrder", sortOrder);
	_jsonstr.compose("maxItems", maxItems);
	return _buf.c_str();
}

void MLobbyNG::cli::TableResultCriteria::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sortOrder", sortOrder);
	_jparser.parseByNameThrow("maxItems", maxItems);
}

/* static */ void MLobbyNG::cli::TableResultCriteria::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 sortOrder; _jparser.validateByNameThrow("sortOrder", sortOrder);
	AtfValidator::validateIntRange(_descr, "sortOrder", sortOrder, NGTableSort_StakesAsc, NGTableSort_Last, _checker, __FILE__, __LINE__);
	UINT32 maxItems; _jparser.validateByNameThrow("maxItems", maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::TableResultCriteria::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 sortOrder; _parser0.parseUINT32(sortOrder);
	AtfValidator::validateIntRange(_descr, "sortOrder", sortOrder, NGTableSort_StakesAsc, NGTableSort_Last, _checker, __FILE__, __LINE__);
	UINT32 maxItems; _parser0.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableDataStruct
//=================================================================

MLobbyNG::cli::TableDataStruct::TableDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TableDataStruct::TableDataStruct(TableDataStruct&& _o)
	: id(std::move(_o.id))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, maxPlayers(std::move(_o.maxPlayers))
	, visibilityMask(std::move(_o.visibilityMask))
	, structure(std::move(_o.structure))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, ante(std::move(_o.ante))
	, cap(std::move(_o.cap))
	, currency(std::move(_o.currency))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, countryRestrictionInverted(std::move(_o.countryRestrictionInverted))
	, restrictedCountries(std::move(_o.restrictedCountries))
	, visible(std::move(_o.visible))
	, scalePM(std::move(_o.scalePM))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, brandMask(std::move(_o.brandMask))
	, seatFinderId(std::move(_o.seatFinderId))
	, poolBlockMinHands(std::move(_o.poolBlockMinHands))
	, poolBlockTimePenalty(std::move(_o.poolBlockTimePenalty))
	, isPasswordProtected(std::move(_o.isPasswordProtected))
	, isMorphLobby(std::move(_o.isMorphLobby))
	, lastEntry(std::move(_o.lastEntry))
	, tableStakes(std::move(_o.tableStakes))
	, variableAntes(std::move(_o.variableAntes))
	, tableFlags(std::move(_o.tableFlags))
	, tableFlags2(std::move(_o.tableFlags2))
	, visibilityMaskEx(std::move(_o.visibilityMaskEx))
{
}

MLobbyNG::cli::TableDataStruct& MLobbyNG::cli::TableDataStruct::operator=(TableDataStruct&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		isPlayMoney = std::move(_o.isPlayMoney);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		maxPlayers = std::move(_o.maxPlayers);
		visibilityMask = std::move(_o.visibilityMask);
		structure = std::move(_o.structure);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		ante = std::move(_o.ante);
		cap = std::move(_o.cap);
		currency = std::move(_o.currency);
		minChipsLimit = std::move(_o.minChipsLimit);
		maxBuyIn = std::move(_o.maxBuyIn);
		countryRestrictionInverted = std::move(_o.countryRestrictionInverted);
		restrictedCountries = std::move(_o.restrictedCountries);
		visible = std::move(_o.visible);
		scalePM = std::move(_o.scalePM);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		brandMask = std::move(_o.brandMask);
		seatFinderId = std::move(_o.seatFinderId);
		poolBlockMinHands = std::move(_o.poolBlockMinHands);
		poolBlockTimePenalty = std::move(_o.poolBlockTimePenalty);
		isPasswordProtected = std::move(_o.isPasswordProtected);
		isMorphLobby = std::move(_o.isMorphLobby);
		lastEntry = std::move(_o.lastEntry);
		tableStakes = std::move(_o.tableStakes);
		variableAntes = std::move(_o.variableAntes);
		tableFlags = std::move(_o.tableFlags);
		tableFlags2 = std::move(_o.tableFlags2);
		visibilityMaskEx = std::move(_o.visibilityMaskEx);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TableDataStruct::clear()
{
	id = 0;
	isPlayMoney = 0;
	game = 0;
	isHiLo = 0;
	maxPlayers = 0;
	visibilityMask = 0;
	structure = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	visible = false;
	scalePM = 0;
	defaultBuyIn = 0;
	brandMask = 0;
	seatFinderId = 0;
	poolBlockMinHands = 0;
	poolBlockTimePenalty.clear();
	isPasswordProtected = false;
	isMorphLobby = false;
	lastEntry.setNull();
	tableStakes.clear();
	variableAntes.clear();
	tableFlags = 0;
	tableFlags2 = 0;
	visibilityMaskEx.clear();
}

bool MLobbyNG::cli::TableDataStruct::equals(const TableDataStruct& _o) const
{
	return id == _o.id &&
		isPlayMoney == _o.isPlayMoney &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		maxPlayers == _o.maxPlayers &&
		visibilityMask == _o.visibilityMask &&
		structure == _o.structure &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		visible == _o.visible &&
		scalePM == _o.scalePM &&
		defaultBuyIn == _o.defaultBuyIn &&
		brandMask == _o.brandMask &&
		seatFinderId == _o.seatFinderId &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		poolBlockTimePenalty.equals(_o.poolBlockTimePenalty) &&
		isPasswordProtected == _o.isPasswordProtected &&
		isMorphLobby == _o.isMorphLobby &&
		lastEntry.equals(_o.lastEntry) &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		tableFlags == _o.tableFlags &&
		tableFlags2 == _o.tableFlags2 &&
		visibilityMaskEx.equals(_o.visibilityMaskEx);
}

const char *MLobbyNG::cli::TableDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendUint(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visible=");
	_buf.appendUint(visible);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendUint(defaultBuyIn);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("seatFinderId=");
	_buf.appendUint(seatFinderId);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("poolBlockTimePenalty=");
	poolBlockTimePenalty.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isPasswordProtected=");
	_buf.appendUint(isPasswordProtected);
	_buf.append(',');
	_buf.append("isMorphLobby=");
	_buf.appendUint(isMorphLobby);
	_buf.append(',');
	_buf.append("lastEntry=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, lastEntry);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::TableDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("visibilityMask", visibilityMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("cap", cap, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("minChipsLimit", minChipsLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryRestrictionInverted", countryRestrictionInverted, _buf);
	restrictedCountries.toXmlString("restrictedCountries", _buf);
	Atf::XmlElement::encodeAsXmlElement("visible", visible, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("defaultBuyIn", defaultBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandMask", brandMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("seatFinderId", seatFinderId, _buf);
	Atf::XmlElement::encodeAsXmlElement("poolBlockMinHands", poolBlockMinHands, _buf);
	poolBlockTimePenalty.toXmlString("poolBlockTimePenalty", _buf);
	Atf::XmlElement::encodeAsXmlElement("isPasswordProtected", isPasswordProtected, _buf);
	Atf::XmlElement::encodeAsXmlElement("isMorphLobby", isMorphLobby, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "lastEntry", lastEntry);
	tableStakes.toXmlString("tableStakes", _buf);
	variableAntes.toXmlString("variableAntes", _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags", tableFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags2", tableFlags2, _buf);
	visibilityMaskEx.toXmlString("visibilityMaskEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::TableDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("id"))
		{
			id = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayers"))
		{
			maxPlayers = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("visibilityMask"))
		{
			visibilityMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("loBet"))
		{
			loBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cap"))
		{
			cap = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("minChipsLimit"))
		{
			minChipsLimit = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("countryRestrictionInverted"))
		{
			countryRestrictionInverted = (*_value.ptr() == '1');
		}
		else if (_element.equals("restrictedCountries"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, restrictedCountries)) return false;
		}
		else if (_element.equals("visible"))
		{
			visible = (*_value.ptr() == '1');
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("defaultBuyIn"))
		{
			defaultBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandMask"))
		{
			brandMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("seatFinderId"))
		{
			seatFinderId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("poolBlockMinHands"))
		{
			poolBlockMinHands = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("poolBlockTimePenalty"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, poolBlockTimePenalty)) return false;
		}
		else if (_element.equals("isPasswordProtected"))
		{
			isPasswordProtected = (*_value.ptr() == '1');
		}
		else if (_element.equals("isMorphLobby"))
		{
			isMorphLobby = (*_value.ptr() == '1');
		}
		else if (_element.equals("lastEntry"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, lastEntry);
		}
		else if (_element.equals("tableStakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
		}
		else if (_element.equals("variableAntes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64, 4 > >::FromXmlString(_value, variableAntes)) return false;
		}
		else if (_element.equals("tableFlags"))
		{
			tableFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableFlags2"))
		{
			tableFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("visibilityMaskEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, visibilityMaskEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::TableDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TableDataStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeBYTE(isPlayMoney);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(maxPlayers);
		_body.composeUINT32(visibilityMask);
		_body.composeBYTE(structure);
		_body.composeUINT32(loBet);
		_body.composeUINT32(hiBet);
		_body.composeUINT32(ante);
		_body.composeUINT32(cap);
		_body.composeString(currency);
		_body.composeUINT32(minChipsLimit);
		_body.composeUINT32(maxBuyIn);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body, _ignoreJSON);
		_body.composeBOOL(visible);
		_body.composeUINT32(scalePM);
		_body.composeUINT32(defaultBuyIn);
		_body.composeUINT32(brandMask);
		_body.composeUINT32(seatFinderId);
		_body.composeINT32(poolBlockMinHands);
		poolBlockTimePenalty.composeMsg(_body, _ignoreJSON);
		_body.composeBOOL(isPasswordProtected);
		_body.composeBOOL(isMorphLobby);
		_body.composeSrvTime(lastEntry);
		tableStakes.composeMsg(_body, _ignoreJSON);
		variableAntes.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(tableFlags);
		_body.composeUINT64(tableFlags2);
		visibilityMaskEx.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TableDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(maxPlayers);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseBYTE(structure);
	_parser0.parseUINT32(loBet);
	_parser0.parseUINT32(hiBet);
	_parser0.parseUINT32(ante);
	_parser0.parseUINT32(cap);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(minChipsLimit);
	_parser0.parseUINT32(maxBuyIn);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseBOOL(visible);
	_parser0.parseUINT32(scalePM);
	_parser0.parseUINT32(defaultBuyIn);
	_parser0.parseUINT32(brandMask);
	_parser0.parseUINT32(seatFinderId);
	_parser0.parseINT32(poolBlockMinHands);
	poolBlockTimePenalty.parseMsg(_parser0);
	_parser0.parseBOOL(isPasswordProtected);
	_parser0.parseBOOL(isMorphLobby);
	_parser0.parseSrvTime(lastEntry);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	variableAntes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(tableFlags);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT64(tableFlags2);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
}

const char *MLobbyNG::cli::TableDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("visibilityMask", visibilityMask);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("cap", cap);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("minChipsLimit", minChipsLimit);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("countryRestrictionInverted", countryRestrictionInverted);
	_jsonstr.compose("restrictedCountries", restrictedCountries);
	_jsonstr.compose("visible", visible);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("defaultBuyIn", defaultBuyIn);
	_jsonstr.compose("brandMask", brandMask);
	_jsonstr.compose("seatFinderId", seatFinderId);
	_jsonstr.compose("poolBlockMinHands", poolBlockMinHands);
	_jsonstr.compose("poolBlockTimePenalty", poolBlockTimePenalty);
	_jsonstr.compose("isPasswordProtected", isPasswordProtected);
	_jsonstr.compose("isMorphLobby", isMorphLobby);
	_jsonstr.compose("lastEntry", lastEntry);
	_jsonstr.compose("tableStakes", tableStakes);
	_jsonstr.compose("variableAntes", variableAntes);
	_jsonstr.compose("tableFlags", tableFlags);
	_jsonstr.compose("tableFlags2", tableFlags2);
	_jsonstr.compose("visibilityMaskEx", visibilityMaskEx);
	return _buf.c_str();
}

void MLobbyNG::cli::TableDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("visibilityMask", visibilityMask);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("cap", cap);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("minChipsLimit", minChipsLimit);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	_jparser.parseByNameThrow("restrictedCountries", restrictedCountries);
	_jparser.parseByNameThrow("visible", visible);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("defaultBuyIn", defaultBuyIn);
	_jparser.parseByNameThrow("brandMask", brandMask);
	_jparser.parseByNameThrow("seatFinderId", seatFinderId);
	_jparser.parseByNameThrow("poolBlockMinHands", poolBlockMinHands);
	_jparser.parseByNameThrow("poolBlockTimePenalty", poolBlockTimePenalty);
	_jparser.parseByNameThrow("isPasswordProtected", isPasswordProtected);
	_jparser.parseByNameThrow("isMorphLobby", isMorphLobby);
	_jparser.parseByNameThrow("lastEntry", lastEntry);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("variableAntes", variableAntes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableFlags", tableFlags);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableFlags2", tableFlags2);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("visibilityMaskEx", visibilityMaskEx);
}

/* static */ void MLobbyNG::cli::TableDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _jparser.validateByNameThrow("visibilityMask", visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 cap; _jparser.validateByNameThrow("cap", cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _jparser.validateByNameThrow("minChipsLimit", minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _jparser.validateByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > restrictedCountries; _jparser.validateByNameThrow("restrictedCountries", restrictedCountries);
	AtfValidator::validateInt(_descr, "restrictedCountries", restrictedCountries.size(), _checker, __FILE__, __LINE__);
	bool visible; _jparser.validateByNameThrow("visible", visible);
	AtfValidator::validateInt(_descr, "visible", visible, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _jparser.validateByNameThrow("defaultBuyIn", defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _jparser.validateByNameThrow("brandMask", brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	UINT32 seatFinderId; _jparser.validateByNameThrow("seatFinderId", seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _jparser.validateByNameThrow("poolBlockMinHands", poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > poolBlockTimePenalty; _jparser.validateByNameThrow("poolBlockTimePenalty", poolBlockTimePenalty);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", poolBlockTimePenalty.size(), _checker, __FILE__, __LINE__);
	bool isPasswordProtected; _jparser.validateByNameThrow("isPasswordProtected", isPasswordProtected);
	AtfValidator::validateInt(_descr, "isPasswordProtected", isPasswordProtected, _checker, __FILE__, __LINE__);
	bool isMorphLobby; _jparser.validateByNameThrow("isMorphLobby", isMorphLobby);
	AtfValidator::validateInt(_descr, "isMorphLobby", isMorphLobby, _checker, __FILE__, __LINE__);
	SrvTime lastEntry; _jparser.validateByNameThrow("lastEntry", lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< INT64 > variableAntes; _jparser.validateByNameThrow("variableAntes", variableAntes);
	AtfValidator::validateInt(_descr, "variableAntes", variableAntes.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 tableFlags; _jparser.validateByNameThrow("tableFlags", tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 tableFlags2; _jparser.validateByNameThrow("tableFlags2", tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask visibilityMaskEx; _jparser.validateByNameThrow("visibilityMaskEx", visibilityMaskEx);
}

/*static*/ void MLobbyNG::cli::TableDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _parser0.parseBYTE(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser0.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser0.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser0.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 cap; _parser0.parseUINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _parser0.parseUINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser0.parseUINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = Atf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	bool visible; _parser0.parseBOOL(visible);
	AtfValidator::validateInt(_descr, "visible", visible, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _parser0.parseUINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser0.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	UINT32 seatFinderId; _parser0.parseUINT32(seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser0.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	int szPoolBlockTimePenalty = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("poolBlockTimePenalty"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", szPoolBlockTimePenalty, _checker, __FILE__, __LINE__);
	bool isPasswordProtected; _parser0.parseBOOL(isPasswordProtected);
	AtfValidator::validateInt(_descr, "isPasswordProtected", isPasswordProtected, _checker, __FILE__, __LINE__);
	bool isMorphLobby; _parser0.parseBOOL(isMorphLobby);
	AtfValidator::validateInt(_descr, "isMorphLobby", isMorphLobby, _checker, __FILE__, __LINE__);
	SrvTime lastEntry; _parser0.parseSrvTime(lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	TableCommon::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	int szVariableAntes = Atf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 tableFlags; _parser0.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT64 tableFlags2; _parser0.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ZoomStaticDataStruct
//=================================================================

MLobbyNG::cli::ZoomStaticDataStruct::ZoomStaticDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::ZoomStaticDataStruct::ZoomStaticDataStruct(ZoomStaticDataStruct&& _o)
	: id(std::move(_o.id))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, maxPlayersPerTable(std::move(_o.maxPlayersPerTable))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, ante(std::move(_o.ante))
	, cap(std::move(_o.cap))
	, currency(std::move(_o.currency))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, visibilityMask(std::move(_o.visibilityMask))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, specialName(std::move(_o.specialName))
	, countryRestrictionInverted(std::move(_o.countryRestrictionInverted))
	, restrictedCountries(std::move(_o.restrictedCountries))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, isMorphLobby(std::move(_o.isMorphLobby))
	, scalePM(std::move(_o.scalePM))
	, server(std::move(_o.server))
	, name(std::move(_o.name))
	, replayerInstance(std::move(_o.replayerInstance))
	, isOneOnOne(std::move(_o.isOneOnOne))
	, tableFlags(std::move(_o.tableFlags))
	, chatLang(std::move(_o.chatLang))
	, quickLobbyVisible(std::move(_o.quickLobbyVisible))
	, blitzFlags(std::move(_o.blitzFlags))
	, brandMask(std::move(_o.brandMask))
	, serverObj(std::move(_o.serverObj))
	, tableStakes(std::move(_o.tableStakes))
	, visibilityMaskEx(std::move(_o.visibilityMaskEx))
	, tableFlags2(std::move(_o.tableFlags2))
{
}

MLobbyNG::cli::ZoomStaticDataStruct& MLobbyNG::cli::ZoomStaticDataStruct::operator=(ZoomStaticDataStruct&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		maxPlayersPerTable = std::move(_o.maxPlayersPerTable);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		ante = std::move(_o.ante);
		cap = std::move(_o.cap);
		currency = std::move(_o.currency);
		minChipsLimit = std::move(_o.minChipsLimit);
		maxBuyIn = std::move(_o.maxBuyIn);
		visibilityMask = std::move(_o.visibilityMask);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		specialName = std::move(_o.specialName);
		countryRestrictionInverted = std::move(_o.countryRestrictionInverted);
		restrictedCountries = std::move(_o.restrictedCountries);
		isPlayMoney = std::move(_o.isPlayMoney);
		isMorphLobby = std::move(_o.isMorphLobby);
		scalePM = std::move(_o.scalePM);
		server = std::move(_o.server);
		name = std::move(_o.name);
		replayerInstance = std::move(_o.replayerInstance);
		isOneOnOne = std::move(_o.isOneOnOne);
		tableFlags = std::move(_o.tableFlags);
		chatLang = std::move(_o.chatLang);
		quickLobbyVisible = std::move(_o.quickLobbyVisible);
		blitzFlags = std::move(_o.blitzFlags);
		brandMask = std::move(_o.brandMask);
		serverObj = std::move(_o.serverObj);
		tableStakes = std::move(_o.tableStakes);
		visibilityMaskEx = std::move(_o.visibilityMaskEx);
		tableFlags2 = std::move(_o.tableFlags2);
	}
	return *this;
}

#endif

void MLobbyNG::cli::ZoomStaticDataStruct::clear()
{
	id = 0;
	game = 0;
	structure = 0;
	isHiLo = 0;
	maxPlayersPerTable = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	visibilityMask = 0;
	defaultBuyIn = 0;
	specialName.clear();
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	isPlayMoney = 0;
	isMorphLobby = false;
	scalePM = 0;
	server.clear();
	name.clear();
	replayerInstance.clear();
	isOneOnOne = 0;
	tableFlags = 0;
	chatLang = 0;
	quickLobbyVisible = false;
	blitzFlags = 0;
	brandMask = 0;
	serverObj.clear();
	tableStakes.clear();
	visibilityMaskEx.clear();
	tableFlags2 = 0;
}

bool MLobbyNG::cli::ZoomStaticDataStruct::equals(const ZoomStaticDataStruct& _o) const
{
	return id == _o.id &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		maxPlayersPerTable == _o.maxPlayersPerTable &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		visibilityMask == _o.visibilityMask &&
		defaultBuyIn == _o.defaultBuyIn &&
		Atf::atfPStringEquals(specialName, _o.specialName) &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		isPlayMoney == _o.isPlayMoney &&
		isMorphLobby == _o.isMorphLobby &&
		scalePM == _o.scalePM &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(replayerInstance, _o.replayerInstance) &&
		isOneOnOne == _o.isOneOnOne &&
		tableFlags == _o.tableFlags &&
		chatLang == _o.chatLang &&
		quickLobbyVisible == _o.quickLobbyVisible &&
		blitzFlags == _o.blitzFlags &&
		brandMask == _o.brandMask &&
		Atf::atfPStringEquals(serverObj, _o.serverObj) &&
		tableStakes.equals(_o.tableStakes) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx) &&
		tableFlags2 == _o.tableFlags2;
}

const char *MLobbyNG::cli::ZoomStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayersPerTable=");
	_buf.appendUint(maxPlayersPerTable);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendInt(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendInt(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendInt(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendInt(cap);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendInt(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt(maxBuyIn);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendInt(defaultBuyIn);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("isMorphLobby=");
	_buf.appendUint(isMorphLobby);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("replayerInstance=");
	_buf.append(replayerInstance);
	_buf.append(',');
	_buf.append("isOneOnOne=");
	_buf.appendUint(isOneOnOne);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("quickLobbyVisible=");
	_buf.appendUint(quickLobbyVisible);
	_buf.append(',');
	_buf.append("blitzFlags=");
	_buf.appendUint(blitzFlags);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::ZoomStaticDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayersPerTable", maxPlayersPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("cap", cap, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("minChipsLimit", minChipsLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("visibilityMask", visibilityMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("defaultBuyIn", defaultBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("specialName", specialName, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryRestrictionInverted", countryRestrictionInverted, _buf);
	restrictedCountries.toXmlString("restrictedCountries", _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("isMorphLobby", isMorphLobby, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("replayerInstance", replayerInstance, _buf);
	Atf::XmlElement::encodeAsXmlElement("isOneOnOne", isOneOnOne, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags", tableFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("chatLang", chatLang, _buf);
	Atf::XmlElement::encodeAsXmlElement("quickLobbyVisible", quickLobbyVisible, _buf);
	Atf::XmlElement::encodeAsXmlElement("blitzFlags", blitzFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandMask", brandMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObj", serverObj, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	visibilityMaskEx.toXmlString("visibilityMaskEx", _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags2", tableFlags2, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::ZoomStaticDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("id"))
		{
			id = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayersPerTable"))
		{
			maxPlayersPerTable = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("loBet"))
		{
			loBet = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cap"))
		{
			cap = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("minChipsLimit"))
		{
			minChipsLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("visibilityMask"))
		{
			visibilityMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("defaultBuyIn"))
		{
			defaultBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("specialName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, specialName)) return false;
		}
		else if (_element.equals("countryRestrictionInverted"))
		{
			countryRestrictionInverted = (*_value.ptr() == '1');
		}
		else if (_element.equals("restrictedCountries"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, restrictedCountries)) return false;
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isMorphLobby"))
		{
			isMorphLobby = (*_value.ptr() == '1');
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("replayerInstance"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, replayerInstance)) return false;
		}
		else if (_element.equals("isOneOnOne"))
		{
			isOneOnOne = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableFlags"))
		{
			tableFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chatLang"))
		{
			chatLang = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("quickLobbyVisible"))
		{
			quickLobbyVisible = (*_value.ptr() == '1');
		}
		else if (_element.equals("blitzFlags"))
		{
			blitzFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandMask"))
		{
			brandMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("serverObj"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObj)) return false;
		}
		else if (_element.equals("tableStakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
		}
		else if (_element.equals("visibilityMaskEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, visibilityMaskEx)) return false;
		}
		else if (_element.equals("tableFlags2"))
		{
			tableFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::ZoomStaticDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ZoomStaticDataStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeBYTE(game);
		_body.composeBYTE(structure);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(maxPlayersPerTable);
		_body.composeINT32(loBet);
		_body.composeINT32(hiBet);
		_body.composeINT32(ante);
		_body.composeINT32(cap);
		_body.composeString(currency);
		_body.composeINT32(minChipsLimit);
		_body.composeINT32(maxBuyIn);
		_body.composeUINT32(visibilityMask);
		_body.composeINT32(defaultBuyIn);
		_body.composeString(specialName);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body, _ignoreJSON);
		_body.composeBYTE(isPlayMoney);
		_body.composeBOOL(isMorphLobby);
		_body.composeUINT32(scalePM);
		_body.composeString(server);
		_body.composeString(name);
		_body.composeString(replayerInstance);
		_body.composeBYTE(isOneOnOne);
		_body.composeUINT32(tableFlags);
		_body.composeUINT16(chatLang);
		_body.composeBOOL(quickLobbyVisible);
		_body.composeUINT32(blitzFlags);
		_body.composeUINT32(brandMask);
		_body.composeString(serverObj);
		tableStakes.composeMsg(_body, _ignoreJSON);
		visibilityMaskEx.composeMsg(_body, _ignoreJSON);
		_body.composeUINT64(tableFlags2);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::ZoomStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(maxPlayersPerTable);
	_parser0.parseINT32(loBet);
	_parser0.parseINT32(hiBet);
	_parser0.parseINT32(ante);
	_parser0.parseINT32(cap);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(minChipsLimit);
	_parser0.parseINT32(maxBuyIn);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseINT32(defaultBuyIn);
	_parser0.parseStringP(specialName);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseBOOL(isMorphLobby);
	_parser0.parseUINT32(scalePM);
	_parser0.parseStringP(server);
	_parser0.parseStringP(name);
	_parser0.parseStringP(replayerInstance);
	_parser0.parseBYTE(isOneOnOne);
	_parser0.parseUINT32(tableFlags);
	_parser0.parseUINT16(chatLang);
	_parser0.parseBOOL(quickLobbyVisible);
	_parser0.parseUINT32(blitzFlags);
	_parser0.parseUINT32(brandMask);
	_parser0.parseStringP(serverObj);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT64(tableFlags2);
}

const char *MLobbyNG::cli::ZoomStaticDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("game", game);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("maxPlayersPerTable", maxPlayersPerTable);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("cap", cap);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("minChipsLimit", minChipsLimit);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("visibilityMask", visibilityMask);
	_jsonstr.compose("defaultBuyIn", defaultBuyIn);
	_jsonstr.compose("specialName", specialName);
	_jsonstr.compose("countryRestrictionInverted", countryRestrictionInverted);
	_jsonstr.compose("restrictedCountries", restrictedCountries);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("isMorphLobby", isMorphLobby);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("server", server);
	_jsonstr.compose("name", name);
	_jsonstr.compose("replayerInstance", replayerInstance);
	_jsonstr.compose("isOneOnOne", isOneOnOne);
	_jsonstr.compose("tableFlags", tableFlags);
	_jsonstr.compose("chatLang", chatLang);
	_jsonstr.compose("quickLobbyVisible", quickLobbyVisible);
	_jsonstr.compose("blitzFlags", blitzFlags);
	_jsonstr.compose("brandMask", brandMask);
	_jsonstr.compose("serverObj", serverObj);
	_jsonstr.compose("tableStakes", tableStakes);
	_jsonstr.compose("visibilityMaskEx", visibilityMaskEx);
	_jsonstr.compose("tableFlags2", tableFlags2);
	return _buf.c_str();
}

void MLobbyNG::cli::ZoomStaticDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("maxPlayersPerTable", maxPlayersPerTable);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("cap", cap);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("minChipsLimit", minChipsLimit);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("visibilityMask", visibilityMask);
	_jparser.parseByNameThrow("defaultBuyIn", defaultBuyIn);
	_jparser.parseByNameThrow("specialName", specialName);
	_jparser.parseByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	_jparser.parseByNameThrow("restrictedCountries", restrictedCountries);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("isMorphLobby", isMorphLobby);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("replayerInstance", replayerInstance);
	_jparser.parseByNameThrow("isOneOnOne", isOneOnOne);
	_jparser.parseByNameThrow("tableFlags", tableFlags);
	_jparser.parseByNameThrow("chatLang", chatLang);
	_jparser.parseByNameThrow("quickLobbyVisible", quickLobbyVisible);
	_jparser.parseByNameThrow("blitzFlags", blitzFlags);
	_jparser.parseByNameThrow("brandMask", brandMask);
	_jparser.parseByNameThrow("serverObj", serverObj);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("visibilityMaskEx", visibilityMaskEx);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableFlags2", tableFlags2);
}

/* static */ void MLobbyNG::cli::ZoomStaticDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayersPerTable; _jparser.validateByNameThrow("maxPlayersPerTable", maxPlayersPerTable);
	AtfValidator::validateInt(_descr, "maxPlayersPerTable", maxPlayersPerTable, _checker, __FILE__, __LINE__);
	INT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT32 cap; _jparser.validateByNameThrow("cap", cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _jparser.validateByNameThrow("minChipsLimit", minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _jparser.validateByNameThrow("visibilityMask", visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	INT32 defaultBuyIn; _jparser.validateByNameThrow("defaultBuyIn", defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	PString specialName; _jparser.validateByNameThrow("specialName", specialName);
	AtfValidator::validateInt(_descr, "specialName", specialName.length(), _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _jparser.validateByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > restrictedCountries; _jparser.validateByNameThrow("restrictedCountries", restrictedCountries);
	AtfValidator::validateInt(_descr, "restrictedCountries", restrictedCountries.size(), _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	bool isMorphLobby; _jparser.validateByNameThrow("isMorphLobby", isMorphLobby);
	AtfValidator::validateInt(_descr, "isMorphLobby", isMorphLobby, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString replayerInstance; _jparser.validateByNameThrow("replayerInstance", replayerInstance);
	AtfValidator::validateInt(_descr, "replayerInstance", replayerInstance.length(), _checker, __FILE__, __LINE__);
	BYTE isOneOnOne; _jparser.validateByNameThrow("isOneOnOne", isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _jparser.validateByNameThrow("tableFlags", tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _jparser.validateByNameThrow("chatLang", chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	bool quickLobbyVisible; _jparser.validateByNameThrow("quickLobbyVisible", quickLobbyVisible);
	AtfValidator::validateInt(_descr, "quickLobbyVisible", quickLobbyVisible, _checker, __FILE__, __LINE__);
	UINT32 blitzFlags; _jparser.validateByNameThrow("blitzFlags", blitzFlags);
	AtfValidator::validateInt(_descr, "blitzFlags", blitzFlags, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _jparser.validateByNameThrow("brandMask", brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	PString serverObj; _jparser.validateByNameThrow("serverObj", serverObj);
	AtfValidator::validateInt(_descr, "serverObj", serverObj.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	PSiteMask visibilityMaskEx; _jparser.validateByNameThrow("visibilityMaskEx", visibilityMaskEx);
	if(_jparser.parseEnded()) return;
	UINT64 tableFlags2; _jparser.validateByNameThrow("tableFlags2", tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::ZoomStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayersPerTable; _parser0.parseBYTE(maxPlayersPerTable);
	AtfValidator::validateInt(_descr, "maxPlayersPerTable", maxPlayersPerTable, _checker, __FILE__, __LINE__);
	INT32 loBet; _parser0.parseINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _parser0.parseINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 ante; _parser0.parseINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT32 cap; _parser0.parseINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _parser0.parseINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _parser0.parseINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	INT32 defaultBuyIn; _parser0.parseINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = Atf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	bool isMorphLobby; _parser0.parseBOOL(isMorphLobby);
	AtfValidator::validateInt(_descr, "isMorphLobby", isMorphLobby, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "replayerInstance"); size_t szReplayerInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "replayerInstance", szReplayerInstance, _checker, __FILE__, __LINE__);
	BYTE isOneOnOne; _parser0.parseBYTE(isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _parser0.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser0.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	bool quickLobbyVisible; _parser0.parseBOOL(quickLobbyVisible);
	AtfValidator::validateInt(_descr, "quickLobbyVisible", quickLobbyVisible, _checker, __FILE__, __LINE__);
	UINT32 blitzFlags; _parser0.parseUINT32(blitzFlags);
	AtfValidator::validateInt(_descr, "blitzFlags", blitzFlags, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser0.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	TableCommon::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	UINT64 tableFlags2; _parser0.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    EarlyBirdMultiplier
//=================================================================

MLobbyNG::cli::EarlyBirdMultiplier::EarlyBirdMultiplier()
{
	clear();
}

void MLobbyNG::cli::EarlyBirdMultiplier::clear()
{
	licenseId = 0;
	multiplier = 0;
}

bool MLobbyNG::cli::EarlyBirdMultiplier::equals(const EarlyBirdMultiplier& _o) const
{
	return licenseId == _o.licenseId &&
		multiplier == _o.multiplier;
}

const char *MLobbyNG::cli::EarlyBirdMultiplier::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	_buf.append(',');
	_buf.append("multiplier=");
	_buf.appendUint(multiplier);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::EarlyBirdMultiplier::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("licenseId", licenseId, _buf);
	Atf::XmlElement::encodeAsXmlElement("multiplier", multiplier, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::EarlyBirdMultiplier::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("licenseId"))
		{
			licenseId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("multiplier"))
		{
			multiplier = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::EarlyBirdMultiplier::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(EarlyBirdMultiplier())) // not empty
	{
		_body.composeUINT32(licenseId);
		_body.composeUINT32(multiplier);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::EarlyBirdMultiplier::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(licenseId);
	_parser0.parseUINT32(multiplier);
}

const char *MLobbyNG::cli::EarlyBirdMultiplier::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("licenseId", licenseId);
	_jsonstr.compose("multiplier", multiplier);
	return _buf.c_str();
}

void MLobbyNG::cli::EarlyBirdMultiplier::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("licenseId", licenseId);
	_jparser.parseByNameThrow("multiplier", multiplier);
}

/* static */ void MLobbyNG::cli::EarlyBirdMultiplier::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 licenseId; _jparser.validateByNameThrow("licenseId", licenseId);
	AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	UINT32 multiplier; _jparser.validateByNameThrow("multiplier", multiplier);
	AtfValidator::validateInt(_descr, "multiplier", multiplier, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::EarlyBirdMultiplier::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 licenseId; _parser0.parseUINT32(licenseId);
	AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	UINT32 multiplier; _parser0.parseUINT32(multiplier);
	AtfValidator::validateInt(_descr, "multiplier", multiplier, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ZoomDynaDataStruct
//=================================================================

MLobbyNG::cli::ZoomDynaDataStruct::ZoomDynaDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::ZoomDynaDataStruct::ZoomDynaDataStruct(ZoomDynaDataStruct&& _o)
	: handsPerHour(std::move(_o.handsPerHour))
	, avgPotSize(std::move(_o.avgPotSize))
	, avgStackSize(std::move(_o.avgStackSize))
	, numPlayers(std::move(_o.numPlayers))
	, publProp(std::move(_o.publProp))
	, avgPlayers(std::move(_o.avgPlayers))
	, avgVpip(std::move(_o.avgVpip))
	, earlyBirdMins(std::move(_o.earlyBirdMins))
	, earlyBirdMultipliers(std::move(_o.earlyBirdMultipliers))
	, licenseEarlyBirdMultiplier(std::move(_o.licenseEarlyBirdMultiplier))
{
}

MLobbyNG::cli::ZoomDynaDataStruct& MLobbyNG::cli::ZoomDynaDataStruct::operator=(ZoomDynaDataStruct&& _o)
{
	if(this != &_o)
	{
		handsPerHour = std::move(_o.handsPerHour);
		avgPotSize = std::move(_o.avgPotSize);
		avgStackSize = std::move(_o.avgStackSize);
		numPlayers = std::move(_o.numPlayers);
		publProp = std::move(_o.publProp);
		avgPlayers = std::move(_o.avgPlayers);
		avgVpip = std::move(_o.avgVpip);
		earlyBirdMins = std::move(_o.earlyBirdMins);
		earlyBirdMultipliers = std::move(_o.earlyBirdMultipliers);
		licenseEarlyBirdMultiplier = std::move(_o.licenseEarlyBirdMultiplier);
	}
	return *this;
}

#endif

void MLobbyNG::cli::ZoomDynaDataStruct::clear()
{
	handsPerHour = 0;
	avgPotSize = 0;
	avgStackSize = 0;
	numPlayers = 0;
	publProp = 0;
	avgPlayers = 0;
	avgVpip = 0;
	earlyBirdMins = 0;
	earlyBirdMultipliers.clear();
	licenseEarlyBirdMultiplier = 0;
}

bool MLobbyNG::cli::ZoomDynaDataStruct::equals(const ZoomDynaDataStruct& _o) const
{
	return handsPerHour == _o.handsPerHour &&
		avgPotSize == _o.avgPotSize &&
		avgStackSize == _o.avgStackSize &&
		numPlayers == _o.numPlayers &&
		publProp == _o.publProp &&
		avgPlayers == _o.avgPlayers &&
		avgVpip == _o.avgVpip &&
		earlyBirdMins == _o.earlyBirdMins &&
		earlyBirdMultipliers.equals(_o.earlyBirdMultipliers) &&
		licenseEarlyBirdMultiplier == _o.licenseEarlyBirdMultiplier;
}

const char *MLobbyNG::cli::ZoomDynaDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handsPerHour=");
	_buf.appendInt(handsPerHour);
	_buf.append(',');
	_buf.append("avgPotSize=");
	_buf.appendInt(avgPotSize);
	_buf.append(',');
	_buf.append("avgStackSize=");
	_buf.appendInt(avgStackSize);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendInt(numPlayers);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("avgPlayers=");
	_buf.appendUint(avgPlayers);
	_buf.append(',');
	_buf.append("avgVpip=");
	_buf.appendUint(avgVpip);
	_buf.append(',');
	_buf.append("earlyBirdMins=");
	_buf.appendInt(earlyBirdMins);
	_buf.append(',');
	_buf.append("earlyBirdMultipliers=");
	earlyBirdMultipliers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("licenseEarlyBirdMultiplier=");
	_buf.appendUint(licenseEarlyBirdMultiplier);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::ZoomDynaDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("handsPerHour", handsPerHour, _buf);
	Atf::XmlElement::encodeAsXmlElement("avgPotSize", avgPotSize, _buf);
	Atf::XmlElement::encodeAsXmlElement("avgStackSize", avgStackSize, _buf);
	Atf::XmlElement::encodeAsXmlElement("numPlayers", numPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("publProp", publProp, _buf);
	Atf::XmlElement::encodeAsXmlElement("avgPlayers", avgPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("avgVpip", avgVpip, _buf);
	Atf::XmlElement::encodeAsXmlElement("earlyBirdMins", earlyBirdMins, _buf);
	earlyBirdMultipliers.toXmlString("earlyBirdMultipliers", _buf);
	Atf::XmlElement::encodeAsXmlElement("licenseEarlyBirdMultiplier", licenseEarlyBirdMultiplier, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::ZoomDynaDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("handsPerHour"))
		{
			handsPerHour = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("avgPotSize"))
		{
			avgPotSize = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("avgStackSize"))
		{
			avgStackSize = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numPlayers"))
		{
			numPlayers = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("publProp"))
		{
			publProp = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("avgPlayers"))
		{
			avgPlayers = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("avgVpip"))
		{
			avgVpip = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("earlyBirdMins"))
		{
			earlyBirdMins = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("earlyBirdMultipliers"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< EarlyBirdMultiplier, 4 > >::FromXmlString(_value, earlyBirdMultipliers)) return false;
		}
		else if (_element.equals("licenseEarlyBirdMultiplier"))
		{
			licenseEarlyBirdMultiplier = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::ZoomDynaDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ZoomDynaDataStruct())) // not empty
	{
		_body.composeINT32(handsPerHour);
		_body.composeINT32(avgPotSize);
		_body.composeINT32(avgStackSize);
		_body.composeINT32(numPlayers);
		_body.composeBYTE(publProp);
		_body.composeBYTE(avgPlayers);
		_body.composeBYTE(avgVpip);
		_body.composeINT32(earlyBirdMins);
		earlyBirdMultipliers.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(licenseEarlyBirdMultiplier);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::ZoomDynaDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(handsPerHour);
	_parser0.parseINT32(avgPotSize);
	_parser0.parseINT32(avgStackSize);
	_parser0.parseINT32(numPlayers);
	_parser0.parseBYTE(publProp);
	_parser0.parseBYTE(avgPlayers);
	_parser0.parseBYTE(avgVpip);
	_parser0.parseINT32(earlyBirdMins);
	earlyBirdMultipliers.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(licenseEarlyBirdMultiplier);
}

const char *MLobbyNG::cli::ZoomDynaDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handsPerHour", handsPerHour);
	_jsonstr.compose("avgPotSize", avgPotSize);
	_jsonstr.compose("avgStackSize", avgStackSize);
	_jsonstr.compose("numPlayers", numPlayers);
	_jsonstr.compose("publProp", publProp);
	_jsonstr.compose("avgPlayers", avgPlayers);
	_jsonstr.compose("avgVpip", avgVpip);
	_jsonstr.compose("earlyBirdMins", earlyBirdMins);
	_jsonstr.compose("earlyBirdMultipliers", earlyBirdMultipliers);
	_jsonstr.compose("licenseEarlyBirdMultiplier", licenseEarlyBirdMultiplier);
	return _buf.c_str();
}

void MLobbyNG::cli::ZoomDynaDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handsPerHour", handsPerHour);
	_jparser.parseByNameThrow("avgPotSize", avgPotSize);
	_jparser.parseByNameThrow("avgStackSize", avgStackSize);
	_jparser.parseByNameThrow("numPlayers", numPlayers);
	_jparser.parseByNameThrow("publProp", publProp);
	_jparser.parseByNameThrow("avgPlayers", avgPlayers);
	_jparser.parseByNameThrow("avgVpip", avgVpip);
	_jparser.parseByNameThrow("earlyBirdMins", earlyBirdMins);
	_jparser.parseByNameThrow("earlyBirdMultipliers", earlyBirdMultipliers);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("licenseEarlyBirdMultiplier", licenseEarlyBirdMultiplier);
}

/* static */ void MLobbyNG::cli::ZoomDynaDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 handsPerHour; _jparser.validateByNameThrow("handsPerHour", handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	INT32 avgPotSize; _jparser.validateByNameThrow("avgPotSize", avgPotSize);
	AtfValidator::validateInt(_descr, "avgPotSize", avgPotSize, _checker, __FILE__, __LINE__);
	INT32 avgStackSize; _jparser.validateByNameThrow("avgStackSize", avgStackSize);
	AtfValidator::validateInt(_descr, "avgStackSize", avgStackSize, _checker, __FILE__, __LINE__);
	INT32 numPlayers; _jparser.validateByNameThrow("numPlayers", numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	BYTE publProp; _jparser.validateByNameThrow("publProp", publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	BYTE avgPlayers; _jparser.validateByNameThrow("avgPlayers", avgPlayers);
	AtfValidator::validateInt(_descr, "avgPlayers", avgPlayers, _checker, __FILE__, __LINE__);
	BYTE avgVpip; _jparser.validateByNameThrow("avgVpip", avgVpip);
	AtfValidator::validateInt(_descr, "avgVpip", avgVpip, _checker, __FILE__, __LINE__);
	INT32 earlyBirdMins; _jparser.validateByNameThrow("earlyBirdMins", earlyBirdMins);
	AtfValidator::validateInt(_descr, "earlyBirdMins", earlyBirdMins, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< EarlyBirdMultiplier > earlyBirdMultipliers; _jparser.validateByNameThrow("earlyBirdMultipliers", earlyBirdMultipliers);
	AtfValidator::validateInt(_descr, "earlyBirdMultipliers", earlyBirdMultipliers.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 licenseEarlyBirdMultiplier; _jparser.validateByNameThrow("licenseEarlyBirdMultiplier", licenseEarlyBirdMultiplier);
	AtfValidator::validateInt(_descr, "licenseEarlyBirdMultiplier", licenseEarlyBirdMultiplier, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::ZoomDynaDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 handsPerHour; _parser0.parseINT32(handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	INT32 avgPotSize; _parser0.parseINT32(avgPotSize);
	AtfValidator::validateInt(_descr, "avgPotSize", avgPotSize, _checker, __FILE__, __LINE__);
	INT32 avgStackSize; _parser0.parseINT32(avgStackSize);
	AtfValidator::validateInt(_descr, "avgStackSize", avgStackSize, _checker, __FILE__, __LINE__);
	INT32 numPlayers; _parser0.parseINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser0.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	BYTE avgPlayers; _parser0.parseBYTE(avgPlayers);
	AtfValidator::validateInt(_descr, "avgPlayers", avgPlayers, _checker, __FILE__, __LINE__);
	BYTE avgVpip; _parser0.parseBYTE(avgVpip);
	AtfValidator::validateInt(_descr, "avgVpip", avgVpip, _checker, __FILE__, __LINE__);
	INT32 earlyBirdMins; _parser0.parseINT32(earlyBirdMins);
	AtfValidator::validateInt(_descr, "earlyBirdMins", earlyBirdMins, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szEarlyBirdMultipliers = Atf::LAtfVector< EarlyBirdMultiplier, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("earlyBirdMultipliers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "earlyBirdMultipliers", szEarlyBirdMultipliers, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 licenseEarlyBirdMultiplier; _parser0.parseUINT32(licenseEarlyBirdMultiplier);
	AtfValidator::validateInt(_descr, "licenseEarlyBirdMultiplier", licenseEarlyBirdMultiplier, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ZoomDataStruct
//=================================================================

MLobbyNG::cli::ZoomDataStruct::ZoomDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::ZoomDataStruct::ZoomDataStruct(ZoomDataStruct&& _o)
	: staticData(std::move(_o.staticData))
	, dynamicData(std::move(_o.dynamicData))
	, lastEntry(std::move(_o.lastEntry))
{
}

MLobbyNG::cli::ZoomDataStruct& MLobbyNG::cli::ZoomDataStruct::operator=(ZoomDataStruct&& _o)
{
	if(this != &_o)
	{
		staticData = std::move(_o.staticData);
		dynamicData = std::move(_o.dynamicData);
		lastEntry = std::move(_o.lastEntry);
	}
	return *this;
}

#endif

void MLobbyNG::cli::ZoomDataStruct::clear()
{
	staticData.clear();
	dynamicData.clear();
	lastEntry.setNull();
}

bool MLobbyNG::cli::ZoomDataStruct::equals(const ZoomDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		dynamicData.equals(_o.dynamicData) &&
		lastEntry.equals(_o.lastEntry);
}

const char *MLobbyNG::cli::ZoomDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dynamicData=");
	dynamicData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("lastEntry=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, lastEntry);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::ZoomDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	staticData.toXmlString("staticData", _buf);
	dynamicData.toXmlString("dynamicData", _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "lastEntry", lastEntry);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::ZoomDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("staticData"))
		{
			if(!Atf::AtfTempl< ZoomStaticDataStruct >::FromXmlString(_value, staticData)) return false;
		}
		else if (_element.equals("dynamicData"))
		{
			if(!Atf::AtfTempl< ZoomDynaDataStruct >::FromXmlString(_value, dynamicData)) return false;
		}
		else if (_element.equals("lastEntry"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, lastEntry);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::ZoomDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ZoomDataStruct())) // not empty
	{
		staticData.composeMsg(_body, _ignoreJSON);
		dynamicData.composeMsg(_body, _ignoreJSON);
		_body.composeSrvTime(lastEntry);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::ZoomDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	dynamicData.parseMsg(_parser0);
	_parser0.parseSrvTime(lastEntry);
}

const char *MLobbyNG::cli::ZoomDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("staticData", staticData);
	_jsonstr.compose("dynamicData", dynamicData);
	_jsonstr.compose("lastEntry", lastEntry);
	return _buf.c_str();
}

void MLobbyNG::cli::ZoomDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("staticData", staticData);
	_jparser.parseByNameThrow("dynamicData", dynamicData);
	_jparser.parseByNameThrow("lastEntry", lastEntry);
}

/* static */ void MLobbyNG::cli::ZoomDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	ZoomStaticDataStruct staticData; _jparser.validateByNameThrow("staticData", staticData);
	ZoomDynaDataStruct dynamicData; _jparser.validateByNameThrow("dynamicData", dynamicData);
	SrvTime lastEntry; _jparser.validateByNameThrow("lastEntry", lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::ZoomDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	ZoomStaticDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	ZoomDynaDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamicData"), _fieldsWithUnparsedContent);
	SrvTime lastEntry; _parser0.parseSrvTime(lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SeatFinderStaticDataStruct
//=================================================================

MLobbyNG::cli::SeatFinderStaticDataStruct::SeatFinderStaticDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SeatFinderStaticDataStruct::SeatFinderStaticDataStruct(SeatFinderStaticDataStruct&& _o)
	: id(std::move(_o.id))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, maxPlayersPerTable(std::move(_o.maxPlayersPerTable))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, ante(std::move(_o.ante))
	, cap(std::move(_o.cap))
	, currency(std::move(_o.currency))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, visibilityMask(std::move(_o.visibilityMask))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, specialName(std::move(_o.specialName))
	, countryRestrictionInverted(std::move(_o.countryRestrictionInverted))
	, restrictedCountries(std::move(_o.restrictedCountries))
	, replayerAddress(std::move(_o.replayerAddress))
	, replayerInstance(std::move(_o.replayerInstance))
	, minPlayersPerTable(std::move(_o.minPlayersPerTable))
	, isPasswordProtected(std::move(_o.isPasswordProtected))
	, poolBlockMinHands(std::move(_o.poolBlockMinHands))
	, poolBlockTimePenalty(std::move(_o.poolBlockTimePenalty))
	, flags(std::move(_o.flags))
	, flags2(std::move(_o.flags2))
	, isPM(std::move(_o.isPM))
	, scalePM(std::move(_o.scalePM))
	, tableStakes(std::move(_o.tableStakes))
	, variableAntes(std::move(_o.variableAntes))
	, visibilityMaskEx(std::move(_o.visibilityMaskEx))
{
}

MLobbyNG::cli::SeatFinderStaticDataStruct& MLobbyNG::cli::SeatFinderStaticDataStruct::operator=(SeatFinderStaticDataStruct&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		maxPlayersPerTable = std::move(_o.maxPlayersPerTable);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		ante = std::move(_o.ante);
		cap = std::move(_o.cap);
		currency = std::move(_o.currency);
		minChipsLimit = std::move(_o.minChipsLimit);
		maxBuyIn = std::move(_o.maxBuyIn);
		visibilityMask = std::move(_o.visibilityMask);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		specialName = std::move(_o.specialName);
		countryRestrictionInverted = std::move(_o.countryRestrictionInverted);
		restrictedCountries = std::move(_o.restrictedCountries);
		replayerAddress = std::move(_o.replayerAddress);
		replayerInstance = std::move(_o.replayerInstance);
		minPlayersPerTable = std::move(_o.minPlayersPerTable);
		isPasswordProtected = std::move(_o.isPasswordProtected);
		poolBlockMinHands = std::move(_o.poolBlockMinHands);
		poolBlockTimePenalty = std::move(_o.poolBlockTimePenalty);
		flags = std::move(_o.flags);
		flags2 = std::move(_o.flags2);
		isPM = std::move(_o.isPM);
		scalePM = std::move(_o.scalePM);
		tableStakes = std::move(_o.tableStakes);
		variableAntes = std::move(_o.variableAntes);
		visibilityMaskEx = std::move(_o.visibilityMaskEx);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SeatFinderStaticDataStruct::clear()
{
	id = 0;
	game = 0;
	structure = 0;
	isHiLo = 0;
	maxPlayersPerTable = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	visibilityMask = 0;
	defaultBuyIn = 0;
	specialName.clear();
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	replayerAddress.clear();
	replayerInstance.clear();
	minPlayersPerTable = 0;
	isPasswordProtected = false;
	poolBlockMinHands = 0;
	poolBlockTimePenalty.clear();
	flags = 0;
	flags2 = 0;
	isPM = false;
	scalePM = 0;
	tableStakes.clear();
	variableAntes.clear();
	visibilityMaskEx.clear();
}

bool MLobbyNG::cli::SeatFinderStaticDataStruct::equals(const SeatFinderStaticDataStruct& _o) const
{
	return id == _o.id &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		maxPlayersPerTable == _o.maxPlayersPerTable &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		visibilityMask == _o.visibilityMask &&
		defaultBuyIn == _o.defaultBuyIn &&
		Atf::atfPStringEquals(specialName, _o.specialName) &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		Atf::atfPStringEquals(replayerAddress, _o.replayerAddress) &&
		Atf::atfPStringEquals(replayerInstance, _o.replayerInstance) &&
		minPlayersPerTable == _o.minPlayersPerTable &&
		isPasswordProtected == _o.isPasswordProtected &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		poolBlockTimePenalty.equals(_o.poolBlockTimePenalty) &&
		flags == _o.flags &&
		flags2 == _o.flags2 &&
		isPM == _o.isPM &&
		scalePM == _o.scalePM &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx);
}

const char *MLobbyNG::cli::SeatFinderStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayersPerTable=");
	_buf.appendUint(maxPlayersPerTable);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendInt(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendInt(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendInt(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendInt(cap);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendInt(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt(maxBuyIn);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendInt(defaultBuyIn);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("replayerAddress=");
	_buf.append(replayerAddress);
	_buf.append(',');
	_buf.append("replayerInstance=");
	_buf.append(replayerInstance);
	_buf.append(',');
	_buf.append("minPlayersPerTable=");
	_buf.appendInt(minPlayersPerTable);
	_buf.append(',');
	_buf.append("isPasswordProtected=");
	_buf.appendUint(isPasswordProtected);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("poolBlockTimePenalty=");
	poolBlockTimePenalty.toTraceString(_buf);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::SeatFinderStaticDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayersPerTable", maxPlayersPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("cap", cap, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("minChipsLimit", minChipsLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("visibilityMask", visibilityMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("defaultBuyIn", defaultBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("specialName", specialName, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryRestrictionInverted", countryRestrictionInverted, _buf);
	restrictedCountries.toXmlString("restrictedCountries", _buf);
	Atf::XmlElement::encodeAsXmlElement("replayerAddress", replayerAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("replayerInstance", replayerInstance, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayersPerTable", minPlayersPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPasswordProtected", isPasswordProtected, _buf);
	Atf::XmlElement::encodeAsXmlElement("poolBlockMinHands", poolBlockMinHands, _buf);
	poolBlockTimePenalty.toXmlString("poolBlockTimePenalty", _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags2", flags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPM", isPM, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	variableAntes.toXmlString("variableAntes", _buf);
	visibilityMaskEx.toXmlString("visibilityMaskEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::SeatFinderStaticDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("id"))
		{
			id = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayersPerTable"))
		{
			maxPlayersPerTable = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("loBet"))
		{
			loBet = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cap"))
		{
			cap = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("minChipsLimit"))
		{
			minChipsLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("visibilityMask"))
		{
			visibilityMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("defaultBuyIn"))
		{
			defaultBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("specialName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, specialName)) return false;
		}
		else if (_element.equals("countryRestrictionInverted"))
		{
			countryRestrictionInverted = (*_value.ptr() == '1');
		}
		else if (_element.equals("restrictedCountries"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, restrictedCountries)) return false;
		}
		else if (_element.equals("replayerAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, replayerAddress)) return false;
		}
		else if (_element.equals("replayerInstance"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, replayerInstance)) return false;
		}
		else if (_element.equals("minPlayersPerTable"))
		{
			minPlayersPerTable = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPasswordProtected"))
		{
			isPasswordProtected = (*_value.ptr() == '1');
		}
		else if (_element.equals("poolBlockMinHands"))
		{
			poolBlockMinHands = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("poolBlockTimePenalty"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, poolBlockTimePenalty)) return false;
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags2"))
		{
			flags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPM"))
		{
			isPM = (*_value.ptr() == '1');
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableStakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
		}
		else if (_element.equals("variableAntes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64, 4 > >::FromXmlString(_value, variableAntes)) return false;
		}
		else if (_element.equals("visibilityMaskEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, visibilityMaskEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::SeatFinderStaticDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SeatFinderStaticDataStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeBYTE(game);
		_body.composeBYTE(structure);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(maxPlayersPerTable);
		_body.composeINT32(loBet);
		_body.composeINT32(hiBet);
		_body.composeINT32(ante);
		_body.composeINT32(cap);
		_body.composeString(currency);
		_body.composeINT32(minChipsLimit);
		_body.composeINT32(maxBuyIn);
		_body.composeUINT32(visibilityMask);
		_body.composeINT32(defaultBuyIn);
		_body.composeString(specialName);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body, _ignoreJSON);
		_body.composeString(replayerAddress);
		_body.composeString(replayerInstance);
		_body.composeINT8(minPlayersPerTable);
		_body.composeBOOL(isPasswordProtected);
		_body.composeINT32(poolBlockMinHands);
		poolBlockTimePenalty.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(flags);
		_body.composeUINT64(flags2);
		_body.composeBOOL(isPM);
		_body.composeUINT32(scalePM);
		tableStakes.composeMsg(_body, _ignoreJSON);
		variableAntes.composeMsg(_body, _ignoreJSON);
		visibilityMaskEx.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SeatFinderStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(maxPlayersPerTable);
	_parser0.parseINT32(loBet);
	_parser0.parseINT32(hiBet);
	_parser0.parseINT32(ante);
	_parser0.parseINT32(cap);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(minChipsLimit);
	_parser0.parseINT32(maxBuyIn);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseINT32(defaultBuyIn);
	_parser0.parseStringP(specialName);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseStringP(replayerAddress);
	_parser0.parseStringP(replayerInstance);
	_parser0.parseINT8(minPlayersPerTable);
	_parser0.parseBOOL(isPasswordProtected);
	_parser0.parseINT32(poolBlockMinHands);
	poolBlockTimePenalty.parseMsg(_parser0);
	_parser0.parseUINT32(flags);
	_parser0.parseUINT64(flags2);
	_parser0.parseBOOL(isPM);
	_parser0.parseUINT32(scalePM);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	variableAntes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
}

const char *MLobbyNG::cli::SeatFinderStaticDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("game", game);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("maxPlayersPerTable", maxPlayersPerTable);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("cap", cap);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("minChipsLimit", minChipsLimit);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("visibilityMask", visibilityMask);
	_jsonstr.compose("defaultBuyIn", defaultBuyIn);
	_jsonstr.compose("specialName", specialName);
	_jsonstr.compose("countryRestrictionInverted", countryRestrictionInverted);
	_jsonstr.compose("restrictedCountries", restrictedCountries);
	_jsonstr.compose("replayerAddress", replayerAddress);
	_jsonstr.compose("replayerInstance", replayerInstance);
	_jsonstr.compose("minPlayersPerTable", minPlayersPerTable);
	_jsonstr.compose("isPasswordProtected", isPasswordProtected);
	_jsonstr.compose("poolBlockMinHands", poolBlockMinHands);
	_jsonstr.compose("poolBlockTimePenalty", poolBlockTimePenalty);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("flags2", flags2);
	_jsonstr.compose("isPM", isPM);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("tableStakes", tableStakes);
	_jsonstr.compose("variableAntes", variableAntes);
	_jsonstr.compose("visibilityMaskEx", visibilityMaskEx);
	return _buf.c_str();
}

void MLobbyNG::cli::SeatFinderStaticDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("maxPlayersPerTable", maxPlayersPerTable);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("cap", cap);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("minChipsLimit", minChipsLimit);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("visibilityMask", visibilityMask);
	_jparser.parseByNameThrow("defaultBuyIn", defaultBuyIn);
	_jparser.parseByNameThrow("specialName", specialName);
	_jparser.parseByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	_jparser.parseByNameThrow("restrictedCountries", restrictedCountries);
	_jparser.parseByNameThrow("replayerAddress", replayerAddress);
	_jparser.parseByNameThrow("replayerInstance", replayerInstance);
	_jparser.parseByNameThrow("minPlayersPerTable", minPlayersPerTable);
	_jparser.parseByNameThrow("isPasswordProtected", isPasswordProtected);
	_jparser.parseByNameThrow("poolBlockMinHands", poolBlockMinHands);
	_jparser.parseByNameThrow("poolBlockTimePenalty", poolBlockTimePenalty);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("flags2", flags2);
	_jparser.parseByNameThrow("isPM", isPM);
	_jparser.parseByNameThrow("scalePM", scalePM);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("variableAntes", variableAntes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("visibilityMaskEx", visibilityMaskEx);
}

/* static */ void MLobbyNG::cli::SeatFinderStaticDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayersPerTable; _jparser.validateByNameThrow("maxPlayersPerTable", maxPlayersPerTable);
	AtfValidator::validateInt(_descr, "maxPlayersPerTable", maxPlayersPerTable, _checker, __FILE__, __LINE__);
	INT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT32 cap; _jparser.validateByNameThrow("cap", cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _jparser.validateByNameThrow("minChipsLimit", minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _jparser.validateByNameThrow("visibilityMask", visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	INT32 defaultBuyIn; _jparser.validateByNameThrow("defaultBuyIn", defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	PString specialName; _jparser.validateByNameThrow("specialName", specialName);
	AtfValidator::validateInt(_descr, "specialName", specialName.length(), _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _jparser.validateByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > restrictedCountries; _jparser.validateByNameThrow("restrictedCountries", restrictedCountries);
	AtfValidator::validateInt(_descr, "restrictedCountries", restrictedCountries.size(), _checker, __FILE__, __LINE__);
	PString replayerAddress; _jparser.validateByNameThrow("replayerAddress", replayerAddress);
	AtfValidator::validateInt(_descr, "replayerAddress", replayerAddress.length(), _checker, __FILE__, __LINE__);
	PString replayerInstance; _jparser.validateByNameThrow("replayerInstance", replayerInstance);
	AtfValidator::validateInt(_descr, "replayerInstance", replayerInstance.length(), _checker, __FILE__, __LINE__);
	INT8 minPlayersPerTable; _jparser.validateByNameThrow("minPlayersPerTable", minPlayersPerTable);
	AtfValidator::validateInt(_descr, "minPlayersPerTable", minPlayersPerTable, _checker, __FILE__, __LINE__);
	bool isPasswordProtected; _jparser.validateByNameThrow("isPasswordProtected", isPasswordProtected);
	AtfValidator::validateInt(_descr, "isPasswordProtected", isPasswordProtected, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _jparser.validateByNameThrow("poolBlockMinHands", poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > poolBlockTimePenalty; _jparser.validateByNameThrow("poolBlockTimePenalty", poolBlockTimePenalty);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", poolBlockTimePenalty.size(), _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _jparser.validateByNameThrow("flags2", flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	bool isPM; _jparser.validateByNameThrow("isPM", isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< INT64 > variableAntes; _jparser.validateByNameThrow("variableAntes", variableAntes);
	AtfValidator::validateInt(_descr, "variableAntes", variableAntes.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask visibilityMaskEx; _jparser.validateByNameThrow("visibilityMaskEx", visibilityMaskEx);
}

/*static*/ void MLobbyNG::cli::SeatFinderStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayersPerTable; _parser0.parseBYTE(maxPlayersPerTable);
	AtfValidator::validateInt(_descr, "maxPlayersPerTable", maxPlayersPerTable, _checker, __FILE__, __LINE__);
	INT32 loBet; _parser0.parseINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _parser0.parseINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 ante; _parser0.parseINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT32 cap; _parser0.parseINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _parser0.parseINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _parser0.parseINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	INT32 defaultBuyIn; _parser0.parseINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = Atf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "replayerAddress"); size_t szReplayerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "replayerAddress", szReplayerAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "replayerInstance"); size_t szReplayerInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "replayerInstance", szReplayerInstance, _checker, __FILE__, __LINE__);
	INT8 minPlayersPerTable; _parser0.parseINT8(minPlayersPerTable);
	AtfValidator::validateInt(_descr, "minPlayersPerTable", minPlayersPerTable, _checker, __FILE__, __LINE__);
	bool isPasswordProtected; _parser0.parseBOOL(isPasswordProtected);
	AtfValidator::validateInt(_descr, "isPasswordProtected", isPasswordProtected, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser0.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	int szPoolBlockTimePenalty = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("poolBlockTimePenalty"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", szPoolBlockTimePenalty, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser0.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	TableCommon::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	int szVariableAntes = Atf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SeatFinderDynaDataStruct
//=================================================================

MLobbyNG::cli::SeatFinderDynaDataStruct::SeatFinderDynaDataStruct()
{
	clear();
}

void MLobbyNG::cli::SeatFinderDynaDataStruct::clear()
{
	handsPerHour = 0;
	avgPotSize = 0;
	avgStackSize = 0;
	numPlayers = 0;
	numTables = 0;
	numFullTables = 0;
}

bool MLobbyNG::cli::SeatFinderDynaDataStruct::equals(const SeatFinderDynaDataStruct& _o) const
{
	return handsPerHour == _o.handsPerHour &&
		avgPotSize == _o.avgPotSize &&
		avgStackSize == _o.avgStackSize &&
		numPlayers == _o.numPlayers &&
		numTables == _o.numTables &&
		numFullTables == _o.numFullTables;
}

const char *MLobbyNG::cli::SeatFinderDynaDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handsPerHour=");
	_buf.appendInt(handsPerHour);
	_buf.append(',');
	_buf.append("avgPotSize=");
	_buf.appendInt(avgPotSize);
	_buf.append(',');
	_buf.append("avgStackSize=");
	_buf.appendInt(avgStackSize);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendInt(numPlayers);
	_buf.append(',');
	_buf.append("numTables=");
	_buf.appendInt(numTables);
	_buf.append(',');
	_buf.append("numFullTables=");
	_buf.appendInt(numFullTables);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::SeatFinderDynaDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("handsPerHour", handsPerHour, _buf);
	Atf::XmlElement::encodeAsXmlElement("avgPotSize", avgPotSize, _buf);
	Atf::XmlElement::encodeAsXmlElement("avgStackSize", avgStackSize, _buf);
	Atf::XmlElement::encodeAsXmlElement("numPlayers", numPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("numTables", numTables, _buf);
	Atf::XmlElement::encodeAsXmlElement("numFullTables", numFullTables, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::SeatFinderDynaDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("handsPerHour"))
		{
			handsPerHour = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("avgPotSize"))
		{
			avgPotSize = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("avgStackSize"))
		{
			avgStackSize = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numPlayers"))
		{
			numPlayers = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numTables"))
		{
			numTables = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numFullTables"))
		{
			numFullTables = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::SeatFinderDynaDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SeatFinderDynaDataStruct())) // not empty
	{
		_body.composeINT32(handsPerHour);
		_body.composeINT32(avgPotSize);
		_body.composeINT32(avgStackSize);
		_body.composeINT32(numPlayers);
		_body.composeINT32(numTables);
		_body.composeINT32(numFullTables);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SeatFinderDynaDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(handsPerHour);
	_parser0.parseINT32(avgPotSize);
	_parser0.parseINT32(avgStackSize);
	_parser0.parseINT32(numPlayers);
	_parser0.parseINT32(numTables);
	_parser0.parseINT32(numFullTables);
}

const char *MLobbyNG::cli::SeatFinderDynaDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handsPerHour", handsPerHour);
	_jsonstr.compose("avgPotSize", avgPotSize);
	_jsonstr.compose("avgStackSize", avgStackSize);
	_jsonstr.compose("numPlayers", numPlayers);
	_jsonstr.compose("numTables", numTables);
	_jsonstr.compose("numFullTables", numFullTables);
	return _buf.c_str();
}

void MLobbyNG::cli::SeatFinderDynaDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handsPerHour", handsPerHour);
	_jparser.parseByNameThrow("avgPotSize", avgPotSize);
	_jparser.parseByNameThrow("avgStackSize", avgStackSize);
	_jparser.parseByNameThrow("numPlayers", numPlayers);
	_jparser.parseByNameThrow("numTables", numTables);
	_jparser.parseByNameThrow("numFullTables", numFullTables);
}

/* static */ void MLobbyNG::cli::SeatFinderDynaDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 handsPerHour; _jparser.validateByNameThrow("handsPerHour", handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	INT32 avgPotSize; _jparser.validateByNameThrow("avgPotSize", avgPotSize);
	AtfValidator::validateInt(_descr, "avgPotSize", avgPotSize, _checker, __FILE__, __LINE__);
	INT32 avgStackSize; _jparser.validateByNameThrow("avgStackSize", avgStackSize);
	AtfValidator::validateInt(_descr, "avgStackSize", avgStackSize, _checker, __FILE__, __LINE__);
	INT32 numPlayers; _jparser.validateByNameThrow("numPlayers", numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	INT32 numTables; _jparser.validateByNameThrow("numTables", numTables);
	AtfValidator::validateInt(_descr, "numTables", numTables, _checker, __FILE__, __LINE__);
	INT32 numFullTables; _jparser.validateByNameThrow("numFullTables", numFullTables);
	AtfValidator::validateInt(_descr, "numFullTables", numFullTables, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::SeatFinderDynaDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 handsPerHour; _parser0.parseINT32(handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	INT32 avgPotSize; _parser0.parseINT32(avgPotSize);
	AtfValidator::validateInt(_descr, "avgPotSize", avgPotSize, _checker, __FILE__, __LINE__);
	INT32 avgStackSize; _parser0.parseINT32(avgStackSize);
	AtfValidator::validateInt(_descr, "avgStackSize", avgStackSize, _checker, __FILE__, __LINE__);
	INT32 numPlayers; _parser0.parseINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	INT32 numTables; _parser0.parseINT32(numTables);
	AtfValidator::validateInt(_descr, "numTables", numTables, _checker, __FILE__, __LINE__);
	INT32 numFullTables; _parser0.parseINT32(numFullTables);
	AtfValidator::validateInt(_descr, "numFullTables", numFullTables, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SeatFinderDataStruct
//=================================================================

MLobbyNG::cli::SeatFinderDataStruct::SeatFinderDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SeatFinderDataStruct::SeatFinderDataStruct(SeatFinderDataStruct&& _o)
	: staticData(std::move(_o.staticData))
	, dynamicData(std::move(_o.dynamicData))
	, lastEntry(std::move(_o.lastEntry))
{
}

MLobbyNG::cli::SeatFinderDataStruct& MLobbyNG::cli::SeatFinderDataStruct::operator=(SeatFinderDataStruct&& _o)
{
	if(this != &_o)
	{
		staticData = std::move(_o.staticData);
		dynamicData = std::move(_o.dynamicData);
		lastEntry = std::move(_o.lastEntry);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SeatFinderDataStruct::clear()
{
	staticData.clear();
	dynamicData.clear();
	lastEntry.setNull();
}

bool MLobbyNG::cli::SeatFinderDataStruct::equals(const SeatFinderDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		dynamicData.equals(_o.dynamicData) &&
		lastEntry.equals(_o.lastEntry);
}

const char *MLobbyNG::cli::SeatFinderDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dynamicData=");
	dynamicData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("lastEntry=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, lastEntry);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::SeatFinderDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	staticData.toXmlString("staticData", _buf);
	dynamicData.toXmlString("dynamicData", _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "lastEntry", lastEntry);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::SeatFinderDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("staticData"))
		{
			if(!Atf::AtfTempl< SeatFinderStaticDataStruct >::FromXmlString(_value, staticData)) return false;
		}
		else if (_element.equals("dynamicData"))
		{
			if(!Atf::AtfTempl< SeatFinderDynaDataStruct >::FromXmlString(_value, dynamicData)) return false;
		}
		else if (_element.equals("lastEntry"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, lastEntry);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::SeatFinderDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SeatFinderDataStruct())) // not empty
	{
		staticData.composeMsg(_body, _ignoreJSON);
		dynamicData.composeMsg(_body, _ignoreJSON);
		_body.composeSrvTime(lastEntry);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SeatFinderDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	dynamicData.parseMsg(_parser0);
	_parser0.parseSrvTime(lastEntry);
}

const char *MLobbyNG::cli::SeatFinderDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("staticData", staticData);
	_jsonstr.compose("dynamicData", dynamicData);
	_jsonstr.compose("lastEntry", lastEntry);
	return _buf.c_str();
}

void MLobbyNG::cli::SeatFinderDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("staticData", staticData);
	_jparser.parseByNameThrow("dynamicData", dynamicData);
	_jparser.parseByNameThrow("lastEntry", lastEntry);
}

/* static */ void MLobbyNG::cli::SeatFinderDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SeatFinderStaticDataStruct staticData; _jparser.validateByNameThrow("staticData", staticData);
	SeatFinderDynaDataStruct dynamicData; _jparser.validateByNameThrow("dynamicData", dynamicData);
	SrvTime lastEntry; _jparser.validateByNameThrow("lastEntry", lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::SeatFinderDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	SeatFinderStaticDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	SeatFinderDynaDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamicData"), _fieldsWithUnparsedContent);
	SrvTime lastEntry; _parser0.parseSrvTime(lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SngSelectionFilter
//=================================================================

MLobbyNG::cli::SngSelectionFilter::SngSelectionFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SngSelectionFilter::SngSelectionFilter(SngSelectionFilter&& _o)
	: locale(std::move(_o.locale))
	, gameMask(std::move(_o.gameMask))
	, buyInMask(std::move(_o.buyInMask))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, speedMask(std::move(_o.speedMask))
	, currencyMask(std::move(_o.currencyMask))
	, tableSizeMask(std::move(_o.tableSizeMask))
	, tournVariantMask(std::move(_o.tournVariantMask))
	, country(std::move(_o.country))
	, isPM(std::move(_o.isPM))
	, tableNumMask(std::move(_o.tableNumMask))
	, gameCategoryMask(std::move(_o.gameCategoryMask))
	, tournGroups(std::move(_o.tournGroups))
	, tournStateMask(std::move(_o.tournStateMask))
	, negateTournVariantMask(std::move(_o.negateTournVariantMask))
	, numPlayers(std::move(_o.numPlayers))
{
}

MLobbyNG::cli::SngSelectionFilter& MLobbyNG::cli::SngSelectionFilter::operator=(SngSelectionFilter&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		gameMask = std::move(_o.gameMask);
		buyInMask = std::move(_o.buyInMask);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		speedMask = std::move(_o.speedMask);
		currencyMask = std::move(_o.currencyMask);
		tableSizeMask = std::move(_o.tableSizeMask);
		tournVariantMask = std::move(_o.tournVariantMask);
		country = std::move(_o.country);
		isPM = std::move(_o.isPM);
		tableNumMask = std::move(_o.tableNumMask);
		gameCategoryMask = std::move(_o.gameCategoryMask);
		tournGroups = std::move(_o.tournGroups);
		tournStateMask = std::move(_o.tournStateMask);
		negateTournVariantMask = std::move(_o.negateTournVariantMask);
		numPlayers = std::move(_o.numPlayers);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SngSelectionFilter::clear()
{
	locale = 0;
	gameMask = 0;
	buyInMask = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	speedMask = 0;
	currencyMask = 0;
	tableSizeMask = 0;
	tournVariantMask = 0;
	country.clear();
	isPM = false;
	tableNumMask = 0;
	gameCategoryMask = 0;
	tournGroups.clear();
	tournStateMask = 0;
	negateTournVariantMask = 0;
	numPlayers = 0;
}

bool MLobbyNG::cli::SngSelectionFilter::equals(const SngSelectionFilter& _o) const
{
	return locale == _o.locale &&
		gameMask == _o.gameMask &&
		buyInMask == _o.buyInMask &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		speedMask == _o.speedMask &&
		currencyMask == _o.currencyMask &&
		tableSizeMask == _o.tableSizeMask &&
		tournVariantMask == _o.tournVariantMask &&
		Atf::atfPStringEquals(country, _o.country) &&
		isPM == _o.isPM &&
		tableNumMask == _o.tableNumMask &&
		gameCategoryMask == _o.gameCategoryMask &&
		tournGroups.equals(_o.tournGroups) &&
		tournStateMask == _o.tournStateMask &&
		negateTournVariantMask == _o.negateTournVariantMask &&
		numPlayers == _o.numPlayers;
}

const char *MLobbyNG::cli::SngSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append(',');
	_buf.append("buyInMask=");
	_buf.appendUint(buyInMask);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendInt64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt64(maxBuyIn);
	_buf.append(',');
	_buf.append("speedMask=");
	_buf.appendUint(speedMask);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("tableSizeMask=");
	_buf.appendUint(tableSizeMask);
	_buf.append(',');
	_buf.append("tournVariantMask=");
	_buf.appendUint(tournVariantMask);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("tableNumMask=");
	_buf.appendUint(tableNumMask);
	_buf.append(',');
	_buf.append("gameCategoryMask=");
	_buf.appendUint(gameCategoryMask);
	_buf.append(',');
	_buf.append("tournGroups=");
	tournGroups.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournStateMask=");
	_buf.appendUint(tournStateMask);
	_buf.append(',');
	_buf.append("negateTournVariantMask=");
	_buf.appendUint(negateTournVariantMask);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendInt(numPlayers);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::SngSelectionFilter::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameMask", gameMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInMask", buyInMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("speedMask", speedMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyMask", currencyMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableSizeMask", tableSizeMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournVariantMask", tournVariantMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPM", isPM, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableNumMask", tableNumMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameCategoryMask", gameCategoryMask, _buf);
	tournGroups.toXmlString("tournGroups", _buf);
	Atf::XmlElement::encodeAsXmlElement("tournStateMask", tournStateMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("negateTournVariantMask", negateTournVariantMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("numPlayers", numPlayers, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::SngSelectionFilter::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("locale"))
		{
			locale = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameMask"))
		{
			gameMask = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyInMask"))
		{
			buyInMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minBuyIn"))
		{
			minBuyIn = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("speedMask"))
		{
			speedMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currencyMask"))
		{
			currencyMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableSizeMask"))
		{
			tableSizeMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournVariantMask"))
		{
			tournVariantMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("isPM"))
		{
			isPM = (*_value.ptr() == '1');
		}
		else if (_element.equals("tableNumMask"))
		{
			tableNumMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameCategoryMask"))
		{
			gameCategoryMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournGroups"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, tournGroups)) return false;
		}
		else if (_element.equals("tournStateMask"))
		{
			tournStateMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("negateTournVariantMask"))
		{
			negateTournVariantMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numPlayers"))
		{
			numPlayers = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::SngSelectionFilter::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SngSelectionFilter())) // not empty
	{
		_body.composeUINT32(locale);
		_body.composeUINT64(gameMask);
		_body.composeUINT32(buyInMask);
		_body.composeINT64(minBuyIn);
		_body.composeINT64(maxBuyIn);
		_body.composeUINT32(speedMask);
		_body.composeUINT32(currencyMask);
		_body.composeUINT32(tableSizeMask);
		_body.composeUINT32(tournVariantMask);
		_body.composeString(country);
		_body.composeBOOL(isPM);
		_body.composeUINT32(tableNumMask);
		_body.composeUINT32(gameCategoryMask);
		tournGroups.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(tournStateMask);
		_body.composeUINT32(negateTournVariantMask);
		_body.composeINT32(numPlayers);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SngSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	_parser0.parseUINT64(gameMask);
	_parser0.parseUINT32(buyInMask);
	_parser0.parseINT64(minBuyIn);
	_parser0.parseINT64(maxBuyIn);
	_parser0.parseUINT32(speedMask);
	_parser0.parseUINT32(currencyMask);
	_parser0.parseUINT32(tableSizeMask);
	_parser0.parseUINT32(tournVariantMask);
	_parser0.parseStringP(country);
	_parser0.parseBOOL(isPM);
	_parser0.parseUINT32(tableNumMask);
	_parser0.parseUINT32(gameCategoryMask);
	tournGroups.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(tournStateMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(negateTournVariantMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(numPlayers);
}

const char *MLobbyNG::cli::SngSelectionFilter::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("gameMask", gameMask);
	_jsonstr.compose("buyInMask", buyInMask);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("speedMask", speedMask);
	_jsonstr.compose("currencyMask", currencyMask);
	_jsonstr.compose("tableSizeMask", tableSizeMask);
	_jsonstr.compose("tournVariantMask", tournVariantMask);
	_jsonstr.compose("country", country);
	_jsonstr.compose("isPM", isPM);
	_jsonstr.compose("tableNumMask", tableNumMask);
	_jsonstr.compose("gameCategoryMask", gameCategoryMask);
	_jsonstr.compose("tournGroups", tournGroups);
	_jsonstr.compose("tournStateMask", tournStateMask);
	_jsonstr.compose("negateTournVariantMask", negateTournVariantMask);
	_jsonstr.compose("numPlayers", numPlayers);
	return _buf.c_str();
}

void MLobbyNG::cli::SngSelectionFilter::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("gameMask", gameMask);
	_jparser.parseByNameThrow("buyInMask", buyInMask);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("speedMask", speedMask);
	_jparser.parseByNameThrow("currencyMask", currencyMask);
	_jparser.parseByNameThrow("tableSizeMask", tableSizeMask);
	_jparser.parseByNameThrow("tournVariantMask", tournVariantMask);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("isPM", isPM);
	_jparser.parseByNameThrow("tableNumMask", tableNumMask);
	_jparser.parseByNameThrow("gameCategoryMask", gameCategoryMask);
	_jparser.parseByNameThrow("tournGroups", tournGroups);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tournStateMask", tournStateMask);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("negateTournVariantMask", negateTournVariantMask);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("numPlayers", numPlayers);
}

/* static */ void MLobbyNG::cli::SngSelectionFilter::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT64 gameMask; _jparser.validateByNameThrow("gameMask", gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _jparser.validateByNameThrow("buyInMask", buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*NGBuyIn_Last-1), _checker, __FILE__, __LINE__);
	INT64 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 speedMask; _jparser.validateByNameThrow("speedMask", speedMask);
	AtfValidator::validateIntMax(_descr, "speedMask", speedMask, (2*NGTournSpeed_Last-1), _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _jparser.validateByNameThrow("currencyMask", currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*NGCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tableSizeMask; _jparser.validateByNameThrow("tableSizeMask", tableSizeMask);
	AtfValidator::validateIntMax(_descr, "tableSizeMask", tableSizeMask, (2*NGMaxTableSize_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tournVariantMask; _jparser.validateByNameThrow("tournVariantMask", tournVariantMask);
	AtfValidator::validateIntMax(_descr, "tournVariantMask", tournVariantMask, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), 3, _checker, __FILE__, __LINE__);
	bool isPM; _jparser.validateByNameThrow("isPM", isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 tableNumMask; _jparser.validateByNameThrow("tableNumMask", tableNumMask);
	AtfValidator::validateIntMax(_descr, "tableNumMask", tableNumMask, (2*NGTableNum_Last-1), _checker, __FILE__, __LINE__);
	UINT32 gameCategoryMask; _jparser.validateByNameThrow("gameCategoryMask", gameCategoryMask);
	AtfValidator::validateIntMax(_descr, "gameCategoryMask", gameCategoryMask, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > tournGroups; _jparser.validateByNameThrow("tournGroups", tournGroups);
	AtfValidator::validateIntMax(_descr, "tournGroups", tournGroups.size(), TournGroup_Last, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 tournStateMask; _jparser.validateByNameThrow("tournStateMask", tournStateMask);
	AtfValidator::validateIntMax(_descr, "tournStateMask", tournStateMask, (2*NGTournState_Last-1), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 negateTournVariantMask; _jparser.validateByNameThrow("negateTournVariantMask", negateTournVariantMask);
	AtfValidator::validateIntMax(_descr, "negateTournVariantMask", negateTournVariantMask, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 numPlayers; _jparser.validateByNameThrow("numPlayers", numPlayers);
	AtfValidator::validateIntRange(_descr, "numPlayers", numPlayers, 0, 10000000, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::SngSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _parser0.parseUINT32(buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*NGBuyIn_Last-1), _checker, __FILE__, __LINE__);
	INT64 minBuyIn; _parser0.parseINT64(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _parser0.parseINT64(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 speedMask; _parser0.parseUINT32(speedMask);
	AtfValidator::validateIntMax(_descr, "speedMask", speedMask, (2*NGTournSpeed_Last-1), _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _parser0.parseUINT32(currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*NGCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tableSizeMask; _parser0.parseUINT32(tableSizeMask);
	AtfValidator::validateIntMax(_descr, "tableSizeMask", tableSizeMask, (2*NGMaxTableSize_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tournVariantMask; _parser0.parseUINT32(tournVariantMask);
	AtfValidator::validateIntMax(_descr, "tournVariantMask", tournVariantMask, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 tableNumMask; _parser0.parseUINT32(tableNumMask);
	AtfValidator::validateIntMax(_descr, "tableNumMask", tableNumMask, (2*NGTableNum_Last-1), _checker, __FILE__, __LINE__);
	UINT32 gameCategoryMask; _parser0.parseUINT32(gameCategoryMask);
	AtfValidator::validateIntMax(_descr, "gameCategoryMask", gameCategoryMask, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournGroups = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournGroups"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tournGroups", szTournGroups, TournGroup_Last, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 tournStateMask; _parser0.parseUINT32(tournStateMask);
	AtfValidator::validateIntMax(_descr, "tournStateMask", tournStateMask, (2*NGTournState_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 negateTournVariantMask; _parser0.parseUINT32(negateTournVariantMask);
	AtfValidator::validateIntMax(_descr, "negateTournVariantMask", negateTournVariantMask, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 numPlayers; _parser0.parseINT32(numPlayers);
	AtfValidator::validateIntRange(_descr, "numPlayers", numPlayers, 0, 10000000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    WinnerAmountData
//=================================================================

MLobbyNG::cli::WinnerAmountData::WinnerAmountData()
{
	clear();
}

void MLobbyNG::cli::WinnerAmountData::clear()
{
	amount = 0;
	flags = 0;
}

bool MLobbyNG::cli::WinnerAmountData::equals(const WinnerAmountData& _o) const
{
	return amount == _o.amount &&
		flags == _o.flags;
}

const char *MLobbyNG::cli::WinnerAmountData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::WinnerAmountData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::WinnerAmountData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("amount"))
		{
			amount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags"))
		{
			flags = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::WinnerAmountData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(WinnerAmountData())) // not empty
	{
		_body.composeINT32(amount);
		_body.composeBYTE(flags);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::WinnerAmountData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(amount);
	_parser0.parseBYTE(flags);
}

const char *MLobbyNG::cli::WinnerAmountData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("flags", flags);
	return _buf.c_str();
}

void MLobbyNG::cli::WinnerAmountData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("flags", flags);
}

/* static */ void MLobbyNG::cli::WinnerAmountData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	BYTE flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::WinnerAmountData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 amount; _parser0.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	BYTE flags; _parser0.parseBYTE(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PrizeData
//=================================================================

MLobbyNG::cli::PrizeData::PrizeData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::PrizeData::PrizeData(PrizeData&& _o)
	: min(std::move(_o.min))
	, max(std::move(_o.max))
	, numTickets(std::move(_o.numTickets))
	, winners(std::move(_o.winners))
{
}

MLobbyNG::cli::PrizeData& MLobbyNG::cli::PrizeData::operator=(PrizeData&& _o)
{
	if(this != &_o)
	{
		min = std::move(_o.min);
		max = std::move(_o.max);
		numTickets = std::move(_o.numTickets);
		winners = std::move(_o.winners);
	}
	return *this;
}

#endif

void MLobbyNG::cli::PrizeData::clear()
{
	min = 0;
	max = 0;
	numTickets = 0;
	winners.clear();
}

bool MLobbyNG::cli::PrizeData::equals(const PrizeData& _o) const
{
	return min == _o.min &&
		max == _o.max &&
		numTickets == _o.numTickets &&
		winners.equals(_o.winners);
}

const char *MLobbyNG::cli::PrizeData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("min=");
	_buf.appendInt(min);
	_buf.append(',');
	_buf.append("max=");
	_buf.appendInt(max);
	_buf.append(',');
	_buf.append("numTickets=");
	_buf.appendInt(numTickets);
	_buf.append(',');
	_buf.append("winners=");
	winners.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::PrizeData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("min", min, _buf);
	Atf::XmlElement::encodeAsXmlElement("max", max, _buf);
	Atf::XmlElement::encodeAsXmlElement("numTickets", numTickets, _buf);
	winners.toXmlString("winners", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::PrizeData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("min"))
		{
			min = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("max"))
		{
			max = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numTickets"))
		{
			numTickets = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("winners"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< WinnerAmountData, 4 > >::FromXmlString(_value, winners)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::PrizeData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PrizeData())) // not empty
	{
		_body.composeINT32(min);
		_body.composeINT32(max);
		_body.composeINT32(numTickets);
		winners.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::PrizeData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(min);
	_parser0.parseINT32(max);
	_parser0.parseINT32(numTickets);
	winners.parseMsg(_parser0);
}

const char *MLobbyNG::cli::PrizeData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("min", min);
	_jsonstr.compose("max", max);
	_jsonstr.compose("numTickets", numTickets);
	_jsonstr.compose("winners", winners);
	return _buf.c_str();
}

void MLobbyNG::cli::PrizeData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("min", min);
	_jparser.parseByNameThrow("max", max);
	_jparser.parseByNameThrow("numTickets", numTickets);
	_jparser.parseByNameThrow("winners", winners);
}

/* static */ void MLobbyNG::cli::PrizeData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 min; _jparser.validateByNameThrow("min", min);
	AtfValidator::validateInt(_descr, "min", min, _checker, __FILE__, __LINE__);
	INT32 max; _jparser.validateByNameThrow("max", max);
	AtfValidator::validateInt(_descr, "max", max, _checker, __FILE__, __LINE__);
	INT32 numTickets; _jparser.validateByNameThrow("numTickets", numTickets);
	AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< WinnerAmountData > winners; _jparser.validateByNameThrow("winners", winners);
	AtfValidator::validateInt(_descr, "winners", winners.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::PrizeData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 min; _parser0.parseINT32(min);
	AtfValidator::validateInt(_descr, "min", min, _checker, __FILE__, __LINE__);
	INT32 max; _parser0.parseINT32(max);
	AtfValidator::validateInt(_descr, "max", max, _checker, __FILE__, __LINE__);
	INT32 numTickets; _parser0.parseINT32(numTickets);
	AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szWinners = Atf::LAtfVector< WinnerAmountData, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("winners"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "winners", szWinners, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TicketData
//=================================================================

MLobbyNG::cli::TicketData::TicketData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TicketData::TicketData(TicketData&& _o)
	: ticketId(std::move(_o.ticketId))
	, admission(std::move(_o.admission))
{
}

MLobbyNG::cli::TicketData& MLobbyNG::cli::TicketData::operator=(TicketData&& _o)
{
	if(this != &_o)
	{
		ticketId = std::move(_o.ticketId);
		admission = std::move(_o.admission);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TicketData::clear()
{
	ticketId = 0;
	admission.clear();
}

bool MLobbyNG::cli::TicketData::equals(const TicketData& _o) const
{
	return ticketId == _o.ticketId &&
		Atf::atfPStringEquals(admission, _o.admission);
}

const char *MLobbyNG::cli::TicketData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketId=");
	_buf.appendUint(ticketId);
	_buf.append(',');
	_buf.append("admission=");
	_buf.append(admission);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::TicketData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("ticketId", ticketId, _buf);
	Atf::XmlElement::encodeAsXmlElement("admission", admission, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::TicketData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("ticketId"))
		{
			ticketId = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("admission"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, admission)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::TicketData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TicketData())) // not empty
	{
		_body.composeUINT16(ticketId);
		_body.composeString(admission);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TicketData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT16(ticketId);
	_parser0.parseStringP(admission);
}

const char *MLobbyNG::cli::TicketData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketId", ticketId);
	_jsonstr.compose("admission", admission);
	return _buf.c_str();
}

void MLobbyNG::cli::TicketData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketId", ticketId);
	_jparser.parseByNameThrow("admission", admission);
}

/* static */ void MLobbyNG::cli::TicketData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 ticketId; _jparser.validateByNameThrow("ticketId", ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	PString admission; _jparser.validateByNameThrow("admission", admission);
	AtfValidator::validateInt(_descr, "admission", admission.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::TicketData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT16 ticketId; _parser0.parseUINT16(ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "admission"); size_t szAdmission = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admission", szAdmission, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SngDataStruct
//=================================================================

MLobbyNG::cli::SngDataStruct::SngDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SngDataStruct::SngDataStruct(SngDataStruct&& _o)
	: id(std::move(_o.id))
	, tournSites(std::move(_o.tournSites))
	, visible(std::move(_o.visible))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, knockout(std::move(_o.knockout))
	, speedDisplay(std::move(_o.speedDisplay))
	, minPlayers(std::move(_o.minPlayers))
	, countryRestrictionInverted(std::move(_o.countryRestrictionInverted))
	, restrictedCountries(std::move(_o.restrictedCountries))
	, scalePM(std::move(_o.scalePM))
	, brandAccessMask(std::move(_o.brandAccessMask))
	, timedTournType(std::move(_o.timedTournType))
	, timedTournTime(std::move(_o.timedTournTime))
	, visibilityCriteria(std::move(_o.visibilityCriteria))
	, maxPerTable(std::move(_o.maxPerTable))
	, timedTournPlayersPercent(std::move(_o.timedTournPlayersPercent))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlags2(std::move(_o.tournFlags2))
	, satelliteTarget(std::move(_o.satelliteTarget))
	, satelliteTargetReference(std::move(_o.satelliteTargetReference))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, regTournId(std::move(_o.regTournId))
	, mobileName(std::move(_o.mobileName))
	, tournGroup(std::move(_o.tournGroup))
	, maxPlayers(std::move(_o.maxPlayers))
	, lastEntry(std::move(_o.lastEntry))
	, admissions(std::move(_o.admissions))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, prizes(std::move(_o.prizes))
	, tickets(std::move(_o.tickets))
	, awardScheme(std::move(_o.awardScheme))
	, tournGroupName(std::move(_o.tournGroupName))
	, tournGroupRef(std::move(_o.tournGroupRef))
	, tournSitesEx(std::move(_o.tournSitesEx))
	, userHasTicket(std::move(_o.userHasTicket))
{
}

MLobbyNG::cli::SngDataStruct& MLobbyNG::cli::SngDataStruct::operator=(SngDataStruct&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		tournSites = std::move(_o.tournSites);
		visible = std::move(_o.visible);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		knockout = std::move(_o.knockout);
		speedDisplay = std::move(_o.speedDisplay);
		minPlayers = std::move(_o.minPlayers);
		countryRestrictionInverted = std::move(_o.countryRestrictionInverted);
		restrictedCountries = std::move(_o.restrictedCountries);
		scalePM = std::move(_o.scalePM);
		brandAccessMask = std::move(_o.brandAccessMask);
		timedTournType = std::move(_o.timedTournType);
		timedTournTime = std::move(_o.timedTournTime);
		visibilityCriteria = std::move(_o.visibilityCriteria);
		maxPerTable = std::move(_o.maxPerTable);
		timedTournPlayersPercent = std::move(_o.timedTournPlayersPercent);
		tournFlags = std::move(_o.tournFlags);
		tournFlags2 = std::move(_o.tournFlags2);
		satelliteTarget = std::move(_o.satelliteTarget);
		satelliteTargetReference = std::move(_o.satelliteTargetReference);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		regTournId = std::move(_o.regTournId);
		mobileName = std::move(_o.mobileName);
		tournGroup = std::move(_o.tournGroup);
		maxPlayers = std::move(_o.maxPlayers);
		lastEntry = std::move(_o.lastEntry);
		admissions = std::move(_o.admissions);
		fppBuyIn = std::move(_o.fppBuyIn);
		prizes = std::move(_o.prizes);
		tickets = std::move(_o.tickets);
		awardScheme = std::move(_o.awardScheme);
		tournGroupName = std::move(_o.tournGroupName);
		tournGroupRef = std::move(_o.tournGroupRef);
		tournSitesEx = std::move(_o.tournSitesEx);
		userHasTicket = std::move(_o.userHasTicket);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SngDataStruct::clear()
{
	id = 0;
	tournSites = 0;
	visible = false;
	game = 0;
	structure = 0;
	isHiLo = 0;
	isPlayMoney = 0;
	currency.clear();
	buyIn = 0;
	rake = 0;
	knockout = 0;
	speedDisplay = 0;
	minPlayers = 0;
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	scalePM = 0;
	brandAccessMask = 0;
	timedTournType = 0;
	timedTournTime = 0;
	visibilityCriteria.clear();
	maxPerTable = 0;
	timedTournPlayersPercent = 0;
	tournFlags = 0;
	tournFlags2 = 0;
	satelliteTarget = 0;
	satelliteTargetReference.clear();
	tournFlagsServInt = 0;
	regTournId = 0;
	mobileName.clear();
	tournGroup = 0;
	maxPlayers = 0;
	lastEntry.setNull();
	admissions.clear();
	fppBuyIn = 0;
	prizes.clear();
	tickets.clear();
	awardScheme = 0;
	tournGroupName.clear();
	tournGroupRef.clear();
	tournSitesEx.clear();
	userHasTicket = false;
}

bool MLobbyNG::cli::SngDataStruct::equals(const SngDataStruct& _o) const
{
	return id == _o.id &&
		tournSites == _o.tournSites &&
		visible == _o.visible &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		isPlayMoney == _o.isPlayMoney &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		knockout == _o.knockout &&
		speedDisplay == _o.speedDisplay &&
		minPlayers == _o.minPlayers &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		scalePM == _o.scalePM &&
		brandAccessMask == _o.brandAccessMask &&
		timedTournType == _o.timedTournType &&
		timedTournTime == _o.timedTournTime &&
		Atf::atfPStringEquals(visibilityCriteria, _o.visibilityCriteria) &&
		maxPerTable == _o.maxPerTable &&
		timedTournPlayersPercent == _o.timedTournPlayersPercent &&
		tournFlags == _o.tournFlags &&
		tournFlags2 == _o.tournFlags2 &&
		satelliteTarget == _o.satelliteTarget &&
		Atf::atfPStringEquals(satelliteTargetReference, _o.satelliteTargetReference) &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		regTournId == _o.regTournId &&
		Atf::atfPStringEquals(mobileName, _o.mobileName) &&
		tournGroup == _o.tournGroup &&
		maxPlayers == _o.maxPlayers &&
		lastEntry.equals(_o.lastEntry) &&
		admissions.equals(_o.admissions) &&
		fppBuyIn == _o.fppBuyIn &&
		prizes.equals(_o.prizes) &&
		tickets.equals(_o.tickets) &&
		awardScheme == _o.awardScheme &&
		Atf::atfPStringEquals(tournGroupName, _o.tournGroupName) &&
		Atf::atfPStringEquals(tournGroupRef, _o.tournGroupRef) &&
		tournSitesEx.equals(_o.tournSitesEx) &&
		userHasTicket == _o.userHasTicket;
}

const char *MLobbyNG::cli::SngDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("tournSites=");
	_buf.appendUint(tournSites);
	_buf.append(',');
	_buf.append("visible=");
	_buf.appendUint(visible);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt(rake);
	_buf.append(',');
	_buf.append("knockout=");
	_buf.appendInt(knockout);
	_buf.append(',');
	_buf.append("speedDisplay=");
	_buf.appendUint(speedDisplay);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("brandAccessMask=");
	_buf.appendUint(brandAccessMask);
	_buf.append(',');
	_buf.append("timedTournType=");
	_buf.appendUint(timedTournType);
	_buf.append(',');
	_buf.append("timedTournTime=");
	_buf.appendUint(timedTournTime);
	_buf.append(',');
	_buf.append("visibilityCriteria=");
	_buf.append(visibilityCriteria);
	_buf.append(',');
	_buf.append("maxPerTable=");
	_buf.appendUint(maxPerTable);
	_buf.append(',');
	_buf.append("timedTournPlayersPercent=");
	_buf.appendUint(timedTournPlayersPercent);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append(',');
	_buf.append("satelliteTarget=");
	_buf.appendUint(satelliteTarget);
	_buf.append(',');
	_buf.append("satelliteTargetReference=");
	_buf.append(satelliteTargetReference);
	_buf.append(',');
	_buf.append("tournFlagsServInt=");
	_buf.appendUint(tournFlagsServInt);
	_buf.append(',');
	_buf.append("regTournId=");
	_buf.appendUint64(regTournId);
	_buf.append(',');
	_buf.append("mobileName=");
	_buf.append(mobileName);
	_buf.append(',');
	_buf.append("tournGroup=");
	_buf.appendUint(tournGroup);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("lastEntry=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, lastEntry);
	_buf.append(',');
	_buf.append("admissions=");
	admissions.toTraceString(_buf);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendInt(fppBuyIn);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tickets=");
	tickets.toTraceString(_buf);
	_buf.append(',');
	_buf.append("awardScheme=");
	_buf.appendInt(awardScheme);
	_buf.append(',');
	_buf.append("tournGroupName=");
	_buf.append(tournGroupName);
	_buf.append(',');
	_buf.append("tournGroupRef=");
	_buf.append(tournGroupRef);
	_buf.append(',');
	_buf.append("tournSitesEx=");
	tournSitesEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("userHasTicket=");
	_buf.appendUint(userHasTicket);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::SngDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournSites", tournSites, _buf);
	Atf::XmlElement::encodeAsXmlElement("visible", visible, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("knockout", knockout, _buf);
	Atf::XmlElement::encodeAsXmlElement("speedDisplay", speedDisplay, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryRestrictionInverted", countryRestrictionInverted, _buf);
	restrictedCountries.toXmlString("restrictedCountries", _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandAccessMask", brandAccessMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournType", timedTournType, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournTime", timedTournTime, _buf);
	Atf::XmlElement::encodeAsXmlElement("visibilityCriteria", visibilityCriteria, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPerTable", maxPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournPlayersPercent", timedTournPlayersPercent, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTarget", satelliteTarget, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTargetReference", satelliteTargetReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlagsServInt", tournFlagsServInt, _buf);
	Atf::XmlElement::encodeAsXmlElement("regTournId", regTournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("mobileName", mobileName, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournGroup", tournGroup, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "lastEntry", lastEntry);
	admissions.toXmlString("admissions", _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBuyIn", fppBuyIn, _buf);
	prizes.toXmlString("prizes", _buf);
	tickets.toXmlString("tickets", _buf);
	Atf::XmlElement::encodeAsXmlElement("awardScheme", awardScheme, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournGroupName", tournGroupName, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournGroupRef", tournGroupRef, _buf);
	tournSitesEx.toXmlString("tournSitesEx", _buf);
	Atf::XmlElement::encodeAsXmlElement("userHasTicket", userHasTicket, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::SngDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("id"))
		{
			id = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournSites"))
		{
			tournSites = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("visible"))
		{
			visible = (*_value.ptr() == '1');
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("knockout"))
		{
			knockout = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("speedDisplay"))
		{
			speedDisplay = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minPlayers"))
		{
			minPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("countryRestrictionInverted"))
		{
			countryRestrictionInverted = (*_value.ptr() == '1');
		}
		else if (_element.equals("restrictedCountries"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, restrictedCountries)) return false;
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandAccessMask"))
		{
			brandAccessMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timedTournType"))
		{
			timedTournType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timedTournTime"))
		{
			timedTournTime = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("visibilityCriteria"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, visibilityCriteria)) return false;
		}
		else if (_element.equals("maxPerTable"))
		{
			maxPerTable = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timedTournPlayersPercent"))
		{
			timedTournPlayersPercent = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlags"))
		{
			tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlags2"))
		{
			tournFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("satelliteTarget"))
		{
			satelliteTarget = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("satelliteTargetReference"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, satelliteTargetReference)) return false;
		}
		else if (_element.equals("tournFlagsServInt"))
		{
			tournFlagsServInt = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("regTournId"))
		{
			regTournId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("mobileName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, mobileName)) return false;
		}
		else if (_element.equals("tournGroup"))
		{
			tournGroup = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayers"))
		{
			maxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lastEntry"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, lastEntry);
		}
		else if (_element.equals("admissions"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, admissions)) return false;
		}
		else if (_element.equals("fppBuyIn"))
		{
			fppBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PrizeData, 4 > >::FromXmlString(_value, prizes)) return false;
		}
		else if (_element.equals("tickets"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TicketData, 4 > >::FromXmlString(_value, tickets)) return false;
		}
		else if (_element.equals("awardScheme"))
		{
			awardScheme = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournGroupName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tournGroupName)) return false;
		}
		else if (_element.equals("tournGroupRef"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tournGroupRef)) return false;
		}
		else if (_element.equals("tournSitesEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, tournSitesEx)) return false;
		}
		else if (_element.equals("userHasTicket"))
		{
			userHasTicket = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::SngDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SngDataStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeUINT32(tournSites);
		_body.composeBOOL(visible);
		_body.composeBYTE(game);
		_body.composeBYTE(structure);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(isPlayMoney);
		_body.composeString(currency);
		_body.composeINT32(buyIn);
		_body.composeINT32(rake);
		_body.composeINT32(knockout);
		_body.composeBYTE(speedDisplay);
		_body.composeUINT32(minPlayers);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(scalePM);
		_body.composeUINT32(brandAccessMask);
		_body.composeBYTE(timedTournType);
		_body.composeUINT16(timedTournTime);
		_body.composeString(visibilityCriteria);
		_body.composeUINT32(maxPerTable);
		_body.composeBYTE(timedTournPlayersPercent);
		_body.composeUINT32(tournFlags);
		_body.composeUINT64(tournFlags2);
		_body.composeUINT32(satelliteTarget);
		_body.composeString(satelliteTargetReference);
		_body.composeUINT32(tournFlagsServInt);
		_body.composeUINT64(regTournId);
		_body.composeString(mobileName);
		_body.composeUINT32(tournGroup);
		_body.composeUINT32(maxPlayers);
		_body.composeSrvTime(lastEntry);
		admissions.composeMsg(_body, _ignoreJSON);
		_body.composeINT32(fppBuyIn);
		prizes.composeMsg(_body, _ignoreJSON);
		tickets.composeMsg(_body, _ignoreJSON);
		_body.composeINT32(awardScheme);
		_body.composeString(tournGroupName);
		_body.composeString(tournGroupRef);
		tournSitesEx.composeMsg(_body, _ignoreJSON);
		_body.composeBOOL(userHasTicket);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SngDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseUINT32(tournSites);
	_parser0.parseBOOL(visible);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(buyIn);
	_parser0.parseINT32(rake);
	_parser0.parseINT32(knockout);
	_parser0.parseBYTE(speedDisplay);
	_parser0.parseUINT32(minPlayers);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseUINT32(scalePM);
	_parser0.parseUINT32(brandAccessMask);
	_parser0.parseBYTE(timedTournType);
	_parser0.parseUINT16(timedTournTime);
	_parser0.parseStringP(visibilityCriteria);
	_parser0.parseUINT32(maxPerTable);
	_parser0.parseBYTE(timedTournPlayersPercent);
	_parser0.parseUINT32(tournFlags);
	_parser0.parseUINT64(tournFlags2);
	_parser0.parseUINT32(satelliteTarget);
	_parser0.parseStringP(satelliteTargetReference);
	_parser0.parseUINT32(tournFlagsServInt);
	_parser0.parseUINT64(regTournId);
	_parser0.parseStringP(mobileName);
	_parser0.parseUINT32(tournGroup);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseSrvTime(lastEntry);
	admissions.parseMsg(_parser0);
	_parser0.parseINT32(fppBuyIn);
	prizes.parseMsg(_parser0);
	tickets.parseMsg(_parser0);
	_parser0.parseINT32(awardScheme);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(tournGroupName);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(tournGroupRef);
	if(_parser0.parseEnded()) return;
	tournSitesEx.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(userHasTicket);
}

const char *MLobbyNG::cli::SngDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("tournSites", tournSites);
	_jsonstr.compose("visible", visible);
	_jsonstr.compose("game", game);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("knockout", knockout);
	_jsonstr.compose("speedDisplay", speedDisplay);
	_jsonstr.compose("minPlayers", minPlayers);
	_jsonstr.compose("countryRestrictionInverted", countryRestrictionInverted);
	_jsonstr.compose("restrictedCountries", restrictedCountries);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("brandAccessMask", brandAccessMask);
	_jsonstr.compose("timedTournType", timedTournType);
	_jsonstr.compose("timedTournTime", timedTournTime);
	_jsonstr.compose("visibilityCriteria", visibilityCriteria);
	_jsonstr.compose("maxPerTable", maxPerTable);
	_jsonstr.compose("timedTournPlayersPercent", timedTournPlayersPercent);
	_jsonstr.compose("tournFlags", tournFlags);
	_jsonstr.compose("tournFlags2", tournFlags2);
	_jsonstr.compose("satelliteTarget", satelliteTarget);
	_jsonstr.compose("satelliteTargetReference", satelliteTargetReference);
	_jsonstr.compose("tournFlagsServInt", tournFlagsServInt);
	_jsonstr.compose("regTournId", regTournId);
	_jsonstr.compose("mobileName", mobileName);
	_jsonstr.compose("tournGroup", tournGroup);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("lastEntry", lastEntry);
	_jsonstr.compose("admissions", admissions);
	_jsonstr.compose("fppBuyIn", fppBuyIn);
	_jsonstr.compose("prizes", prizes);
	_jsonstr.compose("tickets", tickets);
	_jsonstr.compose("awardScheme", awardScheme);
	_jsonstr.compose("tournGroupName", tournGroupName);
	_jsonstr.compose("tournGroupRef", tournGroupRef);
	_jsonstr.compose("tournSitesEx", tournSitesEx);
	_jsonstr.compose("userHasTicket", userHasTicket);
	return _buf.c_str();
}

void MLobbyNG::cli::SngDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("tournSites", tournSites);
	_jparser.parseByNameThrow("visible", visible);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("knockout", knockout);
	_jparser.parseByNameThrow("speedDisplay", speedDisplay);
	_jparser.parseByNameThrow("minPlayers", minPlayers);
	_jparser.parseByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	_jparser.parseByNameThrow("restrictedCountries", restrictedCountries);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("brandAccessMask", brandAccessMask);
	_jparser.parseByNameThrow("timedTournType", timedTournType);
	_jparser.parseByNameThrow("timedTournTime", timedTournTime);
	_jparser.parseByNameThrow("visibilityCriteria", visibilityCriteria);
	_jparser.parseByNameThrow("maxPerTable", maxPerTable);
	_jparser.parseByNameThrow("timedTournPlayersPercent", timedTournPlayersPercent);
	_jparser.parseByNameThrow("tournFlags", tournFlags);
	_jparser.parseByNameThrow("tournFlags2", tournFlags2);
	_jparser.parseByNameThrow("satelliteTarget", satelliteTarget);
	_jparser.parseByNameThrow("satelliteTargetReference", satelliteTargetReference);
	_jparser.parseByNameThrow("tournFlagsServInt", tournFlagsServInt);
	_jparser.parseByNameThrow("regTournId", regTournId);
	_jparser.parseByNameThrow("mobileName", mobileName);
	_jparser.parseByNameThrow("tournGroup", tournGroup);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("lastEntry", lastEntry);
	_jparser.parseByNameThrow("admissions", admissions);
	_jparser.parseByNameThrow("fppBuyIn", fppBuyIn);
	_jparser.parseByNameThrow("prizes", prizes);
	_jparser.parseByNameThrow("tickets", tickets);
	_jparser.parseByNameThrow("awardScheme", awardScheme);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tournGroupName", tournGroupName);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tournGroupRef", tournGroupRef);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tournSitesEx", tournSitesEx);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("userHasTicket", userHasTicket);
}

/* static */ void MLobbyNG::cli::SngDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	UINT32 tournSites; _jparser.validateByNameThrow("tournSites", tournSites);
	AtfValidator::validateInt(_descr, "tournSites", tournSites, _checker, __FILE__, __LINE__);
	bool visible; _jparser.validateByNameThrow("visible", visible);
	AtfValidator::validateInt(_descr, "visible", visible, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	INT32 knockout; _jparser.validateByNameThrow("knockout", knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _jparser.validateByNameThrow("speedDisplay", speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _jparser.validateByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > restrictedCountries; _jparser.validateByNameThrow("restrictedCountries", restrictedCountries);
	AtfValidator::validateInt(_descr, "restrictedCountries", restrictedCountries.size(), _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 brandAccessMask; _jparser.validateByNameThrow("brandAccessMask", brandAccessMask);
	AtfValidator::validateInt(_descr, "brandAccessMask", brandAccessMask, _checker, __FILE__, __LINE__);
	BYTE timedTournType; _jparser.validateByNameThrow("timedTournType", timedTournType);
	AtfValidator::validateInt(_descr, "timedTournType", timedTournType, _checker, __FILE__, __LINE__);
	UINT16 timedTournTime; _jparser.validateByNameThrow("timedTournTime", timedTournTime);
	AtfValidator::validateInt(_descr, "timedTournTime", timedTournTime, _checker, __FILE__, __LINE__);
	PString visibilityCriteria; _jparser.validateByNameThrow("visibilityCriteria", visibilityCriteria);
	AtfValidator::validateInt(_descr, "visibilityCriteria", visibilityCriteria.length(), _checker, __FILE__, __LINE__);
	UINT32 maxPerTable; _jparser.validateByNameThrow("maxPerTable", maxPerTable);
	AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
	BYTE timedTournPlayersPercent; _jparser.validateByNameThrow("timedTournPlayersPercent", timedTournPlayersPercent);
	AtfValidator::validateInt(_descr, "timedTournPlayersPercent", timedTournPlayersPercent, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _jparser.validateByNameThrow("satelliteTarget", satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	PString satelliteTargetReference; _jparser.validateByNameThrow("satelliteTargetReference", satelliteTargetReference);
	AtfValidator::validateInt(_descr, "satelliteTargetReference", satelliteTargetReference.length(), _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _jparser.validateByNameThrow("tournFlagsServInt", tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT64 regTournId; _jparser.validateByNameThrow("regTournId", regTournId);
	AtfValidator::validateUint(_descr, "regTournId", regTournId, _checker, __FILE__, __LINE__);
	PString mobileName; _jparser.validateByNameThrow("mobileName", mobileName);
	AtfValidator::validateInt(_descr, "mobileName", mobileName.length(), _checker, __FILE__, __LINE__);
	UINT32 tournGroup; _jparser.validateByNameThrow("tournGroup", tournGroup);
	AtfValidator::validateInt(_descr, "tournGroup", tournGroup, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	SrvTime lastEntry; _jparser.validateByNameThrow("lastEntry", lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > admissions; _jparser.validateByNameThrow("admissions", admissions);
	AtfValidator::validateInt(_descr, "admissions", admissions.size(), _checker, __FILE__, __LINE__);
	INT32 fppBuyIn; _jparser.validateByNameThrow("fppBuyIn", fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PrizeData > prizes; _jparser.validateByNameThrow("prizes", prizes);
	AtfValidator::validateInt(_descr, "prizes", prizes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TicketData > tickets; _jparser.validateByNameThrow("tickets", tickets);
	AtfValidator::validateInt(_descr, "tickets", tickets.size(), _checker, __FILE__, __LINE__);
	INT32 awardScheme; _jparser.validateByNameThrow("awardScheme", awardScheme);
	AtfValidator::validateInt(_descr, "awardScheme", awardScheme, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString tournGroupName; _jparser.validateByNameThrow("tournGroupName", tournGroupName);
	AtfValidator::validateInt(_descr, "tournGroupName", tournGroupName.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString tournGroupRef; _jparser.validateByNameThrow("tournGroupRef", tournGroupRef);
	AtfValidator::validateInt(_descr, "tournGroupRef", tournGroupRef.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask tournSitesEx; _jparser.validateByNameThrow("tournSitesEx", tournSitesEx);
	if(_jparser.parseEnded()) return;
	bool userHasTicket; _jparser.validateByNameThrow("userHasTicket", userHasTicket);
	AtfValidator::validateInt(_descr, "userHasTicket", userHasTicket, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::SngDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	UINT32 tournSites; _parser0.parseUINT32(tournSites);
	AtfValidator::validateInt(_descr, "tournSites", tournSites, _checker, __FILE__, __LINE__);
	bool visible; _parser0.parseBOOL(visible);
	AtfValidator::validateInt(_descr, "visible", visible, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 buyIn; _parser0.parseINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT32 rake; _parser0.parseINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	INT32 knockout; _parser0.parseINT32(knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _parser0.parseBYTE(speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser0.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = Atf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 brandAccessMask; _parser0.parseUINT32(brandAccessMask);
	AtfValidator::validateInt(_descr, "brandAccessMask", brandAccessMask, _checker, __FILE__, __LINE__);
	BYTE timedTournType; _parser0.parseBYTE(timedTournType);
	AtfValidator::validateInt(_descr, "timedTournType", timedTournType, _checker, __FILE__, __LINE__);
	UINT16 timedTournTime; _parser0.parseUINT16(timedTournTime);
	AtfValidator::validateInt(_descr, "timedTournTime", timedTournTime, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "visibilityCriteria"); size_t szVisibilityCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "visibilityCriteria", szVisibilityCriteria, _checker, __FILE__, __LINE__);
	UINT32 maxPerTable; _parser0.parseUINT32(maxPerTable);
	AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
	BYTE timedTournPlayersPercent; _parser0.parseBYTE(timedTournPlayersPercent);
	AtfValidator::validateInt(_descr, "timedTournPlayersPercent", timedTournPlayersPercent, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser0.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _parser0.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _parser0.parseUINT32(satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "satelliteTargetReference"); size_t szSatelliteTargetReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetReference", szSatelliteTargetReference, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _parser0.parseUINT32(tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT64 regTournId; _parser0.parseUINT64(regTournId);
	AtfValidator::validateUint(_descr, "regTournId", regTournId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "mobileName"); size_t szMobileName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "mobileName", szMobileName, _checker, __FILE__, __LINE__);
	UINT32 tournGroup; _parser0.parseUINT32(tournGroup);
	AtfValidator::validateInt(_descr, "tournGroup", tournGroup, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	SrvTime lastEntry; _parser0.parseSrvTime(lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	int szAdmissions = Atf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("admissions"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "admissions", szAdmissions, _checker, __FILE__, __LINE__);
	INT32 fppBuyIn; _parser0.parseINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	int szPrizes = Atf::LAtfVector< PrizeData, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
	int szTickets = Atf::LAtfVector< TicketData, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
	INT32 awardScheme; _parser0.parseINT32(awardScheme);
	AtfValidator::validateInt(_descr, "awardScheme", awardScheme, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "tournGroupName"); size_t szTournGroupName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournGroupName", szTournGroupName, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "tournGroupRef"); size_t szTournGroupRef = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournGroupRef", szTournGroupRef, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournSitesEx"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	bool userHasTicket; _parser0.parseBOOL(userHasTicket);
	AtfValidator::validateInt(_descr, "userHasTicket", userHasTicket, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ActivityStruct
//=================================================================

MLobbyNG::cli::ActivityStruct::ActivityStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::ActivityStruct::ActivityStruct(ActivityStruct&& _o)
	: eventTime(std::move(_o.eventTime))
	, gameCategory(std::move(_o.gameCategory))
	, handType(std::move(_o.handType))
	, limit(std::move(_o.limit))
	, minPlayers(std::move(_o.minPlayers))
	, maxPlayers(std::move(_o.maxPlayers))
	, playersPerTable(std::move(_o.playersPerTable))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, buyIn(std::move(_o.buyIn))
	, speed(std::move(_o.speed))
	, tournVariant(std::move(_o.tournVariant))
	, strRef(std::move(_o.strRef))
	, flags(std::move(_o.flags))
	, currency(std::move(_o.currency))
{
}

MLobbyNG::cli::ActivityStruct& MLobbyNG::cli::ActivityStruct::operator=(ActivityStruct&& _o)
{
	if(this != &_o)
	{
		eventTime = std::move(_o.eventTime);
		gameCategory = std::move(_o.gameCategory);
		handType = std::move(_o.handType);
		limit = std::move(_o.limit);
		minPlayers = std::move(_o.minPlayers);
		maxPlayers = std::move(_o.maxPlayers);
		playersPerTable = std::move(_o.playersPerTable);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		buyIn = std::move(_o.buyIn);
		speed = std::move(_o.speed);
		tournVariant = std::move(_o.tournVariant);
		strRef = std::move(_o.strRef);
		flags = std::move(_o.flags);
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void MLobbyNG::cli::ActivityStruct::clear()
{
	eventTime.setNull();
	gameCategory = 0;
	handType = 0;
	limit = 0;
	minPlayers = 0;
	maxPlayers = 0;
	playersPerTable = 0;
	loBet = 0;
	hiBet = 0;
	buyIn = 0;
	speed = 0;
	tournVariant = 0;
	strRef.clear();
	flags = 0;
	currency.clear();
}

bool MLobbyNG::cli::ActivityStruct::equals(const ActivityStruct& _o) const
{
	return eventTime.equals(_o.eventTime) &&
		gameCategory == _o.gameCategory &&
		handType == _o.handType &&
		limit == _o.limit &&
		minPlayers == _o.minPlayers &&
		maxPlayers == _o.maxPlayers &&
		playersPerTable == _o.playersPerTable &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		buyIn == _o.buyIn &&
		speed == _o.speed &&
		tournVariant == _o.tournVariant &&
		Atf::atfPStringEquals(strRef, _o.strRef) &&
		flags == _o.flags &&
		Atf::atfPStringEquals(currency, _o.currency);
}

const char *MLobbyNG::cli::ActivityStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("eventTime=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, eventTime);
	_buf.append(',');
	_buf.append("gameCategory=");
	_buf.appendUint(gameCategory);
	_buf.append(',');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("playersPerTable=");
	_buf.appendUint(playersPerTable);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt64(buyIn);
	_buf.append(',');
	_buf.append("speed=");
	_buf.appendUint(speed);
	_buf.append(',');
	_buf.append("tournVariant=");
	_buf.appendUint(tournVariant);
	_buf.append(',');
	_buf.append("strRef=");
	_buf.append(strRef);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::ActivityStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "eventTime", eventTime);
	Atf::XmlElement::encodeAsXmlElement("gameCategory", gameCategory, _buf);
	Atf::XmlElement::encodeAsXmlElement("handType", handType, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("playersPerTable", playersPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("speed", speed, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournVariant", tournVariant, _buf);
	Atf::XmlElement::encodeAsXmlElement("strRef", strRef, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::ActivityStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("eventTime"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, eventTime);
		}
		else if (_element.equals("gameCategory"))
		{
			gameCategory = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handType"))
		{
			handType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("limit"))
		{
			limit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minPlayers"))
		{
			minPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayers"))
		{
			maxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playersPerTable"))
		{
			playersPerTable = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("loBet"))
		{
			loBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("speed"))
		{
			speed = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournVariant"))
		{
			tournVariant = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("strRef"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, strRef)) return false;
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::ActivityStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ActivityStruct())) // not empty
	{
		_body.composeSrvTime(eventTime);
		_body.composeUINT32(gameCategory);
		_body.composeBYTE(handType);
		_body.composeBYTE(limit);
		_body.composeUINT32(minPlayers);
		_body.composeUINT32(maxPlayers);
		_body.composeUINT16(playersPerTable);
		_body.composeUINT32(loBet);
		_body.composeUINT32(hiBet);
		_body.composeINT64(buyIn);
		_body.composeUINT16(speed);
		_body.composeUINT32(tournVariant);
		_body.composeString(strRef);
		_body.composeUINT32(flags);
		_body.composeString(currency);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::ActivityStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseSrvTime(eventTime);
	_parser0.parseUINT32(gameCategory);
	_parser0.parseBYTE(handType);
	_parser0.parseBYTE(limit);
	_parser0.parseUINT32(minPlayers);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseUINT16(playersPerTable);
	_parser0.parseUINT32(loBet);
	_parser0.parseUINT32(hiBet);
	_parser0.parseINT64(buyIn);
	_parser0.parseUINT16(speed);
	_parser0.parseUINT32(tournVariant);
	_parser0.parseStringP(strRef);
	_parser0.parseUINT32(flags);
	_parser0.parseStringP(currency);
}

const char *MLobbyNG::cli::ActivityStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("eventTime", eventTime);
	_jsonstr.compose("gameCategory", gameCategory);
	_jsonstr.compose("handType", handType);
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("minPlayers", minPlayers);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("playersPerTable", playersPerTable);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("speed", speed);
	_jsonstr.compose("tournVariant", tournVariant);
	_jsonstr.compose("strRef", strRef);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void MLobbyNG::cli::ActivityStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("eventTime", eventTime);
	_jparser.parseByNameThrow("gameCategory", gameCategory);
	_jparser.parseByNameThrow("handType", handType);
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("minPlayers", minPlayers);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("playersPerTable", playersPerTable);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("speed", speed);
	_jparser.parseByNameThrow("tournVariant", tournVariant);
	_jparser.parseByNameThrow("strRef", strRef);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("currency", currency);
}

/* static */ void MLobbyNG::cli::ActivityStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime eventTime; _jparser.validateByNameThrow("eventTime", eventTime);
	AtfValidator::validateSrvDateTime(_descr, "eventTime", eventTime, _checker, __FILE__, __LINE__);
	UINT32 gameCategory; _jparser.validateByNameThrow("gameCategory", gameCategory);
	AtfValidator::validateIntMax(_descr, "gameCategory", gameCategory, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	BYTE handType; _jparser.validateByNameThrow("handType", handType);
	AtfValidator::validateIntMax(_descr, "handType", handType, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateIntMax(_descr, "limit", limit, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
	AtfValidator::validateIntMax(_descr, "minPlayers", minPlayers, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateIntMax(_descr, "maxPlayers", maxPlayers, 2000000000, _checker, __FILE__, __LINE__);
	UINT16 playersPerTable; _jparser.validateByNameThrow("playersPerTable", playersPerTable);
	AtfValidator::validateIntMax(_descr, "playersPerTable", playersPerTable, 10, _checker, __FILE__, __LINE__);
	UINT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT64 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT16 speed; _jparser.validateByNameThrow("speed", speed);
	AtfValidator::validateIntMax(_descr, "speed", speed, SpeedDisplay_LastSlot, _checker, __FILE__, __LINE__);
	UINT32 tournVariant; _jparser.validateByNameThrow("tournVariant", tournVariant);
	AtfValidator::validateIntMax(_descr, "tournVariant", tournVariant, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	PString strRef; _jparser.validateByNameThrow("strRef", strRef);
	AtfValidator::validateIntMax(_descr, "strRef", strRef.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), 7, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::ActivityStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	SrvTime eventTime; _parser0.parseSrvTime(eventTime);
	AtfValidator::validateSrvDateTime(_descr, "eventTime", eventTime, _checker, __FILE__, __LINE__);
	UINT32 gameCategory; _parser0.parseUINT32(gameCategory);
	AtfValidator::validateIntMax(_descr, "gameCategory", gameCategory, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	BYTE handType; _parser0.parseBYTE(handType);
	AtfValidator::validateIntMax(_descr, "handType", handType, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE limit; _parser0.parseBYTE(limit);
	AtfValidator::validateIntMax(_descr, "limit", limit, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser0.parseUINT32(minPlayers);
	AtfValidator::validateIntMax(_descr, "minPlayers", minPlayers, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateIntMax(_descr, "maxPlayers", maxPlayers, 2000000000, _checker, __FILE__, __LINE__);
	UINT16 playersPerTable; _parser0.parseUINT16(playersPerTable);
	AtfValidator::validateIntMax(_descr, "playersPerTable", playersPerTable, 10, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser0.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser0.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT64 buyIn; _parser0.parseINT64(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT16 speed; _parser0.parseUINT16(speed);
	AtfValidator::validateIntMax(_descr, "speed", speed, SpeedDisplay_LastSlot, _checker, __FILE__, __LINE__);
	UINT32 tournVariant; _parser0.parseUINT32(tournVariant);
	AtfValidator::validateIntMax(_descr, "tournVariant", tournVariant, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "strRef"); size_t szStrRef = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "strRef", szStrRef, 20, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 7, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    GameListFilter
//=================================================================

MLobbyNG::cli::GameListFilter::GameListFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::GameListFilter::GameListFilter(GameListFilter&& _o)
	: locale(std::move(_o.locale))
	, siteId(std::move(_o.siteId))
	, brandId(std::move(_o.brandId))
	, country(std::move(_o.country))
	, state(std::move(_o.state))
	, isPM(std::move(_o.isPM))
{
}

MLobbyNG::cli::GameListFilter& MLobbyNG::cli::GameListFilter::operator=(GameListFilter&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		siteId = std::move(_o.siteId);
		brandId = std::move(_o.brandId);
		country = std::move(_o.country);
		state = std::move(_o.state);
		isPM = std::move(_o.isPM);
	}
	return *this;
}

#endif

void MLobbyNG::cli::GameListFilter::clear()
{
	locale = 0;
	siteId = 0;
	brandId = 0;
	country.clear();
	state.clear();
	isPM = false;
}

bool MLobbyNG::cli::GameListFilter::equals(const GameListFilter& _o) const
{
	return locale == _o.locale &&
		siteId == _o.siteId &&
		brandId == _o.brandId &&
		Atf::atfPStringEquals(country, _o.country) &&
		Atf::atfPStringEquals(state, _o.state) &&
		isPM == _o.isPM;
}

const char *MLobbyNG::cli::GameListFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::GameListFilter::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandId", brandId, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPM", isPM, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::GameListFilter::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("locale"))
		{
			locale = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("siteId"))
		{
			siteId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandId"))
		{
			brandId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("state"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
		}
		else if (_element.equals("isPM"))
		{
			isPM = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::GameListFilter::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(GameListFilter())) // not empty
	{
		_body.composeUINT32(locale);
		_body.composeUINT32(siteId);
		_body.composeUINT32(brandId);
		_body.composeString(country);
		_body.composeString(state);
		_body.composeBOOL(isPM);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::GameListFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(brandId);
	_parser0.parseStringP(country);
	_parser0.parseStringP(state);
	_parser0.parseBOOL(isPM);
}

const char *MLobbyNG::cli::GameListFilter::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("brandId", brandId);
	_jsonstr.compose("country", country);
	_jsonstr.compose("state", state);
	_jsonstr.compose("isPM", isPM);
	return _buf.c_str();
}

void MLobbyNG::cli::GameListFilter::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("brandId", brandId);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("isPM", isPM);
}

/* static */ void MLobbyNG::cli::GameListFilter::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 brandId; _jparser.validateByNameThrow("brandId", brandId);
	AtfValidator::validateIntMax(_descr, "brandId", brandId, BrandType_Last, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), 7, _checker, __FILE__, __LINE__);
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateIntMax(_descr, "state", state.length(), 50, _checker, __FILE__, __LINE__);
	bool isPM; _jparser.validateByNameThrow("isPM", isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::GameListFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateIntMax(_descr, "brandId", brandId, BrandType_Last, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 7, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, 50, _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SuggestedGamesSelectionFilter
//=================================================================

MLobbyNG::cli::SuggestedGamesSelectionFilter::SuggestedGamesSelectionFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SuggestedGamesSelectionFilter::SuggestedGamesSelectionFilter(SuggestedGamesSelectionFilter&& _o)
	: locale(std::move(_o.locale))
	, country(std::move(_o.country))
	, isPM(std::move(_o.isPM))
	, tournMedianValue(std::move(_o.tournMedianValue))
	, sngMedianValue(std::move(_o.sngMedianValue))
	, ringMedianValue(std::move(_o.ringMedianValue))
	, tournFilter(std::move(_o.tournFilter))
	, tableFilter(std::move(_o.tableFilter))
	, sngFilter(std::move(_o.sngFilter))
{
}

MLobbyNG::cli::SuggestedGamesSelectionFilter& MLobbyNG::cli::SuggestedGamesSelectionFilter::operator=(SuggestedGamesSelectionFilter&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		country = std::move(_o.country);
		isPM = std::move(_o.isPM);
		tournMedianValue = std::move(_o.tournMedianValue);
		sngMedianValue = std::move(_o.sngMedianValue);
		ringMedianValue = std::move(_o.ringMedianValue);
		tournFilter = std::move(_o.tournFilter);
		tableFilter = std::move(_o.tableFilter);
		sngFilter = std::move(_o.sngFilter);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SuggestedGamesSelectionFilter::clear()
{
	locale = 0;
	country.clear();
	isPM = false;
	tournMedianValue = 0;
	sngMedianValue = 0;
	ringMedianValue = 0;
	tournFilter.clear();
	tableFilter.clear();
	sngFilter.clear();
}

bool MLobbyNG::cli::SuggestedGamesSelectionFilter::equals(const SuggestedGamesSelectionFilter& _o) const
{
	return locale == _o.locale &&
		Atf::atfPStringEquals(country, _o.country) &&
		isPM == _o.isPM &&
		tournMedianValue == _o.tournMedianValue &&
		sngMedianValue == _o.sngMedianValue &&
		ringMedianValue == _o.ringMedianValue &&
		tournFilter.equals(_o.tournFilter) &&
		tableFilter.equals(_o.tableFilter) &&
		sngFilter.equals(_o.sngFilter);
}

const char *MLobbyNG::cli::SuggestedGamesSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("tournMedianValue=");
	_buf.appendInt64(tournMedianValue);
	_buf.append(',');
	_buf.append("sngMedianValue=");
	_buf.appendInt64(sngMedianValue);
	_buf.append(',');
	_buf.append("ringMedianValue=");
	_buf.appendInt64(ringMedianValue);
	_buf.append(',');
	_buf.append("tournFilter=");
	tournFilter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFilter=");
	tableFilter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngFilter=");
	sngFilter.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::SuggestedGamesSelectionFilter::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPM", isPM, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMedianValue", tournMedianValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("sngMedianValue", sngMedianValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("ringMedianValue", ringMedianValue, _buf);
	tournFilter.toXmlString("tournFilter", _buf);
	tableFilter.toXmlString("tableFilter", _buf);
	sngFilter.toXmlString("sngFilter", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::SuggestedGamesSelectionFilter::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("locale"))
		{
			locale = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("isPM"))
		{
			isPM = (*_value.ptr() == '1');
		}
		else if (_element.equals("tournMedianValue"))
		{
			tournMedianValue = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sngMedianValue"))
		{
			sngMedianValue = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ringMedianValue"))
		{
			ringMedianValue = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFilter"))
		{
			if(!Atf::AtfTempl< TournSelectionFilter >::FromXmlString(_value, tournFilter)) return false;
		}
		else if (_element.equals("tableFilter"))
		{
			if(!Atf::AtfTempl< TableSelectionFilter >::FromXmlString(_value, tableFilter)) return false;
		}
		else if (_element.equals("sngFilter"))
		{
			if(!Atf::AtfTempl< SngSelectionFilter >::FromXmlString(_value, sngFilter)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::SuggestedGamesSelectionFilter::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SuggestedGamesSelectionFilter())) // not empty
	{
		_body.composeUINT32(locale);
		_body.composeString(country);
		_body.composeBOOL(isPM);
		_body.composeINT64(tournMedianValue);
		_body.composeINT64(sngMedianValue);
		_body.composeINT64(ringMedianValue);
		tournFilter.composeMsg(_body, _ignoreJSON);
		tableFilter.composeMsg(_body, _ignoreJSON);
		sngFilter.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SuggestedGamesSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	_parser0.parseStringP(country);
	_parser0.parseBOOL(isPM);
	_parser0.parseINT64(tournMedianValue);
	_parser0.parseINT64(sngMedianValue);
	_parser0.parseINT64(ringMedianValue);
	tournFilter.parseMsg(_parser0);
	tableFilter.parseMsg(_parser0);
	sngFilter.parseMsg(_parser0);
}

const char *MLobbyNG::cli::SuggestedGamesSelectionFilter::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("country", country);
	_jsonstr.compose("isPM", isPM);
	_jsonstr.compose("tournMedianValue", tournMedianValue);
	_jsonstr.compose("sngMedianValue", sngMedianValue);
	_jsonstr.compose("ringMedianValue", ringMedianValue);
	_jsonstr.compose("tournFilter", tournFilter);
	_jsonstr.compose("tableFilter", tableFilter);
	_jsonstr.compose("sngFilter", sngFilter);
	return _buf.c_str();
}

void MLobbyNG::cli::SuggestedGamesSelectionFilter::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("isPM", isPM);
	_jparser.parseByNameThrow("tournMedianValue", tournMedianValue);
	_jparser.parseByNameThrow("sngMedianValue", sngMedianValue);
	_jparser.parseByNameThrow("ringMedianValue", ringMedianValue);
	_jparser.parseByNameThrow("tournFilter", tournFilter);
	_jparser.parseByNameThrow("tableFilter", tableFilter);
	_jparser.parseByNameThrow("sngFilter", sngFilter);
}

/* static */ void MLobbyNG::cli::SuggestedGamesSelectionFilter::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), 3, _checker, __FILE__, __LINE__);
	bool isPM; _jparser.validateByNameThrow("isPM", isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	INT64 tournMedianValue; _jparser.validateByNameThrow("tournMedianValue", tournMedianValue);
	AtfValidator::validateInt(_descr, "tournMedianValue", tournMedianValue, _checker, __FILE__, __LINE__);
	INT64 sngMedianValue; _jparser.validateByNameThrow("sngMedianValue", sngMedianValue);
	AtfValidator::validateInt(_descr, "sngMedianValue", sngMedianValue, _checker, __FILE__, __LINE__);
	INT64 ringMedianValue; _jparser.validateByNameThrow("ringMedianValue", ringMedianValue);
	AtfValidator::validateInt(_descr, "ringMedianValue", ringMedianValue, _checker, __FILE__, __LINE__);
	TournSelectionFilter tournFilter; _jparser.validateByNameThrow("tournFilter", tournFilter);
	TableSelectionFilter tableFilter; _jparser.validateByNameThrow("tableFilter", tableFilter);
	SngSelectionFilter sngFilter; _jparser.validateByNameThrow("sngFilter", sngFilter);
}

/*static*/ void MLobbyNG::cli::SuggestedGamesSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	INT64 tournMedianValue; _parser0.parseINT64(tournMedianValue);
	AtfValidator::validateInt(_descr, "tournMedianValue", tournMedianValue, _checker, __FILE__, __LINE__);
	INT64 sngMedianValue; _parser0.parseINT64(sngMedianValue);
	AtfValidator::validateInt(_descr, "sngMedianValue", sngMedianValue, _checker, __FILE__, __LINE__);
	INT64 ringMedianValue; _parser0.parseINT64(ringMedianValue);
	AtfValidator::validateInt(_descr, "ringMedianValue", ringMedianValue, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TournSelectionFilter::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournFilter"), _fieldsWithUnparsedContent);
	TableSelectionFilter::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableFilter"), _fieldsWithUnparsedContent);
	SngSelectionFilter::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sngFilter"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FilterCountKey
//=================================================================

// @Override
bool MLobbyNG::cli::FilterCountKey::operator<(const FilterCountKey& rhs) const
{
	if( intVal1 == rhs.intVal1 )
	{
		if( intVal2 == rhs.intVal2 )
		{
			return intVal3 < rhs.intVal3;
		}

		return intVal2 < rhs.intVal2;
	}
	
	return intVal1 < rhs.intVal1;
}

MLobbyNG::cli::FilterCountKey::FilterCountKey()
{
	clear();
}

void MLobbyNG::cli::FilterCountKey::clear()
{
	intVal1 = 0;
	intVal2 = 0;
	intVal3 = 0;
}

bool MLobbyNG::cli::FilterCountKey::equals(const FilterCountKey& _o) const
{
	return intVal1 == _o.intVal1 &&
		intVal2 == _o.intVal2 &&
		intVal3 == _o.intVal3;
}

const char *MLobbyNG::cli::FilterCountKey::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("intVal1=");
	_buf.appendInt64(intVal1);
	_buf.append(',');
	_buf.append("intVal2=");
	_buf.appendInt64(intVal2);
	_buf.append(',');
	_buf.append("intVal3=");
	_buf.appendInt64(intVal3);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::FilterCountKey::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("intVal1", intVal1, _buf);
	Atf::XmlElement::encodeAsXmlElement("intVal2", intVal2, _buf);
	Atf::XmlElement::encodeAsXmlElement("intVal3", intVal3, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::FilterCountKey::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("intVal1"))
		{
			intVal1 = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("intVal2"))
		{
			intVal2 = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("intVal3"))
		{
			intVal3 = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::FilterCountKey::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FilterCountKey())) // not empty
	{
		_body.composeINT64(intVal1);
		_body.composeINT64(intVal2);
		_body.composeINT64(intVal3);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::FilterCountKey::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(intVal1);
	_parser0.parseINT64(intVal2);
	_parser0.parseINT64(intVal3);
}

const char *MLobbyNG::cli::FilterCountKey::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("intVal1", intVal1);
	_jsonstr.compose("intVal2", intVal2);
	_jsonstr.compose("intVal3", intVal3);
	return _buf.c_str();
}

void MLobbyNG::cli::FilterCountKey::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("intVal1", intVal1);
	_jparser.parseByNameThrow("intVal2", intVal2);
	_jparser.parseByNameThrow("intVal3", intVal3);
}

/* static */ void MLobbyNG::cli::FilterCountKey::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 intVal1; _jparser.validateByNameThrow("intVal1", intVal1);
	AtfValidator::validateInt(_descr, "intVal1", intVal1, _checker, __FILE__, __LINE__);
	INT64 intVal2; _jparser.validateByNameThrow("intVal2", intVal2);
	AtfValidator::validateInt(_descr, "intVal2", intVal2, _checker, __FILE__, __LINE__);
	INT64 intVal3; _jparser.validateByNameThrow("intVal3", intVal3);
	AtfValidator::validateInt(_descr, "intVal3", intVal3, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::FilterCountKey::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT64 intVal1; _parser0.parseINT64(intVal1);
	AtfValidator::validateInt(_descr, "intVal1", intVal1, _checker, __FILE__, __LINE__);
	INT64 intVal2; _parser0.parseINT64(intVal2);
	AtfValidator::validateInt(_descr, "intVal2", intVal2, _checker, __FILE__, __LINE__);
	INT64 intVal3; _parser0.parseINT64(intVal3);
	AtfValidator::validateInt(_descr, "intVal3", intVal3, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FilterCountInfo
//=================================================================

MLobbyNG::cli::FilterCountInfo::FilterCountInfo()
{
	clear();
}

void MLobbyNG::cli::FilterCountInfo::clear()
{
	key.clear();
	value = 0;
}

bool MLobbyNG::cli::FilterCountInfo::equals(const FilterCountInfo& _o) const
{
	return key.equals(_o.key) &&
		value == _o.value;
}

const char *MLobbyNG::cli::FilterCountInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("key=");
	key.toTraceString(_buf);
	_buf.append(',');
	_buf.append("value=");
	_buf.appendInt64(value);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::FilterCountInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	key.toXmlString("key", _buf);
	Atf::XmlElement::encodeAsXmlElement("value", value, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::FilterCountInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("key"))
		{
			if(!Atf::AtfTempl< FilterCountKey >::FromXmlString(_value, key)) return false;
		}
		else if (_element.equals("value"))
		{
			value = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::FilterCountInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FilterCountInfo())) // not empty
	{
		key.composeMsg(_body, _ignoreJSON);
		_body.composeINT64(value);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::FilterCountInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	key.parseMsg(_parser0);
	_parser0.parseINT64(value);
}

const char *MLobbyNG::cli::FilterCountInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("key", key);
	_jsonstr.compose("value", value);
	return _buf.c_str();
}

void MLobbyNG::cli::FilterCountInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("key", key);
	_jparser.parseByNameThrow("value", value);
}

/* static */ void MLobbyNG::cli::FilterCountInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	FilterCountKey key; _jparser.validateByNameThrow("key", key);
	INT64 value; _jparser.validateByNameThrow("value", value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::FilterCountInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	FilterCountKey::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("key"), _fieldsWithUnparsedContent);
	INT64 value; _parser0.parseINT64(value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    GameConnInfoReqStruct
//=================================================================

MLobbyNG::cli::GameConnInfoReqStruct::GameConnInfoReqStruct()
{
	clear();
}

void MLobbyNG::cli::GameConnInfoReqStruct::clear()
{
	gameId = 0;
	category = 0;
	ngSagFlags = 0;
}

bool MLobbyNG::cli::GameConnInfoReqStruct::equals(const GameConnInfoReqStruct& _o) const
{
	return gameId == _o.gameId &&
		category == _o.category &&
		ngSagFlags == _o.ngSagFlags;
}

const char *MLobbyNG::cli::GameConnInfoReqStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("category=");
	_buf.appendUint(category);
	_buf.append(',');
	_buf.append("ngSagFlags=");
	_buf.appendUint(ngSagFlags);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::GameConnInfoReqStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameId", gameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("category", category, _buf);
	Atf::XmlElement::encodeAsXmlElement("ngSagFlags", ngSagFlags, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::GameConnInfoReqStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameId"))
		{
			gameId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("category"))
		{
			category = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ngSagFlags"))
		{
			ngSagFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::GameConnInfoReqStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(GameConnInfoReqStruct())) // not empty
	{
		_body.composeUINT64(gameId);
		_body.composeUINT32(category);
		_body.composeUINT32(ngSagFlags);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::GameConnInfoReqStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(gameId);
	_parser0.parseUINT32(category);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(ngSagFlags);
}

const char *MLobbyNG::cli::GameConnInfoReqStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameId", gameId);
	_jsonstr.compose("category", category);
	_jsonstr.compose("ngSagFlags", ngSagFlags);
	return _buf.c_str();
}

void MLobbyNG::cli::GameConnInfoReqStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameId", gameId);
	_jparser.parseByNameThrow("category", category);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("ngSagFlags", ngSagFlags);
}

/* static */ void MLobbyNG::cli::GameConnInfoReqStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 gameId; _jparser.validateByNameThrow("gameId", gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 category; _jparser.validateByNameThrow("category", category);
	AtfValidator::validateIntMax(_descr, "category", category, GameCategory_Last, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 ngSagFlags; _jparser.validateByNameThrow("ngSagFlags", ngSagFlags);
	AtfValidator::validateIntMax(_descr, "ngSagFlags", ngSagFlags, (2*NGSAGFlag_Last-1), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::GameConnInfoReqStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT64 gameId; _parser0.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 category; _parser0.parseUINT32(category);
	AtfValidator::validateIntMax(_descr, "category", category, GameCategory_Last, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 ngSagFlags; _parser0.parseUINT32(ngSagFlags);
	AtfValidator::validateIntMax(_descr, "ngSagFlags", ngSagFlags, (2*NGSAGFlag_Last-1), _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    GameConnectInfo
//=================================================================

MLobbyNG::cli::GameConnectInfo::GameConnectInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::GameConnectInfo::GameConnectInfo(GameConnectInfo&& _o)
	: gameId(std::move(_o.gameId))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, scriptId(std::move(_o.scriptId))
	, category(std::move(_o.category))
	, shouldOpen(std::move(_o.shouldOpen))
{
}

MLobbyNG::cli::GameConnectInfo& MLobbyNG::cli::GameConnectInfo::operator=(GameConnectInfo&& _o)
{
	if(this != &_o)
	{
		gameId = std::move(_o.gameId);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		scriptId = std::move(_o.scriptId);
		category = std::move(_o.category);
		shouldOpen = std::move(_o.shouldOpen);
	}
	return *this;
}

#endif

void MLobbyNG::cli::GameConnectInfo::clear()
{
	gameId = 0;
	server.clear();
	serverObject.clear();
	scriptId = 0;
	category = 0;
	shouldOpen = false;
}

bool MLobbyNG::cli::GameConnectInfo::equals(const GameConnectInfo& _o) const
{
	return gameId == _o.gameId &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObject, _o.serverObject) &&
		scriptId == _o.scriptId &&
		category == _o.category &&
		shouldOpen == _o.shouldOpen;
}

const char *MLobbyNG::cli::GameConnectInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append(',');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	_buf.append(',');
	_buf.append("category=");
	_buf.appendUint(category);
	_buf.append(',');
	_buf.append("shouldOpen=");
	_buf.appendUint(shouldOpen);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::GameConnectInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameId", gameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
	Atf::XmlElement::encodeAsXmlElement("scriptId", scriptId, _buf);
	Atf::XmlElement::encodeAsXmlElement("category", category, _buf);
	Atf::XmlElement::encodeAsXmlElement("shouldOpen", shouldOpen, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::GameConnectInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameId"))
		{
			gameId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("serverObject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
		}
		else if (_element.equals("scriptId"))
		{
			scriptId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("category"))
		{
			category = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("shouldOpen"))
		{
			shouldOpen = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::GameConnectInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(GameConnectInfo())) // not empty
	{
		_body.composeUINT64(gameId);
		_body.composeString(server);
		_body.composeString(serverObject);
		_body.composeUINT32(scriptId);
		_body.composeUINT32(category);
		_body.composeBOOL(shouldOpen);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::GameConnectInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(gameId);
	_parser0.parseStringP(server);
	_parser0.parseStringP(serverObject);
	_parser0.parseUINT32(scriptId);
	_parser0.parseUINT32(category);
	_parser0.parseBOOL(shouldOpen);
}

const char *MLobbyNG::cli::GameConnectInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameId", gameId);
	_jsonstr.compose("server", server);
	_jsonstr.compose("serverObject", serverObject);
	_jsonstr.compose("scriptId", scriptId);
	_jsonstr.compose("category", category);
	_jsonstr.compose("shouldOpen", shouldOpen);
	return _buf.c_str();
}

void MLobbyNG::cli::GameConnectInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameId", gameId);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("serverObject", serverObject);
	_jparser.parseByNameThrow("scriptId", scriptId);
	_jparser.parseByNameThrow("category", category);
	_jparser.parseByNameThrow("shouldOpen", shouldOpen);
}

/* static */ void MLobbyNG::cli::GameConnectInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 gameId; _jparser.validateByNameThrow("gameId", gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
	AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
	UINT32 scriptId; _jparser.validateByNameThrow("scriptId", scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	UINT32 category; _jparser.validateByNameThrow("category", category);
	AtfValidator::validateInt(_descr, "category", category, _checker, __FILE__, __LINE__);
	bool shouldOpen; _jparser.validateByNameThrow("shouldOpen", shouldOpen);
	AtfValidator::validateInt(_descr, "shouldOpen", shouldOpen, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::GameConnectInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT64 gameId; _parser0.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	UINT32 scriptId; _parser0.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	UINT32 category; _parser0.parseUINT32(category);
	AtfValidator::validateInt(_descr, "category", category, _checker, __FILE__, __LINE__);
	bool shouldOpen; _parser0.parseBOOL(shouldOpen);
	AtfValidator::validateInt(_descr, "shouldOpen", shouldOpen, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TicketTournInfo
//=================================================================

MLobbyNG::cli::TicketTournInfo::TicketTournInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TicketTournInfo::TicketTournInfo(TicketTournInfo&& _o)
	: ticketName(std::move(_o.ticketName))
	, tourns(std::move(_o.tourns))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
{
}

MLobbyNG::cli::TicketTournInfo& MLobbyNG::cli::TicketTournInfo::operator=(TicketTournInfo&& _o)
{
	if(this != &_o)
	{
		ticketName = std::move(_o.ticketName);
		tourns = std::move(_o.tourns);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TicketTournInfo::clear()
{
	ticketName.clear();
	tourns.clear();
	sngTypes.clear();
	sagTypes.clear();
}

bool MLobbyNG::cli::TicketTournInfo::equals(const TicketTournInfo& _o) const
{
	return Atf::atfPStringEquals(ticketName, _o.ticketName) &&
		tourns.equals(_o.tourns) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes);
}

const char *MLobbyNG::cli::TicketTournInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketName=");
	_buf.append(ticketName);
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::TicketTournInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("ticketName", ticketName, _buf);
	tourns.toXmlString("tourns", _buf);
	sngTypes.toXmlString("sngTypes", _buf);
	sagTypes.toXmlString("sagTypes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::TicketTournInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("ticketName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, ticketName)) return false;
		}
		else if (_element.equals("tourns"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
		}
		else if (_element.equals("sngTypes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SngDataStruct, 4 > >::FromXmlString(_value, sngTypes)) return false;
		}
		else if (_element.equals("sagTypes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SagDataStruct, 4 > >::FromXmlString(_value, sagTypes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::TicketTournInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TicketTournInfo())) // not empty
	{
		_body.composeString(ticketName);
		tourns.composeMsg(_body, _ignoreJSON);
		sngTypes.composeMsg(_body, _ignoreJSON);
		sagTypes.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TicketTournInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(ticketName);
	tourns.parseMsg(_parser0);
	sngTypes.parseMsg(_parser0);
	sagTypes.parseMsg(_parser0);
}

const char *MLobbyNG::cli::TicketTournInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketName", ticketName);
	_jsonstr.compose("tourns", tourns);
	_jsonstr.compose("sngTypes", sngTypes);
	_jsonstr.compose("sagTypes", sagTypes);
	return _buf.c_str();
}

void MLobbyNG::cli::TicketTournInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketName", ticketName);
	_jparser.parseByNameThrow("tourns", tourns);
	_jparser.parseByNameThrow("sngTypes", sngTypes);
	_jparser.parseByNameThrow("sagTypes", sagTypes);
}

/* static */ void MLobbyNG::cli::TicketTournInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString ticketName; _jparser.validateByNameThrow("ticketName", ticketName);
	AtfValidator::validateInt(_descr, "ticketName", ticketName.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SngDataStruct > sngTypes; _jparser.validateByNameThrow("sngTypes", sngTypes);
	AtfValidator::validateInt(_descr, "sngTypes", sngTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SagDataStruct > sagTypes; _jparser.validateByNameThrow("sagTypes", sagTypes);
	AtfValidator::validateInt(_descr, "sagTypes", sagTypes.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::TicketTournInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "ticketName"); size_t szTicketName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketName", szTicketName, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTourns = Atf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szSngTypes = Atf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = Atf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableStaticDataStruct
//=================================================================

MLobbyNG::cli::TableStaticDataStruct::TableStaticDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TableStaticDataStruct::TableStaticDataStruct(TableStaticDataStruct&& _o)
	: tableId(std::move(_o.tableId))
	, name(std::move(_o.name))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, clubId(std::move(_o.clubId))
	, isOneOnOne(std::move(_o.isOneOnOne))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, maxPlayers(std::move(_o.maxPlayers))
	, visibilityMask(std::move(_o.visibilityMask))
	, tableFlags(std::move(_o.tableFlags))
	, tableInstanceFlags(std::move(_o.tableInstanceFlags))
	, chatLang(std::move(_o.chatLang))
	, structure(std::move(_o.structure))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, ante(std::move(_o.ante))
	, cap(std::move(_o.cap))
	, specialName(std::move(_o.specialName))
	, currency(std::move(_o.currency))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, icon(std::move(_o.icon))
	, filter(std::move(_o.filter))
	, countryRestrictionInverted(std::move(_o.countryRestrictionInverted))
	, restrictedCountries(std::move(_o.restrictedCountries))
	, scalePM(std::move(_o.scalePM))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, tableFlags2(std::move(_o.tableFlags2))
	, isTableStarter(std::move(_o.isTableStarter))
	, brandMask(std::move(_o.brandMask))
	, poolBlockMinHands(std::move(_o.poolBlockMinHands))
	, tableTypeId(std::move(_o.tableTypeId))
	, tableStakes(std::move(_o.tableStakes))
	, variableAntes(std::move(_o.variableAntes))
	, visibilityMaskEx(std::move(_o.visibilityMaskEx))
	, seatFinderId(std::move(_o.seatFinderId))
{
}

MLobbyNG::cli::TableStaticDataStruct& MLobbyNG::cli::TableStaticDataStruct::operator=(TableStaticDataStruct&& _o)
{
	if(this != &_o)
	{
		tableId = std::move(_o.tableId);
		name = std::move(_o.name);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		clubId = std::move(_o.clubId);
		isOneOnOne = std::move(_o.isOneOnOne);
		isPlayMoney = std::move(_o.isPlayMoney);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		maxPlayers = std::move(_o.maxPlayers);
		visibilityMask = std::move(_o.visibilityMask);
		tableFlags = std::move(_o.tableFlags);
		tableInstanceFlags = std::move(_o.tableInstanceFlags);
		chatLang = std::move(_o.chatLang);
		structure = std::move(_o.structure);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		ante = std::move(_o.ante);
		cap = std::move(_o.cap);
		specialName = std::move(_o.specialName);
		currency = std::move(_o.currency);
		minChipsLimit = std::move(_o.minChipsLimit);
		maxBuyIn = std::move(_o.maxBuyIn);
		icon = std::move(_o.icon);
		filter = std::move(_o.filter);
		countryRestrictionInverted = std::move(_o.countryRestrictionInverted);
		restrictedCountries = std::move(_o.restrictedCountries);
		scalePM = std::move(_o.scalePM);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		tableFlags2 = std::move(_o.tableFlags2);
		isTableStarter = std::move(_o.isTableStarter);
		brandMask = std::move(_o.brandMask);
		poolBlockMinHands = std::move(_o.poolBlockMinHands);
		tableTypeId = std::move(_o.tableTypeId);
		tableStakes = std::move(_o.tableStakes);
		variableAntes = std::move(_o.variableAntes);
		visibilityMaskEx = std::move(_o.visibilityMaskEx);
		seatFinderId = std::move(_o.seatFinderId);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TableStaticDataStruct::clear()
{
	tableId = 0;
	name.clear();
	server.clear();
	serverObject.clear();
	clubId = 0;
	isOneOnOne = 0;
	isPlayMoney = 0;
	game = 0;
	isHiLo = 0;
	maxPlayers = 0;
	visibilityMask = 0;
	tableFlags = 0;
	tableInstanceFlags = 0;
	chatLang = 0;
	structure = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	specialName.clear();
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	icon = 0;
	filter = 0;
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	scalePM = 0;
	defaultBuyIn = 0;
	tableFlags2 = 0;
	isTableStarter = false;
	brandMask = 0;
	poolBlockMinHands = 0;
	tableTypeId = 0;
	tableStakes.clear();
	variableAntes.clear();
	visibilityMaskEx.clear();
	seatFinderId = 0;
}

bool MLobbyNG::cli::TableStaticDataStruct::equals(const TableStaticDataStruct& _o) const
{
	return tableId == _o.tableId &&
		Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObject, _o.serverObject) &&
		clubId == _o.clubId &&
		isOneOnOne == _o.isOneOnOne &&
		isPlayMoney == _o.isPlayMoney &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		maxPlayers == _o.maxPlayers &&
		visibilityMask == _o.visibilityMask &&
		tableFlags == _o.tableFlags &&
		tableInstanceFlags == _o.tableInstanceFlags &&
		chatLang == _o.chatLang &&
		structure == _o.structure &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		Atf::atfPStringEquals(specialName, _o.specialName) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		icon == _o.icon &&
		filter == _o.filter &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		scalePM == _o.scalePM &&
		defaultBuyIn == _o.defaultBuyIn &&
		tableFlags2 == _o.tableFlags2 &&
		isTableStarter == _o.isTableStarter &&
		brandMask == _o.brandMask &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		tableTypeId == _o.tableTypeId &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx) &&
		seatFinderId == _o.seatFinderId;
}

const char *MLobbyNG::cli::TableStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("isOneOnOne=");
	_buf.appendUint(isOneOnOne);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("tableInstanceFlags=");
	_buf.appendUint(tableInstanceFlags);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendUint(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("icon=");
	_buf.appendUint(icon);
	_buf.append(',');
	_buf.append("filter=");
	_buf.appendUint(filter);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendUint(defaultBuyIn);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append(',');
	_buf.append("isTableStarter=");
	_buf.appendUint(isTableStarter);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("tableTypeId=");
	_buf.appendUint(tableTypeId);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinderId=");
	_buf.appendUint(seatFinderId);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::TableStaticDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isOneOnOne", isOneOnOne, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("visibilityMask", visibilityMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags", tableFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableInstanceFlags", tableInstanceFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("chatLang", chatLang, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("cap", cap, _buf);
	Atf::XmlElement::encodeAsXmlElement("specialName", specialName, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("minChipsLimit", minChipsLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("icon", icon, _buf);
	Atf::XmlElement::encodeAsXmlElement("filter", filter, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryRestrictionInverted", countryRestrictionInverted, _buf);
	restrictedCountries.toXmlString("restrictedCountries", _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("defaultBuyIn", defaultBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags2", tableFlags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("isTableStarter", isTableStarter, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandMask", brandMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("poolBlockMinHands", poolBlockMinHands, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableTypeId", tableTypeId, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	variableAntes.toXmlString("variableAntes", _buf);
	visibilityMaskEx.toXmlString("visibilityMaskEx", _buf);
	Atf::XmlElement::encodeAsXmlElement("seatFinderId", seatFinderId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::TableStaticDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tableId"))
		{
			tableId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("serverObject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
		}
		else if (_element.equals("clubId"))
		{
			clubId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isOneOnOne"))
		{
			isOneOnOne = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayers"))
		{
			maxPlayers = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("visibilityMask"))
		{
			visibilityMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableFlags"))
		{
			tableFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableInstanceFlags"))
		{
			tableInstanceFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chatLang"))
		{
			chatLang = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("loBet"))
		{
			loBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cap"))
		{
			cap = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("specialName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, specialName)) return false;
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("minChipsLimit"))
		{
			minChipsLimit = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("icon"))
		{
			icon = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("filter"))
		{
			filter = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("countryRestrictionInverted"))
		{
			countryRestrictionInverted = (*_value.ptr() == '1');
		}
		else if (_element.equals("restrictedCountries"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString , 4 > >::FromXmlString(_value, restrictedCountries)) return false;
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("defaultBuyIn"))
		{
			defaultBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableFlags2"))
		{
			tableFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isTableStarter"))
		{
			isTableStarter = (*_value.ptr() == '1');
		}
		else if (_element.equals("brandMask"))
		{
			brandMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("poolBlockMinHands"))
		{
			poolBlockMinHands = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableTypeId"))
		{
			tableTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableStakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
		}
		else if (_element.equals("variableAntes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64, 4 > >::FromXmlString(_value, variableAntes)) return false;
		}
		else if (_element.equals("visibilityMaskEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, visibilityMaskEx)) return false;
		}
		else if (_element.equals("seatFinderId"))
		{
			seatFinderId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::TableStaticDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TableStaticDataStruct())) // not empty
	{
		_body.composeUINT64(tableId);
		_body.composeString(name);
		_body.composeString(server);
		_body.composeString(serverObject);
		_body.composeUINT32(clubId);
		_body.composeBYTE(isOneOnOne);
		_body.composeBYTE(isPlayMoney);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(maxPlayers);
		_body.composeUINT32(visibilityMask);
		_body.composeUINT32(tableFlags);
		_body.composeUINT32(tableInstanceFlags);
		_body.composeUINT16(chatLang);
		_body.composeBYTE(structure);
		_body.composeUINT32(loBet);
		_body.composeUINT32(hiBet);
		_body.composeUINT32(ante);
		_body.composeUINT32(cap);
		_body.composeString(specialName);
		_body.composeString(currency);
		_body.composeUINT32(minChipsLimit);
		_body.composeUINT32(maxBuyIn);
		_body.composeBYTE(icon);
		_body.composeBYTE(filter);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(scalePM);
		_body.composeUINT32(defaultBuyIn);
		_body.composeUINT64(tableFlags2);
		_body.composeBOOL(isTableStarter);
		_body.composeUINT32(brandMask);
		_body.composeINT32(poolBlockMinHands);
		_body.composeUINT32(tableTypeId);
		tableStakes.composeMsg(_body, _ignoreJSON);
		variableAntes.composeMsg(_body, _ignoreJSON);
		visibilityMaskEx.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(seatFinderId);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TableStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(tableId);
	_parser0.parseStringP(name);
	_parser0.parseStringP(server);
	_parser0.parseStringP(serverObject);
	_parser0.parseUINT32(clubId);
	_parser0.parseBYTE(isOneOnOne);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(maxPlayers);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseUINT32(tableFlags);
	_parser0.parseUINT32(tableInstanceFlags);
	_parser0.parseUINT16(chatLang);
	_parser0.parseBYTE(structure);
	_parser0.parseUINT32(loBet);
	_parser0.parseUINT32(hiBet);
	_parser0.parseUINT32(ante);
	_parser0.parseUINT32(cap);
	_parser0.parseStringP(specialName);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(minChipsLimit);
	_parser0.parseUINT32(maxBuyIn);
	_parser0.parseBYTE(icon);
	_parser0.parseBYTE(filter);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseUINT32(scalePM);
	_parser0.parseUINT32(defaultBuyIn);
	_parser0.parseUINT64(tableFlags2);
	_parser0.parseBOOL(isTableStarter);
	_parser0.parseUINT32(brandMask);
	_parser0.parseINT32(poolBlockMinHands);
	_parser0.parseUINT32(tableTypeId);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	variableAntes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(seatFinderId);
}

const char *MLobbyNG::cli::TableStaticDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("name", name);
	_jsonstr.compose("server", server);
	_jsonstr.compose("serverObject", serverObject);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("isOneOnOne", isOneOnOne);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("visibilityMask", visibilityMask);
	_jsonstr.compose("tableFlags", tableFlags);
	_jsonstr.compose("tableInstanceFlags", tableInstanceFlags);
	_jsonstr.compose("chatLang", chatLang);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("cap", cap);
	_jsonstr.compose("specialName", specialName);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("minChipsLimit", minChipsLimit);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("icon", icon);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("countryRestrictionInverted", countryRestrictionInverted);
	_jsonstr.compose("restrictedCountries", restrictedCountries);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("defaultBuyIn", defaultBuyIn);
	_jsonstr.compose("tableFlags2", tableFlags2);
	_jsonstr.compose("isTableStarter", isTableStarter);
	_jsonstr.compose("brandMask", brandMask);
	_jsonstr.compose("poolBlockMinHands", poolBlockMinHands);
	_jsonstr.compose("tableTypeId", tableTypeId);
	_jsonstr.compose("tableStakes", tableStakes);
	_jsonstr.compose("variableAntes", variableAntes);
	_jsonstr.compose("visibilityMaskEx", visibilityMaskEx);
	_jsonstr.compose("seatFinderId", seatFinderId);
	return _buf.c_str();
}

void MLobbyNG::cli::TableStaticDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("serverObject", serverObject);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("isOneOnOne", isOneOnOne);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("visibilityMask", visibilityMask);
	_jparser.parseByNameThrow("tableFlags", tableFlags);
	_jparser.parseByNameThrow("tableInstanceFlags", tableInstanceFlags);
	_jparser.parseByNameThrow("chatLang", chatLang);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("cap", cap);
	_jparser.parseByNameThrow("specialName", specialName);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("minChipsLimit", minChipsLimit);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("icon", icon);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	_jparser.parseByNameThrow("restrictedCountries", restrictedCountries);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("defaultBuyIn", defaultBuyIn);
	_jparser.parseByNameThrow("tableFlags2", tableFlags2);
	_jparser.parseByNameThrow("isTableStarter", isTableStarter);
	_jparser.parseByNameThrow("brandMask", brandMask);
	_jparser.parseByNameThrow("poolBlockMinHands", poolBlockMinHands);
	_jparser.parseByNameThrow("tableTypeId", tableTypeId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("variableAntes", variableAntes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("visibilityMaskEx", visibilityMaskEx);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("seatFinderId", seatFinderId);
}

/* static */ void MLobbyNG::cli::TableStaticDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
	AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	BYTE isOneOnOne; _jparser.validateByNameThrow("isOneOnOne", isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _jparser.validateByNameThrow("visibilityMask", visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _jparser.validateByNameThrow("tableFlags", tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	UINT32 tableInstanceFlags; _jparser.validateByNameThrow("tableInstanceFlags", tableInstanceFlags);
	AtfValidator::validateInt(_descr, "tableInstanceFlags", tableInstanceFlags, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _jparser.validateByNameThrow("chatLang", chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 cap; _jparser.validateByNameThrow("cap", cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	PString specialName; _jparser.validateByNameThrow("specialName", specialName);
	AtfValidator::validateInt(_descr, "specialName", specialName.length(), _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _jparser.validateByNameThrow("minChipsLimit", minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	BYTE icon; _jparser.validateByNameThrow("icon", icon);
	AtfValidator::validateInt(_descr, "icon", icon, _checker, __FILE__, __LINE__);
	BYTE filter; _jparser.validateByNameThrow("filter", filter);
	AtfValidator::validateInt(_descr, "filter", filter, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _jparser.validateByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > restrictedCountries; _jparser.validateByNameThrow("restrictedCountries", restrictedCountries);
	AtfValidator::validateInt(_descr, "restrictedCountries", restrictedCountries.size(), _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _jparser.validateByNameThrow("defaultBuyIn", defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT64 tableFlags2; _jparser.validateByNameThrow("tableFlags2", tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	bool isTableStarter; _jparser.validateByNameThrow("isTableStarter", isTableStarter);
	AtfValidator::validateInt(_descr, "isTableStarter", isTableStarter, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _jparser.validateByNameThrow("brandMask", brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _jparser.validateByNameThrow("poolBlockMinHands", poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	UINT32 tableTypeId; _jparser.validateByNameThrow("tableTypeId", tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< INT64 > variableAntes; _jparser.validateByNameThrow("variableAntes", variableAntes);
	AtfValidator::validateInt(_descr, "variableAntes", variableAntes.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask visibilityMaskEx; _jparser.validateByNameThrow("visibilityMaskEx", visibilityMaskEx);
	if(_jparser.parseEnded()) return;
	UINT32 seatFinderId; _jparser.validateByNameThrow("seatFinderId", seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::TableStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT64 tableId; _parser0.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser0.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	BYTE isOneOnOne; _parser0.parseBYTE(isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _parser0.parseBYTE(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _parser0.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	UINT32 tableInstanceFlags; _parser0.parseUINT32(tableInstanceFlags);
	AtfValidator::validateInt(_descr, "tableInstanceFlags", tableInstanceFlags, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser0.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser0.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser0.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser0.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 cap; _parser0.parseUINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _parser0.parseUINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser0.parseUINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	BYTE icon; _parser0.parseBYTE(icon);
	AtfValidator::validateInt(_descr, "icon", icon, _checker, __FILE__, __LINE__);
	BYTE filter; _parser0.parseBYTE(filter);
	AtfValidator::validateInt(_descr, "filter", filter, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = Atf::LAtfVector< PString , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _parser0.parseUINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT64 tableFlags2; _parser0.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	bool isTableStarter; _parser0.parseBOOL(isTableStarter);
	AtfValidator::validateInt(_descr, "isTableStarter", isTableStarter, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser0.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser0.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	UINT32 tableTypeId; _parser0.parseUINT32(tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	TableCommon::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	int szVariableAntes = Atf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	UINT32 seatFinderId; _parser0.parseUINT32(seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableData
//=================================================================

MLobbyNG::cli::TableData::TableData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TableData::TableData(TableData&& _o)
	: staticData(std::move(_o.staticData))
{
}

MLobbyNG::cli::TableData& MLobbyNG::cli::TableData::operator=(TableData&& _o)
{
	if(this != &_o)
	{
		staticData = std::move(_o.staticData);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TableData::clear()
{
	staticData.clear();
}

bool MLobbyNG::cli::TableData::equals(const TableData& _o) const
{
	return staticData.equals(_o.staticData);
}

const char *MLobbyNG::cli::TableData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::TableData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	staticData.toXmlString("staticData", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::TableData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("staticData"))
		{
			if(!Atf::AtfTempl< TableStaticDataStruct >::FromXmlString(_value, staticData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::TableData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TableData())) // not empty
	{
		staticData.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TableData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
}

const char *MLobbyNG::cli::TableData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("staticData", staticData);
	return _buf.c_str();
}

void MLobbyNG::cli::TableData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("staticData", staticData);
}

/* static */ void MLobbyNG::cli::TableData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableStaticDataStruct staticData; _jparser.validateByNameThrow("staticData", staticData);
}

/*static*/ void MLobbyNG::cli::TableData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TableStaticDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SuggestedGames2SelectionFilter
//=================================================================

MLobbyNG::cli::SuggestedGames2SelectionFilter::SuggestedGames2SelectionFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SuggestedGames2SelectionFilter::SuggestedGames2SelectionFilter(SuggestedGames2SelectionFilter&& _o)
	: locale(std::move(_o.locale))
	, tournMedianValue(std::move(_o.tournMedianValue))
	, sngMedianValue(std::move(_o.sngMedianValue))
	, ringMedianValue(std::move(_o.ringMedianValue))
	, tournFilters(std::move(_o.tournFilters))
	, tableFilters(std::move(_o.tableFilters))
	, sngFilters(std::move(_o.sngFilters))
{
}

MLobbyNG::cli::SuggestedGames2SelectionFilter& MLobbyNG::cli::SuggestedGames2SelectionFilter::operator=(SuggestedGames2SelectionFilter&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		tournMedianValue = std::move(_o.tournMedianValue);
		sngMedianValue = std::move(_o.sngMedianValue);
		ringMedianValue = std::move(_o.ringMedianValue);
		tournFilters = std::move(_o.tournFilters);
		tableFilters = std::move(_o.tableFilters);
		sngFilters = std::move(_o.sngFilters);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SuggestedGames2SelectionFilter::clear()
{
	locale = 0;
	tournMedianValue = 0;
	sngMedianValue = 0;
	ringMedianValue = 0;
	tournFilters.clear();
	tableFilters.clear();
	sngFilters.clear();
}

bool MLobbyNG::cli::SuggestedGames2SelectionFilter::equals(const SuggestedGames2SelectionFilter& _o) const
{
	return locale == _o.locale &&
		tournMedianValue == _o.tournMedianValue &&
		sngMedianValue == _o.sngMedianValue &&
		ringMedianValue == _o.ringMedianValue &&
		tournFilters.equals(_o.tournFilters) &&
		tableFilters.equals(_o.tableFilters) &&
		sngFilters.equals(_o.sngFilters);
}

const char *MLobbyNG::cli::SuggestedGames2SelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("tournMedianValue=");
	_buf.appendInt64(tournMedianValue);
	_buf.append(',');
	_buf.append("sngMedianValue=");
	_buf.appendInt64(sngMedianValue);
	_buf.append(',');
	_buf.append("ringMedianValue=");
	_buf.appendInt64(ringMedianValue);
	_buf.append(',');
	_buf.append("tournFilters=");
	tournFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFilters=");
	tableFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngFilters=");
	sngFilters.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::SuggestedGames2SelectionFilter::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMedianValue", tournMedianValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("sngMedianValue", sngMedianValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("ringMedianValue", ringMedianValue, _buf);
	tournFilters.toXmlString("tournFilters", _buf);
	tableFilters.toXmlString("tableFilters", _buf);
	sngFilters.toXmlString("sngFilters", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::SuggestedGames2SelectionFilter::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("locale"))
		{
			locale = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournMedianValue"))
		{
			tournMedianValue = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sngMedianValue"))
		{
			sngMedianValue = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ringMedianValue"))
		{
			ringMedianValue = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFilters"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournSelectionFilter, 4 > >::FromXmlString(_value, tournFilters)) return false;
		}
		else if (_element.equals("tableFilters"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TableSelectionFilter, 4 > >::FromXmlString(_value, tableFilters)) return false;
		}
		else if (_element.equals("sngFilters"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SngSelectionFilter, 4 > >::FromXmlString(_value, sngFilters)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::SuggestedGames2SelectionFilter::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SuggestedGames2SelectionFilter())) // not empty
	{
		_body.composeUINT32(locale);
		_body.composeINT64(tournMedianValue);
		_body.composeINT64(sngMedianValue);
		_body.composeINT64(ringMedianValue);
		tournFilters.composeMsg(_body, _ignoreJSON);
		tableFilters.composeMsg(_body, _ignoreJSON);
		sngFilters.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SuggestedGames2SelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	_parser0.parseINT64(tournMedianValue);
	_parser0.parseINT64(sngMedianValue);
	_parser0.parseINT64(ringMedianValue);
	tournFilters.parseMsg(_parser0);
	tableFilters.parseMsg(_parser0);
	sngFilters.parseMsg(_parser0);
}

const char *MLobbyNG::cli::SuggestedGames2SelectionFilter::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("tournMedianValue", tournMedianValue);
	_jsonstr.compose("sngMedianValue", sngMedianValue);
	_jsonstr.compose("ringMedianValue", ringMedianValue);
	_jsonstr.compose("tournFilters", tournFilters);
	_jsonstr.compose("tableFilters", tableFilters);
	_jsonstr.compose("sngFilters", sngFilters);
	return _buf.c_str();
}

void MLobbyNG::cli::SuggestedGames2SelectionFilter::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("tournMedianValue", tournMedianValue);
	_jparser.parseByNameThrow("sngMedianValue", sngMedianValue);
	_jparser.parseByNameThrow("ringMedianValue", ringMedianValue);
	_jparser.parseByNameThrow("tournFilters", tournFilters);
	_jparser.parseByNameThrow("tableFilters", tableFilters);
	_jparser.parseByNameThrow("sngFilters", sngFilters);
}

/* static */ void MLobbyNG::cli::SuggestedGames2SelectionFilter::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	INT64 tournMedianValue; _jparser.validateByNameThrow("tournMedianValue", tournMedianValue);
	AtfValidator::validateInt(_descr, "tournMedianValue", tournMedianValue, _checker, __FILE__, __LINE__);
	INT64 sngMedianValue; _jparser.validateByNameThrow("sngMedianValue", sngMedianValue);
	AtfValidator::validateInt(_descr, "sngMedianValue", sngMedianValue, _checker, __FILE__, __LINE__);
	INT64 ringMedianValue; _jparser.validateByNameThrow("ringMedianValue", ringMedianValue);
	AtfValidator::validateInt(_descr, "ringMedianValue", ringMedianValue, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournSelectionFilter > tournFilters; _jparser.validateByNameThrow("tournFilters", tournFilters);
	AtfValidator::validateIntMax(_descr, "tournFilters", tournFilters.size(), 10, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableSelectionFilter > tableFilters; _jparser.validateByNameThrow("tableFilters", tableFilters);
	AtfValidator::validateIntMax(_descr, "tableFilters", tableFilters.size(), 10, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SngSelectionFilter > sngFilters; _jparser.validateByNameThrow("sngFilters", sngFilters);
	AtfValidator::validateIntMax(_descr, "sngFilters", sngFilters.size(), 10, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::SuggestedGames2SelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	INT64 tournMedianValue; _parser0.parseINT64(tournMedianValue);
	AtfValidator::validateInt(_descr, "tournMedianValue", tournMedianValue, _checker, __FILE__, __LINE__);
	INT64 sngMedianValue; _parser0.parseINT64(sngMedianValue);
	AtfValidator::validateInt(_descr, "sngMedianValue", sngMedianValue, _checker, __FILE__, __LINE__);
	INT64 ringMedianValue; _parser0.parseINT64(ringMedianValue);
	AtfValidator::validateInt(_descr, "ringMedianValue", ringMedianValue, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournFilters = Atf::LAtfVector< TournSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tournFilters", szTournFilters, 10, _checker, __FILE__, __LINE__);
	int szTableFilters = Atf::LAtfVector< TableSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tableFilters", szTableFilters, 10, _checker, __FILE__, __LINE__);
	int szSngFilters = Atf::LAtfVector< SngSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sngFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "sngFilters", szSngFilters, 10, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FilterGamesSelectionFilter
//=================================================================

MLobbyNG::cli::FilterGamesSelectionFilter::FilterGamesSelectionFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::FilterGamesSelectionFilter::FilterGamesSelectionFilter(FilterGamesSelectionFilter&& _o)
	: locale(std::move(_o.locale))
	, tournFilters(std::move(_o.tournFilters))
	, tableFilters(std::move(_o.tableFilters))
	, sngFilters(std::move(_o.sngFilters))
{
}

MLobbyNG::cli::FilterGamesSelectionFilter& MLobbyNG::cli::FilterGamesSelectionFilter::operator=(FilterGamesSelectionFilter&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		tournFilters = std::move(_o.tournFilters);
		tableFilters = std::move(_o.tableFilters);
		sngFilters = std::move(_o.sngFilters);
	}
	return *this;
}

#endif

void MLobbyNG::cli::FilterGamesSelectionFilter::clear()
{
	locale = 0;
	tournFilters.clear();
	tableFilters.clear();
	sngFilters.clear();
}

bool MLobbyNG::cli::FilterGamesSelectionFilter::equals(const FilterGamesSelectionFilter& _o) const
{
	return locale == _o.locale &&
		tournFilters.equals(_o.tournFilters) &&
		tableFilters.equals(_o.tableFilters) &&
		sngFilters.equals(_o.sngFilters);
}

const char *MLobbyNG::cli::FilterGamesSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("tournFilters=");
	tournFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFilters=");
	tableFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngFilters=");
	sngFilters.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::FilterGamesSelectionFilter::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	tournFilters.toXmlString("tournFilters", _buf);
	tableFilters.toXmlString("tableFilters", _buf);
	sngFilters.toXmlString("sngFilters", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::FilterGamesSelectionFilter::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("locale"))
		{
			locale = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFilters"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournSelectionFilter, 4 > >::FromXmlString(_value, tournFilters)) return false;
		}
		else if (_element.equals("tableFilters"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TableSelectionFilter, 4 > >::FromXmlString(_value, tableFilters)) return false;
		}
		else if (_element.equals("sngFilters"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SngSelectionFilter, 4 > >::FromXmlString(_value, sngFilters)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::FilterGamesSelectionFilter::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FilterGamesSelectionFilter())) // not empty
	{
		_body.composeUINT32(locale);
		tournFilters.composeMsg(_body, _ignoreJSON);
		tableFilters.composeMsg(_body, _ignoreJSON);
		sngFilters.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::FilterGamesSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	tournFilters.parseMsg(_parser0);
	tableFilters.parseMsg(_parser0);
	sngFilters.parseMsg(_parser0);
}

const char *MLobbyNG::cli::FilterGamesSelectionFilter::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("tournFilters", tournFilters);
	_jsonstr.compose("tableFilters", tableFilters);
	_jsonstr.compose("sngFilters", sngFilters);
	return _buf.c_str();
}

void MLobbyNG::cli::FilterGamesSelectionFilter::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("tournFilters", tournFilters);
	_jparser.parseByNameThrow("tableFilters", tableFilters);
	_jparser.parseByNameThrow("sngFilters", sngFilters);
}

/* static */ void MLobbyNG::cli::FilterGamesSelectionFilter::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournSelectionFilter > tournFilters; _jparser.validateByNameThrow("tournFilters", tournFilters);
	AtfValidator::validateIntMax(_descr, "tournFilters", tournFilters.size(), 10, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableSelectionFilter > tableFilters; _jparser.validateByNameThrow("tableFilters", tableFilters);
	AtfValidator::validateIntMax(_descr, "tableFilters", tableFilters.size(), 10, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SngSelectionFilter > sngFilters; _jparser.validateByNameThrow("sngFilters", sngFilters);
	AtfValidator::validateIntMax(_descr, "sngFilters", sngFilters.size(), 10, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::FilterGamesSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournFilters = Atf::LAtfVector< TournSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tournFilters", szTournFilters, 10, _checker, __FILE__, __LINE__);
	int szTableFilters = Atf::LAtfVector< TableSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tableFilters", szTableFilters, 10, _checker, __FILE__, __LINE__);
	int szSngFilters = Atf::LAtfVector< SngSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sngFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "sngFilters", szSngFilters, 10, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FilterGamesResultCriteria
//=================================================================

MLobbyNG::cli::FilterGamesResultCriteria::FilterGamesResultCriteria()
{
	clear();
}

void MLobbyNG::cli::FilterGamesResultCriteria::clear()
{
	maxItems = 0;
}

bool MLobbyNG::cli::FilterGamesResultCriteria::equals(const FilterGamesResultCriteria& _o) const
{
	return maxItems == _o.maxItems;
}

const char *MLobbyNG::cli::FilterGamesResultCriteria::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::FilterGamesResultCriteria::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("maxItems", maxItems, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::FilterGamesResultCriteria::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("maxItems"))
		{
			maxItems = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::FilterGamesResultCriteria::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FilterGamesResultCriteria())) // not empty
	{
		_body.composeUINT32(maxItems);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::FilterGamesResultCriteria::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(maxItems);
}

const char *MLobbyNG::cli::FilterGamesResultCriteria::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("maxItems", maxItems);
	return _buf.c_str();
}

void MLobbyNG::cli::FilterGamesResultCriteria::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("maxItems", maxItems);
}

/* static */ void MLobbyNG::cli::FilterGamesResultCriteria::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 maxItems; _jparser.validateByNameThrow("maxItems", maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::FilterGamesResultCriteria::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 maxItems; _parser0.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    NameSearchSelectionFilter
//=================================================================

MLobbyNG::cli::NameSearchSelectionFilter::NameSearchSelectionFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::NameSearchSelectionFilter::NameSearchSelectionFilter(NameSearchSelectionFilter&& _o)
	: locale(std::move(_o.locale))
	, name(std::move(_o.name))
	, country(std::move(_o.country))
	, isPM(std::move(_o.isPM))
{
}

MLobbyNG::cli::NameSearchSelectionFilter& MLobbyNG::cli::NameSearchSelectionFilter::operator=(NameSearchSelectionFilter&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		name = std::move(_o.name);
		country = std::move(_o.country);
		isPM = std::move(_o.isPM);
	}
	return *this;
}

#endif

void MLobbyNG::cli::NameSearchSelectionFilter::clear()
{
	locale = 0;
	name.clear();
	country.clear();
	isPM = false;
}

bool MLobbyNG::cli::NameSearchSelectionFilter::equals(const NameSearchSelectionFilter& _o) const
{
	return locale == _o.locale &&
		Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(country, _o.country) &&
		isPM == _o.isPM;
}

const char *MLobbyNG::cli::NameSearchSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::NameSearchSelectionFilter::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPM", isPM, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::NameSearchSelectionFilter::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("locale"))
		{
			locale = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("isPM"))
		{
			isPM = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::NameSearchSelectionFilter::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(NameSearchSelectionFilter())) // not empty
	{
		_body.composeUINT32(locale);
		_body.composeString(name);
		_body.composeString(country);
		_body.composeBOOL(isPM);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::NameSearchSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	_parser0.parseStringP(name);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(country);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(isPM);
}

const char *MLobbyNG::cli::NameSearchSelectionFilter::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("name", name);
	_jsonstr.compose("country", country);
	_jsonstr.compose("isPM", isPM);
	return _buf.c_str();
}

void MLobbyNG::cli::NameSearchSelectionFilter::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("name", name);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("country", country);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("isPM", isPM);
}

/* static */ void MLobbyNG::cli::NameSearchSelectionFilter::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateIntMax(_descr, "name", name.length(), 50, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), 7, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool isPM; _jparser.validateByNameThrow("isPM", isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::NameSearchSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, 50, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 7, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    OrderedTicketTournInfo
//=================================================================

MLobbyNG::cli::OrderedTicketTournInfo::OrderedTicketTournInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::OrderedTicketTournInfo::OrderedTicketTournInfo(OrderedTicketTournInfo&& _o)
	: ticketName(std::move(_o.ticketName))
	, tourns(std::move(_o.tourns))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, gameOrder(std::move(_o.gameOrder))
{
}

MLobbyNG::cli::OrderedTicketTournInfo& MLobbyNG::cli::OrderedTicketTournInfo::operator=(OrderedTicketTournInfo&& _o)
{
	if(this != &_o)
	{
		ticketName = std::move(_o.ticketName);
		tourns = std::move(_o.tourns);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		gameOrder = std::move(_o.gameOrder);
	}
	return *this;
}

#endif

void MLobbyNG::cli::OrderedTicketTournInfo::clear()
{
	ticketName.clear();
	tourns.clear();
	sngTypes.clear();
	sagTypes.clear();
	gameOrder.clear();
}

bool MLobbyNG::cli::OrderedTicketTournInfo::equals(const OrderedTicketTournInfo& _o) const
{
	return Atf::atfPStringEquals(ticketName, _o.ticketName) &&
		tourns.equals(_o.tourns) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		gameOrder.equals(_o.gameOrder);
}

const char *MLobbyNG::cli::OrderedTicketTournInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketName=");
	_buf.append(ticketName);
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::OrderedTicketTournInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("ticketName", ticketName, _buf);
	tourns.toXmlString("tourns", _buf);
	sngTypes.toXmlString("sngTypes", _buf);
	sagTypes.toXmlString("sagTypes", _buf);
	gameOrder.toXmlString("gameOrder", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::OrderedTicketTournInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("ticketName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, ticketName)) return false;
		}
		else if (_element.equals("tourns"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
		}
		else if (_element.equals("sngTypes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SngDataStruct, 4 > >::FromXmlString(_value, sngTypes)) return false;
		}
		else if (_element.equals("sagTypes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SagDataStruct, 4 > >::FromXmlString(_value, sagTypes)) return false;
		}
		else if (_element.equals("gameOrder"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, gameOrder)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::OrderedTicketTournInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(OrderedTicketTournInfo())) // not empty
	{
		_body.composeString(ticketName);
		tourns.composeMsg(_body, _ignoreJSON);
		sngTypes.composeMsg(_body, _ignoreJSON);
		sagTypes.composeMsg(_body, _ignoreJSON);
		gameOrder.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::OrderedTicketTournInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(ticketName);
	tourns.parseMsg(_parser0);
	sngTypes.parseMsg(_parser0);
	sagTypes.parseMsg(_parser0);
	gameOrder.parseMsg(_parser0);
}

const char *MLobbyNG::cli::OrderedTicketTournInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketName", ticketName);
	_jsonstr.compose("tourns", tourns);
	_jsonstr.compose("sngTypes", sngTypes);
	_jsonstr.compose("sagTypes", sagTypes);
	_jsonstr.compose("gameOrder", gameOrder);
	return _buf.c_str();
}

void MLobbyNG::cli::OrderedTicketTournInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketName", ticketName);
	_jparser.parseByNameThrow("tourns", tourns);
	_jparser.parseByNameThrow("sngTypes", sngTypes);
	_jparser.parseByNameThrow("sagTypes", sagTypes);
	_jparser.parseByNameThrow("gameOrder", gameOrder);
}

/* static */ void MLobbyNG::cli::OrderedTicketTournInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString ticketName; _jparser.validateByNameThrow("ticketName", ticketName);
	AtfValidator::validateInt(_descr, "ticketName", ticketName.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SngDataStruct > sngTypes; _jparser.validateByNameThrow("sngTypes", sngTypes);
	AtfValidator::validateInt(_descr, "sngTypes", sngTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SagDataStruct > sagTypes; _jparser.validateByNameThrow("sagTypes", sagTypes);
	AtfValidator::validateInt(_descr, "sagTypes", sagTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > gameOrder; _jparser.validateByNameThrow("gameOrder", gameOrder);
	AtfValidator::validateInt(_descr, "gameOrder", gameOrder.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::OrderedTicketTournInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "ticketName"); size_t szTicketName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketName", szTicketName, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTourns = Atf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szSngTypes = Atf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = Atf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szGameOrder = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TicketTournRequestData
//=================================================================

MLobbyNG::cli::TicketTournRequestData::TicketTournRequestData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TicketTournRequestData::TicketTournRequestData(TicketTournRequestData&& _o)
	: ticketNames(std::move(_o.ticketNames))
	, gameCategoryMask(std::move(_o.gameCategoryMask))
	, ticketTournRequestMask(std::move(_o.ticketTournRequestMask))
	, filter(std::move(_o.filter))
	, activities(std::move(_o.activities))
	, gameMask(std::move(_o.gameMask))
{
}

MLobbyNG::cli::TicketTournRequestData& MLobbyNG::cli::TicketTournRequestData::operator=(TicketTournRequestData&& _o)
{
	if(this != &_o)
	{
		ticketNames = std::move(_o.ticketNames);
		gameCategoryMask = std::move(_o.gameCategoryMask);
		ticketTournRequestMask = std::move(_o.ticketTournRequestMask);
		filter = std::move(_o.filter);
		activities = std::move(_o.activities);
		gameMask = std::move(_o.gameMask);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TicketTournRequestData::clear()
{
	ticketNames.clear();
	gameCategoryMask = 0;
	ticketTournRequestMask = 0;
	filter.clear();
	activities.clear();
	gameMask = (2*(UINT64)NGGameTypes::NGGame_Last-1);
}

bool MLobbyNG::cli::TicketTournRequestData::equals(const TicketTournRequestData& _o) const
{
	return ticketNames.equals(_o.ticketNames) &&
		gameCategoryMask == _o.gameCategoryMask &&
		ticketTournRequestMask == _o.ticketTournRequestMask &&
		filter.equals(_o.filter) &&
		activities.equals(_o.activities) &&
		gameMask == _o.gameMask;
}

const char *MLobbyNG::cli::TicketTournRequestData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketNames=");
	ticketNames.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameCategoryMask=");
	_buf.appendUint(gameCategoryMask);
	_buf.append(',');
	_buf.append("ticketTournRequestMask=");
	_buf.appendUint(ticketTournRequestMask);
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("activities=");
	activities.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::TicketTournRequestData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	ticketNames.toXmlString("ticketNames", _buf);
	Atf::XmlElement::encodeAsXmlElement("gameCategoryMask", gameCategoryMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketTournRequestMask", ticketTournRequestMask, _buf);
	filter.toXmlString("filter", _buf);
	activities.toXmlString("activities", _buf);
	Atf::XmlElement::encodeAsXmlElement("gameMask", gameMask, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::TicketTournRequestData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("ticketNames"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, ticketNames)) return false;
		}
		else if (_element.equals("gameCategoryMask"))
		{
			gameCategoryMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ticketTournRequestMask"))
		{
			ticketTournRequestMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("filter"))
		{
			if(!Atf::AtfTempl< GameListFilter >::FromXmlString(_value, filter)) return false;
		}
		else if (_element.equals("activities"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< ActivityStruct, 4 > >::FromXmlString(_value, activities)) return false;
		}
		else if (_element.equals("gameMask"))
		{
			gameMask = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::TicketTournRequestData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TicketTournRequestData())) // not empty
	{
		ticketNames.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(gameCategoryMask);
		_body.composeUINT32(ticketTournRequestMask);
		filter.composeMsg(_body, _ignoreJSON);
		activities.composeMsg(_body, _ignoreJSON);
		_body.composeUINT64(gameMask);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TicketTournRequestData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	ticketNames.parseMsg(_parser0);
	_parser0.parseUINT32(gameCategoryMask);
	_parser0.parseUINT32(ticketTournRequestMask);
	filter.parseMsg(_parser0);
	activities.parseMsg(_parser0);
	_parser0.parseUINT64(gameMask);
}

const char *MLobbyNG::cli::TicketTournRequestData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketNames", ticketNames);
	_jsonstr.compose("gameCategoryMask", gameCategoryMask);
	_jsonstr.compose("ticketTournRequestMask", ticketTournRequestMask);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("activities", activities);
	_jsonstr.compose("gameMask", gameMask);
	return _buf.c_str();
}

void MLobbyNG::cli::TicketTournRequestData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketNames", ticketNames);
	_jparser.parseByNameThrow("gameCategoryMask", gameCategoryMask);
	_jparser.parseByNameThrow("ticketTournRequestMask", ticketTournRequestMask);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("activities", activities);
	_jparser.parseByNameThrow("gameMask", gameMask);
}

/* static */ void MLobbyNG::cli::TicketTournRequestData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< PString > ticketNames; _jparser.validateByNameThrow("ticketNames", ticketNames);
	AtfValidator::validateIntMax(_descr, "ticketNames", ticketNames.size(), 100, _checker, __FILE__, __LINE__);
	UINT32 gameCategoryMask; _jparser.validateByNameThrow("gameCategoryMask", gameCategoryMask);
	AtfValidator::validateIntMax(_descr, "gameCategoryMask", gameCategoryMask, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	UINT32 ticketTournRequestMask; _jparser.validateByNameThrow("ticketTournRequestMask", ticketTournRequestMask);
	AtfValidator::validateIntMax(_descr, "ticketTournRequestMask", ticketTournRequestMask, (2*TicketTournRequest_Last-1), _checker, __FILE__, __LINE__);
	GameListFilter filter; _jparser.validateByNameThrow("filter", filter);
	Atf::AtfVectorBase< ActivityStruct > activities; _jparser.validateByNameThrow("activities", activities);
	AtfValidator::validateIntMax(_descr, "activities", activities.size(), 100, _checker, __FILE__, __LINE__);
	UINT64 gameMask; _jparser.validateByNameThrow("gameMask", gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::TicketTournRequestData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szTicketNames = Atf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("ticketNames"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "ticketNames", szTicketNames, 100, _checker, __FILE__, __LINE__);
	UINT32 gameCategoryMask; _parser0.parseUINT32(gameCategoryMask);
	AtfValidator::validateIntMax(_descr, "gameCategoryMask", gameCategoryMask, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	UINT32 ticketTournRequestMask; _parser0.parseUINT32(ticketTournRequestMask);
	AtfValidator::validateIntMax(_descr, "ticketTournRequestMask", ticketTournRequestMask, (2*TicketTournRequest_Last-1), _checker, __FILE__, __LINE__);
	GameListFilter::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	int szActivities = Atf::LAtfVector< ActivityStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("activities"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "activities", szActivities, 100, _checker, __FILE__, __LINE__);
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    BrandedLobbyInfo
//=================================================================

MLobbyNG::cli::BrandedLobbyInfo::BrandedLobbyInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::BrandedLobbyInfo::BrandedLobbyInfo(BrandedLobbyInfo&& _o)
	: lobbyName(std::move(_o.lobbyName))
	, displayName(std::move(_o.displayName))
	, tournFilters(std::move(_o.tournFilters))
	, tableFilters(std::move(_o.tableFilters))
	, sngFilters(std::move(_o.sngFilters))
	, gameCount(std::move(_o.gameCount))
	, playerCount(std::move(_o.playerCount))
{
}

MLobbyNG::cli::BrandedLobbyInfo& MLobbyNG::cli::BrandedLobbyInfo::operator=(BrandedLobbyInfo&& _o)
{
	if(this != &_o)
	{
		lobbyName = std::move(_o.lobbyName);
		displayName = std::move(_o.displayName);
		tournFilters = std::move(_o.tournFilters);
		tableFilters = std::move(_o.tableFilters);
		sngFilters = std::move(_o.sngFilters);
		gameCount = std::move(_o.gameCount);
		playerCount = std::move(_o.playerCount);
	}
	return *this;
}

#endif

void MLobbyNG::cli::BrandedLobbyInfo::clear()
{
	lobbyName.clear();
	displayName.clear();
	tournFilters.clear();
	tableFilters.clear();
	sngFilters.clear();
	gameCount = 0;
	playerCount = 0;
}

bool MLobbyNG::cli::BrandedLobbyInfo::equals(const BrandedLobbyInfo& _o) const
{
	return Atf::atfPStringEquals(lobbyName, _o.lobbyName) &&
		Atf::atfPStringEquals(displayName, _o.displayName) &&
		tournFilters.equals(_o.tournFilters) &&
		tableFilters.equals(_o.tableFilters) &&
		sngFilters.equals(_o.sngFilters) &&
		gameCount == _o.gameCount &&
		playerCount == _o.playerCount;
}

const char *MLobbyNG::cli::BrandedLobbyInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("lobbyName=");
	_buf.append(lobbyName);
	_buf.append(',');
	_buf.append("displayName=");
	_buf.append(displayName);
	_buf.append(',');
	_buf.append("tournFilters=");
	tournFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFilters=");
	tableFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngFilters=");
	sngFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameCount=");
	_buf.appendInt(gameCount);
	_buf.append(',');
	_buf.append("playerCount=");
	_buf.appendInt(playerCount);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::BrandedLobbyInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("lobbyName", lobbyName, _buf);
	Atf::XmlElement::encodeAsXmlElement("displayName", displayName, _buf);
	tournFilters.toXmlString("tournFilters", _buf);
	tableFilters.toXmlString("tableFilters", _buf);
	sngFilters.toXmlString("sngFilters", _buf);
	Atf::XmlElement::encodeAsXmlElement("gameCount", gameCount, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerCount", playerCount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::BrandedLobbyInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("lobbyName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, lobbyName)) return false;
		}
		else if (_element.equals("displayName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, displayName)) return false;
		}
		else if (_element.equals("tournFilters"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournSelectionFilter, 4 > >::FromXmlString(_value, tournFilters)) return false;
		}
		else if (_element.equals("tableFilters"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TableSelectionFilter, 4 > >::FromXmlString(_value, tableFilters)) return false;
		}
		else if (_element.equals("sngFilters"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SngSelectionFilter, 4 > >::FromXmlString(_value, sngFilters)) return false;
		}
		else if (_element.equals("gameCount"))
		{
			gameCount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playerCount"))
		{
			playerCount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::BrandedLobbyInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(BrandedLobbyInfo())) // not empty
	{
		_body.composeString(lobbyName);
		_body.composeString(displayName);
		tournFilters.composeMsg(_body, _ignoreJSON);
		tableFilters.composeMsg(_body, _ignoreJSON);
		sngFilters.composeMsg(_body, _ignoreJSON);
		_body.composeINT32(gameCount);
		_body.composeINT32(playerCount);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::BrandedLobbyInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(lobbyName);
	_parser0.parseStringP(displayName);
	tournFilters.parseMsg(_parser0);
	tableFilters.parseMsg(_parser0);
	sngFilters.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(gameCount);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(playerCount);
}

const char *MLobbyNG::cli::BrandedLobbyInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("lobbyName", lobbyName);
	_jsonstr.compose("displayName", displayName);
	_jsonstr.compose("tournFilters", tournFilters);
	_jsonstr.compose("tableFilters", tableFilters);
	_jsonstr.compose("sngFilters", sngFilters);
	_jsonstr.compose("gameCount", gameCount);
	_jsonstr.compose("playerCount", playerCount);
	return _buf.c_str();
}

void MLobbyNG::cli::BrandedLobbyInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("lobbyName", lobbyName);
	_jparser.parseByNameThrow("displayName", displayName);
	_jparser.parseByNameThrow("tournFilters", tournFilters);
	_jparser.parseByNameThrow("tableFilters", tableFilters);
	_jparser.parseByNameThrow("sngFilters", sngFilters);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("gameCount", gameCount);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("playerCount", playerCount);
}

/* static */ void MLobbyNG::cli::BrandedLobbyInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString lobbyName; _jparser.validateByNameThrow("lobbyName", lobbyName);
	AtfValidator::validateIntMax(_descr, "lobbyName", lobbyName.length(), 100, _checker, __FILE__, __LINE__);
	PString displayName; _jparser.validateByNameThrow("displayName", displayName);
	AtfValidator::validateIntMax(_descr, "displayName", displayName.length(), 200, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournSelectionFilter > tournFilters; _jparser.validateByNameThrow("tournFilters", tournFilters);
	AtfValidator::validateIntMax(_descr, "tournFilters", tournFilters.size(), 10, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableSelectionFilter > tableFilters; _jparser.validateByNameThrow("tableFilters", tableFilters);
	AtfValidator::validateIntMax(_descr, "tableFilters", tableFilters.size(), 10, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SngSelectionFilter > sngFilters; _jparser.validateByNameThrow("sngFilters", sngFilters);
	AtfValidator::validateIntMax(_descr, "sngFilters", sngFilters.size(), 10, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 gameCount; _jparser.validateByNameThrow("gameCount", gameCount);
	AtfValidator::validateInt(_descr, "gameCount", gameCount, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 playerCount; _jparser.validateByNameThrow("playerCount", playerCount);
	AtfValidator::validateInt(_descr, "playerCount", playerCount, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::BrandedLobbyInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "lobbyName"); size_t szLobbyName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "lobbyName", szLobbyName, 100, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "displayName"); size_t szDisplayName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "displayName", szDisplayName, 200, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournFilters = Atf::LAtfVector< TournSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tournFilters", szTournFilters, 10, _checker, __FILE__, __LINE__);
	int szTableFilters = Atf::LAtfVector< TableSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tableFilters", szTableFilters, 10, _checker, __FILE__, __LINE__);
	int szSngFilters = Atf::LAtfVector< SngSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sngFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "sngFilters", szSngFilters, 10, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 gameCount; _parser0.parseINT32(gameCount);
	AtfValidator::validateInt(_descr, "gameCount", gameCount, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 playerCount; _parser0.parseINT32(playerCount);
	AtfValidator::validateInt(_descr, "playerCount", playerCount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FullBrandedLobbyInfo
//=================================================================

MLobbyNG::cli::FullBrandedLobbyInfo::FullBrandedLobbyInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::FullBrandedLobbyInfo::FullBrandedLobbyInfo(FullBrandedLobbyInfo&& _o)
	: lobbyName(std::move(_o.lobbyName))
	, displayName(std::move(_o.displayName))
	, sites(std::move(_o.sites))
	, tournFilters(std::move(_o.tournFilters))
	, tableFilters(std::move(_o.tableFilters))
	, sngFilters(std::move(_o.sngFilters))
{
}

MLobbyNG::cli::FullBrandedLobbyInfo& MLobbyNG::cli::FullBrandedLobbyInfo::operator=(FullBrandedLobbyInfo&& _o)
{
	if(this != &_o)
	{
		lobbyName = std::move(_o.lobbyName);
		displayName = std::move(_o.displayName);
		sites = std::move(_o.sites);
		tournFilters = std::move(_o.tournFilters);
		tableFilters = std::move(_o.tableFilters);
		sngFilters = std::move(_o.sngFilters);
	}
	return *this;
}

#endif

void MLobbyNG::cli::FullBrandedLobbyInfo::clear()
{
	lobbyName.clear();
	displayName.clear();
	sites.clear();
	tournFilters.clear();
	tableFilters.clear();
	sngFilters.clear();
}

bool MLobbyNG::cli::FullBrandedLobbyInfo::equals(const FullBrandedLobbyInfo& _o) const
{
	return Atf::atfPStringEquals(lobbyName, _o.lobbyName) &&
		displayName.equals(_o.displayName) &&
		sites.equals(_o.sites) &&
		tournFilters.equals(_o.tournFilters) &&
		tableFilters.equals(_o.tableFilters) &&
		sngFilters.equals(_o.sngFilters);
}

const char *MLobbyNG::cli::FullBrandedLobbyInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("lobbyName=");
	_buf.append(lobbyName);
	_buf.append(',');
	_buf.append("displayName=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, displayName);
	_buf.append(',');
	_buf.append("sites=");
	sites.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournFilters=");
	tournFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFilters=");
	tableFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngFilters=");
	sngFilters.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::FullBrandedLobbyInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("lobbyName", lobbyName, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "displayName", displayName);
	sites.toXmlString("sites", _buf);
	tournFilters.toXmlString("tournFilters", _buf);
	tableFilters.toXmlString("tableFilters", _buf);
	sngFilters.toXmlString("sngFilters", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::FullBrandedLobbyInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("lobbyName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, lobbyName)) return false;
		}
		else if (_element.equals("displayName"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, displayName);
		}
		else if (_element.equals("sites"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, sites)) return false;
		}
		else if (_element.equals("tournFilters"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournSelectionFilter, 4 > >::FromXmlString(_value, tournFilters)) return false;
		}
		else if (_element.equals("tableFilters"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TableSelectionFilter, 4 > >::FromXmlString(_value, tableFilters)) return false;
		}
		else if (_element.equals("sngFilters"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SngSelectionFilter, 4 > >::FromXmlString(_value, sngFilters)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::FullBrandedLobbyInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FullBrandedLobbyInfo())) // not empty
	{
		_body.composeString(lobbyName);
		displayName.compose(_body);
		sites.composeMsg(_body, _ignoreJSON);
		tournFilters.composeMsg(_body, _ignoreJSON);
		tableFilters.composeMsg(_body, _ignoreJSON);
		sngFilters.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::FullBrandedLobbyInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(lobbyName);
	displayName.parse(_parser0);
	sites.parseMsg(_parser0);
	tournFilters.parseMsg(_parser0);
	tableFilters.parseMsg(_parser0);
	sngFilters.parseMsg(_parser0);
}

const char *MLobbyNG::cli::FullBrandedLobbyInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("lobbyName", lobbyName);
	_jsonstr.compose("displayName", displayName);
	_jsonstr.compose("sites", sites);
	_jsonstr.compose("tournFilters", tournFilters);
	_jsonstr.compose("tableFilters", tableFilters);
	_jsonstr.compose("sngFilters", sngFilters);
	return _buf.c_str();
}

void MLobbyNG::cli::FullBrandedLobbyInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("lobbyName", lobbyName);
	_jparser.parseByNameThrow("displayName", displayName);
	_jparser.parseByNameThrow("sites", sites);
	_jparser.parseByNameThrow("tournFilters", tournFilters);
	_jparser.parseByNameThrow("tableFilters", tableFilters);
	_jparser.parseByNameThrow("sngFilters", sngFilters);
}

/* static */ void MLobbyNG::cli::FullBrandedLobbyInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString lobbyName; _jparser.validateByNameThrow("lobbyName", lobbyName);
	AtfValidator::validateIntMax(_descr, "lobbyName", lobbyName.length(), 100, _checker, __FILE__, __LINE__);
	I18nPString displayName; _jparser.validateByNameThrow("displayName", displayName);
	PSiteMask sites; _jparser.validateByNameThrow("sites", sites);
	Atf::AtfVectorBase< TournSelectionFilter > tournFilters; _jparser.validateByNameThrow("tournFilters", tournFilters);
	AtfValidator::validateIntMax(_descr, "tournFilters", tournFilters.size(), 10, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableSelectionFilter > tableFilters; _jparser.validateByNameThrow("tableFilters", tableFilters);
	AtfValidator::validateIntMax(_descr, "tableFilters", tableFilters.size(), 10, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SngSelectionFilter > sngFilters; _jparser.validateByNameThrow("sngFilters", sngFilters);
	AtfValidator::validateIntMax(_descr, "sngFilters", sngFilters.size(), 10, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::FullBrandedLobbyInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "lobbyName"); size_t szLobbyName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "lobbyName", szLobbyName, 100, _checker, __FILE__, __LINE__);
	I18nPString displayName; displayName.parse(_parser0);
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sites"), _fieldsWithUnparsedContent);
	int szTournFilters = Atf::LAtfVector< TournSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tournFilters", szTournFilters, 10, _checker, __FILE__, __LINE__);
	int szTableFilters = Atf::LAtfVector< TableSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tableFilters", szTableFilters, 10, _checker, __FILE__, __LINE__);
	int szSngFilters = Atf::LAtfVector< SngSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sngFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "sngFilters", szSngFilters, 10, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ResultRanges
//=================================================================

MLobbyNG::cli::ResultRanges::ResultRanges()
{
	clear();
}

void MLobbyNG::cli::ResultRanges::clear()
{
	gameMask = 0;
	tableSizeMask = 0;
	speedMask = 0;
	tournVariantMask = 0;
	minNumPlayers = 0;
	maxNumPlayers = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	tournStateMask = 0;
	gameCategoryMask = 0;
}

bool MLobbyNG::cli::ResultRanges::equals(const ResultRanges& _o) const
{
	return gameMask == _o.gameMask &&
		tableSizeMask == _o.tableSizeMask &&
		speedMask == _o.speedMask &&
		tournVariantMask == _o.tournVariantMask &&
		minNumPlayers == _o.minNumPlayers &&
		maxNumPlayers == _o.maxNumPlayers &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		tournStateMask == _o.tournStateMask &&
		gameCategoryMask == _o.gameCategoryMask;
}

const char *MLobbyNG::cli::ResultRanges::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append(',');
	_buf.append("tableSizeMask=");
	_buf.appendUint(tableSizeMask);
	_buf.append(',');
	_buf.append("speedMask=");
	_buf.appendUint(speedMask);
	_buf.append(',');
	_buf.append("tournVariantMask=");
	_buf.appendUint(tournVariantMask);
	_buf.append(',');
	_buf.append("minNumPlayers=");
	_buf.appendInt(minNumPlayers);
	_buf.append(',');
	_buf.append("maxNumPlayers=");
	_buf.appendInt(maxNumPlayers);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendInt64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt64(maxBuyIn);
	_buf.append(',');
	_buf.append("tournStateMask=");
	_buf.appendUint(tournStateMask);
	_buf.append(',');
	_buf.append("gameCategoryMask=");
	_buf.appendUint(gameCategoryMask);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::ResultRanges::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameMask", gameMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableSizeMask", tableSizeMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("speedMask", speedMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournVariantMask", tournVariantMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("minNumPlayers", minNumPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxNumPlayers", maxNumPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournStateMask", tournStateMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameCategoryMask", gameCategoryMask, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::ResultRanges::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameMask"))
		{
			gameMask = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableSizeMask"))
		{
			tableSizeMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("speedMask"))
		{
			speedMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournVariantMask"))
		{
			tournVariantMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minNumPlayers"))
		{
			minNumPlayers = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxNumPlayers"))
		{
			maxNumPlayers = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minBuyIn"))
		{
			minBuyIn = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournStateMask"))
		{
			tournStateMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameCategoryMask"))
		{
			gameCategoryMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::ResultRanges::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ResultRanges())) // not empty
	{
		_body.composeUINT64(gameMask);
		_body.composeUINT32(tableSizeMask);
		_body.composeUINT32(speedMask);
		_body.composeUINT32(tournVariantMask);
		_body.composeINT32(minNumPlayers);
		_body.composeINT32(maxNumPlayers);
		_body.composeINT64(minBuyIn);
		_body.composeINT64(maxBuyIn);
		_body.composeUINT32(tournStateMask);
		_body.composeUINT32(gameCategoryMask);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::ResultRanges::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(gameMask);
	_parser0.parseUINT32(tableSizeMask);
	_parser0.parseUINT32(speedMask);
	_parser0.parseUINT32(tournVariantMask);
	_parser0.parseINT32(minNumPlayers);
	_parser0.parseINT32(maxNumPlayers);
	_parser0.parseINT64(minBuyIn);
	_parser0.parseINT64(maxBuyIn);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(tournStateMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(gameCategoryMask);
}

const char *MLobbyNG::cli::ResultRanges::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameMask", gameMask);
	_jsonstr.compose("tableSizeMask", tableSizeMask);
	_jsonstr.compose("speedMask", speedMask);
	_jsonstr.compose("tournVariantMask", tournVariantMask);
	_jsonstr.compose("minNumPlayers", minNumPlayers);
	_jsonstr.compose("maxNumPlayers", maxNumPlayers);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("tournStateMask", tournStateMask);
	_jsonstr.compose("gameCategoryMask", gameCategoryMask);
	return _buf.c_str();
}

void MLobbyNG::cli::ResultRanges::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameMask", gameMask);
	_jparser.parseByNameThrow("tableSizeMask", tableSizeMask);
	_jparser.parseByNameThrow("speedMask", speedMask);
	_jparser.parseByNameThrow("tournVariantMask", tournVariantMask);
	_jparser.parseByNameThrow("minNumPlayers", minNumPlayers);
	_jparser.parseByNameThrow("maxNumPlayers", maxNumPlayers);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tournStateMask", tournStateMask);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("gameCategoryMask", gameCategoryMask);
}

/* static */ void MLobbyNG::cli::ResultRanges::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 gameMask; _jparser.validateByNameThrow("gameMask", gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tableSizeMask; _jparser.validateByNameThrow("tableSizeMask", tableSizeMask);
	AtfValidator::validateIntMax(_descr, "tableSizeMask", tableSizeMask, (2*NGMaxTableSize_Last-1), _checker, __FILE__, __LINE__);
	UINT32 speedMask; _jparser.validateByNameThrow("speedMask", speedMask);
	AtfValidator::validateIntMax(_descr, "speedMask", speedMask, (2*NGTournSpeed_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tournVariantMask; _jparser.validateByNameThrow("tournVariantMask", tournVariantMask);
	AtfValidator::validateIntMax(_descr, "tournVariantMask", tournVariantMask, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	INT32 minNumPlayers; _jparser.validateByNameThrow("minNumPlayers", minNumPlayers);
	AtfValidator::validateIntMax(_descr, "minNumPlayers", minNumPlayers, 1000000000, _checker, __FILE__, __LINE__);
	INT32 maxNumPlayers; _jparser.validateByNameThrow("maxNumPlayers", maxNumPlayers);
	AtfValidator::validateIntMax(_descr, "maxNumPlayers", maxNumPlayers, 1000000000, _checker, __FILE__, __LINE__);
	INT64 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 tournStateMask; _jparser.validateByNameThrow("tournStateMask", tournStateMask);
	AtfValidator::validateIntMax(_descr, "tournStateMask", tournStateMask, (2*NGTournState_Last-1), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 gameCategoryMask; _jparser.validateByNameThrow("gameCategoryMask", gameCategoryMask);
	AtfValidator::validateIntMax(_descr, "gameCategoryMask", gameCategoryMask, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::ResultRanges::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tableSizeMask; _parser0.parseUINT32(tableSizeMask);
	AtfValidator::validateIntMax(_descr, "tableSizeMask", tableSizeMask, (2*NGMaxTableSize_Last-1), _checker, __FILE__, __LINE__);
	UINT32 speedMask; _parser0.parseUINT32(speedMask);
	AtfValidator::validateIntMax(_descr, "speedMask", speedMask, (2*NGTournSpeed_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tournVariantMask; _parser0.parseUINT32(tournVariantMask);
	AtfValidator::validateIntMax(_descr, "tournVariantMask", tournVariantMask, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	INT32 minNumPlayers; _parser0.parseINT32(minNumPlayers);
	AtfValidator::validateIntMax(_descr, "minNumPlayers", minNumPlayers, 1000000000, _checker, __FILE__, __LINE__);
	INT32 maxNumPlayers; _parser0.parseINT32(maxNumPlayers);
	AtfValidator::validateIntMax(_descr, "maxNumPlayers", maxNumPlayers, 1000000000, _checker, __FILE__, __LINE__);
	INT64 minBuyIn; _parser0.parseINT64(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _parser0.parseINT64(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 tournStateMask; _parser0.parseUINT32(tournStateMask);
	AtfValidator::validateIntMax(_descr, "tournStateMask", tournStateMask, (2*NGTournState_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 gameCategoryMask; _parser0.parseUINT32(gameCategoryMask);
	AtfValidator::validateIntMax(_descr, "gameCategoryMask", gameCategoryMask, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FindTournsByRefFilter
//=================================================================

MLobbyNG::cli::FindTournsByRefFilter::FindTournsByRefFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::FindTournsByRefFilter::FindTournsByRefFilter(FindTournsByRefFilter&& _o)
	: internalRef(std::move(_o.internalRef))
	, siteId(std::move(_o.siteId))
	, brandId(std::move(_o.brandId))
	, country(std::move(_o.country))
	, usePMFlag(std::move(_o.usePMFlag))
	, isPM(std::move(_o.isPM))
	, locale(std::move(_o.locale))
{
}

MLobbyNG::cli::FindTournsByRefFilter& MLobbyNG::cli::FindTournsByRefFilter::operator=(FindTournsByRefFilter&& _o)
{
	if(this != &_o)
	{
		internalRef = std::move(_o.internalRef);
		siteId = std::move(_o.siteId);
		brandId = std::move(_o.brandId);
		country = std::move(_o.country);
		usePMFlag = std::move(_o.usePMFlag);
		isPM = std::move(_o.isPM);
		locale = std::move(_o.locale);
	}
	return *this;
}

#endif

void MLobbyNG::cli::FindTournsByRefFilter::clear()
{
	internalRef.clear();
	siteId = 0;
	brandId = BrandType_AllDefined;
	country.clear();
	usePMFlag = false;
	isPM = false;
	locale = 0;
}

bool MLobbyNG::cli::FindTournsByRefFilter::equals(const FindTournsByRefFilter& _o) const
{
	return Atf::atfPStringEquals(internalRef, _o.internalRef) &&
		siteId == _o.siteId &&
		brandId == _o.brandId &&
		Atf::atfPStringEquals(country, _o.country) &&
		usePMFlag == _o.usePMFlag &&
		isPM == _o.isPM &&
		locale == _o.locale;
}

const char *MLobbyNG::cli::FindTournsByRefFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("internalRef=");
	_buf.append(internalRef);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("usePMFlag=");
	_buf.appendUint(usePMFlag);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobbyNG::cli::FindTournsByRefFilter::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("internalRef", internalRef, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandId", brandId, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("usePMFlag", usePMFlag, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPM", isPM, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobbyNG::cli::FindTournsByRefFilter::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("internalRef"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, internalRef)) return false;
		}
		else if (_element.equals("siteId"))
		{
			siteId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandId"))
		{
			brandId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("usePMFlag"))
		{
			usePMFlag = (*_value.ptr() == '1');
		}
		else if (_element.equals("isPM"))
		{
			isPM = (*_value.ptr() == '1');
		}
		else if (_element.equals("locale"))
		{
			locale = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobbyNG::cli::FindTournsByRefFilter::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FindTournsByRefFilter())) // not empty
	{
		_body.composeString(internalRef);
		_body.composeUINT32(siteId);
		_body.composeUINT32(brandId);
		_body.composeString(country);
		_body.composeBOOL(usePMFlag);
		_body.composeBOOL(isPM);
		_body.composeUINT32(locale);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::FindTournsByRefFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(internalRef);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(brandId);
	_parser0.parseStringP(country);
	_parser0.parseBOOL(usePMFlag);
	_parser0.parseBOOL(isPM);
	_parser0.parseUINT32(locale);
}

const char *MLobbyNG::cli::FindTournsByRefFilter::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("internalRef", internalRef);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("brandId", brandId);
	_jsonstr.compose("country", country);
	_jsonstr.compose("usePMFlag", usePMFlag);
	_jsonstr.compose("isPM", isPM);
	_jsonstr.compose("locale", locale);
	return _buf.c_str();
}

void MLobbyNG::cli::FindTournsByRefFilter::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("internalRef", internalRef);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("brandId", brandId);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("usePMFlag", usePMFlag);
	_jparser.parseByNameThrow("isPM", isPM);
	_jparser.parseByNameThrow("locale", locale);
}

/* static */ void MLobbyNG::cli::FindTournsByRefFilter::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString internalRef; _jparser.validateByNameThrow("internalRef", internalRef);
	AtfValidator::validateIntMax(_descr, "internalRef", internalRef.length(), 100, _checker, __FILE__, __LINE__);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	UINT32 brandId; _jparser.validateByNameThrow("brandId", brandId);
	AtfValidator::validateInt(_descr, "brandId", brandId, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), 20, _checker, __FILE__, __LINE__);
	bool usePMFlag; _jparser.validateByNameThrow("usePMFlag", usePMFlag);
	AtfValidator::validateInt(_descr, "usePMFlag", usePMFlag, _checker, __FILE__, __LINE__);
	bool isPM; _jparser.validateByNameThrow("isPM", isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::FindTournsByRefFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "internalRef"); size_t szInternalRef = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "internalRef", szInternalRef, 100, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateInt(_descr, "brandId", brandId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 20, _checker, __FILE__, __LINE__);
	bool usePMFlag; _parser0.parseBOOL(usePMFlag);
	AtfValidator::validateInt(_descr, "usePMFlag", usePMFlag, _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_GAME_LIST
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::Protocol_MSG_MLOBBYNG_GET_GAME_LIST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::Protocol_MSG_MLOBBYNG_GET_GAME_LIST(Protocol_MSG_MLOBBYNG_GET_GAME_LIST&& _o)
	: filter(std::move(_o.filter))
	, activities(std::move(_o.activities))
	, licenseId(std::move(_o.licenseId))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::operator=(Protocol_MSG_MLOBBYNG_GET_GAME_LIST&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		activities = std::move(_o.activities);
		licenseId = std::move(_o.licenseId);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::clear()
{
	filter.clear();
	activities.clear();
	licenseId = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::equals(const Protocol_MSG_MLOBBYNG_GET_GAME_LIST& _o) const
{
	return filter.equals(_o.filter) &&
		activities.equals(_o.activities) &&
		licenseId == _o.licenseId;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_GET_GAME_LIST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_GET_GAME_LIST*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_GAME_LIST).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("activities=");
	activities.toTraceString(_buf);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_GET_GAME_LIST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	activities.toXmlString("activities", _buf);
	Atf::XmlElement::encodeAsXmlElement("licenseId", licenseId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< GameListFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("activities"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ActivityStruct, 4 > >::FromXmlString(_value, activities)) return false;
			}
			else if (_element.equals("licenseId"))
			{
				licenseId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	activities.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(licenseId);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	activities.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("activities", activities);
	_jsonstr.compose("licenseId", licenseId);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("activities", activities);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("licenseId", licenseId);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	GameListFilter filter; _jparser.validateByNameThrow("filter", filter);
	Atf::AtfVectorBase< ActivityStruct > activities; _jparser.validateByNameThrow("activities", activities);
	AtfValidator::validateIntMax(_descr, "activities", activities.size(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 licenseId; _jparser.validateByNameThrow("licenseId", licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	GameListFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	int szActivities = Atf::LAtfVector< ActivityStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("activities"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "activities", szActivities, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY(Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
	, pppTypes(std::move(_o.pppTypes))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::operator=(Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
		pppTypes = std::move(_o.pppTypes);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
	pppTypes.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::equals(const Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder) &&
		pppTypes.equals(_o.pppTypes);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_GET_GAME_LIST_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_GAME_LIST_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pppTypes=");
	pppTypes.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_GET_GAME_LIST_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tourns.toXmlString("tourns", _buf);
	tableTypes.toXmlString("tableTypes", _buf);
	sngTypes.toXmlString("sngTypes", _buf);
	sagTypes.toXmlString("sagTypes", _buf);
	zoomTypes.toXmlString("zoomTypes", _buf);
	seatFinders.toXmlString("seatFinders", _buf);
	gameOrder.toXmlString("gameOrder", _buf);
	pppTypes.toXmlString("pppTypes", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("tableTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableDataStruct, 4 > >::FromXmlString(_value, tableTypes)) return false;
			}
			else if (_element.equals("sngTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SngDataStruct, 4 > >::FromXmlString(_value, sngTypes)) return false;
			}
			else if (_element.equals("sagTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SagDataStruct, 4 > >::FromXmlString(_value, sagTypes)) return false;
			}
			else if (_element.equals("zoomTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ZoomDataStruct, 4 > >::FromXmlString(_value, zoomTypes)) return false;
			}
			else if (_element.equals("seatFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SeatFinderDataStruct, 4 > >::FromXmlString(_value, seatFinders)) return false;
			}
			else if (_element.equals("gameOrder"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, gameOrder)) return false;
			}
			else if (_element.equals("pppTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PPPDataStruct, 4 > >::FromXmlString(_value, pppTypes)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tourns.composeMsg(_msg, _ignoreJSON);
	tableTypes.composeMsg(_msg, _ignoreJSON);
	sngTypes.composeMsg(_msg, _ignoreJSON);
	sagTypes.composeMsg(_msg, _ignoreJSON);
	zoomTypes.composeMsg(_msg, _ignoreJSON);
	seatFinders.composeMsg(_msg, _ignoreJSON);
	gameOrder.composeMsg(_msg, _ignoreJSON);
	pppTypes.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	pppTypes.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tourns", tourns);
	_jsonstr.compose("tableTypes", tableTypes);
	_jsonstr.compose("sngTypes", sngTypes);
	_jsonstr.compose("sagTypes", sagTypes);
	_jsonstr.compose("zoomTypes", zoomTypes);
	_jsonstr.compose("seatFinders", seatFinders);
	_jsonstr.compose("gameOrder", gameOrder);
	_jsonstr.compose("pppTypes", pppTypes);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tourns", tourns);
	_jparser.parseByNameThrow("tableTypes", tableTypes);
	_jparser.parseByNameThrow("sngTypes", sngTypes);
	_jparser.parseByNameThrow("sagTypes", sagTypes);
	_jparser.parseByNameThrow("zoomTypes", zoomTypes);
	_jparser.parseByNameThrow("seatFinders", seatFinders);
	_jparser.parseByNameThrow("gameOrder", gameOrder);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("pppTypes", pppTypes);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_LIST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableDataStruct > tableTypes; _jparser.validateByNameThrow("tableTypes", tableTypes);
	AtfValidator::validateInt(_descr, "tableTypes", tableTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SngDataStruct > sngTypes; _jparser.validateByNameThrow("sngTypes", sngTypes);
	AtfValidator::validateInt(_descr, "sngTypes", sngTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SagDataStruct > sagTypes; _jparser.validateByNameThrow("sagTypes", sagTypes);
	AtfValidator::validateInt(_descr, "sagTypes", sagTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ZoomDataStruct > zoomTypes; _jparser.validateByNameThrow("zoomTypes", zoomTypes);
	AtfValidator::validateInt(_descr, "zoomTypes", zoomTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SeatFinderDataStruct > seatFinders; _jparser.validateByNameThrow("seatFinders", seatFinders);
	AtfValidator::validateInt(_descr, "seatFinders", seatFinders.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > gameOrder; _jparser.validateByNameThrow("gameOrder", gameOrder);
	AtfValidator::validateInt(_descr, "gameOrder", gameOrder.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< PPPDataStruct > pppTypes; _jparser.validateByNameThrow("pppTypes", pppTypes);
	AtfValidator::validateInt(_descr, "pppTypes", pppTypes.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_LIST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = Atf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = Atf::LAtfVector< TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = Atf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = Atf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = Atf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = Atf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	int szPppTypes = Atf::LAtfVector< PPPDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pppTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "pppTypes", szPppTypes, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS(Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS&& _o)
	: filter(std::move(_o.filter))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
	, filterTypeToCount(std::move(_o.filterTypeToCount))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::operator=(Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
		filterTypeToCount = std::move(_o.filterTypeToCount);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::clear()
{
	filter.clear();
	loginExtraData.clear();
	clientMarkers.clear();
	filterTypeToCount = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::equals(const Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS& _o) const
{
	return filter.equals(_o.filter) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers) &&
		filterTypeToCount == _o.filterTypeToCount;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_TABLE_TYPE_COUNTS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_TABLE_TYPE_COUNTS).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("filterTypeToCount=");
	_buf.appendInt(filterTypeToCount);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_TABLE_TYPE_COUNTS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	loginExtraData.toXmlString("loginExtraData", _buf);
	clientMarkers.toXmlString("clientMarkers", _buf);
	Atf::XmlElement::encodeAsXmlElement("filterTypeToCount", filterTypeToCount, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< TableSelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("loginExtraData"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, loginExtraData)) return false;
			}
			else if (_element.equals("clientMarkers"))
			{
				if(!Atf::AtfTempl< ClientMarkers >::FromXmlString(_value, clientMarkers)) return false;
			}
			else if (_element.equals("filterTypeToCount"))
			{
				filterTypeToCount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	loginExtraData.composeMsg(_msg, _ignoreJSON);
	clientMarkers.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(filterTypeToCount);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
	_parser.parseINT32(filterTypeToCount);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("loginExtraData", loginExtraData);
	_jsonstr.compose("clientMarkers", clientMarkers);
	_jsonstr.compose("filterTypeToCount", filterTypeToCount);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("loginExtraData", loginExtraData);
	_jparser.parseByNameThrow("clientMarkers", clientMarkers);
	_jparser.parseByNameThrow("filterTypeToCount", filterTypeToCount);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TABLE_TYPE_COUNTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableSelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	Common::AtfShared::LoginExtra loginExtraData; _jparser.validateByNameThrow("loginExtraData", loginExtraData);
	ClientMarkers clientMarkers; _jparser.validateByNameThrow("clientMarkers", clientMarkers);
	INT32 filterTypeToCount; _jparser.validateByNameThrow("filterTypeToCount", filterTypeToCount);
	AtfValidator::validateIntMax(_descr, "filterTypeToCount", filterTypeToCount, NGFilter_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TABLE_TYPE_COUNTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	TableSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	INT32 filterTypeToCount; _parser.parseINT32(filterTypeToCount);
	AtfValidator::validateIntMax(_descr, "filterTypeToCount", filterTypeToCount, NGFilter_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY(Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY&& _o)
	: filterTypeToCount(std::move(_o.filterTypeToCount))
	, counts(std::move(_o.counts))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::operator=(Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY&& _o)
{
	if(this != &_o)
	{
		filterTypeToCount = std::move(_o.filterTypeToCount);
		counts = std::move(_o.counts);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::clear()
{
	filterTypeToCount = 0;
	counts.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::equals(const Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY& _o) const
{
	return filterTypeToCount == _o.filterTypeToCount &&
		counts.equals(_o.counts);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("filterTypeToCount=");
	_buf.appendInt(filterTypeToCount);
	_buf.append(',');
	_buf.append("counts=");
	counts.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("filterTypeToCount", filterTypeToCount, _buf);
	counts.toXmlString("counts", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filterTypeToCount"))
			{
				filterTypeToCount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("counts"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< FilterCountInfo, 4 > >::FromXmlString(_value, counts)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(filterTypeToCount);
	counts.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(filterTypeToCount);
	counts.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filterTypeToCount", filterTypeToCount);
	_jsonstr.compose("counts", counts);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filterTypeToCount", filterTypeToCount);
	_jparser.parseByNameThrow("counts", counts);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 filterTypeToCount; _jparser.validateByNameThrow("filterTypeToCount", filterTypeToCount);
	AtfValidator::validateInt(_descr, "filterTypeToCount", filterTypeToCount, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< FilterCountInfo > counts; _jparser.validateByNameThrow("counts", counts);
	AtfValidator::validateInt(_descr, "counts", counts.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 filterTypeToCount; _parser.parseINT32(filterTypeToCount);
	AtfValidator::validateInt(_descr, "filterTypeToCount", filterTypeToCount, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCounts = Atf::LAtfVector< FilterCountInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("counts"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "counts", szCounts, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS(Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS&& _o)
	: filter(std::move(_o.filter))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
	, filterTypeToCount(std::move(_o.filterTypeToCount))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::operator=(Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
		filterTypeToCount = std::move(_o.filterTypeToCount);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::clear()
{
	filter.clear();
	loginExtraData.clear();
	clientMarkers.clear();
	filterTypeToCount = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::equals(const Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS& _o) const
{
	return filter.equals(_o.filter) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers) &&
		filterTypeToCount == _o.filterTypeToCount;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_TOURNAMENT_COUNTS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_TOURNAMENT_COUNTS).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("filterTypeToCount=");
	_buf.appendInt(filterTypeToCount);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_TOURNAMENT_COUNTS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	loginExtraData.toXmlString("loginExtraData", _buf);
	clientMarkers.toXmlString("clientMarkers", _buf);
	Atf::XmlElement::encodeAsXmlElement("filterTypeToCount", filterTypeToCount, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< TournSelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("loginExtraData"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, loginExtraData)) return false;
			}
			else if (_element.equals("clientMarkers"))
			{
				if(!Atf::AtfTempl< ClientMarkers >::FromXmlString(_value, clientMarkers)) return false;
			}
			else if (_element.equals("filterTypeToCount"))
			{
				filterTypeToCount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	loginExtraData.composeMsg(_msg, _ignoreJSON);
	clientMarkers.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(filterTypeToCount);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
	_parser.parseINT32(filterTypeToCount);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("loginExtraData", loginExtraData);
	_jsonstr.compose("clientMarkers", clientMarkers);
	_jsonstr.compose("filterTypeToCount", filterTypeToCount);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("loginExtraData", loginExtraData);
	_jparser.parseByNameThrow("clientMarkers", clientMarkers);
	_jparser.parseByNameThrow("filterTypeToCount", filterTypeToCount);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TOURNAMENT_COUNTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TournSelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	Common::AtfShared::LoginExtra loginExtraData; _jparser.validateByNameThrow("loginExtraData", loginExtraData);
	ClientMarkers clientMarkers; _jparser.validateByNameThrow("clientMarkers", clientMarkers);
	INT32 filterTypeToCount; _jparser.validateByNameThrow("filterTypeToCount", filterTypeToCount);
	AtfValidator::validateIntMax(_descr, "filterTypeToCount", filterTypeToCount, NGFilter_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TOURNAMENT_COUNTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	TournSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	INT32 filterTypeToCount; _parser.parseINT32(filterTypeToCount);
	AtfValidator::validateIntMax(_descr, "filterTypeToCount", filterTypeToCount, NGFilter_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY(Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY&& _o)
	: filterTypeToCount(std::move(_o.filterTypeToCount))
	, counts(std::move(_o.counts))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::operator=(Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY&& _o)
{
	if(this != &_o)
	{
		filterTypeToCount = std::move(_o.filterTypeToCount);
		counts = std::move(_o.counts);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::clear()
{
	filterTypeToCount = 0;
	counts.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::equals(const Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY& _o) const
{
	return filterTypeToCount == _o.filterTypeToCount &&
		counts.equals(_o.counts);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("filterTypeToCount=");
	_buf.appendInt(filterTypeToCount);
	_buf.append(',');
	_buf.append("counts=");
	counts.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("filterTypeToCount", filterTypeToCount, _buf);
	counts.toXmlString("counts", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filterTypeToCount"))
			{
				filterTypeToCount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("counts"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< FilterCountInfo, 4 > >::FromXmlString(_value, counts)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(filterTypeToCount);
	counts.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(filterTypeToCount);
	counts.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filterTypeToCount", filterTypeToCount);
	_jsonstr.compose("counts", counts);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filterTypeToCount", filterTypeToCount);
	_jparser.parseByNameThrow("counts", counts);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 filterTypeToCount; _jparser.validateByNameThrow("filterTypeToCount", filterTypeToCount);
	AtfValidator::validateInt(_descr, "filterTypeToCount", filterTypeToCount, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< FilterCountInfo > counts; _jparser.validateByNameThrow("counts", counts);
	AtfValidator::validateInt(_descr, "counts", counts.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 filterTypeToCount; _parser.parseINT32(filterTypeToCount);
	AtfValidator::validateInt(_descr, "filterTypeToCount", filterTypeToCount, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCounts = Atf::LAtfVector< FilterCountInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("counts"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "counts", szCounts, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_SNG_COUNTS
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::Protocol_MSG_MLOBBYNG_SNG_COUNTS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::Protocol_MSG_MLOBBYNG_SNG_COUNTS(Protocol_MSG_MLOBBYNG_SNG_COUNTS&& _o)
	: filter(std::move(_o.filter))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
	, filterTypeToCount(std::move(_o.filterTypeToCount))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::operator=(Protocol_MSG_MLOBBYNG_SNG_COUNTS&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
		filterTypeToCount = std::move(_o.filterTypeToCount);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::clear()
{
	filter.clear();
	loginExtraData.clear();
	clientMarkers.clear();
	filterTypeToCount = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::equals(const Protocol_MSG_MLOBBYNG_SNG_COUNTS& _o) const
{
	return filter.equals(_o.filter) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers) &&
		filterTypeToCount == _o.filterTypeToCount;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_SNG_COUNTS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_SNG_COUNTS*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_SNG_COUNTS).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("filterTypeToCount=");
	_buf.appendInt(filterTypeToCount);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_SNG_COUNTS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	loginExtraData.toXmlString("loginExtraData", _buf);
	clientMarkers.toXmlString("clientMarkers", _buf);
	Atf::XmlElement::encodeAsXmlElement("filterTypeToCount", filterTypeToCount, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< SngSelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("loginExtraData"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, loginExtraData)) return false;
			}
			else if (_element.equals("clientMarkers"))
			{
				if(!Atf::AtfTempl< ClientMarkers >::FromXmlString(_value, clientMarkers)) return false;
			}
			else if (_element.equals("filterTypeToCount"))
			{
				filterTypeToCount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	loginExtraData.composeMsg(_msg, _ignoreJSON);
	clientMarkers.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(filterTypeToCount);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
	_parser.parseINT32(filterTypeToCount);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("loginExtraData", loginExtraData);
	_jsonstr.compose("clientMarkers", clientMarkers);
	_jsonstr.compose("filterTypeToCount", filterTypeToCount);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("loginExtraData", loginExtraData);
	_jparser.parseByNameThrow("clientMarkers", clientMarkers);
	_jparser.parseByNameThrow("filterTypeToCount", filterTypeToCount);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SNG_COUNTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SngSelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	Common::AtfShared::LoginExtra loginExtraData; _jparser.validateByNameThrow("loginExtraData", loginExtraData);
	ClientMarkers clientMarkers; _jparser.validateByNameThrow("clientMarkers", clientMarkers);
	INT32 filterTypeToCount; _jparser.validateByNameThrow("filterTypeToCount", filterTypeToCount);
	AtfValidator::validateIntMax(_descr, "filterTypeToCount", filterTypeToCount, NGFilter_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SNG_COUNTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	SngSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	INT32 filterTypeToCount; _parser.parseINT32(filterTypeToCount);
	AtfValidator::validateIntMax(_descr, "filterTypeToCount", filterTypeToCount, NGFilter_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY(Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY&& _o)
	: filterTypeToCount(std::move(_o.filterTypeToCount))
	, counts(std::move(_o.counts))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::operator=(Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY&& _o)
{
	if(this != &_o)
	{
		filterTypeToCount = std::move(_o.filterTypeToCount);
		counts = std::move(_o.counts);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::clear()
{
	filterTypeToCount = 0;
	counts.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::equals(const Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY& _o) const
{
	return filterTypeToCount == _o.filterTypeToCount &&
		counts.equals(_o.counts);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_SNG_COUNTS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_SNG_COUNTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("filterTypeToCount=");
	_buf.appendInt(filterTypeToCount);
	_buf.append(',');
	_buf.append("counts=");
	counts.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_SNG_COUNTS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("filterTypeToCount", filterTypeToCount, _buf);
	counts.toXmlString("counts", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filterTypeToCount"))
			{
				filterTypeToCount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("counts"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< FilterCountInfo, 4 > >::FromXmlString(_value, counts)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(filterTypeToCount);
	counts.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(filterTypeToCount);
	counts.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filterTypeToCount", filterTypeToCount);
	_jsonstr.compose("counts", counts);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filterTypeToCount", filterTypeToCount);
	_jparser.parseByNameThrow("counts", counts);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SNG_COUNTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 filterTypeToCount; _jparser.validateByNameThrow("filterTypeToCount", filterTypeToCount);
	AtfValidator::validateInt(_descr, "filterTypeToCount", filterTypeToCount, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< FilterCountInfo > counts; _jparser.validateByNameThrow("counts", counts);
	AtfValidator::validateInt(_descr, "counts", counts.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SNG_COUNTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 filterTypeToCount; _parser.parseINT32(filterTypeToCount);
	AtfValidator::validateInt(_descr, "filterTypeToCount", filterTypeToCount, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCounts = Atf::LAtfVector< FilterCountInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("counts"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "counts", szCounts, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO(Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO&& _o)
	: game(std::move(_o.game))
	, locale(std::move(_o.locale))
	, licenseId(std::move(_o.licenseId))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::operator=(Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO&& _o)
{
	if(this != &_o)
	{
		game = std::move(_o.game);
		locale = std::move(_o.locale);
		licenseId = std::move(_o.licenseId);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::clear()
{
	game.clear();
	locale = 0;
	licenseId = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::equals(const Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO& _o) const
{
	return game.equals(_o.game) &&
		locale == _o.locale &&
		licenseId == _o.licenseId;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_GET_GAME_CONN_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_GAME_CONN_INFO).append(")");
	_buf.append(',');
	_buf.append("game=");
	game.toTraceString(_buf);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_GET_GAME_CONN_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	game.toXmlString("game", _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("licenseId", licenseId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("game"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< GameConnInfoReqStruct, 4 > >::FromXmlString(_value, game)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("licenseId"))
			{
				licenseId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	game.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(licenseId);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::parseMsg(CommMsgParser& _parser)
{
	game.parseMsg(_parser);
	_parser.parseUINT32(locale);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("game", game);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("licenseId", licenseId);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("locale", locale);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("licenseId", licenseId);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_CONN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< GameConnInfoReqStruct > game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateIntMax(_descr, "game", game.size(), 1000, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 licenseId; _jparser.validateByNameThrow("licenseId", licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_CONN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szGame = Atf::LAtfVector< GameConnInfoReqStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("game"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "game", szGame, 1000, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY(Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tables(std::move(_o.tables))
	, zoomTypes(std::move(_o.zoomTypes))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::operator=(Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tables = std::move(_o.tables);
		zoomTypes = std::move(_o.zoomTypes);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::clear()
{
	tourns.clear();
	tables.clear();
	zoomTypes.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::equals(const Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tables.equals(_o.tables) &&
		zoomTypes.equals(_o.zoomTypes);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tables=");
	tables.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tourns.toXmlString("tourns", _buf);
	tables.toXmlString("tables", _buf);
	zoomTypes.toXmlString("zoomTypes", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("tables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableData, 4 > >::FromXmlString(_value, tables)) return false;
			}
			else if (_element.equals("zoomTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ZoomDataStruct, 4 > >::FromXmlString(_value, zoomTypes)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tourns.composeMsg(_msg, _ignoreJSON);
	tables.composeMsg(_msg, _ignoreJSON);
	zoomTypes.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tables.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tourns", tourns);
	_jsonstr.compose("tables", tables);
	_jsonstr.compose("zoomTypes", zoomTypes);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tourns", tourns);
	_jparser.parseByNameThrow("tables", tables);
	_jparser.parseByNameThrow("zoomTypes", zoomTypes);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableData > tables; _jparser.validateByNameThrow("tables", tables);
	AtfValidator::validateInt(_descr, "tables", tables.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ZoomDataStruct > zoomTypes; _jparser.validateByNameThrow("zoomTypes", zoomTypes);
	AtfValidator::validateInt(_descr, "zoomTypes", zoomTypes.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = Atf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTables = Atf::LAtfVector< TableData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tables", szTables, _checker, __FILE__, __LINE__);
	int szZoomTypes = Atf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_TICKET_TOURNS
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::Protocol_MSG_MLOBBYNG_TICKET_TOURNS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::Protocol_MSG_MLOBBYNG_TICKET_TOURNS(Protocol_MSG_MLOBBYNG_TICKET_TOURNS&& _o)
	: ticketNames(std::move(_o.ticketNames))
	, locale(std::move(_o.locale))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::operator=(Protocol_MSG_MLOBBYNG_TICKET_TOURNS&& _o)
{
	if(this != &_o)
	{
		ticketNames = std::move(_o.ticketNames);
		locale = std::move(_o.locale);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::clear()
{
	ticketNames.clear();
	locale = 0;
	loginExtraData.clear();
	clientMarkers.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::equals(const Protocol_MSG_MLOBBYNG_TICKET_TOURNS& _o) const
{
	return ticketNames.equals(_o.ticketNames) &&
		locale == _o.locale &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_TICKET_TOURNS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_TICKET_TOURNS*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_TICKET_TOURNS).append(")");
	_buf.append(',');
	_buf.append("ticketNames=");
	ticketNames.toTraceString(_buf);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_TICKET_TOURNS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	ticketNames.toXmlString("ticketNames", _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	loginExtraData.toXmlString("loginExtraData", _buf);
	clientMarkers.toXmlString("clientMarkers", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("ticketNames"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, ticketNames)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("loginExtraData"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, loginExtraData)) return false;
			}
			else if (_element.equals("clientMarkers"))
			{
				if(!Atf::AtfTempl< ClientMarkers >::FromXmlString(_value, clientMarkers)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	ticketNames.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(locale);
	loginExtraData.composeMsg(_msg, _ignoreJSON);
	clientMarkers.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::parseMsg(CommMsgParser& _parser)
{
	ticketNames.parseMsg(_parser);
	_parser.parseUINT32(locale);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketNames", ticketNames);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("loginExtraData", loginExtraData);
	_jsonstr.compose("clientMarkers", clientMarkers);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketNames", ticketNames);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("loginExtraData", loginExtraData);
	_jparser.parseByNameThrow("clientMarkers", clientMarkers);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TICKET_TOURNS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< PString > ticketNames; _jparser.validateByNameThrow("ticketNames", ticketNames);
	AtfValidator::validateInt(_descr, "ticketNames", ticketNames.size(), _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	Common::AtfShared::LoginExtra loginExtraData; _jparser.validateByNameThrow("loginExtraData", loginExtraData);
	ClientMarkers clientMarkers; _jparser.validateByNameThrow("clientMarkers", clientMarkers);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TICKET_TOURNS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTicketNames = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketNames"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "ticketNames", szTicketNames, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY(Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY&& _o)
	: ticketInfos(std::move(_o.ticketInfos))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::operator=(Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY&& _o)
{
	if(this != &_o)
	{
		ticketInfos = std::move(_o.ticketInfos);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::clear()
{
	ticketInfos.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::equals(const Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY& _o) const
{
	return ticketInfos.equals(_o.ticketInfos);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_TICKET_TOURNS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_TICKET_TOURNS_REPLY).append(")");
	_buf.append(',');
	_buf.append("ticketInfos=");
	ticketInfos.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_TICKET_TOURNS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	ticketInfos.toXmlString("ticketInfos", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("ticketInfos"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TicketTournInfo, 4 > >::FromXmlString(_value, ticketInfos)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	ticketInfos.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::parseMsg(CommMsgParser& _parser)
{
	ticketInfos.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketInfos", ticketInfos);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketInfos", ticketInfos);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TICKET_TOURNS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TicketTournInfo > ticketInfos; _jparser.validateByNameThrow("ticketInfos", ticketInfos);
	AtfValidator::validateInt(_descr, "ticketInfos", ticketInfos.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TICKET_TOURNS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTicketInfos = Atf::LAtfVector< TicketTournInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketInfos"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "ticketInfos", szTicketInfos, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_GAME_INFO
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::Protocol_MSG_MLOBBYNG_GET_GAME_INFO()
{
	clear();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::clear()
{
	gameToFind.clear();
	isPM = false;
	locale = 0;
	clientMarkers.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::equals(const Protocol_MSG_MLOBBYNG_GET_GAME_INFO& _o) const
{
	return gameToFind.equals(_o.gameToFind) &&
		isPM == _o.isPM &&
		locale == _o.locale &&
		clientMarkers.equals(_o.clientMarkers);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_GET_GAME_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_GET_GAME_INFO*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_GAME_INFO).append(")");
	_buf.append(',');
	_buf.append("gameToFind=");
	gameToFind.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_GET_GAME_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	gameToFind.toXmlString("gameToFind", _buf);
	Atf::XmlElement::encodeAsXmlElement("isPM", isPM, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	clientMarkers.toXmlString("clientMarkers", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("gameToFind"))
			{
				if(!Atf::AtfTempl< GameConnInfoReqStruct >::FromXmlString(_value, gameToFind)) return false;
			}
			else if (_element.equals("isPM"))
			{
				isPM = (*_value.ptr() == '1');
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientMarkers"))
			{
				if(!Atf::AtfTempl< ClientMarkers >::FromXmlString(_value, clientMarkers)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	gameToFind.composeMsg(_msg, _ignoreJSON);
	_msg.composeBOOL(isPM);
	_msg.composeUINT32(locale);
	clientMarkers.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::parseMsg(CommMsgParser& _parser)
{
	gameToFind.parseMsg(_parser);
	_parser.parseBOOL(isPM);
	_parser.parseUINT32(locale);
	clientMarkers.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameToFind", gameToFind);
	_jsonstr.compose("isPM", isPM);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("clientMarkers", clientMarkers);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameToFind", gameToFind);
	_jparser.parseByNameThrow("isPM", isPM);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("clientMarkers", clientMarkers);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	GameConnInfoReqStruct gameToFind; _jparser.validateByNameThrow("gameToFind", gameToFind);
	bool isPM; _jparser.validateByNameThrow("isPM", isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	ClientMarkers clientMarkers; _jparser.validateByNameThrow("clientMarkers", clientMarkers);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	GameConnInfoReqStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameToFind"), _fieldsWithUnparsedContent);
	bool isPM; _parser.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY(Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, tables(std::move(_o.tables))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::operator=(Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		tables = std::move(_o.tables);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	tables.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::equals(const Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		tables.equals(_o.tables);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_GET_GAME_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_GAME_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tables=");
	tables.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_GET_GAME_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tourns.toXmlString("tourns", _buf);
	tableTypes.toXmlString("tableTypes", _buf);
	sngTypes.toXmlString("sngTypes", _buf);
	sagTypes.toXmlString("sagTypes", _buf);
	zoomTypes.toXmlString("zoomTypes", _buf);
	seatFinders.toXmlString("seatFinders", _buf);
	tables.toXmlString("tables", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("tableTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableDataStruct, 4 > >::FromXmlString(_value, tableTypes)) return false;
			}
			else if (_element.equals("sngTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SngDataStruct, 4 > >::FromXmlString(_value, sngTypes)) return false;
			}
			else if (_element.equals("sagTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SagDataStruct, 4 > >::FromXmlString(_value, sagTypes)) return false;
			}
			else if (_element.equals("zoomTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ZoomDataStruct, 4 > >::FromXmlString(_value, zoomTypes)) return false;
			}
			else if (_element.equals("seatFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SeatFinderDataStruct, 4 > >::FromXmlString(_value, seatFinders)) return false;
			}
			else if (_element.equals("tables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableData, 4 > >::FromXmlString(_value, tables)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tourns.composeMsg(_msg, _ignoreJSON);
	tableTypes.composeMsg(_msg, _ignoreJSON);
	sngTypes.composeMsg(_msg, _ignoreJSON);
	sagTypes.composeMsg(_msg, _ignoreJSON);
	zoomTypes.composeMsg(_msg, _ignoreJSON);
	seatFinders.composeMsg(_msg, _ignoreJSON);
	tables.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	tables.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tourns", tourns);
	_jsonstr.compose("tableTypes", tableTypes);
	_jsonstr.compose("sngTypes", sngTypes);
	_jsonstr.compose("sagTypes", sagTypes);
	_jsonstr.compose("zoomTypes", zoomTypes);
	_jsonstr.compose("seatFinders", seatFinders);
	_jsonstr.compose("tables", tables);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tourns", tourns);
	_jparser.parseByNameThrow("tableTypes", tableTypes);
	_jparser.parseByNameThrow("sngTypes", sngTypes);
	_jparser.parseByNameThrow("sagTypes", sagTypes);
	_jparser.parseByNameThrow("zoomTypes", zoomTypes);
	_jparser.parseByNameThrow("seatFinders", seatFinders);
	_jparser.parseByNameThrow("tables", tables);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableDataStruct > tableTypes; _jparser.validateByNameThrow("tableTypes", tableTypes);
	AtfValidator::validateInt(_descr, "tableTypes", tableTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SngDataStruct > sngTypes; _jparser.validateByNameThrow("sngTypes", sngTypes);
	AtfValidator::validateInt(_descr, "sngTypes", sngTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SagDataStruct > sagTypes; _jparser.validateByNameThrow("sagTypes", sagTypes);
	AtfValidator::validateInt(_descr, "sagTypes", sagTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ZoomDataStruct > zoomTypes; _jparser.validateByNameThrow("zoomTypes", zoomTypes);
	AtfValidator::validateInt(_descr, "zoomTypes", zoomTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SeatFinderDataStruct > seatFinders; _jparser.validateByNameThrow("seatFinders", seatFinders);
	AtfValidator::validateInt(_descr, "seatFinders", seatFinders.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableData > tables; _jparser.validateByNameThrow("tables", tables);
	AtfValidator::validateInt(_descr, "tables", tables.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = Atf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = Atf::LAtfVector< TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = Atf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = Atf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = Atf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = Atf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szTables = Atf::LAtfVector< TableData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tables", szTables, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_FILTER_GAMES
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::Protocol_MSG_MLOBBYNG_FILTER_GAMES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::Protocol_MSG_MLOBBYNG_FILTER_GAMES(Protocol_MSG_MLOBBYNG_FILTER_GAMES&& _o)
	: filter(std::move(_o.filter))
	, criteria(std::move(_o.criteria))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
	, licenseId(std::move(_o.licenseId))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::operator=(Protocol_MSG_MLOBBYNG_FILTER_GAMES&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		criteria = std::move(_o.criteria);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
		licenseId = std::move(_o.licenseId);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::clear()
{
	filter.clear();
	criteria.clear();
	loginExtraData.clear();
	clientMarkers.clear();
	licenseId = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::equals(const Protocol_MSG_MLOBBYNG_FILTER_GAMES& _o) const
{
	return filter.equals(_o.filter) &&
		criteria.equals(_o.criteria) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers) &&
		licenseId == _o.licenseId;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_FILTER_GAMES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_FILTER_GAMES*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_FILTER_GAMES).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	criteria.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_FILTER_GAMES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	criteria.toXmlString("criteria", _buf);
	loginExtraData.toXmlString("loginExtraData", _buf);
	clientMarkers.toXmlString("clientMarkers", _buf);
	Atf::XmlElement::encodeAsXmlElement("licenseId", licenseId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< FilterGamesSelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("criteria"))
			{
				if(!Atf::AtfTempl< FilterGamesResultCriteria >::FromXmlString(_value, criteria)) return false;
			}
			else if (_element.equals("loginExtraData"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, loginExtraData)) return false;
			}
			else if (_element.equals("clientMarkers"))
			{
				if(!Atf::AtfTempl< ClientMarkers >::FromXmlString(_value, clientMarkers)) return false;
			}
			else if (_element.equals("licenseId"))
			{
				licenseId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	criteria.composeMsg(_msg, _ignoreJSON);
	loginExtraData.composeMsg(_msg, _ignoreJSON);
	clientMarkers.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(licenseId);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	criteria.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("criteria", criteria);
	_jsonstr.compose("loginExtraData", loginExtraData);
	_jsonstr.compose("clientMarkers", clientMarkers);
	_jsonstr.compose("licenseId", licenseId);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("criteria", criteria);
	_jparser.parseByNameThrow("loginExtraData", loginExtraData);
	_jparser.parseByNameThrow("clientMarkers", clientMarkers);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("licenseId", licenseId);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	FilterGamesSelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	FilterGamesResultCriteria criteria; _jparser.validateByNameThrow("criteria", criteria);
	Common::AtfShared::LoginExtra loginExtraData; _jparser.validateByNameThrow("loginExtraData", loginExtraData);
	ClientMarkers clientMarkers; _jparser.validateByNameThrow("clientMarkers", clientMarkers);
	if(_jparser.parseEnded()) return;
	UINT32 licenseId; _jparser.validateByNameThrow("licenseId", licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	FilterGamesSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	FilterGamesResultCriteria::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("criteria"), _fieldsWithUnparsedContent);
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY(Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
	, totalItems(std::move(_o.totalItems))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, resultRanges(std::move(_o.resultRanges))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::operator=(Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
		totalItems = std::move(_o.totalItems);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		resultRanges = std::move(_o.resultRanges);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
	totalItems = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	resultRanges.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::equals(const Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder) &&
		totalItems == _o.totalItems &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		resultRanges.equals(_o.resultRanges);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_FILTER_GAMES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_FILTER_GAMES_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendInt(totalItems);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendInt64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt64(maxBuyIn);
	_buf.append(',');
	_buf.append("resultRanges=");
	resultRanges.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_FILTER_GAMES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tourns.toXmlString("tourns", _buf);
	tableTypes.toXmlString("tableTypes", _buf);
	sngTypes.toXmlString("sngTypes", _buf);
	sagTypes.toXmlString("sagTypes", _buf);
	zoomTypes.toXmlString("zoomTypes", _buf);
	seatFinders.toXmlString("seatFinders", _buf);
	gameOrder.toXmlString("gameOrder", _buf);
	Atf::XmlElement::encodeAsXmlElement("totalItems", totalItems, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	resultRanges.toXmlString("resultRanges", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("tableTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableDataStruct, 4 > >::FromXmlString(_value, tableTypes)) return false;
			}
			else if (_element.equals("sngTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SngDataStruct, 4 > >::FromXmlString(_value, sngTypes)) return false;
			}
			else if (_element.equals("sagTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SagDataStruct, 4 > >::FromXmlString(_value, sagTypes)) return false;
			}
			else if (_element.equals("zoomTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ZoomDataStruct, 4 > >::FromXmlString(_value, zoomTypes)) return false;
			}
			else if (_element.equals("seatFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SeatFinderDataStruct, 4 > >::FromXmlString(_value, seatFinders)) return false;
			}
			else if (_element.equals("gameOrder"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, gameOrder)) return false;
			}
			else if (_element.equals("totalItems"))
			{
				totalItems = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minBuyIn"))
			{
				minBuyIn = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxBuyIn"))
			{
				maxBuyIn = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("resultRanges"))
			{
				if(!Atf::AtfTempl< ResultRanges >::FromXmlString(_value, resultRanges)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tourns.composeMsg(_msg, _ignoreJSON);
	tableTypes.composeMsg(_msg, _ignoreJSON);
	sngTypes.composeMsg(_msg, _ignoreJSON);
	sagTypes.composeMsg(_msg, _ignoreJSON);
	zoomTypes.composeMsg(_msg, _ignoreJSON);
	seatFinders.composeMsg(_msg, _ignoreJSON);
	gameOrder.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(totalItems);
	_msg.composeINT64(minBuyIn);
	_msg.composeINT64(maxBuyIn);
	resultRanges.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
	_parser.parseINT32(totalItems);
	_parser.parseINT64(minBuyIn);
	_parser.parseINT64(maxBuyIn);
	resultRanges.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tourns", tourns);
	_jsonstr.compose("tableTypes", tableTypes);
	_jsonstr.compose("sngTypes", sngTypes);
	_jsonstr.compose("sagTypes", sagTypes);
	_jsonstr.compose("zoomTypes", zoomTypes);
	_jsonstr.compose("seatFinders", seatFinders);
	_jsonstr.compose("gameOrder", gameOrder);
	_jsonstr.compose("totalItems", totalItems);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("resultRanges", resultRanges);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tourns", tourns);
	_jparser.parseByNameThrow("tableTypes", tableTypes);
	_jparser.parseByNameThrow("sngTypes", sngTypes);
	_jparser.parseByNameThrow("sagTypes", sagTypes);
	_jparser.parseByNameThrow("zoomTypes", zoomTypes);
	_jparser.parseByNameThrow("seatFinders", seatFinders);
	_jparser.parseByNameThrow("gameOrder", gameOrder);
	_jparser.parseByNameThrow("totalItems", totalItems);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("resultRanges", resultRanges);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableDataStruct > tableTypes; _jparser.validateByNameThrow("tableTypes", tableTypes);
	AtfValidator::validateInt(_descr, "tableTypes", tableTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SngDataStruct > sngTypes; _jparser.validateByNameThrow("sngTypes", sngTypes);
	AtfValidator::validateInt(_descr, "sngTypes", sngTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SagDataStruct > sagTypes; _jparser.validateByNameThrow("sagTypes", sagTypes);
	AtfValidator::validateInt(_descr, "sagTypes", sagTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ZoomDataStruct > zoomTypes; _jparser.validateByNameThrow("zoomTypes", zoomTypes);
	AtfValidator::validateInt(_descr, "zoomTypes", zoomTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SeatFinderDataStruct > seatFinders; _jparser.validateByNameThrow("seatFinders", seatFinders);
	AtfValidator::validateInt(_descr, "seatFinders", seatFinders.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > gameOrder; _jparser.validateByNameThrow("gameOrder", gameOrder);
	AtfValidator::validateInt(_descr, "gameOrder", gameOrder.size(), _checker, __FILE__, __LINE__);
	INT32 totalItems; _jparser.validateByNameThrow("totalItems", totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	INT64 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	ResultRanges resultRanges; _jparser.validateByNameThrow("resultRanges", resultRanges);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = Atf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = Atf::LAtfVector< TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = Atf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = Atf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = Atf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = Atf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	INT32 totalItems; _parser.parseINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	INT64 minBuyIn; _parser.parseINT64(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _parser.parseINT64(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	ResultRanges::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("resultRanges"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS(Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS&& _o)
	: filter(std::move(_o.filter))
	, criteria(std::move(_o.criteria))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
	, licenseId(std::move(_o.licenseId))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::operator=(Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		criteria = std::move(_o.criteria);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
		licenseId = std::move(_o.licenseId);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::clear()
{
	filter.clear();
	criteria.clear();
	loginExtraData.clear();
	clientMarkers.clear();
	licenseId = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::equals(const Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS& _o) const
{
	return filter.equals(_o.filter) &&
		criteria.equals(_o.criteria) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers) &&
		licenseId == _o.licenseId;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_FILTER_GAMES_PS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_FILTER_GAMES_PS).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	criteria.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_FILTER_GAMES_PS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	criteria.toXmlString("criteria", _buf);
	loginExtraData.toXmlString("loginExtraData", _buf);
	clientMarkers.toXmlString("clientMarkers", _buf);
	Atf::XmlElement::encodeAsXmlElement("licenseId", licenseId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< FilterGamesSelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("criteria"))
			{
				if(!Atf::AtfTempl< FilterGamesResultCriteria >::FromXmlString(_value, criteria)) return false;
			}
			else if (_element.equals("loginExtraData"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, loginExtraData)) return false;
			}
			else if (_element.equals("clientMarkers"))
			{
				if(!Atf::AtfTempl< ClientMarkers >::FromXmlString(_value, clientMarkers)) return false;
			}
			else if (_element.equals("licenseId"))
			{
				licenseId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	criteria.composeMsg(_msg, _ignoreJSON);
	loginExtraData.composeMsg(_msg, _ignoreJSON);
	clientMarkers.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(licenseId);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	criteria.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("criteria", criteria);
	_jsonstr.compose("loginExtraData", loginExtraData);
	_jsonstr.compose("clientMarkers", clientMarkers);
	_jsonstr.compose("licenseId", licenseId);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("criteria", criteria);
	_jparser.parseByNameThrow("loginExtraData", loginExtraData);
	_jparser.parseByNameThrow("clientMarkers", clientMarkers);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("licenseId", licenseId);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_GAMES_PS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	FilterGamesSelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	FilterGamesResultCriteria criteria; _jparser.validateByNameThrow("criteria", criteria);
	Common::AtfShared::LoginExtra loginExtraData; _jparser.validateByNameThrow("loginExtraData", loginExtraData);
	ClientMarkers clientMarkers; _jparser.validateByNameThrow("clientMarkers", clientMarkers);
	if(_jparser.parseEnded()) return;
	UINT32 licenseId; _jparser.validateByNameThrow("licenseId", licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_GAMES_PS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	FilterGamesSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	FilterGamesResultCriteria::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("criteria"), _fieldsWithUnparsedContent);
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY(Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
	, totalItems(std::move(_o.totalItems))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, resultRanges(std::move(_o.resultRanges))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::operator=(Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
		totalItems = std::move(_o.totalItems);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		resultRanges = std::move(_o.resultRanges);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
	totalItems = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	resultRanges.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::equals(const Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder) &&
		totalItems == _o.totalItems &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		resultRanges.equals(_o.resultRanges);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendInt(totalItems);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendInt64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt64(maxBuyIn);
	_buf.append(',');
	_buf.append("resultRanges=");
	resultRanges.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tourns.toXmlString("tourns", _buf);
	tableTypes.toXmlString("tableTypes", _buf);
	sngTypes.toXmlString("sngTypes", _buf);
	sagTypes.toXmlString("sagTypes", _buf);
	zoomTypes.toXmlString("zoomTypes", _buf);
	seatFinders.toXmlString("seatFinders", _buf);
	gameOrder.toXmlString("gameOrder", _buf);
	Atf::XmlElement::encodeAsXmlElement("totalItems", totalItems, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	resultRanges.toXmlString("resultRanges", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("tableTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableDataStruct, 4 > >::FromXmlString(_value, tableTypes)) return false;
			}
			else if (_element.equals("sngTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SngDataStruct, 4 > >::FromXmlString(_value, sngTypes)) return false;
			}
			else if (_element.equals("sagTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SagDataStruct, 4 > >::FromXmlString(_value, sagTypes)) return false;
			}
			else if (_element.equals("zoomTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ZoomDataStruct, 4 > >::FromXmlString(_value, zoomTypes)) return false;
			}
			else if (_element.equals("seatFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SeatFinderDataStruct, 4 > >::FromXmlString(_value, seatFinders)) return false;
			}
			else if (_element.equals("gameOrder"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, gameOrder)) return false;
			}
			else if (_element.equals("totalItems"))
			{
				totalItems = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minBuyIn"))
			{
				minBuyIn = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxBuyIn"))
			{
				maxBuyIn = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("resultRanges"))
			{
				if(!Atf::AtfTempl< ResultRanges >::FromXmlString(_value, resultRanges)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tourns.composeMsg(_msg, _ignoreJSON);
	tableTypes.composeMsg(_msg, _ignoreJSON);
	sngTypes.composeMsg(_msg, _ignoreJSON);
	sagTypes.composeMsg(_msg, _ignoreJSON);
	zoomTypes.composeMsg(_msg, _ignoreJSON);
	seatFinders.composeMsg(_msg, _ignoreJSON);
	gameOrder.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(totalItems);
	_msg.composeINT64(minBuyIn);
	_msg.composeINT64(maxBuyIn);
	resultRanges.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
	_parser.parseINT32(totalItems);
	_parser.parseINT64(minBuyIn);
	_parser.parseINT64(maxBuyIn);
	resultRanges.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tourns", tourns);
	_jsonstr.compose("tableTypes", tableTypes);
	_jsonstr.compose("sngTypes", sngTypes);
	_jsonstr.compose("sagTypes", sagTypes);
	_jsonstr.compose("zoomTypes", zoomTypes);
	_jsonstr.compose("seatFinders", seatFinders);
	_jsonstr.compose("gameOrder", gameOrder);
	_jsonstr.compose("totalItems", totalItems);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("resultRanges", resultRanges);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tourns", tourns);
	_jparser.parseByNameThrow("tableTypes", tableTypes);
	_jparser.parseByNameThrow("sngTypes", sngTypes);
	_jparser.parseByNameThrow("sagTypes", sagTypes);
	_jparser.parseByNameThrow("zoomTypes", zoomTypes);
	_jparser.parseByNameThrow("seatFinders", seatFinders);
	_jparser.parseByNameThrow("gameOrder", gameOrder);
	_jparser.parseByNameThrow("totalItems", totalItems);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("resultRanges", resultRanges);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableDataStruct > tableTypes; _jparser.validateByNameThrow("tableTypes", tableTypes);
	AtfValidator::validateInt(_descr, "tableTypes", tableTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SngDataStruct > sngTypes; _jparser.validateByNameThrow("sngTypes", sngTypes);
	AtfValidator::validateInt(_descr, "sngTypes", sngTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SagDataStruct > sagTypes; _jparser.validateByNameThrow("sagTypes", sagTypes);
	AtfValidator::validateInt(_descr, "sagTypes", sagTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ZoomDataStruct > zoomTypes; _jparser.validateByNameThrow("zoomTypes", zoomTypes);
	AtfValidator::validateInt(_descr, "zoomTypes", zoomTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SeatFinderDataStruct > seatFinders; _jparser.validateByNameThrow("seatFinders", seatFinders);
	AtfValidator::validateInt(_descr, "seatFinders", seatFinders.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > gameOrder; _jparser.validateByNameThrow("gameOrder", gameOrder);
	AtfValidator::validateInt(_descr, "gameOrder", gameOrder.size(), _checker, __FILE__, __LINE__);
	INT32 totalItems; _jparser.validateByNameThrow("totalItems", totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	INT64 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	ResultRanges resultRanges; _jparser.validateByNameThrow("resultRanges", resultRanges);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = Atf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = Atf::LAtfVector< TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = Atf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = Atf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = Atf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = Atf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	INT32 totalItems; _parser.parseINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	INT64 minBuyIn; _parser.parseINT64(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _parser.parseINT64(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	ResultRanges::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("resultRanges"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2(Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2&& _o)
	: filter(std::move(_o.filter))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
	, licenseId(std::move(_o.licenseId))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::operator=(Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
		licenseId = std::move(_o.licenseId);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::clear()
{
	filter.clear();
	loginExtraData.clear();
	clientMarkers.clear();
	licenseId = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::equals(const Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2& _o) const
{
	return filter.equals(_o.filter) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers) &&
		licenseId == _o.licenseId;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_GET_SUGGESTED_GAMES2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_SUGGESTED_GAMES2).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_GET_SUGGESTED_GAMES2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	loginExtraData.toXmlString("loginExtraData", _buf);
	clientMarkers.toXmlString("clientMarkers", _buf);
	Atf::XmlElement::encodeAsXmlElement("licenseId", licenseId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< SuggestedGames2SelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("loginExtraData"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, loginExtraData)) return false;
			}
			else if (_element.equals("clientMarkers"))
			{
				if(!Atf::AtfTempl< ClientMarkers >::FromXmlString(_value, clientMarkers)) return false;
			}
			else if (_element.equals("licenseId"))
			{
				licenseId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	loginExtraData.composeMsg(_msg, _ignoreJSON);
	clientMarkers.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(licenseId);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("loginExtraData", loginExtraData);
	_jsonstr.compose("clientMarkers", clientMarkers);
	_jsonstr.compose("licenseId", licenseId);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("loginExtraData", loginExtraData);
	_jparser.parseByNameThrow("clientMarkers", clientMarkers);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("licenseId", licenseId);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_SUGGESTED_GAMES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SuggestedGames2SelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	Common::AtfShared::LoginExtra loginExtraData; _jparser.validateByNameThrow("loginExtraData", loginExtraData);
	ClientMarkers clientMarkers; _jparser.validateByNameThrow("clientMarkers", clientMarkers);
	if(_jparser.parseEnded()) return;
	UINT32 licenseId; _jparser.validateByNameThrow("licenseId", licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_SUGGESTED_GAMES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	SuggestedGames2SelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY(Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::operator=(Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::equals(const Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tourns.toXmlString("tourns", _buf);
	tableTypes.toXmlString("tableTypes", _buf);
	sngTypes.toXmlString("sngTypes", _buf);
	sagTypes.toXmlString("sagTypes", _buf);
	zoomTypes.toXmlString("zoomTypes", _buf);
	seatFinders.toXmlString("seatFinders", _buf);
	gameOrder.toXmlString("gameOrder", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("tableTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableDataStruct, 4 > >::FromXmlString(_value, tableTypes)) return false;
			}
			else if (_element.equals("sngTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SngDataStruct, 4 > >::FromXmlString(_value, sngTypes)) return false;
			}
			else if (_element.equals("sagTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SagDataStruct, 4 > >::FromXmlString(_value, sagTypes)) return false;
			}
			else if (_element.equals("zoomTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ZoomDataStruct, 4 > >::FromXmlString(_value, zoomTypes)) return false;
			}
			else if (_element.equals("seatFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SeatFinderDataStruct, 4 > >::FromXmlString(_value, seatFinders)) return false;
			}
			else if (_element.equals("gameOrder"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, gameOrder)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tourns.composeMsg(_msg, _ignoreJSON);
	tableTypes.composeMsg(_msg, _ignoreJSON);
	sngTypes.composeMsg(_msg, _ignoreJSON);
	sagTypes.composeMsg(_msg, _ignoreJSON);
	zoomTypes.composeMsg(_msg, _ignoreJSON);
	seatFinders.composeMsg(_msg, _ignoreJSON);
	gameOrder.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tourns", tourns);
	_jsonstr.compose("tableTypes", tableTypes);
	_jsonstr.compose("sngTypes", sngTypes);
	_jsonstr.compose("sagTypes", sagTypes);
	_jsonstr.compose("zoomTypes", zoomTypes);
	_jsonstr.compose("seatFinders", seatFinders);
	_jsonstr.compose("gameOrder", gameOrder);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tourns", tourns);
	_jparser.parseByNameThrow("tableTypes", tableTypes);
	_jparser.parseByNameThrow("sngTypes", sngTypes);
	_jparser.parseByNameThrow("sagTypes", sagTypes);
	_jparser.parseByNameThrow("zoomTypes", zoomTypes);
	_jparser.parseByNameThrow("seatFinders", seatFinders);
	_jparser.parseByNameThrow("gameOrder", gameOrder);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableDataStruct > tableTypes; _jparser.validateByNameThrow("tableTypes", tableTypes);
	AtfValidator::validateInt(_descr, "tableTypes", tableTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SngDataStruct > sngTypes; _jparser.validateByNameThrow("sngTypes", sngTypes);
	AtfValidator::validateInt(_descr, "sngTypes", sngTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SagDataStruct > sagTypes; _jparser.validateByNameThrow("sagTypes", sagTypes);
	AtfValidator::validateInt(_descr, "sagTypes", sagTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ZoomDataStruct > zoomTypes; _jparser.validateByNameThrow("zoomTypes", zoomTypes);
	AtfValidator::validateInt(_descr, "zoomTypes", zoomTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SeatFinderDataStruct > seatFinders; _jparser.validateByNameThrow("seatFinders", seatFinders);
	AtfValidator::validateInt(_descr, "seatFinders", seatFinders.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > gameOrder; _jparser.validateByNameThrow("gameOrder", gameOrder);
	AtfValidator::validateInt(_descr, "gameOrder", gameOrder.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = Atf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = Atf::LAtfVector< TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = Atf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = Atf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = Atf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = Atf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS(Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS&& _o)
	: filter(std::move(_o.filter))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
	, licenseId(std::move(_o.licenseId))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::operator=(Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
		licenseId = std::move(_o.licenseId);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::clear()
{
	filter.clear();
	loginExtraData.clear();
	clientMarkers.clear();
	licenseId = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::equals(const Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS& _o) const
{
	return filter.equals(_o.filter) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers) &&
		licenseId == _o.licenseId;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	loginExtraData.toXmlString("loginExtraData", _buf);
	clientMarkers.toXmlString("clientMarkers", _buf);
	Atf::XmlElement::encodeAsXmlElement("licenseId", licenseId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< SuggestedGames2SelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("loginExtraData"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, loginExtraData)) return false;
			}
			else if (_element.equals("clientMarkers"))
			{
				if(!Atf::AtfTempl< ClientMarkers >::FromXmlString(_value, clientMarkers)) return false;
			}
			else if (_element.equals("licenseId"))
			{
				licenseId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	loginExtraData.composeMsg(_msg, _ignoreJSON);
	clientMarkers.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(licenseId);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("loginExtraData", loginExtraData);
	_jsonstr.compose("clientMarkers", clientMarkers);
	_jsonstr.compose("licenseId", licenseId);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("loginExtraData", loginExtraData);
	_jparser.parseByNameThrow("clientMarkers", clientMarkers);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("licenseId", licenseId);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SuggestedGames2SelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	Common::AtfShared::LoginExtra loginExtraData; _jparser.validateByNameThrow("loginExtraData", loginExtraData);
	ClientMarkers clientMarkers; _jparser.validateByNameThrow("clientMarkers", clientMarkers);
	if(_jparser.parseEnded()) return;
	UINT32 licenseId; _jparser.validateByNameThrow("licenseId", licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	SuggestedGames2SelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY(Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::operator=(Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::equals(const Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tourns.toXmlString("tourns", _buf);
	tableTypes.toXmlString("tableTypes", _buf);
	sngTypes.toXmlString("sngTypes", _buf);
	sagTypes.toXmlString("sagTypes", _buf);
	zoomTypes.toXmlString("zoomTypes", _buf);
	seatFinders.toXmlString("seatFinders", _buf);
	gameOrder.toXmlString("gameOrder", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("tableTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableDataStruct, 4 > >::FromXmlString(_value, tableTypes)) return false;
			}
			else if (_element.equals("sngTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SngDataStruct, 4 > >::FromXmlString(_value, sngTypes)) return false;
			}
			else if (_element.equals("sagTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SagDataStruct, 4 > >::FromXmlString(_value, sagTypes)) return false;
			}
			else if (_element.equals("zoomTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ZoomDataStruct, 4 > >::FromXmlString(_value, zoomTypes)) return false;
			}
			else if (_element.equals("seatFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SeatFinderDataStruct, 4 > >::FromXmlString(_value, seatFinders)) return false;
			}
			else if (_element.equals("gameOrder"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, gameOrder)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tourns.composeMsg(_msg, _ignoreJSON);
	tableTypes.composeMsg(_msg, _ignoreJSON);
	sngTypes.composeMsg(_msg, _ignoreJSON);
	sagTypes.composeMsg(_msg, _ignoreJSON);
	zoomTypes.composeMsg(_msg, _ignoreJSON);
	seatFinders.composeMsg(_msg, _ignoreJSON);
	gameOrder.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tourns", tourns);
	_jsonstr.compose("tableTypes", tableTypes);
	_jsonstr.compose("sngTypes", sngTypes);
	_jsonstr.compose("sagTypes", sagTypes);
	_jsonstr.compose("zoomTypes", zoomTypes);
	_jsonstr.compose("seatFinders", seatFinders);
	_jsonstr.compose("gameOrder", gameOrder);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tourns", tourns);
	_jparser.parseByNameThrow("tableTypes", tableTypes);
	_jparser.parseByNameThrow("sngTypes", sngTypes);
	_jparser.parseByNameThrow("sagTypes", sagTypes);
	_jparser.parseByNameThrow("zoomTypes", zoomTypes);
	_jparser.parseByNameThrow("seatFinders", seatFinders);
	_jparser.parseByNameThrow("gameOrder", gameOrder);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableDataStruct > tableTypes; _jparser.validateByNameThrow("tableTypes", tableTypes);
	AtfValidator::validateInt(_descr, "tableTypes", tableTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SngDataStruct > sngTypes; _jparser.validateByNameThrow("sngTypes", sngTypes);
	AtfValidator::validateInt(_descr, "sngTypes", sngTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SagDataStruct > sagTypes; _jparser.validateByNameThrow("sagTypes", sagTypes);
	AtfValidator::validateInt(_descr, "sagTypes", sagTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ZoomDataStruct > zoomTypes; _jparser.validateByNameThrow("zoomTypes", zoomTypes);
	AtfValidator::validateInt(_descr, "zoomTypes", zoomTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SeatFinderDataStruct > seatFinders; _jparser.validateByNameThrow("seatFinders", seatFinders);
	AtfValidator::validateInt(_descr, "seatFinders", seatFinders.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > gameOrder; _jparser.validateByNameThrow("gameOrder", gameOrder);
	AtfValidator::validateInt(_descr, "gameOrder", gameOrder.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = Atf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = Atf::LAtfVector< TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = Atf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = Atf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = Atf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = Atf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME(Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME&& _o)
	: filter(std::move(_o.filter))
	, criteria(std::move(_o.criteria))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::operator=(Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		criteria = std::move(_o.criteria);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::clear()
{
	filter.clear();
	criteria.clear();
	loginExtraData.clear();
	clientMarkers.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::equals(const Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME& _o) const
{
	return filter.equals(_o.filter) &&
		criteria.equals(_o.criteria) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_SEARCH_BY_NAME != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_SEARCH_BY_NAME).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	criteria.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_SEARCH_BY_NAME).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	criteria.toXmlString("criteria", _buf);
	loginExtraData.toXmlString("loginExtraData", _buf);
	clientMarkers.toXmlString("clientMarkers", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< NameSearchSelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("criteria"))
			{
				if(!Atf::AtfTempl< FilterGamesResultCriteria >::FromXmlString(_value, criteria)) return false;
			}
			else if (_element.equals("loginExtraData"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, loginExtraData)) return false;
			}
			else if (_element.equals("clientMarkers"))
			{
				if(!Atf::AtfTempl< ClientMarkers >::FromXmlString(_value, clientMarkers)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	criteria.composeMsg(_msg, _ignoreJSON);
	loginExtraData.composeMsg(_msg, _ignoreJSON);
	clientMarkers.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	criteria.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("criteria", criteria);
	_jsonstr.compose("loginExtraData", loginExtraData);
	_jsonstr.compose("clientMarkers", clientMarkers);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("criteria", criteria);
	_jparser.parseByNameThrow("loginExtraData", loginExtraData);
	_jparser.parseByNameThrow("clientMarkers", clientMarkers);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SEARCH_BY_NAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	NameSearchSelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	FilterGamesResultCriteria criteria; _jparser.validateByNameThrow("criteria", criteria);
	Common::AtfShared::LoginExtra loginExtraData; _jparser.validateByNameThrow("loginExtraData", loginExtraData);
	ClientMarkers clientMarkers; _jparser.validateByNameThrow("clientMarkers", clientMarkers);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SEARCH_BY_NAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	NameSearchSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	FilterGamesResultCriteria::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("criteria"), _fieldsWithUnparsedContent);
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY(Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::operator=(Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::equals(const Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tourns.toXmlString("tourns", _buf);
	tableTypes.toXmlString("tableTypes", _buf);
	sngTypes.toXmlString("sngTypes", _buf);
	sagTypes.toXmlString("sagTypes", _buf);
	zoomTypes.toXmlString("zoomTypes", _buf);
	seatFinders.toXmlString("seatFinders", _buf);
	gameOrder.toXmlString("gameOrder", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("tableTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableDataStruct, 4 > >::FromXmlString(_value, tableTypes)) return false;
			}
			else if (_element.equals("sngTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SngDataStruct, 4 > >::FromXmlString(_value, sngTypes)) return false;
			}
			else if (_element.equals("sagTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SagDataStruct, 4 > >::FromXmlString(_value, sagTypes)) return false;
			}
			else if (_element.equals("zoomTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ZoomDataStruct, 4 > >::FromXmlString(_value, zoomTypes)) return false;
			}
			else if (_element.equals("seatFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SeatFinderDataStruct, 4 > >::FromXmlString(_value, seatFinders)) return false;
			}
			else if (_element.equals("gameOrder"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, gameOrder)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tourns.composeMsg(_msg, _ignoreJSON);
	tableTypes.composeMsg(_msg, _ignoreJSON);
	sngTypes.composeMsg(_msg, _ignoreJSON);
	sagTypes.composeMsg(_msg, _ignoreJSON);
	zoomTypes.composeMsg(_msg, _ignoreJSON);
	seatFinders.composeMsg(_msg, _ignoreJSON);
	gameOrder.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tourns", tourns);
	_jsonstr.compose("tableTypes", tableTypes);
	_jsonstr.compose("sngTypes", sngTypes);
	_jsonstr.compose("sagTypes", sagTypes);
	_jsonstr.compose("zoomTypes", zoomTypes);
	_jsonstr.compose("seatFinders", seatFinders);
	_jsonstr.compose("gameOrder", gameOrder);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tourns", tourns);
	_jparser.parseByNameThrow("tableTypes", tableTypes);
	_jparser.parseByNameThrow("sngTypes", sngTypes);
	_jparser.parseByNameThrow("sagTypes", sagTypes);
	_jparser.parseByNameThrow("zoomTypes", zoomTypes);
	_jparser.parseByNameThrow("seatFinders", seatFinders);
	_jparser.parseByNameThrow("gameOrder", gameOrder);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableDataStruct > tableTypes; _jparser.validateByNameThrow("tableTypes", tableTypes);
	AtfValidator::validateInt(_descr, "tableTypes", tableTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SngDataStruct > sngTypes; _jparser.validateByNameThrow("sngTypes", sngTypes);
	AtfValidator::validateInt(_descr, "sngTypes", sngTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SagDataStruct > sagTypes; _jparser.validateByNameThrow("sagTypes", sagTypes);
	AtfValidator::validateInt(_descr, "sagTypes", sagTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ZoomDataStruct > zoomTypes; _jparser.validateByNameThrow("zoomTypes", zoomTypes);
	AtfValidator::validateInt(_descr, "zoomTypes", zoomTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SeatFinderDataStruct > seatFinders; _jparser.validateByNameThrow("seatFinders", seatFinders);
	AtfValidator::validateInt(_descr, "seatFinders", seatFinders.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > gameOrder; _jparser.validateByNameThrow("gameOrder", gameOrder);
	AtfValidator::validateInt(_descr, "gameOrder", gameOrder.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = Atf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = Atf::LAtfVector< TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = Atf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = Atf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = Atf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = Atf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS(Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS&& _o)
	: filter(std::move(_o.filter))
	, criteria(std::move(_o.criteria))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::operator=(Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		criteria = std::move(_o.criteria);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::clear()
{
	filter.clear();
	criteria.clear();
	loginExtraData.clear();
	clientMarkers.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::equals(const Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS& _o) const
{
	return filter.equals(_o.filter) &&
		criteria.equals(_o.criteria) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_SEARCH_BY_NAME_PS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_SEARCH_BY_NAME_PS).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	criteria.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_SEARCH_BY_NAME_PS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	criteria.toXmlString("criteria", _buf);
	loginExtraData.toXmlString("loginExtraData", _buf);
	clientMarkers.toXmlString("clientMarkers", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< NameSearchSelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("criteria"))
			{
				if(!Atf::AtfTempl< FilterGamesResultCriteria >::FromXmlString(_value, criteria)) return false;
			}
			else if (_element.equals("loginExtraData"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, loginExtraData)) return false;
			}
			else if (_element.equals("clientMarkers"))
			{
				if(!Atf::AtfTempl< ClientMarkers >::FromXmlString(_value, clientMarkers)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	criteria.composeMsg(_msg, _ignoreJSON);
	loginExtraData.composeMsg(_msg, _ignoreJSON);
	clientMarkers.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	criteria.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("criteria", criteria);
	_jsonstr.compose("loginExtraData", loginExtraData);
	_jsonstr.compose("clientMarkers", clientMarkers);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("criteria", criteria);
	_jparser.parseByNameThrow("loginExtraData", loginExtraData);
	_jparser.parseByNameThrow("clientMarkers", clientMarkers);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SEARCH_BY_NAME_PS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	NameSearchSelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	FilterGamesResultCriteria criteria; _jparser.validateByNameThrow("criteria", criteria);
	Common::AtfShared::LoginExtra loginExtraData; _jparser.validateByNameThrow("loginExtraData", loginExtraData);
	ClientMarkers clientMarkers; _jparser.validateByNameThrow("clientMarkers", clientMarkers);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SEARCH_BY_NAME_PS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	NameSearchSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	FilterGamesResultCriteria::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("criteria"), _fieldsWithUnparsedContent);
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY(Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::operator=(Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::equals(const Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tourns.toXmlString("tourns", _buf);
	tableTypes.toXmlString("tableTypes", _buf);
	sngTypes.toXmlString("sngTypes", _buf);
	sagTypes.toXmlString("sagTypes", _buf);
	zoomTypes.toXmlString("zoomTypes", _buf);
	seatFinders.toXmlString("seatFinders", _buf);
	gameOrder.toXmlString("gameOrder", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("tableTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableDataStruct, 4 > >::FromXmlString(_value, tableTypes)) return false;
			}
			else if (_element.equals("sngTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SngDataStruct, 4 > >::FromXmlString(_value, sngTypes)) return false;
			}
			else if (_element.equals("sagTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SagDataStruct, 4 > >::FromXmlString(_value, sagTypes)) return false;
			}
			else if (_element.equals("zoomTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ZoomDataStruct, 4 > >::FromXmlString(_value, zoomTypes)) return false;
			}
			else if (_element.equals("seatFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SeatFinderDataStruct, 4 > >::FromXmlString(_value, seatFinders)) return false;
			}
			else if (_element.equals("gameOrder"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, gameOrder)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tourns.composeMsg(_msg, _ignoreJSON);
	tableTypes.composeMsg(_msg, _ignoreJSON);
	sngTypes.composeMsg(_msg, _ignoreJSON);
	sagTypes.composeMsg(_msg, _ignoreJSON);
	zoomTypes.composeMsg(_msg, _ignoreJSON);
	seatFinders.composeMsg(_msg, _ignoreJSON);
	gameOrder.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tourns", tourns);
	_jsonstr.compose("tableTypes", tableTypes);
	_jsonstr.compose("sngTypes", sngTypes);
	_jsonstr.compose("sagTypes", sagTypes);
	_jsonstr.compose("zoomTypes", zoomTypes);
	_jsonstr.compose("seatFinders", seatFinders);
	_jsonstr.compose("gameOrder", gameOrder);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tourns", tourns);
	_jparser.parseByNameThrow("tableTypes", tableTypes);
	_jparser.parseByNameThrow("sngTypes", sngTypes);
	_jparser.parseByNameThrow("sagTypes", sagTypes);
	_jparser.parseByNameThrow("zoomTypes", zoomTypes);
	_jparser.parseByNameThrow("seatFinders", seatFinders);
	_jparser.parseByNameThrow("gameOrder", gameOrder);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableDataStruct > tableTypes; _jparser.validateByNameThrow("tableTypes", tableTypes);
	AtfValidator::validateInt(_descr, "tableTypes", tableTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SngDataStruct > sngTypes; _jparser.validateByNameThrow("sngTypes", sngTypes);
	AtfValidator::validateInt(_descr, "sngTypes", sngTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SagDataStruct > sagTypes; _jparser.validateByNameThrow("sagTypes", sagTypes);
	AtfValidator::validateInt(_descr, "sagTypes", sagTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ZoomDataStruct > zoomTypes; _jparser.validateByNameThrow("zoomTypes", zoomTypes);
	AtfValidator::validateInt(_descr, "zoomTypes", zoomTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SeatFinderDataStruct > seatFinders; _jparser.validateByNameThrow("seatFinders", seatFinders);
	AtfValidator::validateInt(_descr, "seatFinders", seatFinders.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > gameOrder; _jparser.validateByNameThrow("gameOrder", gameOrder);
	AtfValidator::validateInt(_descr, "gameOrder", gameOrder.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = Atf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = Atf::LAtfVector< TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = Atf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = Atf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = Atf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = Atf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS(Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS&& _o)
	: input(std::move(_o.input))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::operator=(Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS&& _o)
{
	if(this != &_o)
	{
		input = std::move(_o.input);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::clear()
{
	input.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::equals(const Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS& _o) const
{
	return input.equals(_o.input);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_FILTER_TICKET_TOURNS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_FILTER_TICKET_TOURNS).append(")");
	_buf.append(',');
	_buf.append("input=");
	input.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_FILTER_TICKET_TOURNS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	input.toXmlString("input", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("input"))
			{
				if(!Atf::AtfTempl< TicketTournRequestData >::FromXmlString(_value, input)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	input.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::parseMsg(CommMsgParser& _parser)
{
	input.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("input", input);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("input", input);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_TICKET_TOURNS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TicketTournRequestData input; _jparser.validateByNameThrow("input", input);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_TICKET_TOURNS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	TicketTournRequestData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("input"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY(Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY&& _o)
	: ticketInfos(std::move(_o.ticketInfos))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::operator=(Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY&& _o)
{
	if(this != &_o)
	{
		ticketInfos = std::move(_o.ticketInfos);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::clear()
{
	ticketInfos.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::equals(const Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY& _o) const
{
	return ticketInfos.equals(_o.ticketInfos);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY).append(")");
	_buf.append(',');
	_buf.append("ticketInfos=");
	ticketInfos.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	ticketInfos.toXmlString("ticketInfos", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("ticketInfos"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::OrderedTicketTournInfo, 4 > >::FromXmlString(_value, ticketInfos)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	ticketInfos.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::parseMsg(CommMsgParser& _parser)
{
	ticketInfos.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketInfos", ticketInfos);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketInfos", ticketInfos);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< MLobbyNG::cli::OrderedTicketTournInfo > ticketInfos; _jparser.validateByNameThrow("ticketInfos", ticketInfos);
	AtfValidator::validateInt(_descr, "ticketInfos", ticketInfos.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTicketInfos = Atf::LAtfVector< MLobbyNG::cli::OrderedTicketTournInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketInfos"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "ticketInfos", szTicketInfos, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES(Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES&& _o)
	: locale(std::move(_o.locale))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
	, currencyMask(std::move(_o.currencyMask))
	, country(std::move(_o.country))
	, isPM(std::move(_o.isPM))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::operator=(Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
		currencyMask = std::move(_o.currencyMask);
		country = std::move(_o.country);
		isPM = std::move(_o.isPM);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::clear()
{
	locale = 0;
	loginExtraData.clear();
	clientMarkers.clear();
	currencyMask = 0;
	country.clear();
	isPM = false;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::equals(const Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES& _o) const
{
	return locale == _o.locale &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers) &&
		currencyMask == _o.currencyMask &&
		Atf::atfPStringEquals(country, _o.country) &&
		isPM == _o.isPM;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_GET_BRANDED_LOBBIES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_BRANDED_LOBBIES).append(")");
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_GET_BRANDED_LOBBIES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	loginExtraData.toXmlString("loginExtraData", _buf);
	clientMarkers.toXmlString("clientMarkers", _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyMask", currencyMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPM", isPM, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("loginExtraData"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, loginExtraData)) return false;
			}
			else if (_element.equals("clientMarkers"))
			{
				if(!Atf::AtfTempl< ClientMarkers >::FromXmlString(_value, clientMarkers)) return false;
			}
			else if (_element.equals("currencyMask"))
			{
				currencyMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("isPM"))
			{
				isPM = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(locale);
	loginExtraData.composeMsg(_msg, _ignoreJSON);
	clientMarkers.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(currencyMask);
	_msg.composeString(country);
	_msg.composeBOOL(isPM);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(locale);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(currencyMask);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(country);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isPM);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("loginExtraData", loginExtraData);
	_jsonstr.compose("clientMarkers", clientMarkers);
	_jsonstr.compose("currencyMask", currencyMask);
	_jsonstr.compose("country", country);
	_jsonstr.compose("isPM", isPM);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("loginExtraData", loginExtraData);
	_jparser.parseByNameThrow("clientMarkers", clientMarkers);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("currencyMask", currencyMask);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("country", country);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("isPM", isPM);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	Common::AtfShared::LoginExtra loginExtraData; _jparser.validateByNameThrow("loginExtraData", loginExtraData);
	ClientMarkers clientMarkers; _jparser.validateByNameThrow("clientMarkers", clientMarkers);
	if(_jparser.parseEnded()) return;
	UINT32 currencyMask; _jparser.validateByNameThrow("currencyMask", currencyMask);
	AtfValidator::validateInt(_descr, "currencyMask", currencyMask, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool isPM; _jparser.validateByNameThrow("isPM", isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	PString _descbuf;
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 currencyMask; _parser.parseUINT32(currencyMask);
	AtfValidator::validateInt(_descr, "currencyMask", currencyMask, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool isPM; _parser.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY(Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY&& _o)
	: lobbies(std::move(_o.lobbies))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::operator=(Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY&& _o)
{
	if(this != &_o)
	{
		lobbies = std::move(_o.lobbies);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::clear()
{
	lobbies.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::equals(const Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY& _o) const
{
	return lobbies.equals(_o.lobbies);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY).append(")");
	_buf.append(',');
	_buf.append("lobbies=");
	lobbies.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	lobbies.toXmlString("lobbies", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("lobbies"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< BrandedLobbyInfo, 4 > >::FromXmlString(_value, lobbies)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	lobbies.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::parseMsg(CommMsgParser& _parser)
{
	lobbies.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("lobbies", lobbies);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("lobbies", lobbies);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< BrandedLobbyInfo > lobbies; _jparser.validateByNameThrow("lobbies", lobbies);
	AtfValidator::validateInt(_descr, "lobbies", lobbies.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szLobbies = Atf::LAtfVector< BrandedLobbyInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("lobbies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "lobbies", szLobbies, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF(Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF&& _o)
	: input(std::move(_o.input))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::operator=(Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF&& _o)
{
	if(this != &_o)
	{
		input = std::move(_o.input);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::clear()
{
	input.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::equals(const Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF& _o) const
{
	return input.equals(_o.input);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_FIND_TOURNS_BY_REF != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_FIND_TOURNS_BY_REF).append(")");
	_buf.append(',');
	_buf.append("input=");
	input.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_FIND_TOURNS_BY_REF).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	input.toXmlString("input", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("input"))
			{
				if(!Atf::AtfTempl< FindTournsByRefFilter >::FromXmlString(_value, input)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	input.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::parseMsg(CommMsgParser& _parser)
{
	input.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("input", input);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("input", input);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FIND_TOURNS_BY_REF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	FindTournsByRefFilter input; _jparser.validateByNameThrow("input", input);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FIND_TOURNS_BY_REF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	FindTournsByRefFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("input"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY(Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY&& _o)
	: tourns(std::move(_o.tourns))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::operator=(Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::clear()
{
	tourns.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::equals(const Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY& _o) const
{
	return tourns.equals(_o.tourns);
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY*)_other));
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tourns.toXmlString("tourns", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tourns.composeMsg(_msg, _ignoreJSON);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tourns", tourns);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tourns", tourns);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = Atf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* MLobbyNG::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_MLOBBYNG_FILTER_GAMES: _obj = new cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES(); break;
			case MSG_MLOBBYNG_FILTER_GAMES_PS: _obj = new cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS(); break;
			case MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY: _obj = new cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY(); break;
			case MSG_MLOBBYNG_FILTER_GAMES_REPLY: _obj = new cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY(); break;
			case MSG_MLOBBYNG_FILTER_TICKET_TOURNS: _obj = new cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS(); break;
			case MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY: _obj = new cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY(); break;
			case MSG_MLOBBYNG_FIND_TOURNS_BY_REF: _obj = new cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF(); break;
			case MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY: _obj = new cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY(); break;
			case MSG_MLOBBYNG_GET_BRANDED_LOBBIES: _obj = new cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES(); break;
			case MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY: _obj = new cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY(); break;
			case MSG_MLOBBYNG_GET_GAME_CONN_INFO: _obj = new cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO(); break;
			case MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY: _obj = new cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY(); break;
			case MSG_MLOBBYNG_GET_GAME_INFO: _obj = new cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO(); break;
			case MSG_MLOBBYNG_GET_GAME_INFO_REPLY: _obj = new cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY(); break;
			case MSG_MLOBBYNG_GET_GAME_LIST: _obj = new cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST(); break;
			case MSG_MLOBBYNG_GET_GAME_LIST_REPLY: _obj = new cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY(); break;
			case MSG_MLOBBYNG_GET_SUGGESTED_GAMES2: _obj = new cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2(); break;
			case MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS: _obj = new cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS(); break;
			case MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY: _obj = new cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY(); break;
			case MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY: _obj = new cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY(); break;
			case MSG_MLOBBYNG_SEARCH_BY_NAME: _obj = new cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME(); break;
			case MSG_MLOBBYNG_SEARCH_BY_NAME_PS: _obj = new cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS(); break;
			case MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY: _obj = new cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY(); break;
			case MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY: _obj = new cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY(); break;
			case MSG_MLOBBYNG_SNG_COUNTS: _obj = new cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS(); break;
			case MSG_MLOBBYNG_SNG_COUNTS_REPLY: _obj = new cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY(); break;
			case MSG_MLOBBYNG_TABLE_TYPE_COUNTS: _obj = new cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS(); break;
			case MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY: _obj = new cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY(); break;
			case MSG_MLOBBYNG_TICKET_TOURNS: _obj = new cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS(); break;
			case MSG_MLOBBYNG_TICKET_TOURNS_REPLY: _obj = new cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY(); break;
			case MSG_MLOBBYNG_TOURNAMENT_COUNTS: _obj = new cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS(); break;
			case MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY: _obj = new cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool MLobbyNG::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_MLOBBYNG_FILTER_GAMES: cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FILTER_GAMES_PS: cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY: cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FILTER_GAMES_REPLY: cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FILTER_TICKET_TOURNS: cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY: cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FIND_TOURNS_BY_REF: cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY: cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_BRANDED_LOBBIES: cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_CONN_INFO: cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_INFO: cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_INFO_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_LIST: cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_LIST_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_SUGGESTED_GAMES2: cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS: cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SEARCH_BY_NAME: cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SEARCH_BY_NAME_PS: cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY: cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY: cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SNG_COUNTS: cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SNG_COUNTS_REPLY: cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TABLE_TYPE_COUNTS: cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY: cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TICKET_TOURNS: cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TICKET_TOURNS_REPLY: cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TOURNAMENT_COUNTS: cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY: cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool MLobbyNG::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_MLOBBYNG_FILTER_GAMES: cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FILTER_GAMES_PS: cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY: cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FILTER_GAMES_REPLY: cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FILTER_TICKET_TOURNS: cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY: cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FIND_TOURNS_BY_REF: cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY: cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_BRANDED_LOBBIES: cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_CONN_INFO: cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_INFO: cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_INFO_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_LIST: cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_LIST_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_SUGGESTED_GAMES2: cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS: cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SEARCH_BY_NAME: cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SEARCH_BY_NAME_PS: cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY: cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY: cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SNG_COUNTS: cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SNG_COUNTS_REPLY: cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TABLE_TYPE_COUNTS: cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY: cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TICKET_TOURNS: cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TICKET_TOURNS_REPLY: cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TOURNAMENT_COUNTS: cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY: cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

