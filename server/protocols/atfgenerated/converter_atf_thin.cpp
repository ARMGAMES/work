/**
 * converter_atf_thin.cpp
 *
 * This file was auto-generated from converter_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin converter_atf.txt
 */
 
#include "converter_atf_thin.h"

//=================================================================
//                    CountryCurrency
//=================================================================

// @Override
converter::CountryCurrency::CountryCurrency(PString code, PString isoCode)
{
	countryCode = code;
	localCurrencyIsoCode = isoCode;
}

converter::CountryCurrency::CountryCurrency()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

converter::CountryCurrency::CountryCurrency(CountryCurrency&& _o)
	: countryCode(std::move(_o.countryCode))
	, localCurrencyIsoCode(std::move(_o.localCurrencyIsoCode))
{
}

converter::CountryCurrency& converter::CountryCurrency::operator=(CountryCurrency&& _o)
{
	if(this != &_o)
	{
		countryCode = std::move(_o.countryCode);
		localCurrencyIsoCode = std::move(_o.localCurrencyIsoCode);
	}
	return *this;
}

#endif

void converter::CountryCurrency::clear()
{
	countryCode.clear();
	localCurrencyIsoCode.clear();
}

bool converter::CountryCurrency::equals(const CountryCurrency& _o) const
{
	return countryCode.equals(_o.countryCode) &&
		localCurrencyIsoCode.equals(_o.localCurrencyIsoCode);
}

const char *converter::CountryCurrency::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("countryCode=");
	_buf.append(countryCode);
	_buf.append(',');
	_buf.append("localCurrencyIsoCode=");
	_buf.append(localCurrencyIsoCode);
	_buf.append('}');
	return _buf.c_str();
}

void converter::CountryCurrency::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CountryCurrency())) // not empty
	{
		_body.composeString(countryCode);
		_body.composeString(localCurrencyIsoCode);
	}

	_msg.composeMsgBody(_body);
}

void converter::CountryCurrency::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(countryCode);
	_parser0.parseStringP(localCurrencyIsoCode);
}

/*static*/ void converter::CountryCurrency::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "countryCode"); size_t szCountryCode = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "countryCode", szCountryCode, 2, 2, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "localCurrencyIsoCode"); size_t szLocalCurrencyIsoCode = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "localCurrencyIsoCode", szLocalCurrencyIsoCode, 3, 3, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CurrencyConvertRate
//=================================================================

converter::CurrencyConvertRate::CurrencyConvertRate()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

converter::CurrencyConvertRate::CurrencyConvertRate(CurrencyConvertRate&& _o)
	: currency(std::move(_o.currency))
	, rate(std::move(_o.rate))
{
}

converter::CurrencyConvertRate& converter::CurrencyConvertRate::operator=(CurrencyConvertRate&& _o)
{
	if(this != &_o)
	{
		currency = std::move(_o.currency);
		rate = std::move(_o.rate);
	}
	return *this;
}

#endif

void converter::CurrencyConvertRate::clear()
{
	currency.clear();
	rate = 0;
}

bool converter::CurrencyConvertRate::equals(const CurrencyConvertRate& _o) const
{
	return currency.equals(_o.currency) &&
		rate == _o.rate;
}

const char *converter::CurrencyConvertRate::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("rate=");
	_buf.appendInt(rate);
	_buf.append('}');
	return _buf.c_str();
}

void converter::CurrencyConvertRate::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CurrencyConvertRate())) // not empty
	{
		_body.composeString(currency);
		_body.composeINT32(rate);
	}

	_msg.composeMsgBody(_body);
}

void converter::CurrencyConvertRate::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(rate);
}

/*static*/ void converter::CurrencyConvertRate::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 rate; _parser0.parseINT32(rate);
	AtfValidator::validateInt(_descr, "rate", rate, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CONVERTER_GET_ALL_RATES
//=================================================================

converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::Protocol_MSG_CONVERTER_GET_ALL_RATES()
{
	clear();
}

void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::clear()
{
	time.setNull();
}

bool converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::equals(const Protocol_MSG_CONVERTER_GET_ALL_RATES& _o) const
{
	return time.equals(_o.time);
}

const char *converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_GET_ALL_RATES).append(")");
	_buf.append(',');
	_buf.append("time=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, time);
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(time);
}

void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(time);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_ALL_RATES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	SrvTime time; _parser.parseSrvTime(time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY
//=================================================================

converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY(Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errorDescription(std::move(_o.errorDescription))
	, rates(std::move(_o.rates))
{
}

converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY& converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::operator=(Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errorDescription = std::move(_o.errorDescription);
		rates = std::move(_o.rates);
	}
	return *this;
}

#endif

void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::clear()
{
	errCode = 0;
	errorDescription.clear();
	rates.clear();
}

bool converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::equals(const Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errorDescription.equals(_o.errorDescription) &&
		rates.equals(_o.rates);
}

const char *converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_GET_ALL_RATES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errorDescription=");
		_buf.append(errorDescription);
	}
	else
	{
		_buf.append(',');
		_buf.append("rates=");
		rates.toTraceString(_buf);
	}
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errorDescription);
	}
	else
	{
		rates.composeMsg(_msg);
	}
}

void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errorDescription);
	}
	else
	{
		rates.parseMsg(_parser);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_ALL_RATES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errorDescription"); size_t szErrorDescription = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorDescription", szErrorDescription, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szRates = ThinAtf::LAtfVector< CurrencyConvertRate, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("rates"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "rates", szRates, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CONVERTER_GET_RATE
//=================================================================

converter::Protocol_MSG_CONVERTER_GET_RATE::Protocol_MSG_CONVERTER_GET_RATE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

converter::Protocol_MSG_CONVERTER_GET_RATE::Protocol_MSG_CONVERTER_GET_RATE(Protocol_MSG_CONVERTER_GET_RATE&& _o)
	: time(std::move(_o.time))
	, currency(std::move(_o.currency))
{
}

converter::Protocol_MSG_CONVERTER_GET_RATE& converter::Protocol_MSG_CONVERTER_GET_RATE::operator=(Protocol_MSG_CONVERTER_GET_RATE&& _o)
{
	if(this != &_o)
	{
		time = std::move(_o.time);
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void converter::Protocol_MSG_CONVERTER_GET_RATE::clear()
{
	time.setNull();
	currency.clear();
}

bool converter::Protocol_MSG_CONVERTER_GET_RATE::equals(const Protocol_MSG_CONVERTER_GET_RATE& _o) const
{
	return time.equals(_o.time) &&
		currency.equals(_o.currency);
}

const char *converter::Protocol_MSG_CONVERTER_GET_RATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_GET_RATE).append(")");
	_buf.append(',');
	_buf.append("time=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, time);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_GET_RATE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(time);
	_msg.composeString(currency);
}

void converter::Protocol_MSG_CONVERTER_GET_RATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(time);
	_parser.parseStringP(currency);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_RATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_RATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	SrvTime time; _parser.parseSrvTime(time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CONVERTER_GET_RATE_REPLY
//=================================================================

converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::Protocol_MSG_CONVERTER_GET_RATE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::Protocol_MSG_CONVERTER_GET_RATE_REPLY(Protocol_MSG_CONVERTER_GET_RATE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errorDescription(std::move(_o.errorDescription))
	, rate(std::move(_o.rate))
{
}

converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY& converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::operator=(Protocol_MSG_CONVERTER_GET_RATE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errorDescription = std::move(_o.errorDescription);
		rate = std::move(_o.rate);
	}
	return *this;
}

#endif

void converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::clear()
{
	errCode = 0;
	errorDescription.clear();
	rate = 0;
}

bool converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::equals(const Protocol_MSG_CONVERTER_GET_RATE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errorDescription.equals(_o.errorDescription) &&
		rate == _o.rate;
}

const char *converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_GET_RATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errorDescription=");
		_buf.append(errorDescription);
	}
	else
	{
		_buf.append(',');
		_buf.append("rate=");
		_buf.appendInt(rate);
	}
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errorDescription);
	}
	else
	{
		_msg.composeINT32(rate);
	}
}

void converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errorDescription);
	}
	else
	{
		_parser.parseINT32(rate);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_RATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errorDescription"); size_t szErrorDescription = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorDescription", szErrorDescription, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 rate; _parser.parseINT32(rate);
		AtfValidator::validateInt(_descr, "rate", rate, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CONVERTER_CONVERT_AMOUNT
//=================================================================

converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::Protocol_MSG_CONVERTER_CONVERT_AMOUNT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::Protocol_MSG_CONVERTER_CONVERT_AMOUNT(Protocol_MSG_CONVERTER_CONVERT_AMOUNT&& _o)
	: time(std::move(_o.time))
	, srcCurrencyAmount(std::move(_o.srcCurrencyAmount))
	, srcCurrencyType(std::move(_o.srcCurrencyType))
	, destCurrencyType(std::move(_o.destCurrencyType))
	, applyRounding(std::move(_o.applyRounding))
	, roundUp(std::move(_o.roundUp))
{
}

converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT& converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::operator=(Protocol_MSG_CONVERTER_CONVERT_AMOUNT&& _o)
{
	if(this != &_o)
	{
		time = std::move(_o.time);
		srcCurrencyAmount = std::move(_o.srcCurrencyAmount);
		srcCurrencyType = std::move(_o.srcCurrencyType);
		destCurrencyType = std::move(_o.destCurrencyType);
		applyRounding = std::move(_o.applyRounding);
		roundUp = std::move(_o.roundUp);
	}
	return *this;
}

#endif

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::clear()
{
	time.setNull();
	srcCurrencyAmount = 0;
	srcCurrencyType.clear();
	destCurrencyType.clear();
	applyRounding = false;
	roundUp = false;
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::equals(const Protocol_MSG_CONVERTER_CONVERT_AMOUNT& _o) const
{
	return time.equals(_o.time) &&
		srcCurrencyAmount == _o.srcCurrencyAmount &&
		srcCurrencyType.equals(_o.srcCurrencyType) &&
		destCurrencyType.equals(_o.destCurrencyType) &&
		applyRounding == _o.applyRounding &&
		roundUp == _o.roundUp;
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_CONVERT_AMOUNT).append(")");
	_buf.append(',');
	_buf.append("time=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, time);
	_buf.append(',');
	_buf.append("srcCurrencyAmount=");
	_buf.appendInt64(srcCurrencyAmount);
	_buf.append(',');
	_buf.append("srcCurrencyType=");
	_buf.append(srcCurrencyType);
	_buf.append(',');
	_buf.append("destCurrencyType=");
	_buf.append(destCurrencyType);
	_buf.append(',');
	_buf.append("applyRounding=");
	_buf.appendUint(applyRounding);
	_buf.append(',');
	_buf.append("roundUp=");
	_buf.appendUint(roundUp);
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(time);
	_msg.composeINT64(srcCurrencyAmount);
	_msg.composeString(srcCurrencyType);
	_msg.composeString(destCurrencyType);
	_msg.composeBOOL(applyRounding);
	_msg.composeBOOL(roundUp);
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(time);
	_parser.parseINT64(srcCurrencyAmount);
	_parser.parseStringP(srcCurrencyType);
	_parser.parseStringP(destCurrencyType);
	_parser.parseBOOL(applyRounding);
	_parser.parseBOOL(roundUp);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_AMOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	SrvTime time; _parser.parseSrvTime(time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	INT64 srcCurrencyAmount; _parser.parseINT64(srcCurrencyAmount);
	AtfValidator::validateInt(_descr, "srcCurrencyAmount", srcCurrencyAmount, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "srcCurrencyType"); size_t szSrcCurrencyType = strlen(_dummy);
	AtfValidator::validateInt(_descr, "srcCurrencyType", szSrcCurrencyType, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "destCurrencyType"); size_t szDestCurrencyType = strlen(_dummy);
	AtfValidator::validateInt(_descr, "destCurrencyType", szDestCurrencyType, _checker, __FILE__, __LINE__);
	bool applyRounding; _parser.parseBOOL(applyRounding);
	AtfValidator::validateInt(_descr, "applyRounding", applyRounding, _checker, __FILE__, __LINE__);
	bool roundUp; _parser.parseBOOL(roundUp);
	AtfValidator::validateInt(_descr, "roundUp", roundUp, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY
//=================================================================

converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY(Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errorDescription(std::move(_o.errorDescription))
	, destAmount(std::move(_o.destAmount))
	, rate(std::move(_o.rate))
{
}

converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY& converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::operator=(Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errorDescription = std::move(_o.errorDescription);
		destAmount = std::move(_o.destAmount);
		rate = std::move(_o.rate);
	}
	return *this;
}

#endif

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::clear()
{
	errCode = 0;
	errorDescription.clear();
	destAmount = 0;
	rate = 0;
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::equals(const Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errorDescription.equals(_o.errorDescription) &&
		destAmount == _o.destAmount &&
		rate == _o.rate;
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_CONVERT_AMOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errorDescription=");
		_buf.append(errorDescription);
	}
	else
	{
		_buf.append(',');
		_buf.append("destAmount=");
		_buf.appendInt64(destAmount);
		_buf.append(',');
		_buf.append("rate=");
		_buf.appendInt64(rate);
	}
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errorDescription);
	}
	else
	{
		_msg.composeINT64(destAmount);
		_msg.composeINT64(rate);
	}
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errorDescription);
	}
	else
	{
		_parser.parseINT64(destAmount);
		if(_parser.parseEnded()) return;
		_parser.parseINT64(rate);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_AMOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errorDescription"); size_t szErrorDescription = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorDescription", szErrorDescription, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 destAmount; _parser.parseINT64(destAmount);
		AtfValidator::validateInt(_descr, "destAmount", destAmount, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		INT64 rate; _parser.parseINT64(rate);
		AtfValidator::validateInt(_descr, "rate", rate, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CurrencyConvertBatchRequest
//=================================================================

converter::CurrencyConvertBatchRequest::CurrencyConvertBatchRequest()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

converter::CurrencyConvertBatchRequest::CurrencyConvertBatchRequest(CurrencyConvertBatchRequest&& _o)
	: srcCurrencyAmount(std::move(_o.srcCurrencyAmount))
	, srcCurrencyType(std::move(_o.srcCurrencyType))
	, destCurrencyType(std::move(_o.destCurrencyType))
{
}

converter::CurrencyConvertBatchRequest& converter::CurrencyConvertBatchRequest::operator=(CurrencyConvertBatchRequest&& _o)
{
	if(this != &_o)
	{
		srcCurrencyAmount = std::move(_o.srcCurrencyAmount);
		srcCurrencyType = std::move(_o.srcCurrencyType);
		destCurrencyType = std::move(_o.destCurrencyType);
	}
	return *this;
}

#endif

void converter::CurrencyConvertBatchRequest::clear()
{
	srcCurrencyAmount = 0;
	srcCurrencyType.clear();
	destCurrencyType.clear();
}

bool converter::CurrencyConvertBatchRequest::equals(const CurrencyConvertBatchRequest& _o) const
{
	return srcCurrencyAmount == _o.srcCurrencyAmount &&
		srcCurrencyType.equals(_o.srcCurrencyType) &&
		destCurrencyType.equals(_o.destCurrencyType);
}

const char *converter::CurrencyConvertBatchRequest::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("srcCurrencyAmount=");
	_buf.appendInt64(srcCurrencyAmount);
	_buf.append(',');
	_buf.append("srcCurrencyType=");
	_buf.append(srcCurrencyType);
	_buf.append(',');
	_buf.append("destCurrencyType=");
	_buf.append(destCurrencyType);
	_buf.append('}');
	return _buf.c_str();
}

void converter::CurrencyConvertBatchRequest::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CurrencyConvertBatchRequest())) // not empty
	{
		_body.composeINT64(srcCurrencyAmount);
		_body.composeString(srcCurrencyType);
		_body.composeString(destCurrencyType);
	}

	_msg.composeMsgBody(_body);
}

void converter::CurrencyConvertBatchRequest::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(srcCurrencyAmount);
	_parser0.parseStringP(srcCurrencyType);
	_parser0.parseStringP(destCurrencyType);
}

/*static*/ void converter::CurrencyConvertBatchRequest::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT64 srcCurrencyAmount; _parser0.parseINT64(srcCurrencyAmount);
	AtfValidator::validateInt(_descr, "srcCurrencyAmount", srcCurrencyAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "srcCurrencyType"); size_t szSrcCurrencyType = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "srcCurrencyType", szSrcCurrencyType, 3, 3, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "destCurrencyType"); size_t szDestCurrencyType = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "destCurrencyType", szDestCurrencyType, 3, 3, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS
//=================================================================

converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS(Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS&& _o)
	: time(std::move(_o.time))
	, applyRounding(std::move(_o.applyRounding))
	, roundUp(std::move(_o.roundUp))
	, convertRequests(std::move(_o.convertRequests))
{
}

converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS& converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::operator=(Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS&& _o)
{
	if(this != &_o)
	{
		time = std::move(_o.time);
		applyRounding = std::move(_o.applyRounding);
		roundUp = std::move(_o.roundUp);
		convertRequests = std::move(_o.convertRequests);
	}
	return *this;
}

#endif

void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::clear()
{
	time.setNull();
	applyRounding = false;
	roundUp = false;
	convertRequests.clear();
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::equals(const Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS& _o) const
{
	return time.equals(_o.time) &&
		applyRounding == _o.applyRounding &&
		roundUp == _o.roundUp &&
		convertRequests.equals(_o.convertRequests);
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_CONVERT_BATCH_AMOUNTS).append(")");
	_buf.append(',');
	_buf.append("time=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, time);
	_buf.append(',');
	_buf.append("applyRounding=");
	_buf.appendUint(applyRounding);
	_buf.append(',');
	_buf.append("roundUp=");
	_buf.appendUint(roundUp);
	_buf.append(',');
	_buf.append("convertRequests=");
	convertRequests.toTraceString(_buf);
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(time);
	_msg.composeBOOL(applyRounding);
	_msg.composeBOOL(roundUp);
	convertRequests.composeMsg(_msg);
}

void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(time);
	_parser.parseBOOL(applyRounding);
	_parser.parseBOOL(roundUp);
	convertRequests.parseMsg(_parser);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_BATCH_AMOUNTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	SrvTime time; _parser.parseSrvTime(time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	bool applyRounding; _parser.parseBOOL(applyRounding);
	AtfValidator::validateInt(_descr, "applyRounding", applyRounding, _checker, __FILE__, __LINE__);
	bool roundUp; _parser.parseBOOL(roundUp);
	AtfValidator::validateInt(_descr, "roundUp", roundUp, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szConvertRequests = ThinAtf::LAtfVector< CurrencyConvertBatchRequest, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("convertRequests"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "convertRequests", szConvertRequests, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CurrencyConvertBatchReply
//=================================================================

converter::CurrencyConvertBatchReply::CurrencyConvertBatchReply()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

converter::CurrencyConvertBatchReply::CurrencyConvertBatchReply(CurrencyConvertBatchReply&& _o)
	: errCode(std::move(_o.errCode))
	, errorDescription(std::move(_o.errorDescription))
	, destAmount(std::move(_o.destAmount))
	, rate(std::move(_o.rate))
{
}

converter::CurrencyConvertBatchReply& converter::CurrencyConvertBatchReply::operator=(CurrencyConvertBatchReply&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errorDescription = std::move(_o.errorDescription);
		destAmount = std::move(_o.destAmount);
		rate = std::move(_o.rate);
	}
	return *this;
}

#endif

void converter::CurrencyConvertBatchReply::clear()
{
	errCode = 0;
	errorDescription.clear();
	destAmount = 0;
	rate = 0;
}

bool converter::CurrencyConvertBatchReply::equals(const CurrencyConvertBatchReply& _o) const
{
	return errCode == _o.errCode &&
		errorDescription.equals(_o.errorDescription) &&
		destAmount == _o.destAmount &&
		rate == _o.rate;
}

const char *converter::CurrencyConvertBatchReply::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errorDescription=");
		_buf.append(errorDescription);
	}
	else
	{
		_buf.append(',');
		_buf.append("destAmount=");
		_buf.appendInt64(destAmount);
		_buf.append(',');
		_buf.append("rate=");
		_buf.appendInt64(rate);
	}
	_buf.append('}');
	return _buf.c_str();
}

void converter::CurrencyConvertBatchReply::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CurrencyConvertBatchReply())) // not empty
	{
		_body.composeINT16(errCode);
		if(errCode)
		{
			_body.composeString(errorDescription);
		}
		else
		{
			_body.composeINT64(destAmount);
			_body.composeINT64(rate);
		}
	}

	_msg.composeMsgBody(_body);
}

void converter::CurrencyConvertBatchReply::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT16(errCode);
	if(errCode)
	{
		_parser0.parseStringP(errorDescription);
	}
	else
	{
		_parser0.parseINT64(destAmount);
		if(_parser0.parseEnded()) return;
		_parser0.parseINT64(rate);
	}
}

/*static*/ void converter::CurrencyConvertBatchReply::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser0.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser0.parseStringN(_dummy, 0, "errorDescription"); size_t szErrorDescription = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorDescription", szErrorDescription, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 destAmount; _parser0.parseINT64(destAmount);
		AtfValidator::validateInt(_descr, "destAmount", destAmount, _checker, __FILE__, __LINE__);
		if(_parser0.parseEnded()) return;
		INT64 rate; _parser0.parseINT64(rate);
		AtfValidator::validateInt(_descr, "rate", rate, _checker, __FILE__, __LINE__);
	}
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY
//=================================================================

converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY(Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errorDescription(std::move(_o.errorDescription))
	, conversionResults(std::move(_o.conversionResults))
{
}

converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY& converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::operator=(Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errorDescription = std::move(_o.errorDescription);
		conversionResults = std::move(_o.conversionResults);
	}
	return *this;
}

#endif

void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::clear()
{
	errCode = 0;
	errorDescription.clear();
	conversionResults.clear();
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::equals(const Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errorDescription.equals(_o.errorDescription) &&
		conversionResults.equals(_o.conversionResults);
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errorDescription=");
		_buf.append(errorDescription);
	}
	else
	{
		_buf.append(',');
		_buf.append("conversionResults=");
		conversionResults.toTraceString(_buf);
	}
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errorDescription);
	}
	else
	{
		conversionResults.composeMsg(_msg);
	}
}

void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errorDescription);
	}
	else
	{
		conversionResults.parseMsg(_parser);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errorDescription"); size_t szErrorDescription = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorDescription", szErrorDescription, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szConversionResults = ThinAtf::LAtfVector< CurrencyConvertBatchReply, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("conversionResults"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "conversionResults", szConversionResults, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS
//=================================================================

converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS()
{
	clear();
}

void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::clear()
{
	time.setNull();
}

bool converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::equals(const Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS& _o) const
{
	return time.equals(_o.time);
}

const char *converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS).append(")");
	_buf.append(',');
	_buf.append("time=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, time);
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(time);
}

void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(time);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	SrvTime time; _parser.parseSrvTime(time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CurrencyConvertData
//=================================================================

converter::CurrencyConvertData::CurrencyConvertData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

converter::CurrencyConvertData::CurrencyConvertData(CurrencyConvertData&& _o)
	: roundingFactorsCommonRatio(std::move(_o.roundingFactorsCommonRatio))
	, roundingFactors(std::move(_o.roundingFactors))
	, rates(std::move(_o.rates))
{
}

converter::CurrencyConvertData& converter::CurrencyConvertData::operator=(CurrencyConvertData&& _o)
{
	if(this != &_o)
	{
		roundingFactorsCommonRatio = std::move(_o.roundingFactorsCommonRatio);
		roundingFactors = std::move(_o.roundingFactors);
		rates = std::move(_o.rates);
	}
	return *this;
}

#endif

void converter::CurrencyConvertData::clear()
{
	roundingFactorsCommonRatio = 0;
	roundingFactors.clear();
	rates.clear();
}

bool converter::CurrencyConvertData::equals(const CurrencyConvertData& _o) const
{
	return roundingFactorsCommonRatio == _o.roundingFactorsCommonRatio &&
		roundingFactors.equals(_o.roundingFactors) &&
		rates.equals(_o.rates);
}

const char *converter::CurrencyConvertData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("roundingFactorsCommonRatio=");
	_buf.appendInt64(roundingFactorsCommonRatio);
	_buf.append(',');
	_buf.append("roundingFactors=");
	roundingFactors.toTraceString(_buf);
	_buf.append(',');
	_buf.append("rates=");
	rates.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void converter::CurrencyConvertData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CurrencyConvertData())) // not empty
	{
		_body.composeINT64(roundingFactorsCommonRatio);
		roundingFactors.composeMsg(_body);
		rates.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void converter::CurrencyConvertData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(roundingFactorsCommonRatio);
	roundingFactors.parseMsg(_parser0);
	rates.parseMsg(_parser0);
}

/*static*/ void converter::CurrencyConvertData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT64 roundingFactorsCommonRatio; _parser0.parseINT64(roundingFactorsCommonRatio);
	AtfValidator::validateInt(_descr, "roundingFactorsCommonRatio", roundingFactorsCommonRatio, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRoundingFactors = ThinAtf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("roundingFactors"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "roundingFactors", szRoundingFactors, _checker, __FILE__, __LINE__);
	int szRates = ThinAtf::LAtfVector< CurrencyConvertRate, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("rates"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "rates", szRates, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY
//=================================================================

converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY(Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errorDescription(std::move(_o.errorDescription))
	, payload(std::move(_o.payload))
{
}

converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY& converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::operator=(Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errorDescription = std::move(_o.errorDescription);
		payload = std::move(_o.payload);
	}
	return *this;
}

#endif

void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::clear()
{
	errCode = 0;
	errorDescription.clear();
	payload.clear();
}

bool converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::equals(const Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errorDescription.equals(_o.errorDescription) &&
		payload.equals(_o.payload);
}

const char *converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errorDescription=");
		_buf.append(errorDescription);
	}
	else
	{
		_buf.append(',');
		_buf.append("payload=");
		payload.toTraceString(_buf);
	}
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errorDescription);
	}
	else
	{
		payload.composeMsg(_msg);
	}
}

void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errorDescription);
	}
	else
	{
		payload.parseMsg(_parser);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errorDescription"); size_t szErrorDescription = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorDescription", szErrorDescription, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		CurrencyConvertData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("payload"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE
//=================================================================

converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE(Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE&& _o)
	: time(std::move(_o.time))
	, srcCurrencyAmount(std::move(_o.srcCurrencyAmount))
	, srcCurrencyType(std::move(_o.srcCurrencyType))
	, destCountryCode(std::move(_o.destCountryCode))
	, applyRounding(std::move(_o.applyRounding))
	, roundUp(std::move(_o.roundUp))
{
}

converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE& converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::operator=(Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE&& _o)
{
	if(this != &_o)
	{
		time = std::move(_o.time);
		srcCurrencyAmount = std::move(_o.srcCurrencyAmount);
		srcCurrencyType = std::move(_o.srcCurrencyType);
		destCountryCode = std::move(_o.destCountryCode);
		applyRounding = std::move(_o.applyRounding);
		roundUp = std::move(_o.roundUp);
	}
	return *this;
}

#endif

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::clear()
{
	time.setNull();
	srcCurrencyAmount = 0;
	srcCurrencyType.clear();
	destCountryCode.clear();
	applyRounding = false;
	roundUp = false;
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::equals(const Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE& _o) const
{
	return time.equals(_o.time) &&
		srcCurrencyAmount == _o.srcCurrencyAmount &&
		srcCurrencyType.equals(_o.srcCurrencyType) &&
		destCountryCode.equals(_o.destCountryCode) &&
		applyRounding == _o.applyRounding &&
		roundUp == _o.roundUp;
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE).append(")");
	_buf.append(',');
	_buf.append("time=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, time);
	_buf.append(',');
	_buf.append("srcCurrencyAmount=");
	_buf.appendInt64(srcCurrencyAmount);
	_buf.append(',');
	_buf.append("srcCurrencyType=");
	_buf.append(srcCurrencyType);
	_buf.append(',');
	_buf.append("destCountryCode=");
	_buf.append(destCountryCode);
	_buf.append(',');
	_buf.append("applyRounding=");
	_buf.appendUint(applyRounding);
	_buf.append(',');
	_buf.append("roundUp=");
	_buf.appendUint(roundUp);
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(time);
	_msg.composeINT64(srcCurrencyAmount);
	_msg.composeString(srcCurrencyType);
	_msg.composeString(destCountryCode);
	_msg.composeBOOL(applyRounding);
	_msg.composeBOOL(roundUp);
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(time);
	_parser.parseINT64(srcCurrencyAmount);
	_parser.parseStringP(srcCurrencyType);
	_parser.parseStringP(destCountryCode);
	_parser.parseBOOL(applyRounding);
	_parser.parseBOOL(roundUp);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	SrvTime time; _parser.parseSrvTime(time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	INT64 srcCurrencyAmount; _parser.parseINT64(srcCurrencyAmount);
	AtfValidator::validateInt(_descr, "srcCurrencyAmount", srcCurrencyAmount, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "srcCurrencyType"); size_t szSrcCurrencyType = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "srcCurrencyType", szSrcCurrencyType, 3, 3, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "destCountryCode"); size_t szDestCountryCode = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "destCountryCode", szDestCountryCode, 2, 2, _checker, __FILE__, __LINE__);
	bool applyRounding; _parser.parseBOOL(applyRounding);
	AtfValidator::validateInt(_descr, "applyRounding", applyRounding, _checker, __FILE__, __LINE__);
	bool roundUp; _parser.parseBOOL(roundUp);
	AtfValidator::validateInt(_descr, "roundUp", roundUp, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY
//=================================================================

converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY(Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errorDescription(std::move(_o.errorDescription))
	, destAmount(std::move(_o.destAmount))
	, destCurrencyType(std::move(_o.destCurrencyType))
	, rate(std::move(_o.rate))
{
}

converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY& converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::operator=(Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errorDescription = std::move(_o.errorDescription);
		destAmount = std::move(_o.destAmount);
		destCurrencyType = std::move(_o.destCurrencyType);
		rate = std::move(_o.rate);
	}
	return *this;
}

#endif

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::clear()
{
	errCode = 0;
	errorDescription.clear();
	destAmount = 0;
	destCurrencyType.clear();
	rate = 0;
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::equals(const Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errorDescription.equals(_o.errorDescription) &&
		destAmount == _o.destAmount &&
		destCurrencyType.equals(_o.destCurrencyType) &&
		rate == _o.rate;
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errorDescription=");
		_buf.append(errorDescription);
	}
	else
	{
		_buf.append(',');
		_buf.append("destAmount=");
		_buf.appendInt64(destAmount);
		_buf.append(',');
		_buf.append("destCurrencyType=");
		_buf.append(destCurrencyType);
		_buf.append(',');
		_buf.append("rate=");
		_buf.appendInt64(rate);
	}
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errorDescription);
	}
	else
	{
		_msg.composeINT64(destAmount);
		_msg.composeString(destCurrencyType);
		_msg.composeINT64(rate);
	}
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errorDescription);
	}
	else
	{
		_parser.parseINT64(destAmount);
		_parser.parseStringP(destCurrencyType);
		if(_parser.parseEnded()) return;
		_parser.parseINT64(rate);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errorDescription"); size_t szErrorDescription = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorDescription", szErrorDescription, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 destAmount; _parser.parseINT64(destAmount);
		AtfValidator::validateInt(_descr, "destAmount", destAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "destCurrencyType"); size_t szDestCurrencyType = strlen(_dummy);
		AtfValidator::validateIntRange(_descr, "destCurrencyType", szDestCurrencyType, 3, 3, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		INT64 rate; _parser.parseINT64(rate);
		AtfValidator::validateInt(_descr, "rate", rate, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool converter::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case MSG_CONVERTER_CONVERT_AMOUNT: Protocol_MSG_CONVERTER_CONVERT_AMOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE: Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY: Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_CONVERT_AMOUNT_REPLY: Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_CONVERT_BATCH_AMOUNTS: Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY: Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_ALL_RATES: Protocol_MSG_CONVERTER_GET_ALL_RATES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_ALL_RATES_REPLY: Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS: Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY: Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_RATE: Protocol_MSG_CONVERTER_GET_RATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_RATE_REPLY: Protocol_MSG_CONVERTER_GET_RATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

