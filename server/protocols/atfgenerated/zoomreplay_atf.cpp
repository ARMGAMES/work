/**
 * zoomreplay_atf.cpp
 *
 * This file was auto-generated from zoomreplay_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: zoomreplay_atf.txt
 */
 
#include "zoomreplay_atf.h"

//=================================================================
//                Protocol_MSG_TABLE_LOGIN
//=================================================================

ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN::Protocol_MSG_TABLE_LOGIN()
{
	clear();
}

void ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN::clear()
{
	user.clear();
	clientSiteId = 0;
	notShowWhenAllIn = false;
	sitOutNextHand = false;
	useAllInitStacks = false;
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN::equals(const Protocol_MSG_TABLE_LOGIN& _o) const
{
	return Atf::atfPStringEquals(user, _o.user) &&
		clientSiteId == _o.clientSiteId &&
		notShowWhenAllIn == _o.notShowWhenAllIn &&
		sitOutNextHand == _o.sitOutNextHand &&
		useAllInitStacks == _o.useAllInitStacks;
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_LOGIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_LOGIN*)_other));
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_LOGIN).append(")");
	_buf.append(',');
	_buf.append("user=");
	_buf.append(user);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("notShowWhenAllIn=");
	_buf.appendUint(notShowWhenAllIn);
	_buf.append(',');
	_buf.append("sitOutNextHand=");
	_buf.appendUint(sitOutNextHand);
	_buf.append(',');
	_buf.append("useAllInitStacks=");
	_buf.appendUint(useAllInitStacks);
	return _buf.c_str();
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_LOGIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("user", user, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientSiteId", clientSiteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("notShowWhenAllIn", notShowWhenAllIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("sitOutNextHand", sitOutNextHand, _buf);
	Atf::XmlElement::encodeAsXmlElement("useAllInitStacks", useAllInitStacks, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("user"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, user)) return false;
			}
			else if (_element.equals("clientSiteId"))
			{
				clientSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notShowWhenAllIn"))
			{
				notShowWhenAllIn = (*_value.ptr() == '1');
			}
			else if (_element.equals("sitOutNextHand"))
			{
				sitOutNextHand = (*_value.ptr() == '1');
			}
			else if (_element.equals("useAllInitStacks"))
			{
				useAllInitStacks = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(user);
	_msg.composeUINT32(clientSiteId);
	_msg.composeBOOL(notShowWhenAllIn);
	_msg.composeBOOL(sitOutNextHand);
	_msg.composeBOOL(useAllInitStacks);
}

void ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(user);
	_parser.parseUINT32(clientSiteId);
	_parser.parseBOOL(notShowWhenAllIn);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(sitOutNextHand);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(useAllInitStacks);
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("user", user);
	_jsonstr.compose("clientSiteId", clientSiteId);
	_jsonstr.compose("notShowWhenAllIn", notShowWhenAllIn);
	_jsonstr.compose("sitOutNextHand", sitOutNextHand);
	_jsonstr.compose("useAllInitStacks", useAllInitStacks);
	return _buf.c_str();
}

void ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("user", user);
	_jparser.parseByNameThrow("clientSiteId", clientSiteId);
	_jparser.parseByNameThrow("notShowWhenAllIn", notShowWhenAllIn);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("sitOutNextHand", sitOutNextHand);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("useAllInitStacks", useAllInitStacks);
}

/*static*/ void ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString user; _jparser.validateByNameThrow("user", user);
	AtfValidator::validateIntMax(_descr, "user", user.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _jparser.validateByNameThrow("clientSiteId", clientSiteId);
	AtfValidator::validateIntMax(_descr, "clientSiteId", clientSiteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	bool notShowWhenAllIn; _jparser.validateByNameThrow("notShowWhenAllIn", notShowWhenAllIn);
	AtfValidator::validateInt(_descr, "notShowWhenAllIn", notShowWhenAllIn, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool sitOutNextHand; _jparser.validateByNameThrow("sitOutNextHand", sitOutNextHand);
	AtfValidator::validateInt(_descr, "sitOutNextHand", sitOutNextHand, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool useAllInitStacks; _jparser.validateByNameThrow("useAllInitStacks", useAllInitStacks);
	AtfValidator::validateInt(_descr, "useAllInitStacks", useAllInitStacks, _checker, __FILE__, __LINE__);
}

/*static*/ void ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "user"); size_t szUser = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "user", szUser, 20, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntMax(_descr, "clientSiteId", clientSiteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	bool notShowWhenAllIn; _parser.parseBOOL(notShowWhenAllIn);
	AtfValidator::validateInt(_descr, "notShowWhenAllIn", notShowWhenAllIn, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool sitOutNextHand; _parser.parseBOOL(sitOutNextHand);
	AtfValidator::validateInt(_descr, "sitOutNextHand", sitOutNextHand, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool useAllInitStacks; _parser.parseBOOL(useAllInitStacks);
	AtfValidator::validateInt(_descr, "useAllInitStacks", useAllInitStacks, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_LOGIN_REPLY
//=================================================================

ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::Protocol_MSG_TABLE_LOGIN_REPLY()
{
	clear();
}

void ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::clear()
{
	errCode = 0;
	errStr.clear();
	seat = 0;
	sittingOut = 0;
	clientIP.clear();
	privilege = 0;
	clientMsg_txtEx.clear();
	autoRebuyOptions = 0;
	autoRebuyBigBets = 0;
	autoRebuyFallUnderBigBets = 0;
	autoRebuyFallUnderPercents = 0;
	playerRITFavored = false;
	campingPreventionEnabled = false;
	isTableDealingHands = false;
	campingCountingDownSec = 0;
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::equals(const Protocol_MSG_TABLE_LOGIN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		seat == _o.seat &&
		sittingOut == _o.sittingOut &&
		privilege == _o.privilege &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx) &&
		autoRebuyOptions == _o.autoRebuyOptions &&
		autoRebuyBigBets == _o.autoRebuyBigBets &&
		autoRebuyFallUnderBigBets == _o.autoRebuyFallUnderBigBets &&
		autoRebuyFallUnderPercents == _o.autoRebuyFallUnderPercents &&
		playerRITFavored == _o.playerRITFavored &&
		campingPreventionEnabled == _o.campingPreventionEnabled &&
		isTableDealingHands == _o.isTableDealingHands &&
		campingCountingDownSec == _o.campingCountingDownSec;
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_LOGIN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_LOGIN_REPLY*)_other));
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_LOGIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errStr=");
	_buf.append(errStr);
	_buf.append(',');
	_buf.append("seat=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("sittingOut=");
	_buf.appendUint(sittingOut);
	_buf.append(',');
	_buf.append("clientIP=");
	_buf.append(clientIP);
	_buf.append(',');
	_buf.append("privilege=");
	_buf.appendUint(privilege);
	_buf.append(',');
	_buf.append("clientMsg_txtEx=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("autoRebuyOptions=");
	_buf.appendInt(autoRebuyOptions);
	_buf.append(',');
	_buf.append("autoRebuyBigBets=");
	_buf.appendUint(autoRebuyBigBets);
	_buf.append(',');
	_buf.append("autoRebuyFallUnderBigBets=");
	_buf.appendUint(autoRebuyFallUnderBigBets);
	_buf.append(',');
	_buf.append("autoRebuyFallUnderPercents=");
	_buf.appendUint(autoRebuyFallUnderPercents);
	_buf.append(',');
	_buf.append("playerRITFavored=");
	_buf.appendUint(playerRITFavored);
	_buf.append(',');
	_buf.append("campingPreventionEnabled=");
	_buf.appendUint(campingPreventionEnabled);
	_buf.append(',');
	_buf.append("isTableDealingHands=");
	_buf.appendUint(isTableDealingHands);
	_buf.append(',');
	_buf.append("campingCountingDownSec=");
	_buf.appendUint(campingCountingDownSec);
	return _buf.c_str();
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_LOGIN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("seat", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("sittingOut", sittingOut, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientIP", clientIP, _buf);
	Atf::XmlElement::encodeAsXmlElement("privilege", privilege, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientMsg_txtEx", clientMsg_txtEx, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoRebuyOptions", autoRebuyOptions, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoRebuyBigBets", autoRebuyBigBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoRebuyFallUnderPercents", autoRebuyFallUnderPercents, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerRITFavored", playerRITFavored, _buf);
	Atf::XmlElement::encodeAsXmlElement("campingPreventionEnabled", campingPreventionEnabled, _buf);
	Atf::XmlElement::encodeAsXmlElement("isTableDealingHands", isTableDealingHands, _buf);
	Atf::XmlElement::encodeAsXmlElement("campingCountingDownSec", campingCountingDownSec, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("seat"))
			{
				seat = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sittingOut"))
			{
				sittingOut = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientIP"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clientIP)) return false;
			}
			else if (_element.equals("privilege"))
			{
				privilege = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else if (_element.equals("autoRebuyOptions"))
			{
				autoRebuyOptions = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("autoRebuyBigBets"))
			{
				autoRebuyBigBets = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("autoRebuyFallUnderBigBets"))
			{
				autoRebuyFallUnderBigBets = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("autoRebuyFallUnderPercents"))
			{
				autoRebuyFallUnderPercents = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playerRITFavored"))
			{
				playerRITFavored = (*_value.ptr() == '1');
			}
			else if (_element.equals("campingPreventionEnabled"))
			{
				campingPreventionEnabled = (*_value.ptr() == '1');
			}
			else if (_element.equals("isTableDealingHands"))
			{
				isTableDealingHands = (*_value.ptr() == '1');
			}
			else if (_element.equals("campingCountingDownSec"))
			{
				campingCountingDownSec = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errCode);
	_msg.composeString(errStr);
	_msg.composeINT8(seat);
	_msg.composeBYTE(sittingOut);
	_msg.composeString(clientIP);
	_msg.composeUINT32(privilege);
	_msg.composeMsgBody(clientMsg_txtEx);
	_msg.composeINT8(autoRebuyOptions);
	_msg.composeUINT16(autoRebuyBigBets);
	_msg.composeUINT16(autoRebuyFallUnderBigBets);
	_msg.composeUINT16(autoRebuyFallUnderPercents);
	_msg.composeBOOL(playerRITFavored);
	_msg.composeBOOL(campingPreventionEnabled);
	_msg.composeBOOL(isTableDealingHands);
	_msg.composeUINT16(campingCountingDownSec);
}

void ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errCode);
	_parser.parseStringP(errStr);
	_parser.parseINT8(seat);
	_parser.parseBYTE(sittingOut);
	_parser.parseStringP(clientIP);
	_parser.parseUINT32(privilege);
	_parser.parseMsgBody(clientMsg_txtEx);
	_parser.parseINT8(autoRebuyOptions);
	_parser.parseUINT16(autoRebuyBigBets);
	_parser.parseUINT16(autoRebuyFallUnderBigBets);
	_parser.parseUINT16(autoRebuyFallUnderPercents);
	_parser.parseBOOL(playerRITFavored);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(campingPreventionEnabled);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isTableDealingHands);
	if(_parser.parseEnded()) return;
	_parser.parseUINT16(campingCountingDownSec);
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errStr", errStr);
	_jsonstr.compose("seat", seat);
	_jsonstr.compose("sittingOut", sittingOut);
	_jsonstr.compose("clientIP", clientIP);
	_jsonstr.compose("privilege", privilege);
	_jsonstr.compose("clientMsg_txtEx", clientMsg_txtEx);
	_jsonstr.compose("autoRebuyOptions", autoRebuyOptions);
	_jsonstr.compose("autoRebuyBigBets", autoRebuyBigBets);
	_jsonstr.compose("autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets);
	_jsonstr.compose("autoRebuyFallUnderPercents", autoRebuyFallUnderPercents);
	_jsonstr.compose("playerRITFavored", playerRITFavored);
	_jsonstr.compose("campingPreventionEnabled", campingPreventionEnabled);
	_jsonstr.compose("isTableDealingHands", isTableDealingHands);
	_jsonstr.compose("campingCountingDownSec", campingCountingDownSec);
	return _buf.c_str();
}

void ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errStr", errStr);
	_jparser.parseByNameThrow("seat", seat);
	_jparser.parseByNameThrow("sittingOut", sittingOut);
	_jparser.parseByNameThrow("clientIP", clientIP);
	_jparser.parseByNameThrow("privilege", privilege);
	_jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	_jparser.parseByNameThrow("autoRebuyOptions", autoRebuyOptions);
	_jparser.parseByNameThrow("autoRebuyBigBets", autoRebuyBigBets);
	_jparser.parseByNameThrow("autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets);
	_jparser.parseByNameThrow("autoRebuyFallUnderPercents", autoRebuyFallUnderPercents);
	_jparser.parseByNameThrow("playerRITFavored", playerRITFavored);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("campingPreventionEnabled", campingPreventionEnabled);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("isTableDealingHands", isTableDealingHands);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("campingCountingDownSec", campingCountingDownSec);
}

/*static*/ void ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errStr; _jparser.validateByNameThrow("errStr", errStr);
	AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	INT8 seat; _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	BYTE sittingOut; _jparser.validateByNameThrow("sittingOut", sittingOut);
	AtfValidator::validateInt(_descr, "sittingOut", sittingOut, _checker, __FILE__, __LINE__);
	PString clientIP; _jparser.validateByNameThrow("clientIP", clientIP);
	AtfValidator::validateInt(_descr, "clientIP", clientIP.length(), _checker, __FILE__, __LINE__);
	UINT32 privilege; _jparser.validateByNameThrow("privilege", privilege);
	AtfValidator::validateInt(_descr, "privilege", privilege, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientMsg_txtEx; _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
	INT8 autoRebuyOptions; _jparser.validateByNameThrow("autoRebuyOptions", autoRebuyOptions);
	AtfValidator::validateInt(_descr, "autoRebuyOptions", autoRebuyOptions, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyBigBets; _jparser.validateByNameThrow("autoRebuyBigBets", autoRebuyBigBets);
	AtfValidator::validateInt(_descr, "autoRebuyBigBets", autoRebuyBigBets, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyFallUnderBigBets; _jparser.validateByNameThrow("autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets);
	AtfValidator::validateInt(_descr, "autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyFallUnderPercents; _jparser.validateByNameThrow("autoRebuyFallUnderPercents", autoRebuyFallUnderPercents);
	AtfValidator::validateInt(_descr, "autoRebuyFallUnderPercents", autoRebuyFallUnderPercents, _checker, __FILE__, __LINE__);
	bool playerRITFavored; _jparser.validateByNameThrow("playerRITFavored", playerRITFavored);
	AtfValidator::validateInt(_descr, "playerRITFavored", playerRITFavored, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool campingPreventionEnabled; _jparser.validateByNameThrow("campingPreventionEnabled", campingPreventionEnabled);
	AtfValidator::validateInt(_descr, "campingPreventionEnabled", campingPreventionEnabled, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool isTableDealingHands; _jparser.validateByNameThrow("isTableDealingHands", isTableDealingHands);
	AtfValidator::validateInt(_descr, "isTableDealingHands", isTableDealingHands, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT16 campingCountingDownSec; _jparser.validateByNameThrow("campingCountingDownSec", campingCountingDownSec);
	AtfValidator::validateInt(_descr, "campingCountingDownSec", campingCountingDownSec, _checker, __FILE__, __LINE__);
}

/*static*/ void ZoomReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errCode; _parser.parseBYTE(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	BYTE sittingOut; _parser.parseBYTE(sittingOut);
	AtfValidator::validateInt(_descr, "sittingOut", sittingOut, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "clientIP"); size_t szClientIP = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clientIP", szClientIP, _checker, __FILE__, __LINE__);
	UINT32 privilege; _parser.parseUINT32(privilege);
	AtfValidator::validateInt(_descr, "privilege", privilege, _checker, __FILE__, __LINE__);
	size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	INT8 autoRebuyOptions; _parser.parseINT8(autoRebuyOptions);
	AtfValidator::validateInt(_descr, "autoRebuyOptions", autoRebuyOptions, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyBigBets; _parser.parseUINT16(autoRebuyBigBets);
	AtfValidator::validateInt(_descr, "autoRebuyBigBets", autoRebuyBigBets, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyFallUnderBigBets; _parser.parseUINT16(autoRebuyFallUnderBigBets);
	AtfValidator::validateInt(_descr, "autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyFallUnderPercents; _parser.parseUINT16(autoRebuyFallUnderPercents);
	AtfValidator::validateInt(_descr, "autoRebuyFallUnderPercents", autoRebuyFallUnderPercents, _checker, __FILE__, __LINE__);
	bool playerRITFavored; _parser.parseBOOL(playerRITFavored);
	AtfValidator::validateInt(_descr, "playerRITFavored", playerRITFavored, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool campingPreventionEnabled; _parser.parseBOOL(campingPreventionEnabled);
	AtfValidator::validateInt(_descr, "campingPreventionEnabled", campingPreventionEnabled, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool isTableDealingHands; _parser.parseBOOL(isTableDealingHands);
	AtfValidator::validateInt(_descr, "isTableDealingHands", isTableDealingHands, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT16 campingCountingDownSec; _parser.parseUINT16(campingCountingDownSec);
	AtfValidator::validateInt(_descr, "campingCountingDownSec", campingCountingDownSec, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_LOGOUT
//=================================================================

ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT::Protocol_MSG_TABLE_LOGOUT()
{
	clear();
}

void ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT::clear()
{
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT::equals(const Protocol_MSG_TABLE_LOGOUT& _o) const
{
	return true;
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_LOGOUT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_LOGOUT*)_other));
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_LOGOUT).append(")");
	return _buf.c_str();
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_LOGOUT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT::parseMsg(CommMsgParser& _parser)
{
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_LOGOUT_REPLY
//=================================================================

ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT_REPLY::Protocol_MSG_TABLE_LOGOUT_REPLY()
{
	clear();
}

void ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT_REPLY::clear()
{
	errCode = 0;
	errStr.clear();
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT_REPLY::equals(const Protocol_MSG_TABLE_LOGOUT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr);
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_LOGOUT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_LOGOUT_REPLY*)_other));
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_LOGOUT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errStr=");
	_buf.append(errStr);
	return _buf.c_str();
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_LOGOUT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errCode);
	_msg.composeString(errStr);
}

void ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errCode);
	_parser.parseStringP(errStr);
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errStr", errStr);
	return _buf.c_str();
}

void ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errStr", errStr);
}

/*static*/ void ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errStr; _jparser.validateByNameThrow("errStr", errStr);
	AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void ZoomReplay::cli::Protocol_MSG_TABLE_LOGOUT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errCode; _parser.parseBYTE(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_CHAT2
//=================================================================

ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2::Protocol_MSG_TABLE_CHAT2()
{
	clear();
}

void ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2::clear()
{
	chat.clear();
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2::equals(const Protocol_MSG_TABLE_CHAT2& _o) const
{
	return Atf::atfPStringEquals(chat, _o.chat);
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_CHAT2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_CHAT2*)_other));
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_CHAT2).append(")");
	_buf.append(',');
	_buf.append("chat=");
	_buf.append(chat);
	return _buf.c_str();
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_CHAT2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("chat", chat, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("chat"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, chat)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(chat);
}

void ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(chat);
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("chat", chat);
	return _buf.c_str();
}

void ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("chat", chat);
}

/*static*/ void ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHAT2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString chat; _jparser.validateByNameThrow("chat", chat);
	AtfValidator::validateIntMax(_descr, "chat", chat.length(), MAX_CHAT_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHAT2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "chat"); size_t szChat = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "chat", szChat, MAX_CHAT_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_CHAT2_REPLY
//=================================================================

ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::Protocol_MSG_TABLE_CHAT2_REPLY()
{
	clear();
}

void ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::clear()
{
	errCode = 0;
	errMsgBody.clear();
	chatMsg.clear();
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::equals(const Protocol_MSG_TABLE_CHAT2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errMsgBody.equals(_o.errMsgBody) &&
		Atf::atfPStringEquals(chatMsg, _o.chatMsg);
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_CHAT2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_CHAT2_REPLY*)_other));
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_CHAT2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsgBody=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(errMsgBody, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("chatMsg=");
	_buf.append(chatMsg);
	return _buf.c_str();
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_CHAT2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsgBody", errMsgBody, _buf);
	Atf::XmlElement::encodeAsXmlElement("chatMsg", chatMsg, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsgBody"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, errMsgBody)) return false;
			}
			else if (_element.equals("chatMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, chatMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeMsgBody(errMsgBody);
	_msg.composeString(chatMsg);
}

void ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseMsgBody(errMsgBody);
	_parser.parseStringP(chatMsg);
}

const char *ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsgBody", errMsgBody);
	_jsonstr.compose("chatMsg", chatMsg);
	return _buf.c_str();
}

void ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsgBody", errMsgBody);
	_jparser.parseByNameThrow("chatMsg", chatMsg);
}

/*static*/ void ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHAT2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody errMsgBody; _jparser.validateByNameThrow("errMsgBody", errMsgBody);
	AtfValidator::validateInt(_descr, "errMsgBody", errMsgBody._size(), _checker, __FILE__, __LINE__);
	PString chatMsg; _jparser.validateByNameThrow("chatMsg", chatMsg);
	AtfValidator::validateInt(_descr, "chatMsg", chatMsg.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void ZoomReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHAT2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	size_t szErrMsgBody; _parser.skipMsgBody(szErrMsgBody);  /*errMsgBody*/
	AtfValidator::validateInt(_descr, "errMsgBody", szErrMsgBody, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "chatMsg"); size_t szChatMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "chatMsg", szChatMsg, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* ZoomReplay::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_TABLE_CHAT2: _obj = new cli::Protocol_MSG_TABLE_CHAT2(); break;
			case MSG_TABLE_CHAT2_REPLY: _obj = new cli::Protocol_MSG_TABLE_CHAT2_REPLY(); break;
			case MSG_TABLE_LOGIN: _obj = new cli::Protocol_MSG_TABLE_LOGIN(); break;
			case MSG_TABLE_LOGIN_REPLY: _obj = new cli::Protocol_MSG_TABLE_LOGIN_REPLY(); break;
			case MSG_TABLE_LOGOUT: _obj = new cli::Protocol_MSG_TABLE_LOGOUT(); break;
			case MSG_TABLE_LOGOUT_REPLY: _obj = new cli::Protocol_MSG_TABLE_LOGOUT_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool ZoomReplay::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_TABLE_CHAT2: cli::Protocol_MSG_TABLE_CHAT2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CHAT2_REPLY: cli::Protocol_MSG_TABLE_CHAT2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGIN: cli::Protocol_MSG_TABLE_LOGIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGIN_REPLY: cli::Protocol_MSG_TABLE_LOGIN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGOUT: cli::Protocol_MSG_TABLE_LOGOUT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGOUT_REPLY: cli::Protocol_MSG_TABLE_LOGOUT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool ZoomReplay::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_TABLE_CHAT2: cli::Protocol_MSG_TABLE_CHAT2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CHAT2_REPLY: cli::Protocol_MSG_TABLE_CHAT2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGIN: cli::Protocol_MSG_TABLE_LOGIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGIN_REPLY: cli::Protocol_MSG_TABLE_LOGIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGOUT: cli::Protocol_MSG_TABLE_LOGOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGOUT_REPLY: cli::Protocol_MSG_TABLE_LOGOUT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

