/**
 * mtlobby_atf_cli.cpp
 *
 * This file was auto-generated from mtlobby_atf_cli.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor mtlobby_atf_cli.txt
 */
 
#include "mtlobby_atf_cli.h"

//=================================================================
//                    UserStatsReply
//=================================================================

MTLobbyCli::UserStatsReply::UserStatsReply()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::UserStatsReply::UserStatsReply(UserStatsReply&& _o)
	: place(std::move(_o.place))
	, totalPlayers(std::move(_o.totalPlayers))
	, tableName(std::move(_o.tableName))
	, userName(std::move(_o.userName))
	, city(std::move(_o.city))
	, chips(std::move(_o.chips))
	, tableServer(std::move(_o.tableServer))
	, tableObject(std::move(_o.tableObject))
	, country(std::move(_o.country))
	, showCity(std::move(_o.showCity))
	, fromFlightId(std::move(_o.fromFlightId))
	, fromFlightName(std::move(_o.fromFlightName))
	, bountyAndKnockouts(std::move(_o.bountyAndKnockouts))
	, rebuysDone(std::move(_o.rebuysDone))
	, addonsDone(std::move(_o.addonsDone))
	, rebuysRemaining(std::move(_o.rebuysRemaining))
	, headBounty(std::move(_o.headBounty))
{
}

MTLobbyCli::UserStatsReply& MTLobbyCli::UserStatsReply::operator=(UserStatsReply&& _o)
{
	if(this != &_o)
	{
		place = std::move(_o.place);
		totalPlayers = std::move(_o.totalPlayers);
		tableName = std::move(_o.tableName);
		userName = std::move(_o.userName);
		city = std::move(_o.city);
		chips = std::move(_o.chips);
		tableServer = std::move(_o.tableServer);
		tableObject = std::move(_o.tableObject);
		country = std::move(_o.country);
		showCity = std::move(_o.showCity);
		fromFlightId = std::move(_o.fromFlightId);
		fromFlightName = std::move(_o.fromFlightName);
		bountyAndKnockouts = std::move(_o.bountyAndKnockouts);
		rebuysDone = std::move(_o.rebuysDone);
		addonsDone = std::move(_o.addonsDone);
		rebuysRemaining = std::move(_o.rebuysRemaining);
		headBounty = std::move(_o.headBounty);
	}
	return *this;
}

#endif

void MTLobbyCli::UserStatsReply::clear()
{
	place = 0;
	totalPlayers = 0;
	tableName.clear();
	userName.clear();
	city.clear();
	chips = 0;
	tableServer.clear();
	tableObject.clear();
	country.clear();
	showCity = 0;
	fromFlightId = 0;
	fromFlightName.clear();
	bountyAndKnockouts = 0;
	rebuysDone = 0;
	addonsDone = 0;
	rebuysRemaining = 0;
	headBounty = 0;
}

bool MTLobbyCli::UserStatsReply::equals(const UserStatsReply& _o) const
{
	return place == _o.place &&
		totalPlayers == _o.totalPlayers &&
		Atf::atfPStringEquals(tableName, _o.tableName) &&
		Atf::atfPStringEquals(userName, _o.userName) &&
		Atf::atfPStringEquals(city, _o.city) &&
		chips == _o.chips &&
		Atf::atfPStringEquals(tableServer, _o.tableServer) &&
		Atf::atfPStringEquals(tableObject, _o.tableObject) &&
		Atf::atfPStringEquals(country, _o.country) &&
		showCity == _o.showCity &&
		fromFlightId == _o.fromFlightId &&
		Atf::atfPStringEquals(fromFlightName, _o.fromFlightName) &&
		bountyAndKnockouts == _o.bountyAndKnockouts &&
		rebuysDone == _o.rebuysDone &&
		addonsDone == _o.addonsDone &&
		rebuysRemaining == _o.rebuysRemaining &&
		headBounty == _o.headBounty;
}

const char *MTLobbyCli::UserStatsReply::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("place=");
	_buf.appendUint(place);
	_buf.append(',');
	_buf.append("totalPlayers=");
	_buf.appendInt(totalPlayers);
	_buf.append(',');
	_buf.append("tableName=");
	_buf.append(tableName);
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendUint(chips);
	_buf.append(',');
	_buf.append("tableServer=");
	_buf.append(tableServer);
	_buf.append(',');
	_buf.append("tableObject=");
	_buf.append(tableObject);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("showCity=");
	_buf.appendUint(showCity);
	_buf.append(',');
	_buf.append("fromFlightId=");
	_buf.appendUint(fromFlightId);
	_buf.append(',');
	_buf.append("fromFlightName=");
	_buf.append(fromFlightName);
	_buf.append(',');
	_buf.append("bountyAndKnockouts=");
	_buf.appendInt(bountyAndKnockouts);
	_buf.append(',');
	_buf.append("rebuysDone=");
	_buf.appendUint(rebuysDone);
	_buf.append(',');
	_buf.append("addonsDone=");
	_buf.appendUint(addonsDone);
	_buf.append(',');
	_buf.append("rebuysRemaining=");
	_buf.appendInt(rebuysRemaining);
	_buf.append(',');
	_buf.append("headBounty=");
	_buf.appendInt(headBounty);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::UserStatsReply::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("place", place, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalPlayers", totalPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableName", tableName, _buf);
	Atf::XmlElement::encodeAsXmlElement("userName", userName, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableServer", tableServer, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableObject", tableObject, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("showCity", showCity, _buf);
	Atf::XmlElement::encodeAsXmlElement("fromFlightId", fromFlightId, _buf);
	Atf::XmlElement::encodeAsXmlElement("fromFlightName", fromFlightName, _buf);
	Atf::XmlElement::encodeAsXmlElement("bountyAndKnockouts", bountyAndKnockouts, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuysDone", rebuysDone, _buf);
	Atf::XmlElement::encodeAsXmlElement("addonsDone", addonsDone, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuysRemaining", rebuysRemaining, _buf);
	Atf::XmlElement::encodeAsXmlElement("headBounty", headBounty, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::UserStatsReply::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("place"))
		{
			place = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalPlayers"))
		{
			totalPlayers = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tableName)) return false;
		}
		else if (_element.equals("userName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userName)) return false;
		}
		else if (_element.equals("city"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
		}
		else if (_element.equals("chips"))
		{
			chips = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableServer"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tableServer)) return false;
		}
		else if (_element.equals("tableObject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tableObject)) return false;
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("showCity"))
		{
			showCity = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fromFlightId"))
		{
			fromFlightId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fromFlightName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, fromFlightName)) return false;
		}
		else if (_element.equals("bountyAndKnockouts"))
		{
			bountyAndKnockouts = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rebuysDone"))
		{
			rebuysDone = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("addonsDone"))
		{
			addonsDone = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rebuysRemaining"))
		{
			rebuysRemaining = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("headBounty"))
		{
			headBounty = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::UserStatsReply::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(place);
	_msg.composeINT32(totalPlayers);
	_msg.composeString(tableName);
	_msg.composeString(userName);
	_msg.composeString(city);
	_msg.composeUINT32(chips);
	_msg.composeString(tableServer);
	_msg.composeString(tableObject);
	_msg.composeString(country);
	_msg.composeBYTE(showCity);
	_msg.composeUINT32(fromFlightId);
	_msg.composeString(fromFlightName);
	_msg.composeINT32(bountyAndKnockouts);
	_msg.composeUINT16(rebuysDone);
	_msg.composeUINT16(addonsDone);
	_msg.composeINT16(rebuysRemaining);
	_msg.composeINT32(headBounty);
}

void MTLobbyCli::UserStatsReply::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(place);
	_parser.parseINT32(totalPlayers);
	_parser.parseStringP(tableName);
	_parser.parseStringP(userName);
	_parser.parseStringP(city);
	_parser.parseUINT32(chips);
	_parser.parseStringP(tableServer);
	_parser.parseStringP(tableObject);
	_parser.parseStringP(country);
	_parser.parseBYTE(showCity);
	_parser.parseUINT32(fromFlightId);
	_parser.parseStringP(fromFlightName);
	_parser.parseINT32(bountyAndKnockouts);
	_parser.parseUINT16(rebuysDone);
	_parser.parseUINT16(addonsDone);
	_parser.parseINT16(rebuysRemaining);
	_parser.parseINT32(headBounty);
}

const char *MTLobbyCli::UserStatsReply::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("place", place);
	_jsonstr.compose("totalPlayers", totalPlayers);
	_jsonstr.compose("tableName", tableName);
	_jsonstr.compose("userName", userName);
	_jsonstr.compose("city", city);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("tableServer", tableServer);
	_jsonstr.compose("tableObject", tableObject);
	_jsonstr.compose("country", country);
	_jsonstr.compose("showCity", showCity);
	_jsonstr.compose("fromFlightId", fromFlightId);
	_jsonstr.compose("fromFlightName", fromFlightName);
	_jsonstr.compose("bountyAndKnockouts", bountyAndKnockouts);
	_jsonstr.compose("rebuysDone", rebuysDone);
	_jsonstr.compose("addonsDone", addonsDone);
	_jsonstr.compose("rebuysRemaining", rebuysRemaining);
	_jsonstr.compose("headBounty", headBounty);
	return _buf.c_str();
}

void MTLobbyCli::UserStatsReply::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("place", place);
	_jparser.parseByNameThrow("totalPlayers", totalPlayers);
	_jparser.parseByNameThrow("tableName", tableName);
	_jparser.parseByNameThrow("userName", userName);
	_jparser.parseByNameThrow("city", city);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("tableServer", tableServer);
	_jparser.parseByNameThrow("tableObject", tableObject);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("showCity", showCity);
	_jparser.parseByNameThrow("fromFlightId", fromFlightId);
	_jparser.parseByNameThrow("fromFlightName", fromFlightName);
	_jparser.parseByNameThrow("bountyAndKnockouts", bountyAndKnockouts);
	_jparser.parseByNameThrow("rebuysDone", rebuysDone);
	_jparser.parseByNameThrow("addonsDone", addonsDone);
	_jparser.parseByNameThrow("rebuysRemaining", rebuysRemaining);
	_jparser.parseByNameThrow("headBounty", headBounty);
}

/* static */ void MTLobbyCli::UserStatsReply::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 place; _jparser.validateByNameThrow("place", place);
	AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	INT32 totalPlayers; _jparser.validateByNameThrow("totalPlayers", totalPlayers);
	AtfValidator::validateInt(_descr, "totalPlayers", totalPlayers, _checker, __FILE__, __LINE__);
	PString tableName; _jparser.validateByNameThrow("tableName", tableName);
	AtfValidator::validateInt(_descr, "tableName", tableName.length(), _checker, __FILE__, __LINE__);
	PString userName; _jparser.validateByNameThrow("userName", userName);
	AtfValidator::validateInt(_descr, "userName", userName.length(), _checker, __FILE__, __LINE__);
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateInt(_descr, "city", city.length(), _checker, __FILE__, __LINE__);
	UINT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	PString tableServer; _jparser.validateByNameThrow("tableServer", tableServer);
	AtfValidator::validateInt(_descr, "tableServer", tableServer.length(), _checker, __FILE__, __LINE__);
	PString tableObject; _jparser.validateByNameThrow("tableObject", tableObject);
	AtfValidator::validateInt(_descr, "tableObject", tableObject.length(), _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	BYTE showCity; _jparser.validateByNameThrow("showCity", showCity);
	AtfValidator::validateInt(_descr, "showCity", showCity, _checker, __FILE__, __LINE__);
	UINT32 fromFlightId; _jparser.validateByNameThrow("fromFlightId", fromFlightId);
	AtfValidator::validateInt(_descr, "fromFlightId", fromFlightId, _checker, __FILE__, __LINE__);
	PString fromFlightName; _jparser.validateByNameThrow("fromFlightName", fromFlightName);
	AtfValidator::validateInt(_descr, "fromFlightName", fromFlightName.length(), _checker, __FILE__, __LINE__);
	INT32 bountyAndKnockouts; _jparser.validateByNameThrow("bountyAndKnockouts", bountyAndKnockouts);
	AtfValidator::validateInt(_descr, "bountyAndKnockouts", bountyAndKnockouts, _checker, __FILE__, __LINE__);
	UINT16 rebuysDone; _jparser.validateByNameThrow("rebuysDone", rebuysDone);
	AtfValidator::validateInt(_descr, "rebuysDone", rebuysDone, _checker, __FILE__, __LINE__);
	UINT16 addonsDone; _jparser.validateByNameThrow("addonsDone", addonsDone);
	AtfValidator::validateInt(_descr, "addonsDone", addonsDone, _checker, __FILE__, __LINE__);
	INT16 rebuysRemaining; _jparser.validateByNameThrow("rebuysRemaining", rebuysRemaining);
	AtfValidator::validateInt(_descr, "rebuysRemaining", rebuysRemaining, _checker, __FILE__, __LINE__);
	INT32 headBounty; _jparser.validateByNameThrow("headBounty", headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::UserStatsReply::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 place; _parser.parseUINT32(place);
	AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	INT32 totalPlayers; _parser.parseINT32(totalPlayers);
	AtfValidator::validateInt(_descr, "totalPlayers", totalPlayers, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableName"); size_t szTableName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableName", szTableName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userName", szUserName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	UINT32 chips; _parser.parseUINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableServer"); size_t szTableServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableServer", szTableServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableObject"); size_t szTableObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableObject", szTableObject, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	BYTE showCity; _parser.parseBYTE(showCity);
	AtfValidator::validateInt(_descr, "showCity", showCity, _checker, __FILE__, __LINE__);
	UINT32 fromFlightId; _parser.parseUINT32(fromFlightId);
	AtfValidator::validateInt(_descr, "fromFlightId", fromFlightId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "fromFlightName"); size_t szFromFlightName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "fromFlightName", szFromFlightName, _checker, __FILE__, __LINE__);
	INT32 bountyAndKnockouts; _parser.parseINT32(bountyAndKnockouts);
	AtfValidator::validateInt(_descr, "bountyAndKnockouts", bountyAndKnockouts, _checker, __FILE__, __LINE__);
	UINT16 rebuysDone; _parser.parseUINT16(rebuysDone);
	AtfValidator::validateInt(_descr, "rebuysDone", rebuysDone, _checker, __FILE__, __LINE__);
	UINT16 addonsDone; _parser.parseUINT16(addonsDone);
	AtfValidator::validateInt(_descr, "addonsDone", addonsDone, _checker, __FILE__, __LINE__);
	INT16 rebuysRemaining; _parser.parseINT16(rebuysRemaining);
	AtfValidator::validateInt(_descr, "rebuysRemaining", rebuysRemaining, _checker, __FILE__, __LINE__);
	INT32 headBounty; _parser.parseINT32(headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSpendLimit
//=================================================================

MTLobbyCli::TournSpendLimit::TournSpendLimit()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::TournSpendLimit::TournSpendLimit(TournSpendLimit&& _o)
	: limitImposed(std::move(_o.limitImposed))
	, spendAmount(std::move(_o.spendAmount))
	, spendLimit(std::move(_o.spendLimit))
{
}

MTLobbyCli::TournSpendLimit& MTLobbyCli::TournSpendLimit::operator=(TournSpendLimit&& _o)
{
	if(this != &_o)
	{
		limitImposed = std::move(_o.limitImposed);
		spendAmount = std::move(_o.spendAmount);
		spendLimit = std::move(_o.spendLimit);
	}
	return *this;
}

#endif

void MTLobbyCli::TournSpendLimit::clear()
{
	limitImposed = false;
	spendAmount = 0;
	spendLimit = 0;
}

bool MTLobbyCli::TournSpendLimit::equals(const TournSpendLimit& _o) const
{
	return limitImposed == _o.limitImposed &&
		spendAmount == _o.spendAmount &&
		spendLimit == _o.spendLimit;
}

const char *MTLobbyCli::TournSpendLimit::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limitImposed=");
	_buf.appendUint(limitImposed);
	if( limitImposed )
	{
		_buf.append(',');
		_buf.append("spendAmount=");
		_buf.appendInt(spendAmount);
		_buf.append(',');
		_buf.append("spendLimit=");
		_buf.appendInt(spendLimit);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::TournSpendLimit::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("limitImposed", limitImposed, _buf);
	if( limitImposed )
	{
		Atf::XmlElement::encodeAsXmlElement("spendAmount", spendAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("spendLimit", spendLimit, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::TournSpendLimit::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("limitImposed"))
		{
			limitImposed = (*_value.ptr() == '1');
		}
		else if (_element.equals("spendAmount"))
		{
			spendAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("spendLimit"))
		{
			spendLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::TournSpendLimit::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournSpendLimit())) // not empty
	{
		_body.composeBOOL(limitImposed);
		if( limitImposed )
		{
			_body.composeINT32(spendAmount);
			_body.composeINT32(spendLimit);
		}
	}

	_msg.composeMsgBody(_body);
}

void MTLobbyCli::TournSpendLimit::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(limitImposed);
	if( limitImposed )
	{
		_parser0.parseINT32(spendAmount);
		_parser0.parseINT32(spendLimit);
	}
}

const char *MTLobbyCli::TournSpendLimit::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limitImposed", limitImposed);
	if( limitImposed )
	{
		_jsonstr.compose("spendAmount", spendAmount);
		_jsonstr.compose("spendLimit", spendLimit);
	}
	return _buf.c_str();
}

void MTLobbyCli::TournSpendLimit::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("limitImposed", limitImposed);
	if( limitImposed )
	{
		_jparser.parseByNameThrow("spendAmount", spendAmount);
		_jparser.parseByNameThrow("spendLimit", spendLimit);
	}
}

/* static */ void MTLobbyCli::TournSpendLimit::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool limitImposed = false;
	_jparser.validateByNameThrow("limitImposed", limitImposed);
	AtfValidator::validateInt(_descr, "limitImposed", limitImposed, _checker, __FILE__, __LINE__);
	if( limitImposed )
	{
		INT32 spendAmount; _jparser.validateByNameThrow("spendAmount", spendAmount);
		AtfValidator::validateInt(_descr, "spendAmount", spendAmount, _checker, __FILE__, __LINE__);
		INT32 spendLimit; _jparser.validateByNameThrow("spendLimit", spendLimit);
		AtfValidator::validateInt(_descr, "spendLimit", spendLimit, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MTLobbyCli::TournSpendLimit::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool limitImposed = false;
	_parser0.parseBOOL(limitImposed);
	AtfValidator::validateInt(_descr, "limitImposed", limitImposed, _checker, __FILE__, __LINE__);
	if( limitImposed )
	{
		INT32 spendAmount; _parser0.parseINT32(spendAmount);
		AtfValidator::validateInt(_descr, "spendAmount", spendAmount, _checker, __FILE__, __LINE__);
		INT32 spendLimit; _parser0.parseINT32(spendLimit);
		AtfValidator::validateInt(_descr, "spendLimit", spendLimit, _checker, __FILE__, __LINE__);
	}
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    P_TicketType
//=================================================================

MTLobbyCli::publication::P_TicketType::P_TicketType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::P_TicketType::P_TicketType(P_TicketType&& _o)
	: ticketTypeId(std::move(_o.ticketTypeId))
	, name(std::move(_o.name))
{
}

MTLobbyCli::publication::P_TicketType& MTLobbyCli::publication::P_TicketType::operator=(P_TicketType&& _o)
{
	if(this != &_o)
	{
		ticketTypeId = std::move(_o.ticketTypeId);
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::P_TicketType::clear()
{
	ticketTypeId = 0;
	name.clear();
}

bool MTLobbyCli::publication::P_TicketType::equals(const P_TicketType& _o) const
{
	return ticketTypeId == _o.ticketTypeId &&
		Atf::atfPStringEquals(name, _o.name);
}

const char *MTLobbyCli::publication::P_TicketType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketTypeId=");
	_buf.appendUint(ticketTypeId);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::P_TicketType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("ticketTypeId", ticketTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::P_TicketType::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("ticketTypeId"))
		{
			ticketTypeId = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::P_TicketType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(ticketTypeId);
	_msg.composeString(name);
}

void MTLobbyCli::publication::P_TicketType::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(ticketTypeId);
	_parser.parseStringP(name);
}

const char *MTLobbyCli::publication::P_TicketType::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketTypeId", ticketTypeId);
	_jsonstr.compose("name", name);
	return _buf.c_str();
}

void MTLobbyCli::publication::P_TicketType::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketTypeId", ticketTypeId);
	_jparser.parseByNameThrow("name", name);
}

/* static */ void MTLobbyCli::publication::P_TicketType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 ticketTypeId; _jparser.validateByNameThrow("ticketTypeId", ticketTypeId);
	AtfValidator::validateInt(_descr, "ticketTypeId", ticketTypeId, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::P_TicketType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT16 ticketTypeId; _parser.parseUINT16(ticketTypeId);
	AtfValidator::validateInt(_descr, "ticketTypeId", ticketTypeId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_FppReward
//=================================================================

MTLobbyCli::publication::P_FppReward::P_FppReward()
{
	clear();
}

void MTLobbyCli::publication::P_FppReward::clear()
{
	siteId = 0;
	reward = 0;
}

bool MTLobbyCli::publication::P_FppReward::equals(const P_FppReward& _o) const
{
	return siteId == _o.siteId &&
		reward == _o.reward;
}

const char *MTLobbyCli::publication::P_FppReward::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("reward=");
	_buf.appendUint(reward);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::P_FppReward::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("reward", reward, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::P_FppReward::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("siteId"))
		{
			siteId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("reward"))
		{
			reward = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::P_FppReward::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(P_FppReward())) // not empty
	{
		_body.composeUINT32(siteId);
		_body.composeUINT32(reward);
	}

	_msg.composeMsgBody(_body);
}

void MTLobbyCli::publication::P_FppReward::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(reward);
}

const char *MTLobbyCli::publication::P_FppReward::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("reward", reward);
	return _buf.c_str();
}

void MTLobbyCli::publication::P_FppReward::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("reward", reward);
}

/* static */ void MTLobbyCli::publication::P_FppReward::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	UINT32 reward; _jparser.validateByNameThrow("reward", reward);
	AtfValidator::validateInt(_descr, "reward", reward, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::P_FppReward::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	UINT32 reward; _parser0.parseUINT32(reward);
	AtfValidator::validateInt(_descr, "reward", reward, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    P_MultiDayInfo
//=================================================================

MTLobbyCli::publication::P_MultiDayInfo::P_MultiDayInfo()
{
	clear();
}

void MTLobbyCli::publication::P_MultiDayInfo::clear()
{
	props = 0;
	dayOneStopValue = 0;
	dayTwoStartMinutes = 0;
	dayTwoStart.setNull();
}

bool MTLobbyCli::publication::P_MultiDayInfo::equals(const P_MultiDayInfo& _o) const
{
	return props == _o.props &&
		dayOneStopValue == _o.dayOneStopValue &&
		dayTwoStartMinutes == _o.dayTwoStartMinutes &&
		dayTwoStart.equals(_o.dayTwoStart);
}

const char *MTLobbyCli::publication::P_MultiDayInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("props=");
	_buf.appendUint(props);
	_buf.append(',');
	_buf.append("dayOneStopValue=");
	_buf.appendInt(dayOneStopValue);
	_buf.append(',');
	_buf.append("dayTwoStartMinutes=");
	_buf.appendUint(dayTwoStartMinutes);
	_buf.append(',');
	_buf.append("dayTwoStart=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, dayTwoStart);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::P_MultiDayInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("props", props, _buf);
	Atf::XmlElement::encodeAsXmlElement("dayOneStopValue", dayOneStopValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("dayTwoStartMinutes", dayTwoStartMinutes, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "dayTwoStart", dayTwoStart);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::P_MultiDayInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("props"))
		{
			props = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("dayOneStopValue"))
		{
			dayOneStopValue = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("dayTwoStartMinutes"))
		{
			dayTwoStartMinutes = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("dayTwoStart"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, dayTwoStart);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::P_MultiDayInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(P_MultiDayInfo())) // not empty
	{
		_body.composeUINT32(props);
		_body.composeINT32(dayOneStopValue);
		_body.composeUINT32(dayTwoStartMinutes);
		_body.composeSrvTime(dayTwoStart);
	}

	_msg.composeMsgBody(_body);
}

void MTLobbyCli::publication::P_MultiDayInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(props);
	_parser0.parseINT32(dayOneStopValue);
	_parser0.parseUINT32(dayTwoStartMinutes);
	_parser0.parseSrvTime(dayTwoStart);
}

const char *MTLobbyCli::publication::P_MultiDayInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("props", props);
	_jsonstr.compose("dayOneStopValue", dayOneStopValue);
	_jsonstr.compose("dayTwoStartMinutes", dayTwoStartMinutes);
	_jsonstr.compose("dayTwoStart", dayTwoStart);
	return _buf.c_str();
}

void MTLobbyCli::publication::P_MultiDayInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("props", props);
	_jparser.parseByNameThrow("dayOneStopValue", dayOneStopValue);
	_jparser.parseByNameThrow("dayTwoStartMinutes", dayTwoStartMinutes);
	_jparser.parseByNameThrow("dayTwoStart", dayTwoStart);
}

/* static */ void MTLobbyCli::publication::P_MultiDayInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 props; _jparser.validateByNameThrow("props", props);
	AtfValidator::validateInt(_descr, "props", props, _checker, __FILE__, __LINE__);
	INT32 dayOneStopValue; _jparser.validateByNameThrow("dayOneStopValue", dayOneStopValue);
	AtfValidator::validateInt(_descr, "dayOneStopValue", dayOneStopValue, _checker, __FILE__, __LINE__);
	UINT32 dayTwoStartMinutes; _jparser.validateByNameThrow("dayTwoStartMinutes", dayTwoStartMinutes);
	AtfValidator::validateInt(_descr, "dayTwoStartMinutes", dayTwoStartMinutes, _checker, __FILE__, __LINE__);
	SrvTime dayTwoStart; _jparser.validateByNameThrow("dayTwoStart", dayTwoStart);
	AtfValidator::validateSrvDateTime(_descr, "dayTwoStart", dayTwoStart, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::P_MultiDayInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 props; _parser0.parseUINT32(props);
	AtfValidator::validateInt(_descr, "props", props, _checker, __FILE__, __LINE__);
	INT32 dayOneStopValue; _parser0.parseINT32(dayOneStopValue);
	AtfValidator::validateInt(_descr, "dayOneStopValue", dayOneStopValue, _checker, __FILE__, __LINE__);
	UINT32 dayTwoStartMinutes; _parser0.parseUINT32(dayTwoStartMinutes);
	AtfValidator::validateInt(_descr, "dayTwoStartMinutes", dayTwoStartMinutes, _checker, __FILE__, __LINE__);
	SrvTime dayTwoStart; _parser0.parseSrvTime(dayTwoStart);
	AtfValidator::validateSrvDateTime(_descr, "dayTwoStart", dayTwoStart, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournSubscr_Static
//=================================================================

MTLobbyCli::publication::TournSubscr_Static::TournSubscr_Static()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_Static::TournSubscr_Static(TournSubscr_Static&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, startingChips(std::move(_o.startingChips))
	, maxPlayers(std::move(_o.maxPlayers))
	, playersPerTable(std::move(_o.playersPerTable))
	, gameType(std::move(_o.gameType))
	, isHiLo(std::move(_o.isHiLo))
	, startingTime(std::move(_o.startingTime))
	, registrationStarts(std::move(_o.registrationStarts))
	, registrationEnds(std::move(_o.registrationEnds))
	, seatingStarts(std::move(_o.seatingStarts))
	, minPlayers(std::move(_o.minPlayers))
	, restricted(std::move(_o.restricted))
	, fppReward(std::move(_o.fppReward))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, isRestricted(std::move(_o.isRestricted))
	, isPwdProtected(std::move(_o.isPwdProtected))
	, name(std::move(_o.name))
	, numRebuys(std::move(_o.numRebuys))
	, rebuyChips(std::move(_o.rebuyChips))
	, _obsolete_1(std::move(_o._obsolete_1))
	, rebuyMaxChips(std::move(_o.rebuyMaxChips))
	, numAddOns(std::move(_o.numAddOns))
	, addOnChips(std::move(_o.addOnChips))
	, _obsolete_2(std::move(_o._obsolete_2))
	, addOnMaxChips(std::move(_o.addOnMaxChips))
	, scriptPrizeAddOn(std::move(_o.scriptPrizeAddOn))
	, guaranteedPrizePool(std::move(_o.guaranteedPrizePool))
	, tournFlags(std::move(_o.tournFlags))
	, maxAllins(std::move(_o.maxAllins))
	, awardSchema(std::move(_o.awardSchema))
	, timeBank(std::move(_o.timeBank))
	, unregistrationEnds_t(std::move(_o.unregistrationEnds_t))
	, satelliteTarget(std::move(_o.satelliteTarget))
	, satelliteTargetBuyIn(std::move(_o.satelliteTargetBuyIn))
	, rebuyFppPrice(std::move(_o.rebuyFppPrice))
	, addOnFppPrice(std::move(_o.addOnFppPrice))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, startingTime_t(std::move(_o.startingTime_t))
	, registrationStarts_t(std::move(_o.registrationStarts_t))
	, registrationEnds_t(std::move(_o.registrationEnds_t))
	, seatingStarts_t(std::move(_o.seatingStarts_t))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, tournProp2(std::move(_o.tournProp2))
	, ticketTypes(std::move(_o.ticketTypes))
	, tableLogo(std::move(_o.tableLogo))
	, finalTableText(std::move(_o.finalTableText))
	, chatLang(std::move(_o.chatLang))
	, lobbyRestricted(std::move(_o.lobbyRestricted))
	, fppFraction(std::move(_o.fppFraction))
	, currency(std::move(_o.currency))
	, rebuyFppReward(std::move(_o.rebuyFppReward))
	, addOnFppReward(std::move(_o.addOnFppReward))
	, fppRewardPercent(std::move(_o.fppRewardPercent))
	, nPublishLobbyPlayersLess(std::move(_o.nPublishLobbyPlayersLess))
	, bounty(std::move(_o.bounty))
	, fallbackSatelliteTargets(std::move(_o.fallbackSatelliteTargets))
	, teamProBounties(std::move(_o.teamProBounties))
	, bountyMultipliers(std::move(_o.bountyMultipliers))
	, publPropFlag(std::move(_o.publPropFlag))
	, multiDayTournProps(std::move(_o.multiDayTournProps))
	, multiDayTournDayOneStopValue(std::move(_o.multiDayTournDayOneStopValue))
	, multiDayTournDayTwoStartMinutes(std::move(_o.multiDayTournDayTwoStartMinutes))
	, multiDayTournDayTwoStarts(std::move(_o.multiDayTournDayTwoStarts))
	, satelliteTargetReference(std::move(_o.satelliteTargetReference))
	, satelliteTargetReferenceLock(std::move(_o.satelliteTargetReferenceLock))
	, clubId(std::move(_o.clubId))
	, timedTournType(std::move(_o.timedTournType))
	, timedTournLevelsOrMinutes(std::move(_o.timedTournLevelsOrMinutes))
	, timedTournPayoutStructure(std::move(_o.timedTournPayoutStructure))
	, _obsolete_3(std::move(_o._obsolete_3))
	, fppRewards(std::move(_o.fppRewards))
	, speedDisplay(std::move(_o.speedDisplay))
	, tournBrand(std::move(_o.tournBrand))
	, scalePM(std::move(_o.scalePM))
	, blitzNormalDealingThreshold(std::move(_o.blitzNormalDealingThreshold))
	, _obsolete_4(std::move(_o._obsolete_4))
	, progressiveKnockout(std::move(_o.progressiveKnockout))
	, tableText(std::move(_o.tableText))
	, reEntryAllowed(std::move(_o.reEntryAllowed))
	, tournMask(std::move(_o.tournMask))
	, tournMask2(std::move(_o.tournMask2))
	, tournMask3(std::move(_o.tournMask3))
	, tournMask4(std::move(_o.tournMask4))
	, internalReference(std::move(_o.internalReference))
	, favoriteReference(std::move(_o.favoriteReference))
	, ticketPrice(std::move(_o.ticketPrice))
	, tournFlags2(std::move(_o.tournFlags2))
	, cannotUnregisterFromTarget(std::move(_o.cannotUnregisterFromTarget))
	, initialStacks(std::move(_o.initialStacks))
	, singleStackChips(std::move(_o.singleStackChips))
	, forceReloadAllStacksInLevel(std::move(_o.forceReloadAllStacksInLevel))
	, forceReloadAllStacksInMinutes(std::move(_o.forceReloadAllStacksInMinutes))
	, reloadStacksOnlyWhenEmpty(std::move(_o.reloadStacksOnlyWhenEmpty))
	, targetWhenStarts(std::move(_o.targetWhenStarts))
	, admission(std::move(_o.admission))
	, siteMask(std::move(_o.siteMask))
	, publStartLevel(std::move(_o.publStartLevel))
	, tournMask5(std::move(_o.tournMask5))
	, tournMask6(std::move(_o.tournMask6))
	, dealExclusionType(std::move(_o.dealExclusionType))
	, dealExclusionValue(std::move(_o.dealExclusionValue))
	, timedTournPlayersPercent(std::move(_o.timedTournPlayersPercent))
	, _obsolete_5(std::move(_o._obsolete_5))
	, spinGoStartDelay(std::move(_o.spinGoStartDelay))
	, rmPmLobby(std::move(_o.rmPmLobby))
	, brandMask(std::move(_o.brandMask))
	, playerKnockOutAddOn(std::move(_o.playerKnockOutAddOn))
	, totalKnockOutAddOn(std::move(_o.totalKnockOutAddOn))
	, knockOutAddOnProgressive(std::move(_o.knockOutAddOnProgressive))
	, sitGoStarterGameId(std::move(_o.sitGoStarterGameId))
	, numStandardButton(std::move(_o.numStandardButton))
	, lateRegDelta(std::move(_o.lateRegDelta))
	, finalTablePlusOne(std::move(_o.finalTablePlusOne))
	, multidayIndex(std::move(_o.multidayIndex))
	, multiDayInfo(std::move(_o.multiDayInfo))
	, criteria(std::move(_o.criteria))
	, groupReference(std::move(_o.groupReference))
{
}

MTLobbyCli::publication::TournSubscr_Static& MTLobbyCli::publication::TournSubscr_Static::operator=(TournSubscr_Static&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		startingChips = std::move(_o.startingChips);
		maxPlayers = std::move(_o.maxPlayers);
		playersPerTable = std::move(_o.playersPerTable);
		gameType = std::move(_o.gameType);
		isHiLo = std::move(_o.isHiLo);
		startingTime = std::move(_o.startingTime);
		registrationStarts = std::move(_o.registrationStarts);
		registrationEnds = std::move(_o.registrationEnds);
		seatingStarts = std::move(_o.seatingStarts);
		minPlayers = std::move(_o.minPlayers);
		restricted = std::move(_o.restricted);
		fppReward = std::move(_o.fppReward);
		fppBuyIn = std::move(_o.fppBuyIn);
		isRestricted = std::move(_o.isRestricted);
		isPwdProtected = std::move(_o.isPwdProtected);
		name = std::move(_o.name);
		numRebuys = std::move(_o.numRebuys);
		rebuyChips = std::move(_o.rebuyChips);
		_obsolete_1 = std::move(_o._obsolete_1);
		rebuyMaxChips = std::move(_o.rebuyMaxChips);
		numAddOns = std::move(_o.numAddOns);
		addOnChips = std::move(_o.addOnChips);
		_obsolete_2 = std::move(_o._obsolete_2);
		addOnMaxChips = std::move(_o.addOnMaxChips);
		scriptPrizeAddOn = std::move(_o.scriptPrizeAddOn);
		guaranteedPrizePool = std::move(_o.guaranteedPrizePool);
		tournFlags = std::move(_o.tournFlags);
		maxAllins = std::move(_o.maxAllins);
		awardSchema = std::move(_o.awardSchema);
		timeBank = std::move(_o.timeBank);
		unregistrationEnds_t = std::move(_o.unregistrationEnds_t);
		satelliteTarget = std::move(_o.satelliteTarget);
		satelliteTargetBuyIn = std::move(_o.satelliteTargetBuyIn);
		rebuyFppPrice = std::move(_o.rebuyFppPrice);
		addOnFppPrice = std::move(_o.addOnFppPrice);
		isPlayMoney = std::move(_o.isPlayMoney);
		startingTime_t = std::move(_o.startingTime_t);
		registrationStarts_t = std::move(_o.registrationStarts_t);
		registrationEnds_t = std::move(_o.registrationEnds_t);
		seatingStarts_t = std::move(_o.seatingStarts_t);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		tournProp2 = std::move(_o.tournProp2);
		ticketTypes = std::move(_o.ticketTypes);
		tableLogo = std::move(_o.tableLogo);
		finalTableText = std::move(_o.finalTableText);
		chatLang = std::move(_o.chatLang);
		lobbyRestricted = std::move(_o.lobbyRestricted);
		fppFraction = std::move(_o.fppFraction);
		currency = std::move(_o.currency);
		rebuyFppReward = std::move(_o.rebuyFppReward);
		addOnFppReward = std::move(_o.addOnFppReward);
		fppRewardPercent = std::move(_o.fppRewardPercent);
		nPublishLobbyPlayersLess = std::move(_o.nPublishLobbyPlayersLess);
		bounty = std::move(_o.bounty);
		fallbackSatelliteTargets = std::move(_o.fallbackSatelliteTargets);
		teamProBounties = std::move(_o.teamProBounties);
		bountyMultipliers = std::move(_o.bountyMultipliers);
		publPropFlag = std::move(_o.publPropFlag);
		multiDayTournProps = std::move(_o.multiDayTournProps);
		multiDayTournDayOneStopValue = std::move(_o.multiDayTournDayOneStopValue);
		multiDayTournDayTwoStartMinutes = std::move(_o.multiDayTournDayTwoStartMinutes);
		multiDayTournDayTwoStarts = std::move(_o.multiDayTournDayTwoStarts);
		satelliteTargetReference = std::move(_o.satelliteTargetReference);
		satelliteTargetReferenceLock = std::move(_o.satelliteTargetReferenceLock);
		clubId = std::move(_o.clubId);
		timedTournType = std::move(_o.timedTournType);
		timedTournLevelsOrMinutes = std::move(_o.timedTournLevelsOrMinutes);
		timedTournPayoutStructure = std::move(_o.timedTournPayoutStructure);
		_obsolete_3 = std::move(_o._obsolete_3);
		fppRewards = std::move(_o.fppRewards);
		speedDisplay = std::move(_o.speedDisplay);
		tournBrand = std::move(_o.tournBrand);
		scalePM = std::move(_o.scalePM);
		blitzNormalDealingThreshold = std::move(_o.blitzNormalDealingThreshold);
		_obsolete_4 = std::move(_o._obsolete_4);
		progressiveKnockout = std::move(_o.progressiveKnockout);
		tableText = std::move(_o.tableText);
		reEntryAllowed = std::move(_o.reEntryAllowed);
		tournMask = std::move(_o.tournMask);
		tournMask2 = std::move(_o.tournMask2);
		tournMask3 = std::move(_o.tournMask3);
		tournMask4 = std::move(_o.tournMask4);
		internalReference = std::move(_o.internalReference);
		favoriteReference = std::move(_o.favoriteReference);
		ticketPrice = std::move(_o.ticketPrice);
		tournFlags2 = std::move(_o.tournFlags2);
		cannotUnregisterFromTarget = std::move(_o.cannotUnregisterFromTarget);
		initialStacks = std::move(_o.initialStacks);
		singleStackChips = std::move(_o.singleStackChips);
		forceReloadAllStacksInLevel = std::move(_o.forceReloadAllStacksInLevel);
		forceReloadAllStacksInMinutes = std::move(_o.forceReloadAllStacksInMinutes);
		reloadStacksOnlyWhenEmpty = std::move(_o.reloadStacksOnlyWhenEmpty);
		targetWhenStarts = std::move(_o.targetWhenStarts);
		admission = std::move(_o.admission);
		siteMask = std::move(_o.siteMask);
		publStartLevel = std::move(_o.publStartLevel);
		tournMask5 = std::move(_o.tournMask5);
		tournMask6 = std::move(_o.tournMask6);
		dealExclusionType = std::move(_o.dealExclusionType);
		dealExclusionValue = std::move(_o.dealExclusionValue);
		timedTournPlayersPercent = std::move(_o.timedTournPlayersPercent);
		_obsolete_5 = std::move(_o._obsolete_5);
		spinGoStartDelay = std::move(_o.spinGoStartDelay);
		rmPmLobby = std::move(_o.rmPmLobby);
		brandMask = std::move(_o.brandMask);
		playerKnockOutAddOn = std::move(_o.playerKnockOutAddOn);
		totalKnockOutAddOn = std::move(_o.totalKnockOutAddOn);
		knockOutAddOnProgressive = std::move(_o.knockOutAddOnProgressive);
		sitGoStarterGameId = std::move(_o.sitGoStarterGameId);
		numStandardButton = std::move(_o.numStandardButton);
		lateRegDelta = std::move(_o.lateRegDelta);
		finalTablePlusOne = std::move(_o.finalTablePlusOne);
		multidayIndex = std::move(_o.multidayIndex);
		multiDayInfo = std::move(_o.multiDayInfo);
		criteria = std::move(_o.criteria);
		groupReference = std::move(_o.groupReference);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_Static::clear()
{
	tournamentId = 0;
	buyIn = 0;
	rake = 0;
	startingChips = 0;
	maxPlayers = 0;
	playersPerTable = 0;
	gameType = 0;
	isHiLo = false;
	startingTime.setNull();
	registrationStarts.setNull();
	registrationEnds.setNull();
	seatingStarts.setNull();
	minPlayers = 0;
	restricted = 0;
	fppReward = 0;
	fppBuyIn = 0;
	isRestricted = false;
	isPwdProtected = false;
	name.clear();
	numRebuys = 0;
	rebuyChips = 0;
	_obsolete_1 = 0;
	rebuyMaxChips = 0;
	numAddOns = 0;
	addOnChips = 0;
	_obsolete_2 = 0;
	addOnMaxChips = 0;
	scriptPrizeAddOn = 0;
	guaranteedPrizePool = 0;
	tournFlags = 0;
	maxAllins = 0;
	awardSchema = 0;
	timeBank = 0;
	unregistrationEnds_t = 0;
	satelliteTarget = 0;
	satelliteTargetBuyIn = 0;
	rebuyFppPrice = 0;
	addOnFppPrice = 0;
	isPlayMoney = false;
	startingTime_t = 0;
	registrationStarts_t = 0;
	registrationEnds_t = 0;
	seatingStarts_t = 0;
	tournFlagsServInt = 0;
	tournProp2 = 0;
	ticketTypes.clear();
	tableLogo = 0;
	finalTableText.clear();
	chatLang = 0;
	lobbyRestricted = 0;
	fppFraction = 0;
	currency.clear();
	rebuyFppReward = 0;
	addOnFppReward = 0;
	fppRewardPercent = 0;
	nPublishLobbyPlayersLess = 0;
	bounty = 0;
	fallbackSatelliteTargets.clear();
	teamProBounties.clear();
	bountyMultipliers.clear();
	publPropFlag = 0;
	multiDayTournProps = 0;
	multiDayTournDayOneStopValue = 0;
	multiDayTournDayTwoStartMinutes = 0;
	multiDayTournDayTwoStarts.setNull();
	satelliteTargetReference.clear();
	satelliteTargetReferenceLock = 0;
	clubId = 0;
	timedTournType = 0;
	timedTournLevelsOrMinutes = 0;
	timedTournPayoutStructure = 0;
	_obsolete_3 = false;
	fppRewards.clear();
	speedDisplay = 0;
	tournBrand.clear();
	scalePM = 0;
	blitzNormalDealingThreshold = 0;
	_obsolete_4 = false;
	progressiveKnockout = 0;
	tableText.clear();
	reEntryAllowed = 0;
	tournMask = 0;
	tournMask2 = 0;
	tournMask3 = 0;
	tournMask4 = 0;
	internalReference.clear();
	favoriteReference.clear();
	ticketPrice = 0;
	tournFlags2 = 0;
	cannotUnregisterFromTarget = false;
	initialStacks = 0;
	singleStackChips = 0;
	forceReloadAllStacksInLevel = 0;
	forceReloadAllStacksInMinutes = 0;
	reloadStacksOnlyWhenEmpty = false;
	targetWhenStarts.setNull();
	admission.clear();
	siteMask = 0;
	publStartLevel = 0;
	tournMask5 = 0;
	tournMask6 = 0;
	dealExclusionType = 0;
	dealExclusionValue = 0;
	timedTournPlayersPercent = 0;
	_obsolete_5 = 0;
	spinGoStartDelay = 0;
	rmPmLobby = 0;
	brandMask = 0;
	playerKnockOutAddOn = 0;
	totalKnockOutAddOn = 0;
	knockOutAddOnProgressive = 0;
	sitGoStarterGameId = 0;
	numStandardButton = 0;
	lateRegDelta = 0;
	finalTablePlusOne = 0;
	multidayIndex = 0;
	multiDayInfo.clear();
	criteria.clear();
	groupReference.clear();
}

bool MTLobbyCli::publication::TournSubscr_Static::equals(const TournSubscr_Static& _o) const
{
	return tournamentId == _o.tournamentId &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		startingChips == _o.startingChips &&
		maxPlayers == _o.maxPlayers &&
		playersPerTable == _o.playersPerTable &&
		gameType == _o.gameType &&
		isHiLo == _o.isHiLo &&
		startingTime.equals(_o.startingTime) &&
		registrationStarts.equals(_o.registrationStarts) &&
		registrationEnds.equals(_o.registrationEnds) &&
		seatingStarts.equals(_o.seatingStarts) &&
		minPlayers == _o.minPlayers &&
		restricted == _o.restricted &&
		fppReward == _o.fppReward &&
		fppBuyIn == _o.fppBuyIn &&
		isRestricted == _o.isRestricted &&
		isPwdProtected == _o.isPwdProtected &&
		Atf::atfPStringEquals(name, _o.name) &&
		numRebuys == _o.numRebuys &&
		rebuyChips == _o.rebuyChips &&
		_obsolete_1 == _o._obsolete_1 &&
		rebuyMaxChips == _o.rebuyMaxChips &&
		numAddOns == _o.numAddOns &&
		addOnChips == _o.addOnChips &&
		_obsolete_2 == _o._obsolete_2 &&
		addOnMaxChips == _o.addOnMaxChips &&
		scriptPrizeAddOn == _o.scriptPrizeAddOn &&
		guaranteedPrizePool == _o.guaranteedPrizePool &&
		tournFlags == _o.tournFlags &&
		maxAllins == _o.maxAllins &&
		awardSchema == _o.awardSchema &&
		timeBank == _o.timeBank &&
		unregistrationEnds_t == _o.unregistrationEnds_t &&
		satelliteTarget == _o.satelliteTarget &&
		satelliteTargetBuyIn == _o.satelliteTargetBuyIn &&
		rebuyFppPrice == _o.rebuyFppPrice &&
		addOnFppPrice == _o.addOnFppPrice &&
		isPlayMoney == _o.isPlayMoney &&
		startingTime_t == _o.startingTime_t &&
		registrationStarts_t == _o.registrationStarts_t &&
		registrationEnds_t == _o.registrationEnds_t &&
		seatingStarts_t == _o.seatingStarts_t &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		tournProp2 == _o.tournProp2 &&
		ticketTypes.equals(_o.ticketTypes) &&
		tableLogo == _o.tableLogo &&
		finalTableText.equals(_o.finalTableText) &&
		chatLang == _o.chatLang &&
		lobbyRestricted == _o.lobbyRestricted &&
		fppFraction == _o.fppFraction &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		rebuyFppReward == _o.rebuyFppReward &&
		addOnFppReward == _o.addOnFppReward &&
		fppRewardPercent == _o.fppRewardPercent &&
		nPublishLobbyPlayersLess == _o.nPublishLobbyPlayersLess &&
		bounty == _o.bounty &&
		fallbackSatelliteTargets.equals(_o.fallbackSatelliteTargets) &&
		teamProBounties.equals(_o.teamProBounties) &&
		bountyMultipliers.equals(_o.bountyMultipliers) &&
		publPropFlag == _o.publPropFlag &&
		multiDayTournProps == _o.multiDayTournProps &&
		multiDayTournDayOneStopValue == _o.multiDayTournDayOneStopValue &&
		multiDayTournDayTwoStartMinutes == _o.multiDayTournDayTwoStartMinutes &&
		multiDayTournDayTwoStarts.equals(_o.multiDayTournDayTwoStarts) &&
		Atf::atfPStringEquals(satelliteTargetReference, _o.satelliteTargetReference) &&
		satelliteTargetReferenceLock == _o.satelliteTargetReferenceLock &&
		clubId == _o.clubId &&
		timedTournType == _o.timedTournType &&
		timedTournLevelsOrMinutes == _o.timedTournLevelsOrMinutes &&
		timedTournPayoutStructure == _o.timedTournPayoutStructure &&
		_obsolete_3 == _o._obsolete_3 &&
		fppRewards.equals(_o.fppRewards) &&
		speedDisplay == _o.speedDisplay &&
		Atf::atfPStringEquals(tournBrand, _o.tournBrand) &&
		scalePM == _o.scalePM &&
		blitzNormalDealingThreshold == _o.blitzNormalDealingThreshold &&
		_obsolete_4 == _o._obsolete_4 &&
		progressiveKnockout == _o.progressiveKnockout &&
		tableText.equals(_o.tableText) &&
		reEntryAllowed == _o.reEntryAllowed &&
		tournMask == _o.tournMask &&
		tournMask2 == _o.tournMask2 &&
		tournMask3 == _o.tournMask3 &&
		tournMask4 == _o.tournMask4 &&
		Atf::atfPStringEquals(internalReference, _o.internalReference) &&
		Atf::atfPStringEquals(favoriteReference, _o.favoriteReference) &&
		ticketPrice == _o.ticketPrice &&
		tournFlags2 == _o.tournFlags2 &&
		cannotUnregisterFromTarget == _o.cannotUnregisterFromTarget &&
		initialStacks == _o.initialStacks &&
		singleStackChips == _o.singleStackChips &&
		forceReloadAllStacksInLevel == _o.forceReloadAllStacksInLevel &&
		forceReloadAllStacksInMinutes == _o.forceReloadAllStacksInMinutes &&
		reloadStacksOnlyWhenEmpty == _o.reloadStacksOnlyWhenEmpty &&
		targetWhenStarts.equals(_o.targetWhenStarts) &&
		Atf::atfPStringEquals(admission, _o.admission) &&
		siteMask == _o.siteMask &&
		publStartLevel == _o.publStartLevel &&
		tournMask5 == _o.tournMask5 &&
		tournMask6 == _o.tournMask6 &&
		dealExclusionType == _o.dealExclusionType &&
		dealExclusionValue == _o.dealExclusionValue &&
		timedTournPlayersPercent == _o.timedTournPlayersPercent &&
		_obsolete_5 == _o._obsolete_5 &&
		spinGoStartDelay == _o.spinGoStartDelay &&
		rmPmLobby == _o.rmPmLobby &&
		brandMask == _o.brandMask &&
		playerKnockOutAddOn == _o.playerKnockOutAddOn &&
		totalKnockOutAddOn == _o.totalKnockOutAddOn &&
		knockOutAddOnProgressive == _o.knockOutAddOnProgressive &&
		sitGoStarterGameId == _o.sitGoStarterGameId &&
		numStandardButton == _o.numStandardButton &&
		lateRegDelta == _o.lateRegDelta &&
		finalTablePlusOne == _o.finalTablePlusOne &&
		multidayIndex == _o.multidayIndex &&
		multiDayInfo.equals(_o.multiDayInfo) &&
		Atf::atfPStringEquals(criteria, _o.criteria) &&
		Atf::atfPStringEquals(groupReference, _o.groupReference);
}

const char *MTLobbyCli::publication::TournSubscr_Static::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("startingChips=");
	_buf.appendUint(startingChips);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("playersPerTable=");
	_buf.appendUint(playersPerTable);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("startingTime=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, startingTime);
	_buf.append(',');
	_buf.append("registrationStarts=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, registrationStarts);
	_buf.append(',');
	_buf.append("registrationEnds=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, registrationEnds);
	_buf.append(',');
	_buf.append("seatingStarts=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, seatingStarts);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("restricted=");
	_buf.appendUint(restricted);
	_buf.append(',');
	_buf.append("fppReward=");
	_buf.appendUint(fppReward);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("isRestricted=");
	_buf.appendUint(isRestricted);
	_buf.append(',');
	_buf.append("isPwdProtected=");
	_buf.appendUint(isPwdProtected);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("numRebuys=");
	_buf.appendUint(numRebuys);
	_buf.append(',');
	_buf.append("rebuyChips=");
	_buf.appendUint(rebuyChips);
	_buf.append(',');
	_buf.append("_obsolete_1=");
	_buf.appendUint(_obsolete_1);
	_buf.append(',');
	_buf.append("rebuyMaxChips=");
	_buf.appendUint(rebuyMaxChips);
	_buf.append(',');
	_buf.append("numAddOns=");
	_buf.appendUint(numAddOns);
	_buf.append(',');
	_buf.append("addOnChips=");
	_buf.appendUint(addOnChips);
	_buf.append(',');
	_buf.append("_obsolete_2=");
	_buf.appendUint(_obsolete_2);
	_buf.append(',');
	_buf.append("addOnMaxChips=");
	_buf.appendUint(addOnMaxChips);
	_buf.append(',');
	_buf.append("scriptPrizeAddOn=");
	_buf.appendUint(scriptPrizeAddOn);
	_buf.append(',');
	_buf.append("guaranteedPrizePool=");
	_buf.appendUint(guaranteedPrizePool);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("maxAllins=");
	_buf.appendUint(maxAllins);
	_buf.append(',');
	_buf.append("awardSchema=");
	_buf.appendUint(awardSchema);
	_buf.append(',');
	_buf.append("timeBank=");
	_buf.appendUint(timeBank);
	_buf.append(',');
	_buf.append("unregistrationEnds_t=");
	_buf.appendUint(unregistrationEnds_t);
	_buf.append(',');
	_buf.append("satelliteTarget=");
	_buf.appendUint(satelliteTarget);
	_buf.append(',');
	_buf.append("satelliteTargetBuyIn=");
	_buf.appendUint(satelliteTargetBuyIn);
	_buf.append(',');
	_buf.append("rebuyFppPrice=");
	_buf.appendUint(rebuyFppPrice);
	_buf.append(',');
	_buf.append("addOnFppPrice=");
	_buf.appendUint(addOnFppPrice);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("startingTime_t=");
	_buf.appendUint(startingTime_t);
	_buf.append(',');
	_buf.append("registrationStarts_t=");
	_buf.appendUint(registrationStarts_t);
	_buf.append(',');
	_buf.append("registrationEnds_t=");
	_buf.appendUint(registrationEnds_t);
	_buf.append(',');
	_buf.append("seatingStarts_t=");
	_buf.appendUint(seatingStarts_t);
	_buf.append(',');
	_buf.append("tournFlagsServInt=");
	_buf.appendUint(tournFlagsServInt);
	_buf.append(',');
	_buf.append("tournProp2=");
	_buf.appendUint(tournProp2);
	_buf.append(',');
	_buf.append("ticketTypes=");
	ticketTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableLogo=");
	_buf.appendUint(tableLogo);
	_buf.append(',');
	_buf.append("finalTableText=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, finalTableText);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("lobbyRestricted=");
	_buf.appendUint(lobbyRestricted);
	_buf.append(',');
	_buf.append("fppFraction=");
	_buf.appendUint(fppFraction);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("rebuyFppReward=");
	_buf.appendUint(rebuyFppReward);
	_buf.append(',');
	_buf.append("addOnFppReward=");
	_buf.appendUint(addOnFppReward);
	_buf.append(',');
	_buf.append("fppRewardPercent=");
	_buf.appendUint(fppRewardPercent);
	_buf.append(',');
	_buf.append("nPublishLobbyPlayersLess=");
	_buf.appendUint(nPublishLobbyPlayersLess);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendUint(bounty);
	_buf.append(',');
	_buf.append("fallbackSatelliteTargets=");
	fallbackSatelliteTargets.toTraceString(_buf);
	_buf.append(',');
	_buf.append("teamProBounties=");
	teamProBounties.toTraceString(_buf);
	_buf.append(',');
	_buf.append("bountyMultipliers=");
	bountyMultipliers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("publPropFlag=");
	_buf.appendUint(publPropFlag);
	_buf.append(',');
	_buf.append("multiDayTournProps=");
	_buf.appendUint(multiDayTournProps);
	_buf.append(',');
	_buf.append("multiDayTournDayOneStopValue=");
	_buf.appendUint(multiDayTournDayOneStopValue);
	_buf.append(',');
	_buf.append("multiDayTournDayTwoStartMinutes=");
	_buf.appendUint(multiDayTournDayTwoStartMinutes);
	_buf.append(',');
	_buf.append("multiDayTournDayTwoStarts=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, multiDayTournDayTwoStarts);
	_buf.append(',');
	_buf.append("satelliteTargetReference=");
	_buf.append(satelliteTargetReference);
	_buf.append(',');
	_buf.append("satelliteTargetReferenceLock=");
	_buf.appendUint(satelliteTargetReferenceLock);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("timedTournType=");
	_buf.appendUint(timedTournType);
	_buf.append(',');
	_buf.append("timedTournLevelsOrMinutes=");
	_buf.appendUint(timedTournLevelsOrMinutes);
	_buf.append(',');
	_buf.append("timedTournPayoutStructure=");
	_buf.appendUint(timedTournPayoutStructure);
	_buf.append(',');
	_buf.append("_obsolete_3=");
	_buf.appendUint(_obsolete_3);
	_buf.append(',');
	_buf.append("fppRewards=");
	fppRewards.toTraceString(_buf);
	_buf.append(',');
	_buf.append("speedDisplay=");
	_buf.appendUint(speedDisplay);
	_buf.append(',');
	_buf.append("tournBrand=");
	_buf.append(tournBrand);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("blitzNormalDealingThreshold=");
	_buf.appendUint(blitzNormalDealingThreshold);
	_buf.append(',');
	_buf.append("_obsolete_4=");
	_buf.appendUint(_obsolete_4);
	_buf.append(',');
	_buf.append("progressiveKnockout=");
	_buf.appendUint(progressiveKnockout);
	_buf.append(',');
	_buf.append("tableText=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, tableText);
	_buf.append(',');
	_buf.append("reEntryAllowed=");
	_buf.appendUint(reEntryAllowed);
	_buf.append(',');
	_buf.append("tournMask=");
	_buf.appendUint(tournMask);
	_buf.append(',');
	_buf.append("tournMask2=");
	_buf.appendUint(tournMask2);
	_buf.append(',');
	_buf.append("tournMask3=");
	_buf.appendUint(tournMask3);
	_buf.append(',');
	_buf.append("tournMask4=");
	_buf.appendUint(tournMask4);
	_buf.append(',');
	_buf.append("internalReference=");
	_buf.append(internalReference);
	_buf.append(',');
	_buf.append("favoriteReference=");
	_buf.append(favoriteReference);
	_buf.append(',');
	_buf.append("ticketPrice=");
	_buf.appendInt64(ticketPrice);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append(',');
	_buf.append("cannotUnregisterFromTarget=");
	_buf.appendUint(cannotUnregisterFromTarget);
	_buf.append(',');
	_buf.append("initialStacks=");
	_buf.appendUint(initialStacks);
	_buf.append(',');
	_buf.append("singleStackChips=");
	_buf.appendUint(singleStackChips);
	_buf.append(',');
	_buf.append("forceReloadAllStacksInLevel=");
	_buf.appendUint(forceReloadAllStacksInLevel);
	_buf.append(',');
	_buf.append("forceReloadAllStacksInMinutes=");
	_buf.appendUint(forceReloadAllStacksInMinutes);
	_buf.append(',');
	_buf.append("reloadStacksOnlyWhenEmpty=");
	_buf.appendUint(reloadStacksOnlyWhenEmpty);
	_buf.append(',');
	_buf.append("targetWhenStarts=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, targetWhenStarts);
	_buf.append(',');
	_buf.append("admission=");
	_buf.append(admission);
	_buf.append(',');
	_buf.append("siteMask=");
	_buf.appendUint(siteMask);
	_buf.append(',');
	_buf.append("publStartLevel=");
	_buf.appendUint(publStartLevel);
	_buf.append(',');
	_buf.append("tournMask5=");
	_buf.appendUint(tournMask5);
	_buf.append(',');
	_buf.append("tournMask6=");
	_buf.appendUint(tournMask6);
	_buf.append(',');
	_buf.append("dealExclusionType=");
	_buf.appendUint(dealExclusionType);
	_buf.append(',');
	_buf.append("dealExclusionValue=");
	_buf.appendUint(dealExclusionValue);
	_buf.append(',');
	_buf.append("timedTournPlayersPercent=");
	_buf.appendUint(timedTournPlayersPercent);
	_buf.append(',');
	_buf.append("_obsolete_5=");
	_buf.appendUint(_obsolete_5);
	_buf.append(',');
	_buf.append("spinGoStartDelay=");
	_buf.appendUint(spinGoStartDelay);
	_buf.append(',');
	_buf.append("rmPmLobby=");
	_buf.appendUint(rmPmLobby);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("playerKnockOutAddOn=");
	_buf.appendUint(playerKnockOutAddOn);
	_buf.append(',');
	_buf.append("totalKnockOutAddOn=");
	_buf.appendUint(totalKnockOutAddOn);
	_buf.append(',');
	_buf.append("knockOutAddOnProgressive=");
	_buf.appendUint(knockOutAddOnProgressive);
	_buf.append(',');
	_buf.append("sitGoStarterGameId=");
	_buf.appendUint(sitGoStarterGameId);
	_buf.append(',');
	_buf.append("numStandardButton=");
	_buf.appendUint(numStandardButton);
	_buf.append(',');
	_buf.append("lateRegDelta=");
	_buf.appendInt(lateRegDelta);
	_buf.append(',');
	_buf.append("finalTablePlusOne=");
	_buf.appendInt(finalTablePlusOne);
	_buf.append(',');
	_buf.append("multidayIndex=");
	_buf.appendUint(multidayIndex);
	_buf.append(',');
	_buf.append("multiDayInfo=");
	multiDayInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	_buf.append(criteria);
	_buf.append(',');
	_buf.append("groupReference=");
	_buf.append(groupReference);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournSubscr_Static::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournamentId", tournamentId, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("startingChips", startingChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("playersPerTable", playersPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "startingTime", startingTime);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "registrationStarts", registrationStarts);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "registrationEnds", registrationEnds);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "seatingStarts", seatingStarts);
	Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("restricted", restricted, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppReward", fppReward, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBuyIn", fppBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("isRestricted", isRestricted, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPwdProtected", isPwdProtected, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("numRebuys", numRebuys, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuyChips", rebuyChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("_obsolete_1", _obsolete_1, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuyMaxChips", rebuyMaxChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("numAddOns", numAddOns, _buf);
	Atf::XmlElement::encodeAsXmlElement("addOnChips", addOnChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("_obsolete_2", _obsolete_2, _buf);
	Atf::XmlElement::encodeAsXmlElement("addOnMaxChips", addOnMaxChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("scriptPrizeAddOn", scriptPrizeAddOn, _buf);
	Atf::XmlElement::encodeAsXmlElement("guaranteedPrizePool", guaranteedPrizePool, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxAllins", maxAllins, _buf);
	Atf::XmlElement::encodeAsXmlElement("awardSchema", awardSchema, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeBank", timeBank, _buf);
	Atf::XmlElement::encodeAsXmlElement("unregistrationEnds_t", unregistrationEnds_t, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTarget", satelliteTarget, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTargetBuyIn", satelliteTargetBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuyFppPrice", rebuyFppPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("addOnFppPrice", addOnFppPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("startingTime_t", startingTime_t, _buf);
	Atf::XmlElement::encodeAsXmlElement("registrationStarts_t", registrationStarts_t, _buf);
	Atf::XmlElement::encodeAsXmlElement("registrationEnds_t", registrationEnds_t, _buf);
	Atf::XmlElement::encodeAsXmlElement("seatingStarts_t", seatingStarts_t, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlagsServInt", tournFlagsServInt, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournProp2", tournProp2, _buf);
	ticketTypes.toXmlString("ticketTypes", _buf);
	Atf::XmlElement::encodeAsXmlElement("tableLogo", tableLogo, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "finalTableText", finalTableText);
	Atf::XmlElement::encodeAsXmlElement("chatLang", chatLang, _buf);
	Atf::XmlElement::encodeAsXmlElement("lobbyRestricted", lobbyRestricted, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppFraction", fppFraction, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuyFppReward", rebuyFppReward, _buf);
	Atf::XmlElement::encodeAsXmlElement("addOnFppReward", addOnFppReward, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppRewardPercent", fppRewardPercent, _buf);
	Atf::XmlElement::encodeAsXmlElement("nPublishLobbyPlayersLess", nPublishLobbyPlayersLess, _buf);
	Atf::XmlElement::encodeAsXmlElement("bounty", bounty, _buf);
	fallbackSatelliteTargets.toXmlString("fallbackSatelliteTargets", _buf);
	teamProBounties.toXmlString("teamProBounties", _buf);
	bountyMultipliers.toXmlString("bountyMultipliers", _buf);
	Atf::XmlElement::encodeAsXmlElement("publPropFlag", publPropFlag, _buf);
	Atf::XmlElement::encodeAsXmlElement("multiDayTournProps", multiDayTournProps, _buf);
	Atf::XmlElement::encodeAsXmlElement("multiDayTournDayOneStopValue", multiDayTournDayOneStopValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("multiDayTournDayTwoStartMinutes", multiDayTournDayTwoStartMinutes, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "multiDayTournDayTwoStarts", multiDayTournDayTwoStarts);
	Atf::XmlElement::encodeAsXmlElement("satelliteTargetReference", satelliteTargetReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTargetReferenceLock", satelliteTargetReferenceLock, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournType", timedTournType, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournLevelsOrMinutes", timedTournLevelsOrMinutes, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournPayoutStructure", timedTournPayoutStructure, _buf);
	Atf::XmlElement::encodeAsXmlElement("_obsolete_3", _obsolete_3, _buf);
	fppRewards.toXmlString("fppRewards", _buf);
	Atf::XmlElement::encodeAsXmlElement("speedDisplay", speedDisplay, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournBrand", tournBrand, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("blitzNormalDealingThreshold", blitzNormalDealingThreshold, _buf);
	Atf::XmlElement::encodeAsXmlElement("_obsolete_4", _obsolete_4, _buf);
	Atf::XmlElement::encodeAsXmlElement("progressiveKnockout", progressiveKnockout, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "tableText", tableText);
	Atf::XmlElement::encodeAsXmlElement("reEntryAllowed", reEntryAllowed, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask", tournMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask2", tournMask2, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask3", tournMask3, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask4", tournMask4, _buf);
	Atf::XmlElement::encodeAsXmlElement("internalReference", internalReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("favoriteReference", favoriteReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketPrice", ticketPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("cannotUnregisterFromTarget", cannotUnregisterFromTarget, _buf);
	Atf::XmlElement::encodeAsXmlElement("initialStacks", initialStacks, _buf);
	Atf::XmlElement::encodeAsXmlElement("singleStackChips", singleStackChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("forceReloadAllStacksInLevel", forceReloadAllStacksInLevel, _buf);
	Atf::XmlElement::encodeAsXmlElement("forceReloadAllStacksInMinutes", forceReloadAllStacksInMinutes, _buf);
	Atf::XmlElement::encodeAsXmlElement("reloadStacksOnlyWhenEmpty", reloadStacksOnlyWhenEmpty, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "targetWhenStarts", targetWhenStarts);
	Atf::XmlElement::encodeAsXmlElement("admission", admission, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteMask", siteMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("publStartLevel", publStartLevel, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask5", tournMask5, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask6", tournMask6, _buf);
	Atf::XmlElement::encodeAsXmlElement("dealExclusionType", dealExclusionType, _buf);
	Atf::XmlElement::encodeAsXmlElement("dealExclusionValue", dealExclusionValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournPlayersPercent", timedTournPlayersPercent, _buf);
	Atf::XmlElement::encodeAsXmlElement("_obsolete_5", _obsolete_5, _buf);
	Atf::XmlElement::encodeAsXmlElement("spinGoStartDelay", spinGoStartDelay, _buf);
	Atf::XmlElement::encodeAsXmlElement("rmPmLobby", rmPmLobby, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandMask", brandMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerKnockOutAddOn", playerKnockOutAddOn, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalKnockOutAddOn", totalKnockOutAddOn, _buf);
	Atf::XmlElement::encodeAsXmlElement("knockOutAddOnProgressive", knockOutAddOnProgressive, _buf);
	Atf::XmlElement::encodeAsXmlElement("sitGoStarterGameId", sitGoStarterGameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("numStandardButton", numStandardButton, _buf);
	Atf::XmlElement::encodeAsXmlElement("lateRegDelta", lateRegDelta, _buf);
	Atf::XmlElement::encodeAsXmlElement("finalTablePlusOne", finalTablePlusOne, _buf);
	Atf::XmlElement::encodeAsXmlElement("multidayIndex", multidayIndex, _buf);
	multiDayInfo.toXmlString("multiDayInfo", _buf);
	Atf::XmlElement::encodeAsXmlElement("criteria", criteria, _buf);
	Atf::XmlElement::encodeAsXmlElement("groupReference", groupReference, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournSubscr_Static::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		switch((BYTE)*_element)
		{
		case '_':
			if (_element.equals("_obsolete_1"))
			{
				_obsolete_1 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("_obsolete_2"))
			{
				_obsolete_2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("_obsolete_3"))
			{
				_obsolete_3 = (*_value.ptr() == '1');
			}
			else if (_element.equals("_obsolete_4"))
			{
				_obsolete_4 = (*_value.ptr() == '1');
			}
			else if (_element.equals("_obsolete_5"))
			{
				_obsolete_5 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'a':
			if (_element.equals("addOnChips"))
			{
				addOnChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("addOnMaxChips"))
			{
				addOnMaxChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("awardSchema"))
			{
				awardSchema = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("addOnFppPrice"))
			{
				addOnFppPrice = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("addOnFppReward"))
			{
				addOnFppReward = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("admission"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, admission)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'b':
			if (_element.equals("buyIn"))
			{
				buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bounty"))
			{
				bounty = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bountyMultipliers"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32 , 4 > >::FromXmlString(_value, bountyMultipliers)) return false;
			}
			else if (_element.equals("blitzNormalDealingThreshold"))
			{
				blitzNormalDealingThreshold = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("brandMask"))
			{
				brandMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'c':
			if (_element.equals("chatLang"))
			{
				chatLang = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cannotUnregisterFromTarget"))
			{
				cannotUnregisterFromTarget = (*_value.ptr() == '1');
			}
			else if (_element.equals("criteria"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, criteria)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'd':
			if (_element.equals("dealExclusionType"))
			{
				dealExclusionType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("dealExclusionValue"))
			{
				dealExclusionValue = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'f':
			if (_element.equals("fppReward"))
			{
				fppReward = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppBuyIn"))
			{
				fppBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("finalTableText"))
			{
				Atf::AtfTempl<I18nPString>::FromXmlString(_value, finalTableText);
			}
			else if (_element.equals("fppFraction"))
			{
				fppFraction = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppRewardPercent"))
			{
				fppRewardPercent = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fallbackSatelliteTargets"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32 , 4 > >::FromXmlString(_value, fallbackSatelliteTargets)) return false;
			}
			else if (_element.equals("fppRewards"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< P_FppReward , 4 > >::FromXmlString(_value, fppRewards)) return false;
			}
			else if (_element.equals("favoriteReference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, favoriteReference)) return false;
			}
			else if (_element.equals("forceReloadAllStacksInLevel"))
			{
				forceReloadAllStacksInLevel = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("forceReloadAllStacksInMinutes"))
			{
				forceReloadAllStacksInMinutes = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("finalTablePlusOne"))
			{
				finalTablePlusOne = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'g':
			if (_element.equals("gameType"))
			{
				gameType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("guaranteedPrizePool"))
			{
				guaranteedPrizePool = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("groupReference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, groupReference)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'i':
			if (_element.equals("isHiLo"))
			{
				isHiLo = (*_value.ptr() == '1');
			}
			else if (_element.equals("isRestricted"))
			{
				isRestricted = (*_value.ptr() == '1');
			}
			else if (_element.equals("isPwdProtected"))
			{
				isPwdProtected = (*_value.ptr() == '1');
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (*_value.ptr() == '1');
			}
			else if (_element.equals("internalReference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, internalReference)) return false;
			}
			else if (_element.equals("initialStacks"))
			{
				initialStacks = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'k':
			if (_element.equals("knockOutAddOnProgressive"))
			{
				knockOutAddOnProgressive = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'l':
			if (_element.equals("lobbyRestricted"))
			{
				lobbyRestricted = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("lateRegDelta"))
			{
				lateRegDelta = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'm':
			if (_element.equals("maxPlayers"))
			{
				maxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minPlayers"))
			{
				minPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxAllins"))
			{
				maxAllins = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("multiDayTournProps"))
			{
				multiDayTournProps = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("multiDayTournDayOneStopValue"))
			{
				multiDayTournDayOneStopValue = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("multiDayTournDayTwoStartMinutes"))
			{
				multiDayTournDayTwoStartMinutes = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("multiDayTournDayTwoStarts"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, multiDayTournDayTwoStarts);
			}
			else if (_element.equals("multidayIndex"))
			{
				multidayIndex = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("multiDayInfo"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< P_MultiDayInfo , 4 > >::FromXmlString(_value, multiDayInfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'n':
			if (_element.equals("name"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
			}
			else if (_element.equals("numRebuys"))
			{
				numRebuys = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numAddOns"))
			{
				numAddOns = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("nPublishLobbyPlayersLess"))
			{
				nPublishLobbyPlayersLess = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numStandardButton"))
			{
				numStandardButton = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'p':
			if (_element.equals("playersPerTable"))
			{
				playersPerTable = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("publPropFlag"))
			{
				publPropFlag = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("progressiveKnockout"))
			{
				progressiveKnockout = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("publStartLevel"))
			{
				publStartLevel = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playerKnockOutAddOn"))
			{
				playerKnockOutAddOn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'r':
			if (_element.equals("rake"))
			{
				rake = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("registrationStarts"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, registrationStarts);
			}
			else if (_element.equals("registrationEnds"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, registrationEnds);
			}
			else if (_element.equals("restricted"))
			{
				restricted = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuyChips"))
			{
				rebuyChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuyMaxChips"))
			{
				rebuyMaxChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuyFppPrice"))
			{
				rebuyFppPrice = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("registrationStarts_t"))
			{
				registrationStarts_t = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("registrationEnds_t"))
			{
				registrationEnds_t = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuyFppReward"))
			{
				rebuyFppReward = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("reEntryAllowed"))
			{
				reEntryAllowed = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("reloadStacksOnlyWhenEmpty"))
			{
				reloadStacksOnlyWhenEmpty = (*_value.ptr() == '1');
			}
			else if (_element.equals("rmPmLobby"))
			{
				rmPmLobby = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 's':
			if (_element.equals("startingChips"))
			{
				startingChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("startingTime"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, startingTime);
			}
			else if (_element.equals("seatingStarts"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, seatingStarts);
			}
			else if (_element.equals("scriptPrizeAddOn"))
			{
				scriptPrizeAddOn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("satelliteTarget"))
			{
				satelliteTarget = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("satelliteTargetBuyIn"))
			{
				satelliteTargetBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("startingTime_t"))
			{
				startingTime_t = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seatingStarts_t"))
			{
				seatingStarts_t = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("satelliteTargetReference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, satelliteTargetReference)) return false;
			}
			else if (_element.equals("satelliteTargetReferenceLock"))
			{
				satelliteTargetReferenceLock = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("speedDisplay"))
			{
				speedDisplay = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("scalePM"))
			{
				scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("singleStackChips"))
			{
				singleStackChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("siteMask"))
			{
				siteMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("spinGoStartDelay"))
			{
				spinGoStartDelay = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sitGoStarterGameId"))
			{
				sitGoStarterGameId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 't':
			if (_element.equals("tournamentId"))
			{
				tournamentId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlags"))
			{
				tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timeBank"))
			{
				timeBank = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlagsServInt"))
			{
				tournFlagsServInt = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournProp2"))
			{
				tournProp2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ticketTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< P_TicketType , 4 > >::FromXmlString(_value, ticketTypes)) return false;
			}
			else if (_element.equals("tableLogo"))
			{
				tableLogo = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("teamProBounties"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32 , 4 > >::FromXmlString(_value, teamProBounties)) return false;
			}
			else if (_element.equals("timedTournType"))
			{
				timedTournType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timedTournLevelsOrMinutes"))
			{
				timedTournLevelsOrMinutes = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timedTournPayoutStructure"))
			{
				timedTournPayoutStructure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournBrand"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournBrand)) return false;
			}
			else if (_element.equals("tableText"))
			{
				Atf::AtfTempl<I18nPString>::FromXmlString(_value, tableText);
			}
			else if (_element.equals("tournMask"))
			{
				tournMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask2"))
			{
				tournMask2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask3"))
			{
				tournMask3 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask4"))
			{
				tournMask4 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ticketPrice"))
			{
				ticketPrice = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlags2"))
			{
				tournFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("targetWhenStarts"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, targetWhenStarts);
			}
			else if (_element.equals("tournMask5"))
			{
				tournMask5 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask6"))
			{
				tournMask6 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timedTournPlayersPercent"))
			{
				timedTournPlayersPercent = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("totalKnockOutAddOn"))
			{
				totalKnockOutAddOn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'u':
			if (_element.equals("unregistrationEnds_t"))
			{
				unregistrationEnds_t = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		default:
			return false;
		}
	}
	return true;
}

void MTLobbyCli::publication::TournSubscr_Static::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournamentId);
	_msg.composeUINT32(buyIn);
	_msg.composeUINT32(rake);
	_msg.composeUINT32(startingChips);
	_msg.composeUINT32(maxPlayers);
	_msg.composeUINT32(playersPerTable);
	_msg.composeBYTE(gameType);
	_msg.composeBOOL(isHiLo);
	_msg.composeSrvTime(startingTime);
	_msg.composeSrvTime(registrationStarts);
	_msg.composeSrvTime(registrationEnds);
	_msg.composeSrvTime(seatingStarts);
	_msg.composeUINT32(minPlayers);
	_msg.composeBYTE(restricted);
	_msg.composeUINT32(fppReward);
	_msg.composeUINT32(fppBuyIn);
	_msg.composeBOOL(isRestricted);
	_msg.composeBOOL(isPwdProtected);
	_msg.composeString(name);
	_msg.composeUINT32(numRebuys);
	_msg.composeUINT32(rebuyChips);
	_msg.composeUINT32(_obsolete_1);
	_msg.composeUINT32(rebuyMaxChips);
	_msg.composeUINT32(numAddOns);
	_msg.composeUINT32(addOnChips);
	_msg.composeUINT32(_obsolete_2);
	_msg.composeUINT32(addOnMaxChips);
	_msg.composeUINT32(scriptPrizeAddOn);
	_msg.composeUINT32(guaranteedPrizePool);
	_msg.composeUINT32(tournFlags);
	_msg.composeUINT16(maxAllins);
	_msg.composeBYTE(awardSchema);
	_msg.composeUINT32(timeBank);
	_msg.composeUINT32(unregistrationEnds_t);
	_msg.composeUINT32(satelliteTarget);
	_msg.composeUINT32(satelliteTargetBuyIn);
	_msg.composeUINT32(rebuyFppPrice);
	_msg.composeUINT32(addOnFppPrice);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeUINT32(startingTime_t);
	_msg.composeUINT32(registrationStarts_t);
	_msg.composeUINT32(registrationEnds_t);
	_msg.composeUINT32(seatingStarts_t);
	_msg.composeUINT32(tournFlagsServInt);
	_msg.composeUINT32(tournProp2);
	ticketTypes.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(tableLogo);
	finalTableText.compose(_msg);
	_msg.composeUINT16(chatLang);
	_msg.composeUINT32(lobbyRestricted);
	_msg.composeUINT32(fppFraction);
	_msg.composeString(currency);
	_msg.composeUINT32(rebuyFppReward);
	_msg.composeUINT32(addOnFppReward);
	_msg.composeBYTE(fppRewardPercent);
	_msg.composeUINT32(nPublishLobbyPlayersLess);
	_msg.composeUINT32(bounty);
	fallbackSatelliteTargets.composeMsg(_msg, _ignoreJSON);
	CommMsgBody _msg0;
	teamProBounties.composeMsg(_msg0, _ignoreJSON);
	bountyMultipliers.composeMsg(_msg0, _ignoreJSON);
	_msg.composeMsgBody(_msg0);
	_msg.composeBYTE(publPropFlag);
	_msg.composeUINT32(multiDayTournProps);
	_msg.composeUINT32(multiDayTournDayOneStopValue);
	_msg.composeUINT32(multiDayTournDayTwoStartMinutes);
	_msg.composeSrvTime(multiDayTournDayTwoStarts);
	_msg.composeString(satelliteTargetReference);
	_msg.composeUINT16(satelliteTargetReferenceLock);
	_msg.composeUINT32(clubId);
	_msg.composeBYTE(timedTournType);
	_msg.composeUINT16(timedTournLevelsOrMinutes);
	_msg.composeBYTE(timedTournPayoutStructure);
	_msg.composeBOOL(_obsolete_3);
	fppRewards.composeMsg(_msg, _ignoreJSON);
	_msg.composeBYTE(speedDisplay);
	_msg.composeString(tournBrand);
	_msg.composeUINT32(scalePM);
	_msg.composeUINT32(blitzNormalDealingThreshold);
	_msg.composeBOOL(_obsolete_4);
	_msg.composeBYTE(progressiveKnockout);
	tableText.compose(_msg);
	_msg.composeUINT16(reEntryAllowed);
	_msg.composeUINT32(tournMask);
	_msg.composeUINT32(tournMask2);
	_msg.composeUINT32(tournMask3);
	_msg.composeUINT32(tournMask4);
	_msg.composeString(internalReference);
	_msg.composeString(favoriteReference);
	_msg.composeINT64(ticketPrice);
	_msg.composeUINT64(tournFlags2);
	_msg.composeBOOL(cannotUnregisterFromTarget);
	CommMsgBody _msg1;
	_msg1.composeUINT32(initialStacks);
	_msg1.composeUINT32(singleStackChips);
	_msg1.composeUINT32(forceReloadAllStacksInLevel);
	_msg1.composeUINT32(forceReloadAllStacksInMinutes);
	_msg1.composeBOOL(reloadStacksOnlyWhenEmpty);
	_msg.composeMsgBody(_msg1);
	_msg.composeSrvTime(targetWhenStarts);
	_msg.composeString(admission);
	_msg.composeUINT32(siteMask);
	_msg.composeUINT32(publStartLevel);
	_msg.composeUINT32(tournMask5);
	_msg.composeUINT32(tournMask6);
	_msg.composeBYTE(dealExclusionType);
	_msg.composeUINT32(dealExclusionValue);
	_msg.composeBYTE(timedTournPlayersPercent);
	_msg.composeUINT32(_obsolete_5);
	_msg.composeUINT32(spinGoStartDelay);
	_msg.composeBYTE(rmPmLobby);
	_msg.composeUINT32(brandMask);
	_msg.composeUINT32(playerKnockOutAddOn);
	_msg.composeUINT32(totalKnockOutAddOn);
	_msg.composeBYTE(knockOutAddOnProgressive);
	_msg.composeUINT32(sitGoStarterGameId);
	_msg.composeUINT32(numStandardButton);
	_msg.composeINT32(lateRegDelta);
	_msg.composeINT32(finalTablePlusOne);
	_msg.composeUINT32(multidayIndex);
	multiDayInfo.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(criteria);
	_msg.composeString(groupReference);
}

void MTLobbyCli::publication::TournSubscr_Static::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournamentId);
	_parser.parseUINT32(buyIn);
	_parser.parseUINT32(rake);
	_parser.parseUINT32(startingChips);
	_parser.parseUINT32(maxPlayers);
	_parser.parseUINT32(playersPerTable);
	_parser.parseBYTE(gameType);
	_parser.parseBOOL(isHiLo);
	_parser.parseSrvTime(startingTime);
	_parser.parseSrvTime(registrationStarts);
	_parser.parseSrvTime(registrationEnds);
	_parser.parseSrvTime(seatingStarts);
	_parser.parseUINT32(minPlayers);
	_parser.parseBYTE(restricted);
	_parser.parseUINT32(fppReward);
	_parser.parseUINT32(fppBuyIn);
	_parser.parseBOOL(isRestricted);
	_parser.parseBOOL(isPwdProtected);
	_parser.parseStringP(name);
	_parser.parseUINT32(numRebuys);
	_parser.parseUINT32(rebuyChips);
	_parser.parseUINT32(_obsolete_1);
	_parser.parseUINT32(rebuyMaxChips);
	_parser.parseUINT32(numAddOns);
	_parser.parseUINT32(addOnChips);
	_parser.parseUINT32(_obsolete_2);
	_parser.parseUINT32(addOnMaxChips);
	_parser.parseUINT32(scriptPrizeAddOn);
	_parser.parseUINT32(guaranteedPrizePool);
	_parser.parseUINT32(tournFlags);
	_parser.parseUINT16(maxAllins);
	_parser.parseBYTE(awardSchema);
	_parser.parseUINT32(timeBank);
	_parser.parseUINT32(unregistrationEnds_t);
	_parser.parseUINT32(satelliteTarget);
	_parser.parseUINT32(satelliteTargetBuyIn);
	_parser.parseUINT32(rebuyFppPrice);
	_parser.parseUINT32(addOnFppPrice);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseUINT32(startingTime_t);
	_parser.parseUINT32(registrationStarts_t);
	_parser.parseUINT32(registrationEnds_t);
	_parser.parseUINT32(seatingStarts_t);
	_parser.parseUINT32(tournFlagsServInt);
	_parser.parseUINT32(tournProp2);
	ticketTypes.parseMsg(_parser);
	_parser.parseUINT32(tableLogo);
	finalTableText.parse(_parser);
	_parser.parseUINT16(chatLang);
	_parser.parseUINT32(lobbyRestricted);
	_parser.parseUINT32(fppFraction);
	_parser.parseStringP(currency);
	_parser.parseUINT32(rebuyFppReward);
	_parser.parseUINT32(addOnFppReward);
	_parser.parseBYTE(fppRewardPercent);
	_parser.parseUINT32(nPublishLobbyPlayersLess);
	_parser.parseUINT32(bounty);
	fallbackSatelliteTargets.parseMsg(_parser);
	parseAnonymousMsgBody0(_parser);
	_parser.parseBYTE(publPropFlag);
	_parser.parseUINT32(multiDayTournProps);
	_parser.parseUINT32(multiDayTournDayOneStopValue);
	_parser.parseUINT32(multiDayTournDayTwoStartMinutes);
	_parser.parseSrvTime(multiDayTournDayTwoStarts);
	_parser.parseStringP(satelliteTargetReference);
	_parser.parseUINT16(satelliteTargetReferenceLock);
	_parser.parseUINT32(clubId);
	_parser.parseBYTE(timedTournType);
	_parser.parseUINT16(timedTournLevelsOrMinutes);
	_parser.parseBYTE(timedTournPayoutStructure);
	_parser.parseBOOL(_obsolete_3);
	fppRewards.parseMsg(_parser);
	_parser.parseBYTE(speedDisplay);
	_parser.parseStringP(tournBrand);
	_parser.parseUINT32(scalePM);
	_parser.parseUINT32(blitzNormalDealingThreshold);
	_parser.parseBOOL(_obsolete_4);
	_parser.parseBYTE(progressiveKnockout);
	tableText.parse(_parser);
	_parser.parseUINT16(reEntryAllowed);
	_parser.parseUINT32(tournMask);
	_parser.parseUINT32(tournMask2);
	_parser.parseUINT32(tournMask3);
	_parser.parseUINT32(tournMask4);
	_parser.parseStringP(internalReference);
	_parser.parseStringP(favoriteReference);
	_parser.parseINT64(ticketPrice);
	_parser.parseUINT64(tournFlags2);
	_parser.parseBOOL(cannotUnregisterFromTarget);
	parseAnonymousMsgBody1(_parser);
	_parser.parseSrvTime(targetWhenStarts);
	_parser.parseStringP(admission);
	_parser.parseUINT32(siteMask);
	_parser.parseUINT32(publStartLevel);
	_parser.parseUINT32(tournMask5);
	_parser.parseUINT32(tournMask6);
	_parser.parseBYTE(dealExclusionType);
	_parser.parseUINT32(dealExclusionValue);
	_parser.parseBYTE(timedTournPlayersPercent);
	_parser.parseUINT32(_obsolete_5);
	_parser.parseUINT32(spinGoStartDelay);
	_parser.parseBYTE(rmPmLobby);
	_parser.parseUINT32(brandMask);
	_parser.parseUINT32(playerKnockOutAddOn);
	_parser.parseUINT32(totalKnockOutAddOn);
	_parser.parseBYTE(knockOutAddOnProgressive);
	_parser.parseUINT32(sitGoStarterGameId);
	_parser.parseUINT32(numStandardButton);
	_parser.parseINT32(lateRegDelta);
	_parser.parseINT32(finalTablePlusOne);
	_parser.parseUINT32(multidayIndex);
	multiDayInfo.parseMsg(_parser);
	_parser.parseStringP(criteria);
	_parser.parseStringP(groupReference);
}

const char *MTLobbyCli::publication::TournSubscr_Static::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournamentId", tournamentId);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("startingChips", startingChips);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("playersPerTable", playersPerTable);
	_jsonstr.compose("gameType", gameType);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("startingTime", startingTime);
	_jsonstr.compose("registrationStarts", registrationStarts);
	_jsonstr.compose("registrationEnds", registrationEnds);
	_jsonstr.compose("seatingStarts", seatingStarts);
	_jsonstr.compose("minPlayers", minPlayers);
	_jsonstr.compose("restricted", restricted);
	_jsonstr.compose("fppReward", fppReward);
	_jsonstr.compose("fppBuyIn", fppBuyIn);
	_jsonstr.compose("isRestricted", isRestricted);
	_jsonstr.compose("isPwdProtected", isPwdProtected);
	_jsonstr.compose("name", name);
	_jsonstr.compose("numRebuys", numRebuys);
	_jsonstr.compose("rebuyChips", rebuyChips);
	_jsonstr.compose("_obsolete_1", _obsolete_1);
	_jsonstr.compose("rebuyMaxChips", rebuyMaxChips);
	_jsonstr.compose("numAddOns", numAddOns);
	_jsonstr.compose("addOnChips", addOnChips);
	_jsonstr.compose("_obsolete_2", _obsolete_2);
	_jsonstr.compose("addOnMaxChips", addOnMaxChips);
	_jsonstr.compose("scriptPrizeAddOn", scriptPrizeAddOn);
	_jsonstr.compose("guaranteedPrizePool", guaranteedPrizePool);
	_jsonstr.compose("tournFlags", tournFlags);
	_jsonstr.compose("maxAllins", maxAllins);
	_jsonstr.compose("awardSchema", awardSchema);
	_jsonstr.compose("timeBank", timeBank);
	_jsonstr.compose("unregistrationEnds_t", unregistrationEnds_t);
	_jsonstr.compose("satelliteTarget", satelliteTarget);
	_jsonstr.compose("satelliteTargetBuyIn", satelliteTargetBuyIn);
	_jsonstr.compose("rebuyFppPrice", rebuyFppPrice);
	_jsonstr.compose("addOnFppPrice", addOnFppPrice);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("startingTime_t", startingTime_t);
	_jsonstr.compose("registrationStarts_t", registrationStarts_t);
	_jsonstr.compose("registrationEnds_t", registrationEnds_t);
	_jsonstr.compose("seatingStarts_t", seatingStarts_t);
	_jsonstr.compose("tournFlagsServInt", tournFlagsServInt);
	_jsonstr.compose("tournProp2", tournProp2);
	_jsonstr.compose("ticketTypes", ticketTypes);
	_jsonstr.compose("tableLogo", tableLogo);
	_jsonstr.compose("finalTableText", finalTableText);
	_jsonstr.compose("chatLang", chatLang);
	_jsonstr.compose("lobbyRestricted", lobbyRestricted);
	_jsonstr.compose("fppFraction", fppFraction);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("rebuyFppReward", rebuyFppReward);
	_jsonstr.compose("addOnFppReward", addOnFppReward);
	_jsonstr.compose("fppRewardPercent", fppRewardPercent);
	_jsonstr.compose("nPublishLobbyPlayersLess", nPublishLobbyPlayersLess);
	_jsonstr.compose("bounty", bounty);
	_jsonstr.compose("fallbackSatelliteTargets", fallbackSatelliteTargets);
	_jsonstr.compose("teamProBounties", teamProBounties);
	_jsonstr.compose("bountyMultipliers", bountyMultipliers);
	_jsonstr.compose("publPropFlag", publPropFlag);
	_jsonstr.compose("multiDayTournProps", multiDayTournProps);
	_jsonstr.compose("multiDayTournDayOneStopValue", multiDayTournDayOneStopValue);
	_jsonstr.compose("multiDayTournDayTwoStartMinutes", multiDayTournDayTwoStartMinutes);
	_jsonstr.compose("multiDayTournDayTwoStarts", multiDayTournDayTwoStarts);
	_jsonstr.compose("satelliteTargetReference", satelliteTargetReference);
	_jsonstr.compose("satelliteTargetReferenceLock", satelliteTargetReferenceLock);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("timedTournType", timedTournType);
	_jsonstr.compose("timedTournLevelsOrMinutes", timedTournLevelsOrMinutes);
	_jsonstr.compose("timedTournPayoutStructure", timedTournPayoutStructure);
	_jsonstr.compose("_obsolete_3", _obsolete_3);
	_jsonstr.compose("fppRewards", fppRewards);
	_jsonstr.compose("speedDisplay", speedDisplay);
	_jsonstr.compose("tournBrand", tournBrand);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("blitzNormalDealingThreshold", blitzNormalDealingThreshold);
	_jsonstr.compose("_obsolete_4", _obsolete_4);
	_jsonstr.compose("progressiveKnockout", progressiveKnockout);
	_jsonstr.compose("tableText", tableText);
	_jsonstr.compose("reEntryAllowed", reEntryAllowed);
	_jsonstr.compose("tournMask", tournMask);
	_jsonstr.compose("tournMask2", tournMask2);
	_jsonstr.compose("tournMask3", tournMask3);
	_jsonstr.compose("tournMask4", tournMask4);
	_jsonstr.compose("internalReference", internalReference);
	_jsonstr.compose("favoriteReference", favoriteReference);
	_jsonstr.compose("ticketPrice", ticketPrice);
	_jsonstr.compose("tournFlags2", tournFlags2);
	_jsonstr.compose("cannotUnregisterFromTarget", cannotUnregisterFromTarget);
	_jsonstr.compose("initialStacks", initialStacks);
	_jsonstr.compose("singleStackChips", singleStackChips);
	_jsonstr.compose("forceReloadAllStacksInLevel", forceReloadAllStacksInLevel);
	_jsonstr.compose("forceReloadAllStacksInMinutes", forceReloadAllStacksInMinutes);
	_jsonstr.compose("reloadStacksOnlyWhenEmpty", reloadStacksOnlyWhenEmpty);
	_jsonstr.compose("targetWhenStarts", targetWhenStarts);
	_jsonstr.compose("admission", admission);
	_jsonstr.compose("siteMask", siteMask);
	_jsonstr.compose("publStartLevel", publStartLevel);
	_jsonstr.compose("tournMask5", tournMask5);
	_jsonstr.compose("tournMask6", tournMask6);
	_jsonstr.compose("dealExclusionType", dealExclusionType);
	_jsonstr.compose("dealExclusionValue", dealExclusionValue);
	_jsonstr.compose("timedTournPlayersPercent", timedTournPlayersPercent);
	_jsonstr.compose("_obsolete_5", _obsolete_5);
	_jsonstr.compose("spinGoStartDelay", spinGoStartDelay);
	_jsonstr.compose("rmPmLobby", rmPmLobby);
	_jsonstr.compose("brandMask", brandMask);
	_jsonstr.compose("playerKnockOutAddOn", playerKnockOutAddOn);
	_jsonstr.compose("totalKnockOutAddOn", totalKnockOutAddOn);
	_jsonstr.compose("knockOutAddOnProgressive", knockOutAddOnProgressive);
	_jsonstr.compose("sitGoStarterGameId", sitGoStarterGameId);
	_jsonstr.compose("numStandardButton", numStandardButton);
	_jsonstr.compose("lateRegDelta", lateRegDelta);
	_jsonstr.compose("finalTablePlusOne", finalTablePlusOne);
	_jsonstr.compose("multidayIndex", multidayIndex);
	_jsonstr.compose("multiDayInfo", multiDayInfo);
	_jsonstr.compose("criteria", criteria);
	_jsonstr.compose("groupReference", groupReference);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_Static::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournamentId", tournamentId);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("startingChips", startingChips);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("playersPerTable", playersPerTable);
	_jparser.parseByNameThrow("gameType", gameType);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("startingTime", startingTime);
	_jparser.parseByNameThrow("registrationStarts", registrationStarts);
	_jparser.parseByNameThrow("registrationEnds", registrationEnds);
	_jparser.parseByNameThrow("seatingStarts", seatingStarts);
	_jparser.parseByNameThrow("minPlayers", minPlayers);
	_jparser.parseByNameThrow("restricted", restricted);
	_jparser.parseByNameThrow("fppReward", fppReward);
	_jparser.parseByNameThrow("fppBuyIn", fppBuyIn);
	_jparser.parseByNameThrow("isRestricted", isRestricted);
	_jparser.parseByNameThrow("isPwdProtected", isPwdProtected);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("numRebuys", numRebuys);
	_jparser.parseByNameThrow("rebuyChips", rebuyChips);
	_jparser.parseByNameThrow("_obsolete_1", _obsolete_1);
	_jparser.parseByNameThrow("rebuyMaxChips", rebuyMaxChips);
	_jparser.parseByNameThrow("numAddOns", numAddOns);
	_jparser.parseByNameThrow("addOnChips", addOnChips);
	_jparser.parseByNameThrow("_obsolete_2", _obsolete_2);
	_jparser.parseByNameThrow("addOnMaxChips", addOnMaxChips);
	_jparser.parseByNameThrow("scriptPrizeAddOn", scriptPrizeAddOn);
	_jparser.parseByNameThrow("guaranteedPrizePool", guaranteedPrizePool);
	_jparser.parseByNameThrow("tournFlags", tournFlags);
	_jparser.parseByNameThrow("maxAllins", maxAllins);
	_jparser.parseByNameThrow("awardSchema", awardSchema);
	_jparser.parseByNameThrow("timeBank", timeBank);
	_jparser.parseByNameThrow("unregistrationEnds_t", unregistrationEnds_t);
	_jparser.parseByNameThrow("satelliteTarget", satelliteTarget);
	_jparser.parseByNameThrow("satelliteTargetBuyIn", satelliteTargetBuyIn);
	_jparser.parseByNameThrow("rebuyFppPrice", rebuyFppPrice);
	_jparser.parseByNameThrow("addOnFppPrice", addOnFppPrice);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("startingTime_t", startingTime_t);
	_jparser.parseByNameThrow("registrationStarts_t", registrationStarts_t);
	_jparser.parseByNameThrow("registrationEnds_t", registrationEnds_t);
	_jparser.parseByNameThrow("seatingStarts_t", seatingStarts_t);
	_jparser.parseByNameThrow("tournFlagsServInt", tournFlagsServInt);
	_jparser.parseByNameThrow("tournProp2", tournProp2);
	_jparser.parseByNameThrow("ticketTypes", ticketTypes);
	_jparser.parseByNameThrow("tableLogo", tableLogo);
	_jparser.parseByNameThrow("finalTableText", finalTableText);
	_jparser.parseByNameThrow("chatLang", chatLang);
	_jparser.parseByNameThrow("lobbyRestricted", lobbyRestricted);
	_jparser.parseByNameThrow("fppFraction", fppFraction);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("rebuyFppReward", rebuyFppReward);
	_jparser.parseByNameThrow("addOnFppReward", addOnFppReward);
	_jparser.parseByNameThrow("fppRewardPercent", fppRewardPercent);
	_jparser.parseByNameThrow("nPublishLobbyPlayersLess", nPublishLobbyPlayersLess);
	_jparser.parseByNameThrow("bounty", bounty);
	_jparser.parseByNameThrow("fallbackSatelliteTargets", fallbackSatelliteTargets);
	_jparser.parseByName("teamProBounties", teamProBounties);
	_jparser.parseByName("bountyMultipliers", bountyMultipliers);
	_jparser.parseByNameThrow("publPropFlag", publPropFlag);
	_jparser.parseByNameThrow("multiDayTournProps", multiDayTournProps);
	_jparser.parseByNameThrow("multiDayTournDayOneStopValue", multiDayTournDayOneStopValue);
	_jparser.parseByNameThrow("multiDayTournDayTwoStartMinutes", multiDayTournDayTwoStartMinutes);
	_jparser.parseByNameThrow("multiDayTournDayTwoStarts", multiDayTournDayTwoStarts);
	_jparser.parseByNameThrow("satelliteTargetReference", satelliteTargetReference);
	_jparser.parseByNameThrow("satelliteTargetReferenceLock", satelliteTargetReferenceLock);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("timedTournType", timedTournType);
	_jparser.parseByNameThrow("timedTournLevelsOrMinutes", timedTournLevelsOrMinutes);
	_jparser.parseByNameThrow("timedTournPayoutStructure", timedTournPayoutStructure);
	_jparser.parseByNameThrow("_obsolete_3", _obsolete_3);
	_jparser.parseByNameThrow("fppRewards", fppRewards);
	_jparser.parseByNameThrow("speedDisplay", speedDisplay);
	_jparser.parseByNameThrow("tournBrand", tournBrand);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("blitzNormalDealingThreshold", blitzNormalDealingThreshold);
	_jparser.parseByNameThrow("_obsolete_4", _obsolete_4);
	_jparser.parseByNameThrow("progressiveKnockout", progressiveKnockout);
	_jparser.parseByNameThrow("tableText", tableText);
	_jparser.parseByNameThrow("reEntryAllowed", reEntryAllowed);
	_jparser.parseByNameThrow("tournMask", tournMask);
	_jparser.parseByNameThrow("tournMask2", tournMask2);
	_jparser.parseByNameThrow("tournMask3", tournMask3);
	_jparser.parseByNameThrow("tournMask4", tournMask4);
	_jparser.parseByNameThrow("internalReference", internalReference);
	_jparser.parseByNameThrow("favoriteReference", favoriteReference);
	_jparser.parseByNameThrow("ticketPrice", ticketPrice);
	_jparser.parseByNameThrow("tournFlags2", tournFlags2);
	_jparser.parseByNameThrow("cannotUnregisterFromTarget", cannotUnregisterFromTarget);
	_jparser.parseByName("initialStacks", initialStacks);
	_jparser.parseByName("singleStackChips", singleStackChips);
	_jparser.parseByName("forceReloadAllStacksInLevel", forceReloadAllStacksInLevel);
	_jparser.parseByName("forceReloadAllStacksInMinutes", forceReloadAllStacksInMinutes);
	_jparser.parseByName("reloadStacksOnlyWhenEmpty", reloadStacksOnlyWhenEmpty);
	_jparser.parseByNameThrow("targetWhenStarts", targetWhenStarts);
	_jparser.parseByNameThrow("admission", admission);
	_jparser.parseByNameThrow("siteMask", siteMask);
	_jparser.parseByNameThrow("publStartLevel", publStartLevel);
	_jparser.parseByNameThrow("tournMask5", tournMask5);
	_jparser.parseByNameThrow("tournMask6", tournMask6);
	_jparser.parseByNameThrow("dealExclusionType", dealExclusionType);
	_jparser.parseByNameThrow("dealExclusionValue", dealExclusionValue);
	_jparser.parseByNameThrow("timedTournPlayersPercent", timedTournPlayersPercent);
	_jparser.parseByNameThrow("_obsolete_5", _obsolete_5);
	_jparser.parseByNameThrow("spinGoStartDelay", spinGoStartDelay);
	_jparser.parseByNameThrow("rmPmLobby", rmPmLobby);
	_jparser.parseByNameThrow("brandMask", brandMask);
	_jparser.parseByNameThrow("playerKnockOutAddOn", playerKnockOutAddOn);
	_jparser.parseByNameThrow("totalKnockOutAddOn", totalKnockOutAddOn);
	_jparser.parseByNameThrow("knockOutAddOnProgressive", knockOutAddOnProgressive);
	_jparser.parseByNameThrow("sitGoStarterGameId", sitGoStarterGameId);
	_jparser.parseByNameThrow("numStandardButton", numStandardButton);
	_jparser.parseByNameThrow("lateRegDelta", lateRegDelta);
	_jparser.parseByNameThrow("finalTablePlusOne", finalTablePlusOne);
	_jparser.parseByNameThrow("multidayIndex", multidayIndex);
	_jparser.parseByNameThrow("multiDayInfo", multiDayInfo);
	_jparser.parseByNameThrow("criteria", criteria);
	_jparser.parseByNameThrow("groupReference", groupReference);
}

/* static */ void MTLobbyCli::publication::TournSubscr_Static::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournamentId; _jparser.validateByNameThrow("tournamentId", tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 startingChips; _jparser.validateByNameThrow("startingChips", startingChips);
	AtfValidator::validateInt(_descr, "startingChips", startingChips, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 playersPerTable; _jparser.validateByNameThrow("playersPerTable", playersPerTable);
	AtfValidator::validateInt(_descr, "playersPerTable", playersPerTable, _checker, __FILE__, __LINE__);
	BYTE gameType; _jparser.validateByNameThrow("gameType", gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	SrvTime startingTime; _jparser.validateByNameThrow("startingTime", startingTime);
	AtfValidator::validateSrvDateTime(_descr, "startingTime", startingTime, _checker, __FILE__, __LINE__);
	SrvTime registrationStarts; _jparser.validateByNameThrow("registrationStarts", registrationStarts);
	AtfValidator::validateSrvDateTime(_descr, "registrationStarts", registrationStarts, _checker, __FILE__, __LINE__);
	SrvTime registrationEnds; _jparser.validateByNameThrow("registrationEnds", registrationEnds);
	AtfValidator::validateSrvDateTime(_descr, "registrationEnds", registrationEnds, _checker, __FILE__, __LINE__);
	SrvTime seatingStarts; _jparser.validateByNameThrow("seatingStarts", seatingStarts);
	AtfValidator::validateSrvDateTime(_descr, "seatingStarts", seatingStarts, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	BYTE restricted; _jparser.validateByNameThrow("restricted", restricted);
	AtfValidator::validateInt(_descr, "restricted", restricted, _checker, __FILE__, __LINE__);
	UINT32 fppReward; _jparser.validateByNameThrow("fppReward", fppReward);
	AtfValidator::validateInt(_descr, "fppReward", fppReward, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _jparser.validateByNameThrow("fppBuyIn", fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	bool isRestricted; _jparser.validateByNameThrow("isRestricted", isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	bool isPwdProtected; _jparser.validateByNameThrow("isPwdProtected", isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	UINT32 numRebuys; _jparser.validateByNameThrow("numRebuys", numRebuys);
	AtfValidator::validateInt(_descr, "numRebuys", numRebuys, _checker, __FILE__, __LINE__);
	UINT32 rebuyChips; _jparser.validateByNameThrow("rebuyChips", rebuyChips);
	AtfValidator::validateInt(_descr, "rebuyChips", rebuyChips, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_1; _jparser.validateByNameThrow("_obsolete_1", _obsolete_1);
	AtfValidator::validateInt(_descr, "_obsolete_1", _obsolete_1, _checker, __FILE__, __LINE__);
	UINT32 rebuyMaxChips; _jparser.validateByNameThrow("rebuyMaxChips", rebuyMaxChips);
	AtfValidator::validateInt(_descr, "rebuyMaxChips", rebuyMaxChips, _checker, __FILE__, __LINE__);
	UINT32 numAddOns; _jparser.validateByNameThrow("numAddOns", numAddOns);
	AtfValidator::validateInt(_descr, "numAddOns", numAddOns, _checker, __FILE__, __LINE__);
	UINT32 addOnChips; _jparser.validateByNameThrow("addOnChips", addOnChips);
	AtfValidator::validateInt(_descr, "addOnChips", addOnChips, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_2; _jparser.validateByNameThrow("_obsolete_2", _obsolete_2);
	AtfValidator::validateInt(_descr, "_obsolete_2", _obsolete_2, _checker, __FILE__, __LINE__);
	UINT32 addOnMaxChips; _jparser.validateByNameThrow("addOnMaxChips", addOnMaxChips);
	AtfValidator::validateInt(_descr, "addOnMaxChips", addOnMaxChips, _checker, __FILE__, __LINE__);
	UINT32 scriptPrizeAddOn; _jparser.validateByNameThrow("scriptPrizeAddOn", scriptPrizeAddOn);
	AtfValidator::validateInt(_descr, "scriptPrizeAddOn", scriptPrizeAddOn, _checker, __FILE__, __LINE__);
	UINT32 guaranteedPrizePool; _jparser.validateByNameThrow("guaranteedPrizePool", guaranteedPrizePool);
	AtfValidator::validateInt(_descr, "guaranteedPrizePool", guaranteedPrizePool, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	UINT16 maxAllins; _jparser.validateByNameThrow("maxAllins", maxAllins);
	AtfValidator::validateInt(_descr, "maxAllins", maxAllins, _checker, __FILE__, __LINE__);
	BYTE awardSchema; _jparser.validateByNameThrow("awardSchema", awardSchema);
	AtfValidator::validateInt(_descr, "awardSchema", awardSchema, _checker, __FILE__, __LINE__);
	UINT32 timeBank; _jparser.validateByNameThrow("timeBank", timeBank);
	AtfValidator::validateInt(_descr, "timeBank", timeBank, _checker, __FILE__, __LINE__);
	UINT32 unregistrationEnds_t; _jparser.validateByNameThrow("unregistrationEnds_t", unregistrationEnds_t);
	AtfValidator::validateInt(_descr, "unregistrationEnds_t", unregistrationEnds_t, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _jparser.validateByNameThrow("satelliteTarget", satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	UINT32 satelliteTargetBuyIn; _jparser.validateByNameThrow("satelliteTargetBuyIn", satelliteTargetBuyIn);
	AtfValidator::validateInt(_descr, "satelliteTargetBuyIn", satelliteTargetBuyIn, _checker, __FILE__, __LINE__);
	UINT32 rebuyFppPrice; _jparser.validateByNameThrow("rebuyFppPrice", rebuyFppPrice);
	AtfValidator::validateInt(_descr, "rebuyFppPrice", rebuyFppPrice, _checker, __FILE__, __LINE__);
	UINT32 addOnFppPrice; _jparser.validateByNameThrow("addOnFppPrice", addOnFppPrice);
	AtfValidator::validateInt(_descr, "addOnFppPrice", addOnFppPrice, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 startingTime_t; _jparser.validateByNameThrow("startingTime_t", startingTime_t);
	AtfValidator::validateInt(_descr, "startingTime_t", startingTime_t, _checker, __FILE__, __LINE__);
	UINT32 registrationStarts_t; _jparser.validateByNameThrow("registrationStarts_t", registrationStarts_t);
	AtfValidator::validateInt(_descr, "registrationStarts_t", registrationStarts_t, _checker, __FILE__, __LINE__);
	UINT32 registrationEnds_t; _jparser.validateByNameThrow("registrationEnds_t", registrationEnds_t);
	AtfValidator::validateInt(_descr, "registrationEnds_t", registrationEnds_t, _checker, __FILE__, __LINE__);
	UINT32 seatingStarts_t; _jparser.validateByNameThrow("seatingStarts_t", seatingStarts_t);
	AtfValidator::validateInt(_descr, "seatingStarts_t", seatingStarts_t, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _jparser.validateByNameThrow("tournFlagsServInt", tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT32 tournProp2; _jparser.validateByNameThrow("tournProp2", tournProp2);
	AtfValidator::validateInt(_descr, "tournProp2", tournProp2, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< P_TicketType > ticketTypes; _jparser.validateByNameThrow("ticketTypes", ticketTypes);
	AtfValidator::validateInt(_descr, "ticketTypes", ticketTypes.size(), _checker, __FILE__, __LINE__);
	UINT32 tableLogo; _jparser.validateByNameThrow("tableLogo", tableLogo);
	AtfValidator::validateInt(_descr, "tableLogo", tableLogo, _checker, __FILE__, __LINE__);
	I18nPString finalTableText; _jparser.validateByNameThrow("finalTableText", finalTableText);
	UINT16 chatLang; _jparser.validateByNameThrow("chatLang", chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	UINT32 lobbyRestricted; _jparser.validateByNameThrow("lobbyRestricted", lobbyRestricted);
	AtfValidator::validateInt(_descr, "lobbyRestricted", lobbyRestricted, _checker, __FILE__, __LINE__);
	UINT32 fppFraction; _jparser.validateByNameThrow("fppFraction", fppFraction);
	AtfValidator::validateInt(_descr, "fppFraction", fppFraction, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 rebuyFppReward; _jparser.validateByNameThrow("rebuyFppReward", rebuyFppReward);
	AtfValidator::validateInt(_descr, "rebuyFppReward", rebuyFppReward, _checker, __FILE__, __LINE__);
	UINT32 addOnFppReward; _jparser.validateByNameThrow("addOnFppReward", addOnFppReward);
	AtfValidator::validateInt(_descr, "addOnFppReward", addOnFppReward, _checker, __FILE__, __LINE__);
	BYTE fppRewardPercent; _jparser.validateByNameThrow("fppRewardPercent", fppRewardPercent);
	AtfValidator::validateInt(_descr, "fppRewardPercent", fppRewardPercent, _checker, __FILE__, __LINE__);
	UINT32 nPublishLobbyPlayersLess; _jparser.validateByNameThrow("nPublishLobbyPlayersLess", nPublishLobbyPlayersLess);
	AtfValidator::validateInt(_descr, "nPublishLobbyPlayersLess", nPublishLobbyPlayersLess, _checker, __FILE__, __LINE__);
	UINT32 bounty; _jparser.validateByNameThrow("bounty", bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > fallbackSatelliteTargets; _jparser.validateByNameThrow("fallbackSatelliteTargets", fallbackSatelliteTargets);
	AtfValidator::validateInt(_descr, "fallbackSatelliteTargets", fallbackSatelliteTargets.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > teamProBounties; _jparser.validateByName("teamProBounties", teamProBounties);
	AtfValidator::validateInt(_descr, "teamProBounties", teamProBounties.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > bountyMultipliers; _jparser.validateByName("bountyMultipliers", bountyMultipliers);
	AtfValidator::validateInt(_descr, "bountyMultipliers", bountyMultipliers.size(), _checker, __FILE__, __LINE__);
	BYTE publPropFlag; _jparser.validateByNameThrow("publPropFlag", publPropFlag);
	AtfValidator::validateInt(_descr, "publPropFlag", publPropFlag, _checker, __FILE__, __LINE__);
	UINT32 multiDayTournProps; _jparser.validateByNameThrow("multiDayTournProps", multiDayTournProps);
	AtfValidator::validateInt(_descr, "multiDayTournProps", multiDayTournProps, _checker, __FILE__, __LINE__);
	UINT32 multiDayTournDayOneStopValue; _jparser.validateByNameThrow("multiDayTournDayOneStopValue", multiDayTournDayOneStopValue);
	AtfValidator::validateInt(_descr, "multiDayTournDayOneStopValue", multiDayTournDayOneStopValue, _checker, __FILE__, __LINE__);
	UINT32 multiDayTournDayTwoStartMinutes; _jparser.validateByNameThrow("multiDayTournDayTwoStartMinutes", multiDayTournDayTwoStartMinutes);
	AtfValidator::validateInt(_descr, "multiDayTournDayTwoStartMinutes", multiDayTournDayTwoStartMinutes, _checker, __FILE__, __LINE__);
	SrvTime multiDayTournDayTwoStarts; _jparser.validateByNameThrow("multiDayTournDayTwoStarts", multiDayTournDayTwoStarts);
	AtfValidator::validateSrvDateTime(_descr, "multiDayTournDayTwoStarts", multiDayTournDayTwoStarts, _checker, __FILE__, __LINE__);
	PString satelliteTargetReference; _jparser.validateByNameThrow("satelliteTargetReference", satelliteTargetReference);
	AtfValidator::validateInt(_descr, "satelliteTargetReference", satelliteTargetReference.length(), _checker, __FILE__, __LINE__);
	UINT16 satelliteTargetReferenceLock; _jparser.validateByNameThrow("satelliteTargetReferenceLock", satelliteTargetReferenceLock);
	AtfValidator::validateInt(_descr, "satelliteTargetReferenceLock", satelliteTargetReferenceLock, _checker, __FILE__, __LINE__);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	BYTE timedTournType; _jparser.validateByNameThrow("timedTournType", timedTournType);
	AtfValidator::validateInt(_descr, "timedTournType", timedTournType, _checker, __FILE__, __LINE__);
	UINT16 timedTournLevelsOrMinutes; _jparser.validateByNameThrow("timedTournLevelsOrMinutes", timedTournLevelsOrMinutes);
	AtfValidator::validateInt(_descr, "timedTournLevelsOrMinutes", timedTournLevelsOrMinutes, _checker, __FILE__, __LINE__);
	BYTE timedTournPayoutStructure; _jparser.validateByNameThrow("timedTournPayoutStructure", timedTournPayoutStructure);
	AtfValidator::validateInt(_descr, "timedTournPayoutStructure", timedTournPayoutStructure, _checker, __FILE__, __LINE__);
	bool _obsolete_3; _jparser.validateByNameThrow("_obsolete_3", _obsolete_3);
	AtfValidator::validateInt(_descr, "_obsolete_3", _obsolete_3, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< P_FppReward > fppRewards; _jparser.validateByNameThrow("fppRewards", fppRewards);
	AtfValidator::validateInt(_descr, "fppRewards", fppRewards.size(), _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _jparser.validateByNameThrow("speedDisplay", speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	PString tournBrand; _jparser.validateByNameThrow("tournBrand", tournBrand);
	AtfValidator::validateInt(_descr, "tournBrand", tournBrand.length(), _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 blitzNormalDealingThreshold; _jparser.validateByNameThrow("blitzNormalDealingThreshold", blitzNormalDealingThreshold);
	AtfValidator::validateInt(_descr, "blitzNormalDealingThreshold", blitzNormalDealingThreshold, _checker, __FILE__, __LINE__);
	bool _obsolete_4; _jparser.validateByNameThrow("_obsolete_4", _obsolete_4);
	AtfValidator::validateInt(_descr, "_obsolete_4", _obsolete_4, _checker, __FILE__, __LINE__);
	BYTE progressiveKnockout; _jparser.validateByNameThrow("progressiveKnockout", progressiveKnockout);
	AtfValidator::validateInt(_descr, "progressiveKnockout", progressiveKnockout, _checker, __FILE__, __LINE__);
	I18nPString tableText; _jparser.validateByNameThrow("tableText", tableText);
	UINT16 reEntryAllowed; _jparser.validateByNameThrow("reEntryAllowed", reEntryAllowed);
	AtfValidator::validateInt(_descr, "reEntryAllowed", reEntryAllowed, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _jparser.validateByNameThrow("tournMask", tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _jparser.validateByNameThrow("tournMask2", tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _jparser.validateByNameThrow("tournMask3", tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _jparser.validateByNameThrow("tournMask4", tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	PString internalReference; _jparser.validateByNameThrow("internalReference", internalReference);
	AtfValidator::validateInt(_descr, "internalReference", internalReference.length(), _checker, __FILE__, __LINE__);
	PString favoriteReference; _jparser.validateByNameThrow("favoriteReference", favoriteReference);
	AtfValidator::validateInt(_descr, "favoriteReference", favoriteReference.length(), _checker, __FILE__, __LINE__);
	INT64 ticketPrice; _jparser.validateByNameThrow("ticketPrice", ticketPrice);
	AtfValidator::validateInt(_descr, "ticketPrice", ticketPrice, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	bool cannotUnregisterFromTarget; _jparser.validateByNameThrow("cannotUnregisterFromTarget", cannotUnregisterFromTarget);
	AtfValidator::validateInt(_descr, "cannotUnregisterFromTarget", cannotUnregisterFromTarget, _checker, __FILE__, __LINE__);
	UINT32 initialStacks; _jparser.validateByName("initialStacks", initialStacks);
	AtfValidator::validateInt(_descr, "initialStacks", initialStacks, _checker, __FILE__, __LINE__);
	UINT32 singleStackChips; _jparser.validateByName("singleStackChips", singleStackChips);
	AtfValidator::validateInt(_descr, "singleStackChips", singleStackChips, _checker, __FILE__, __LINE__);
	UINT32 forceReloadAllStacksInLevel; _jparser.validateByName("forceReloadAllStacksInLevel", forceReloadAllStacksInLevel);
	AtfValidator::validateInt(_descr, "forceReloadAllStacksInLevel", forceReloadAllStacksInLevel, _checker, __FILE__, __LINE__);
	UINT32 forceReloadAllStacksInMinutes; _jparser.validateByName("forceReloadAllStacksInMinutes", forceReloadAllStacksInMinutes);
	AtfValidator::validateInt(_descr, "forceReloadAllStacksInMinutes", forceReloadAllStacksInMinutes, _checker, __FILE__, __LINE__);
	bool reloadStacksOnlyWhenEmpty; _jparser.validateByName("reloadStacksOnlyWhenEmpty", reloadStacksOnlyWhenEmpty);
	AtfValidator::validateInt(_descr, "reloadStacksOnlyWhenEmpty", reloadStacksOnlyWhenEmpty, _checker, __FILE__, __LINE__);
	SrvTime targetWhenStarts; _jparser.validateByNameThrow("targetWhenStarts", targetWhenStarts);
	AtfValidator::validateSrvDateTime(_descr, "targetWhenStarts", targetWhenStarts, _checker, __FILE__, __LINE__);
	PString admission; _jparser.validateByNameThrow("admission", admission);
	AtfValidator::validateInt(_descr, "admission", admission.length(), _checker, __FILE__, __LINE__);
	UINT32 siteMask; _jparser.validateByNameThrow("siteMask", siteMask);
	AtfValidator::validateInt(_descr, "siteMask", siteMask, _checker, __FILE__, __LINE__);
	UINT32 publStartLevel; _jparser.validateByNameThrow("publStartLevel", publStartLevel);
	AtfValidator::validateInt(_descr, "publStartLevel", publStartLevel, _checker, __FILE__, __LINE__);
	UINT32 tournMask5; _jparser.validateByNameThrow("tournMask5", tournMask5);
	AtfValidator::validateInt(_descr, "tournMask5", tournMask5, _checker, __FILE__, __LINE__);
	UINT32 tournMask6; _jparser.validateByNameThrow("tournMask6", tournMask6);
	AtfValidator::validateInt(_descr, "tournMask6", tournMask6, _checker, __FILE__, __LINE__);
	BYTE dealExclusionType; _jparser.validateByNameThrow("dealExclusionType", dealExclusionType);
	AtfValidator::validateInt(_descr, "dealExclusionType", dealExclusionType, _checker, __FILE__, __LINE__);
	UINT32 dealExclusionValue; _jparser.validateByNameThrow("dealExclusionValue", dealExclusionValue);
	AtfValidator::validateInt(_descr, "dealExclusionValue", dealExclusionValue, _checker, __FILE__, __LINE__);
	BYTE timedTournPlayersPercent; _jparser.validateByNameThrow("timedTournPlayersPercent", timedTournPlayersPercent);
	AtfValidator::validateInt(_descr, "timedTournPlayersPercent", timedTournPlayersPercent, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_5; _jparser.validateByNameThrow("_obsolete_5", _obsolete_5);
	AtfValidator::validateInt(_descr, "_obsolete_5", _obsolete_5, _checker, __FILE__, __LINE__);
	UINT32 spinGoStartDelay; _jparser.validateByNameThrow("spinGoStartDelay", spinGoStartDelay);
	AtfValidator::validateInt(_descr, "spinGoStartDelay", spinGoStartDelay, _checker, __FILE__, __LINE__);
	BYTE rmPmLobby; _jparser.validateByNameThrow("rmPmLobby", rmPmLobby);
	AtfValidator::validateInt(_descr, "rmPmLobby", rmPmLobby, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _jparser.validateByNameThrow("brandMask", brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	UINT32 playerKnockOutAddOn; _jparser.validateByNameThrow("playerKnockOutAddOn", playerKnockOutAddOn);
	AtfValidator::validateInt(_descr, "playerKnockOutAddOn", playerKnockOutAddOn, _checker, __FILE__, __LINE__);
	UINT32 totalKnockOutAddOn; _jparser.validateByNameThrow("totalKnockOutAddOn", totalKnockOutAddOn);
	AtfValidator::validateInt(_descr, "totalKnockOutAddOn", totalKnockOutAddOn, _checker, __FILE__, __LINE__);
	BYTE knockOutAddOnProgressive; _jparser.validateByNameThrow("knockOutAddOnProgressive", knockOutAddOnProgressive);
	AtfValidator::validateInt(_descr, "knockOutAddOnProgressive", knockOutAddOnProgressive, _checker, __FILE__, __LINE__);
	UINT32 sitGoStarterGameId; _jparser.validateByNameThrow("sitGoStarterGameId", sitGoStarterGameId);
	AtfValidator::validateInt(_descr, "sitGoStarterGameId", sitGoStarterGameId, _checker, __FILE__, __LINE__);
	UINT32 numStandardButton; _jparser.validateByNameThrow("numStandardButton", numStandardButton);
	AtfValidator::validateInt(_descr, "numStandardButton", numStandardButton, _checker, __FILE__, __LINE__);
	INT32 lateRegDelta; _jparser.validateByNameThrow("lateRegDelta", lateRegDelta);
	AtfValidator::validateInt(_descr, "lateRegDelta", lateRegDelta, _checker, __FILE__, __LINE__);
	INT32 finalTablePlusOne; _jparser.validateByNameThrow("finalTablePlusOne", finalTablePlusOne);
	AtfValidator::validateInt(_descr, "finalTablePlusOne", finalTablePlusOne, _checker, __FILE__, __LINE__);
	UINT32 multidayIndex; _jparser.validateByNameThrow("multidayIndex", multidayIndex);
	AtfValidator::validateInt(_descr, "multidayIndex", multidayIndex, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< P_MultiDayInfo > multiDayInfo; _jparser.validateByNameThrow("multiDayInfo", multiDayInfo);
	AtfValidator::validateInt(_descr, "multiDayInfo", multiDayInfo.size(), _checker, __FILE__, __LINE__);
	PString criteria; _jparser.validateByNameThrow("criteria", criteria);
	AtfValidator::validateInt(_descr, "criteria", criteria.length(), _checker, __FILE__, __LINE__);
	PString groupReference; _jparser.validateByNameThrow("groupReference", groupReference);
	AtfValidator::validateInt(_descr, "groupReference", groupReference.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_Static::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 tournamentId; _parser.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 startingChips; _parser.parseUINT32(startingChips);
	AtfValidator::validateInt(_descr, "startingChips", startingChips, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 playersPerTable; _parser.parseUINT32(playersPerTable);
	AtfValidator::validateInt(_descr, "playersPerTable", playersPerTable, _checker, __FILE__, __LINE__);
	BYTE gameType; _parser.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	SrvTime startingTime; _parser.parseSrvTime(startingTime);
	AtfValidator::validateSrvDateTime(_descr, "startingTime", startingTime, _checker, __FILE__, __LINE__);
	SrvTime registrationStarts; _parser.parseSrvTime(registrationStarts);
	AtfValidator::validateSrvDateTime(_descr, "registrationStarts", registrationStarts, _checker, __FILE__, __LINE__);
	SrvTime registrationEnds; _parser.parseSrvTime(registrationEnds);
	AtfValidator::validateSrvDateTime(_descr, "registrationEnds", registrationEnds, _checker, __FILE__, __LINE__);
	SrvTime seatingStarts; _parser.parseSrvTime(seatingStarts);
	AtfValidator::validateSrvDateTime(_descr, "seatingStarts", seatingStarts, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	BYTE restricted; _parser.parseBYTE(restricted);
	AtfValidator::validateInt(_descr, "restricted", restricted, _checker, __FILE__, __LINE__);
	UINT32 fppReward; _parser.parseUINT32(fppReward);
	AtfValidator::validateInt(_descr, "fppReward", fppReward, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	bool isRestricted; _parser.parseBOOL(isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	bool isPwdProtected; _parser.parseBOOL(isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	UINT32 numRebuys; _parser.parseUINT32(numRebuys);
	AtfValidator::validateInt(_descr, "numRebuys", numRebuys, _checker, __FILE__, __LINE__);
	UINT32 rebuyChips; _parser.parseUINT32(rebuyChips);
	AtfValidator::validateInt(_descr, "rebuyChips", rebuyChips, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_1; _parser.parseUINT32(_obsolete_1);
	AtfValidator::validateInt(_descr, "_obsolete_1", _obsolete_1, _checker, __FILE__, __LINE__);
	UINT32 rebuyMaxChips; _parser.parseUINT32(rebuyMaxChips);
	AtfValidator::validateInt(_descr, "rebuyMaxChips", rebuyMaxChips, _checker, __FILE__, __LINE__);
	UINT32 numAddOns; _parser.parseUINT32(numAddOns);
	AtfValidator::validateInt(_descr, "numAddOns", numAddOns, _checker, __FILE__, __LINE__);
	UINT32 addOnChips; _parser.parseUINT32(addOnChips);
	AtfValidator::validateInt(_descr, "addOnChips", addOnChips, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_2; _parser.parseUINT32(_obsolete_2);
	AtfValidator::validateInt(_descr, "_obsolete_2", _obsolete_2, _checker, __FILE__, __LINE__);
	UINT32 addOnMaxChips; _parser.parseUINT32(addOnMaxChips);
	AtfValidator::validateInt(_descr, "addOnMaxChips", addOnMaxChips, _checker, __FILE__, __LINE__);
	UINT32 scriptPrizeAddOn; _parser.parseUINT32(scriptPrizeAddOn);
	AtfValidator::validateInt(_descr, "scriptPrizeAddOn", scriptPrizeAddOn, _checker, __FILE__, __LINE__);
	UINT32 guaranteedPrizePool; _parser.parseUINT32(guaranteedPrizePool);
	AtfValidator::validateInt(_descr, "guaranteedPrizePool", guaranteedPrizePool, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	UINT16 maxAllins; _parser.parseUINT16(maxAllins);
	AtfValidator::validateInt(_descr, "maxAllins", maxAllins, _checker, __FILE__, __LINE__);
	BYTE awardSchema; _parser.parseBYTE(awardSchema);
	AtfValidator::validateInt(_descr, "awardSchema", awardSchema, _checker, __FILE__, __LINE__);
	UINT32 timeBank; _parser.parseUINT32(timeBank);
	AtfValidator::validateInt(_descr, "timeBank", timeBank, _checker, __FILE__, __LINE__);
	UINT32 unregistrationEnds_t; _parser.parseUINT32(unregistrationEnds_t);
	AtfValidator::validateInt(_descr, "unregistrationEnds_t", unregistrationEnds_t, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _parser.parseUINT32(satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	UINT32 satelliteTargetBuyIn; _parser.parseUINT32(satelliteTargetBuyIn);
	AtfValidator::validateInt(_descr, "satelliteTargetBuyIn", satelliteTargetBuyIn, _checker, __FILE__, __LINE__);
	UINT32 rebuyFppPrice; _parser.parseUINT32(rebuyFppPrice);
	AtfValidator::validateInt(_descr, "rebuyFppPrice", rebuyFppPrice, _checker, __FILE__, __LINE__);
	UINT32 addOnFppPrice; _parser.parseUINT32(addOnFppPrice);
	AtfValidator::validateInt(_descr, "addOnFppPrice", addOnFppPrice, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 startingTime_t; _parser.parseUINT32(startingTime_t);
	AtfValidator::validateInt(_descr, "startingTime_t", startingTime_t, _checker, __FILE__, __LINE__);
	UINT32 registrationStarts_t; _parser.parseUINT32(registrationStarts_t);
	AtfValidator::validateInt(_descr, "registrationStarts_t", registrationStarts_t, _checker, __FILE__, __LINE__);
	UINT32 registrationEnds_t; _parser.parseUINT32(registrationEnds_t);
	AtfValidator::validateInt(_descr, "registrationEnds_t", registrationEnds_t, _checker, __FILE__, __LINE__);
	UINT32 seatingStarts_t; _parser.parseUINT32(seatingStarts_t);
	AtfValidator::validateInt(_descr, "seatingStarts_t", seatingStarts_t, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _parser.parseUINT32(tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT32 tournProp2; _parser.parseUINT32(tournProp2);
	AtfValidator::validateInt(_descr, "tournProp2", tournProp2, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTicketTypes = Atf::LAtfVector< P_TicketType , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "ticketTypes", szTicketTypes, _checker, __FILE__, __LINE__);
	UINT32 tableLogo; _parser.parseUINT32(tableLogo);
	AtfValidator::validateInt(_descr, "tableLogo", tableLogo, _checker, __FILE__, __LINE__);
	I18nPString finalTableText; finalTableText.parse(_parser);
	UINT16 chatLang; _parser.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	UINT32 lobbyRestricted; _parser.parseUINT32(lobbyRestricted);
	AtfValidator::validateInt(_descr, "lobbyRestricted", lobbyRestricted, _checker, __FILE__, __LINE__);
	UINT32 fppFraction; _parser.parseUINT32(fppFraction);
	AtfValidator::validateInt(_descr, "fppFraction", fppFraction, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 rebuyFppReward; _parser.parseUINT32(rebuyFppReward);
	AtfValidator::validateInt(_descr, "rebuyFppReward", rebuyFppReward, _checker, __FILE__, __LINE__);
	UINT32 addOnFppReward; _parser.parseUINT32(addOnFppReward);
	AtfValidator::validateInt(_descr, "addOnFppReward", addOnFppReward, _checker, __FILE__, __LINE__);
	BYTE fppRewardPercent; _parser.parseBYTE(fppRewardPercent);
	AtfValidator::validateInt(_descr, "fppRewardPercent", fppRewardPercent, _checker, __FILE__, __LINE__);
	UINT32 nPublishLobbyPlayersLess; _parser.parseUINT32(nPublishLobbyPlayersLess);
	AtfValidator::validateInt(_descr, "nPublishLobbyPlayersLess", nPublishLobbyPlayersLess, _checker, __FILE__, __LINE__);
	UINT32 bounty; _parser.parseUINT32(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	int szFallbackSatelliteTargets = Atf::LAtfVector< UINT32 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("fallbackSatelliteTargets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "fallbackSatelliteTargets", szFallbackSatelliteTargets, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE publPropFlag; _parser.parseBYTE(publPropFlag);
	AtfValidator::validateInt(_descr, "publPropFlag", publPropFlag, _checker, __FILE__, __LINE__);
	UINT32 multiDayTournProps; _parser.parseUINT32(multiDayTournProps);
	AtfValidator::validateInt(_descr, "multiDayTournProps", multiDayTournProps, _checker, __FILE__, __LINE__);
	UINT32 multiDayTournDayOneStopValue; _parser.parseUINT32(multiDayTournDayOneStopValue);
	AtfValidator::validateInt(_descr, "multiDayTournDayOneStopValue", multiDayTournDayOneStopValue, _checker, __FILE__, __LINE__);
	UINT32 multiDayTournDayTwoStartMinutes; _parser.parseUINT32(multiDayTournDayTwoStartMinutes);
	AtfValidator::validateInt(_descr, "multiDayTournDayTwoStartMinutes", multiDayTournDayTwoStartMinutes, _checker, __FILE__, __LINE__);
	SrvTime multiDayTournDayTwoStarts; _parser.parseSrvTime(multiDayTournDayTwoStarts);
	AtfValidator::validateSrvDateTime(_descr, "multiDayTournDayTwoStarts", multiDayTournDayTwoStarts, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "satelliteTargetReference"); size_t szSatelliteTargetReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetReference", szSatelliteTargetReference, _checker, __FILE__, __LINE__);
	UINT16 satelliteTargetReferenceLock; _parser.parseUINT16(satelliteTargetReferenceLock);
	AtfValidator::validateInt(_descr, "satelliteTargetReferenceLock", satelliteTargetReferenceLock, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	BYTE timedTournType; _parser.parseBYTE(timedTournType);
	AtfValidator::validateInt(_descr, "timedTournType", timedTournType, _checker, __FILE__, __LINE__);
	UINT16 timedTournLevelsOrMinutes; _parser.parseUINT16(timedTournLevelsOrMinutes);
	AtfValidator::validateInt(_descr, "timedTournLevelsOrMinutes", timedTournLevelsOrMinutes, _checker, __FILE__, __LINE__);
	BYTE timedTournPayoutStructure; _parser.parseBYTE(timedTournPayoutStructure);
	AtfValidator::validateInt(_descr, "timedTournPayoutStructure", timedTournPayoutStructure, _checker, __FILE__, __LINE__);
	bool _obsolete_3; _parser.parseBOOL(_obsolete_3);
	AtfValidator::validateInt(_descr, "_obsolete_3", _obsolete_3, _checker, __FILE__, __LINE__);
	int szFppRewards = Atf::LAtfVector< P_FppReward , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("fppRewards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "fppRewards", szFppRewards, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _parser.parseBYTE(speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tournBrand"); size_t szTournBrand = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournBrand", szTournBrand, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 blitzNormalDealingThreshold; _parser.parseUINT32(blitzNormalDealingThreshold);
	AtfValidator::validateInt(_descr, "blitzNormalDealingThreshold", blitzNormalDealingThreshold, _checker, __FILE__, __LINE__);
	bool _obsolete_4; _parser.parseBOOL(_obsolete_4);
	AtfValidator::validateInt(_descr, "_obsolete_4", _obsolete_4, _checker, __FILE__, __LINE__);
	BYTE progressiveKnockout; _parser.parseBYTE(progressiveKnockout);
	AtfValidator::validateInt(_descr, "progressiveKnockout", progressiveKnockout, _checker, __FILE__, __LINE__);
	I18nPString tableText; tableText.parse(_parser);
	UINT16 reEntryAllowed; _parser.parseUINT16(reEntryAllowed);
	AtfValidator::validateInt(_descr, "reEntryAllowed", reEntryAllowed, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _parser.parseUINT32(tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _parser.parseUINT32(tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _parser.parseUINT32(tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _parser.parseUINT32(tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "internalReference"); size_t szInternalReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "internalReference", szInternalReference, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "favoriteReference"); size_t szFavoriteReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "favoriteReference", szFavoriteReference, _checker, __FILE__, __LINE__);
	INT64 ticketPrice; _parser.parseINT64(ticketPrice);
	AtfValidator::validateInt(_descr, "ticketPrice", ticketPrice, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	bool cannotUnregisterFromTarget; _parser.parseBOOL(cannotUnregisterFromTarget);
	AtfValidator::validateInt(_descr, "cannotUnregisterFromTarget", cannotUnregisterFromTarget, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime targetWhenStarts; _parser.parseSrvTime(targetWhenStarts);
	AtfValidator::validateSrvDateTime(_descr, "targetWhenStarts", targetWhenStarts, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "admission"); size_t szAdmission = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admission", szAdmission, _checker, __FILE__, __LINE__);
	UINT32 siteMask; _parser.parseUINT32(siteMask);
	AtfValidator::validateInt(_descr, "siteMask", siteMask, _checker, __FILE__, __LINE__);
	UINT32 publStartLevel; _parser.parseUINT32(publStartLevel);
	AtfValidator::validateInt(_descr, "publStartLevel", publStartLevel, _checker, __FILE__, __LINE__);
	UINT32 tournMask5; _parser.parseUINT32(tournMask5);
	AtfValidator::validateInt(_descr, "tournMask5", tournMask5, _checker, __FILE__, __LINE__);
	UINT32 tournMask6; _parser.parseUINT32(tournMask6);
	AtfValidator::validateInt(_descr, "tournMask6", tournMask6, _checker, __FILE__, __LINE__);
	BYTE dealExclusionType; _parser.parseBYTE(dealExclusionType);
	AtfValidator::validateInt(_descr, "dealExclusionType", dealExclusionType, _checker, __FILE__, __LINE__);
	UINT32 dealExclusionValue; _parser.parseUINT32(dealExclusionValue);
	AtfValidator::validateInt(_descr, "dealExclusionValue", dealExclusionValue, _checker, __FILE__, __LINE__);
	BYTE timedTournPlayersPercent; _parser.parseBYTE(timedTournPlayersPercent);
	AtfValidator::validateInt(_descr, "timedTournPlayersPercent", timedTournPlayersPercent, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_5; _parser.parseUINT32(_obsolete_5);
	AtfValidator::validateInt(_descr, "_obsolete_5", _obsolete_5, _checker, __FILE__, __LINE__);
	UINT32 spinGoStartDelay; _parser.parseUINT32(spinGoStartDelay);
	AtfValidator::validateInt(_descr, "spinGoStartDelay", spinGoStartDelay, _checker, __FILE__, __LINE__);
	BYTE rmPmLobby; _parser.parseBYTE(rmPmLobby);
	AtfValidator::validateInt(_descr, "rmPmLobby", rmPmLobby, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	UINT32 playerKnockOutAddOn; _parser.parseUINT32(playerKnockOutAddOn);
	AtfValidator::validateInt(_descr, "playerKnockOutAddOn", playerKnockOutAddOn, _checker, __FILE__, __LINE__);
	UINT32 totalKnockOutAddOn; _parser.parseUINT32(totalKnockOutAddOn);
	AtfValidator::validateInt(_descr, "totalKnockOutAddOn", totalKnockOutAddOn, _checker, __FILE__, __LINE__);
	BYTE knockOutAddOnProgressive; _parser.parseBYTE(knockOutAddOnProgressive);
	AtfValidator::validateInt(_descr, "knockOutAddOnProgressive", knockOutAddOnProgressive, _checker, __FILE__, __LINE__);
	UINT32 sitGoStarterGameId; _parser.parseUINT32(sitGoStarterGameId);
	AtfValidator::validateInt(_descr, "sitGoStarterGameId", sitGoStarterGameId, _checker, __FILE__, __LINE__);
	UINT32 numStandardButton; _parser.parseUINT32(numStandardButton);
	AtfValidator::validateInt(_descr, "numStandardButton", numStandardButton, _checker, __FILE__, __LINE__);
	INT32 lateRegDelta; _parser.parseINT32(lateRegDelta);
	AtfValidator::validateInt(_descr, "lateRegDelta", lateRegDelta, _checker, __FILE__, __LINE__);
	INT32 finalTablePlusOne; _parser.parseINT32(finalTablePlusOne);
	AtfValidator::validateInt(_descr, "finalTablePlusOne", finalTablePlusOne, _checker, __FILE__, __LINE__);
	UINT32 multidayIndex; _parser.parseUINT32(multidayIndex);
	AtfValidator::validateInt(_descr, "multidayIndex", multidayIndex, _checker, __FILE__, __LINE__);
	int szMultiDayInfo = Atf::LAtfVector< P_MultiDayInfo , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("multiDayInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "multiDayInfo", szMultiDayInfo, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "criteria"); size_t szCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "criteria", szCriteria, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "groupReference"); size_t szGroupReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "groupReference", szGroupReference, _checker, __FILE__, __LINE__);
}

void MTLobbyCli::publication::TournSubscr_Static::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	teamProBounties.parseMsg(_parser0);
	bountyMultipliers.parseMsg(_parser0);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_Static::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szTeamProBounties = Atf::LAtfVector< UINT32 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("teamProBounties"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "teamProBounties", szTeamProBounties, _checker, __FILE__, __LINE__);
	int szBountyMultipliers = Atf::LAtfVector< UINT32 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("bountyMultipliers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "bountyMultipliers", szBountyMultipliers, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MTLobbyCli::publication::TournSubscr_Static::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(initialStacks);
	_parser0.parseUINT32(singleStackChips);
	_parser0.parseUINT32(forceReloadAllStacksInLevel);
	_parser0.parseUINT32(forceReloadAllStacksInMinutes);
	_parser0.parseBOOL(reloadStacksOnlyWhenEmpty);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_Static::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.parseEnded()) return;
	UINT32 initialStacks; _parser0.parseUINT32(initialStacks);
	AtfValidator::validateInt(_descr, "initialStacks", initialStacks, _checker, __FILE__, __LINE__);
	UINT32 singleStackChips; _parser0.parseUINT32(singleStackChips);
	AtfValidator::validateInt(_descr, "singleStackChips", singleStackChips, _checker, __FILE__, __LINE__);
	UINT32 forceReloadAllStacksInLevel; _parser0.parseUINT32(forceReloadAllStacksInLevel);
	AtfValidator::validateInt(_descr, "forceReloadAllStacksInLevel", forceReloadAllStacksInLevel, _checker, __FILE__, __LINE__);
	UINT32 forceReloadAllStacksInMinutes; _parser0.parseUINT32(forceReloadAllStacksInMinutes);
	AtfValidator::validateInt(_descr, "forceReloadAllStacksInMinutes", forceReloadAllStacksInMinutes, _checker, __FILE__, __LINE__);
	bool reloadStacksOnlyWhenEmpty; _parser0.parseBOOL(reloadStacksOnlyWhenEmpty);
	AtfValidator::validateInt(_descr, "reloadStacksOnlyWhenEmpty", reloadStacksOnlyWhenEmpty, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournSubscr_Betting
//=================================================================

MTLobbyCli::publication::TournSubscr_Betting::TournSubscr_Betting()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_Betting::TournSubscr_Betting(TournSubscr_Betting&& _o)
	: loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, bringIn(std::move(_o.bringIn))
	, smallBlind(std::move(_o.smallBlind))
	, structure(std::move(_o.structure))
	, ante(std::move(_o.ante))
	, blindsLevel(std::move(_o.blindsLevel))
	, nextLevelOrdinal(std::move(_o.nextLevelOrdinal))
	, nextAnte(std::move(_o.nextAnte))
	, nextSmallBlind(std::move(_o.nextSmallBlind))
	, nextLoBet(std::move(_o.nextLoBet))
	, nextHiBet(std::move(_o.nextHiBet))
	, nextBringIn(std::move(_o.nextBringIn))
	, nextLevelStart_t(std::move(_o.nextLevelStart_t))
	, nextLevelStart(std::move(_o.nextLevelStart))
	, olympicLevel(std::move(_o.olympicLevel))
	, gameType(std::move(_o.gameType))
	, limit(std::move(_o.limit))
	, isHiLo(std::move(_o.isHiLo))
{
}

MTLobbyCli::publication::TournSubscr_Betting& MTLobbyCli::publication::TournSubscr_Betting::operator=(TournSubscr_Betting&& _o)
{
	if(this != &_o)
	{
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		bringIn = std::move(_o.bringIn);
		smallBlind = std::move(_o.smallBlind);
		structure = std::move(_o.structure);
		ante = std::move(_o.ante);
		blindsLevel = std::move(_o.blindsLevel);
		nextLevelOrdinal = std::move(_o.nextLevelOrdinal);
		nextAnte = std::move(_o.nextAnte);
		nextSmallBlind = std::move(_o.nextSmallBlind);
		nextLoBet = std::move(_o.nextLoBet);
		nextHiBet = std::move(_o.nextHiBet);
		nextBringIn = std::move(_o.nextBringIn);
		nextLevelStart_t = std::move(_o.nextLevelStart_t);
		nextLevelStart = std::move(_o.nextLevelStart);
		olympicLevel = std::move(_o.olympicLevel);
		gameType = std::move(_o.gameType);
		limit = std::move(_o.limit);
		isHiLo = std::move(_o.isHiLo);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_Betting::clear()
{
	loBet = 0;
	hiBet = 0;
	bringIn = 0;
	smallBlind = 0;
	structure = 0;
	ante = 0;
	blindsLevel = 0;
	nextLevelOrdinal = 0;
	nextAnte = 0;
	nextSmallBlind = 0;
	nextLoBet = 0;
	nextHiBet = 0;
	nextBringIn = 0;
	nextLevelStart_t = 0;
	nextLevelStart.setNull();
	olympicLevel = 0;
	gameType = 0;
	limit = 0;
	isHiLo = false;
}

bool MTLobbyCli::publication::TournSubscr_Betting::equals(const TournSubscr_Betting& _o) const
{
	return loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		bringIn == _o.bringIn &&
		smallBlind == _o.smallBlind &&
		structure == _o.structure &&
		ante == _o.ante &&
		blindsLevel == _o.blindsLevel &&
		nextLevelOrdinal == _o.nextLevelOrdinal &&
		nextAnte == _o.nextAnte &&
		nextSmallBlind == _o.nextSmallBlind &&
		nextLoBet == _o.nextLoBet &&
		nextHiBet == _o.nextHiBet &&
		nextBringIn == _o.nextBringIn &&
		nextLevelStart_t == _o.nextLevelStart_t &&
		nextLevelStart.equals(_o.nextLevelStart) &&
		olympicLevel == _o.olympicLevel &&
		gameType == _o.gameType &&
		limit == _o.limit &&
		isHiLo == _o.isHiLo;
}

const char *MTLobbyCli::publication::TournSubscr_Betting::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("bringIn=");
	_buf.appendUint(bringIn);
	_buf.append(',');
	_buf.append("smallBlind=");
	_buf.appendUint(smallBlind);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("blindsLevel=");
	_buf.appendUint(blindsLevel);
	_buf.append(',');
	_buf.append("nextLevelOrdinal=");
	_buf.appendUint(nextLevelOrdinal);
	if( nextLevelOrdinal )
	{
		_buf.append(',');
		_buf.append("nextAnte=");
		_buf.appendUint(nextAnte);
		_buf.append(',');
		_buf.append("nextSmallBlind=");
		_buf.appendUint(nextSmallBlind);
		_buf.append(',');
		_buf.append("nextLoBet=");
		_buf.appendUint(nextLoBet);
		_buf.append(',');
		_buf.append("nextHiBet=");
		_buf.appendUint(nextHiBet);
		_buf.append(',');
		_buf.append("nextBringIn=");
		_buf.appendUint(nextBringIn);
		_buf.append(',');
		_buf.append("nextLevelStart_t=");
		_buf.appendUint(nextLevelStart_t);
		_buf.append(',');
		_buf.append("nextLevelStart=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, nextLevelStart);
	}
	_buf.append(',');
	_buf.append("olympicLevel=");
	_buf.appendUint(olympicLevel);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournSubscr_Betting::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("bringIn", bringIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("smallBlind", smallBlind, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("blindsLevel", blindsLevel, _buf);
	Atf::XmlElement::encodeAsXmlElement("nextLevelOrdinal", nextLevelOrdinal, _buf);
	if( nextLevelOrdinal )
	{
		Atf::XmlElement::encodeAsXmlElement("nextAnte", nextAnte, _buf);
		Atf::XmlElement::encodeAsXmlElement("nextSmallBlind", nextSmallBlind, _buf);
		Atf::XmlElement::encodeAsXmlElement("nextLoBet", nextLoBet, _buf);
		Atf::XmlElement::encodeAsXmlElement("nextHiBet", nextHiBet, _buf);
		Atf::XmlElement::encodeAsXmlElement("nextBringIn", nextBringIn, _buf);
		Atf::XmlElement::encodeAsXmlElement("nextLevelStart_t", nextLevelStart_t, _buf);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "nextLevelStart", nextLevelStart);
	}
	Atf::XmlElement::encodeAsXmlElement("olympicLevel", olympicLevel, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournSubscr_Betting::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("loBet"))
		{
			loBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bringIn"))
		{
			bringIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("smallBlind"))
		{
			smallBlind = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("blindsLevel"))
		{
			blindsLevel = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextLevelOrdinal"))
		{
			nextLevelOrdinal = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextAnte"))
		{
			nextAnte = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextSmallBlind"))
		{
			nextSmallBlind = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextLoBet"))
		{
			nextLoBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextHiBet"))
		{
			nextHiBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextBringIn"))
		{
			nextBringIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextLevelStart_t"))
		{
			nextLevelStart_t = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextLevelStart"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, nextLevelStart);
		}
		else if (_element.equals("olympicLevel"))
		{
			olympicLevel = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameType"))
		{
			gameType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("limit"))
		{
			limit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournSubscr_Betting::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(loBet);
	_msg.composeUINT32(hiBet);
	_msg.composeUINT32(bringIn);
	_msg.composeUINT32(smallBlind);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(ante);
	_msg.composeBYTE(blindsLevel);
	_msg.composeBYTE(nextLevelOrdinal);
	if( nextLevelOrdinal )
	{
		_msg.composeUINT32(nextAnte);
		_msg.composeUINT32(nextSmallBlind);
		_msg.composeUINT32(nextLoBet);
		_msg.composeUINT32(nextHiBet);
		_msg.composeUINT32(nextBringIn);
		_msg.composeUINT32(nextLevelStart_t);
		_msg.composeSrvTime(nextLevelStart);
	}
	_msg.composeUINT16(olympicLevel);
	_msg.composeBYTE(gameType);
	_msg.composeBYTE(limit);
	_msg.composeBOOL(isHiLo);
}

void MTLobbyCli::publication::TournSubscr_Betting::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(loBet);
	_parser.parseUINT32(hiBet);
	_parser.parseUINT32(bringIn);
	_parser.parseUINT32(smallBlind);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(ante);
	_parser.parseBYTE(blindsLevel);
	_parser.parseBYTE(nextLevelOrdinal);
	if( nextLevelOrdinal )
	{
		_parser.parseUINT32(nextAnte);
		_parser.parseUINT32(nextSmallBlind);
		_parser.parseUINT32(nextLoBet);
		_parser.parseUINT32(nextHiBet);
		_parser.parseUINT32(nextBringIn);
		_parser.parseUINT32(nextLevelStart_t);
		_parser.parseSrvTime(nextLevelStart);
	}
	_parser.parseUINT16(olympicLevel);
	_parser.parseBYTE(gameType);
	_parser.parseBYTE(limit);
	_parser.parseBOOL(isHiLo);
}

const char *MTLobbyCli::publication::TournSubscr_Betting::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("bringIn", bringIn);
	_jsonstr.compose("smallBlind", smallBlind);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("blindsLevel", blindsLevel);
	_jsonstr.compose("nextLevelOrdinal", nextLevelOrdinal);
	if( nextLevelOrdinal )
	{
		_jsonstr.compose("nextAnte", nextAnte);
		_jsonstr.compose("nextSmallBlind", nextSmallBlind);
		_jsonstr.compose("nextLoBet", nextLoBet);
		_jsonstr.compose("nextHiBet", nextHiBet);
		_jsonstr.compose("nextBringIn", nextBringIn);
		_jsonstr.compose("nextLevelStart_t", nextLevelStart_t);
		_jsonstr.compose("nextLevelStart", nextLevelStart);
	}
	_jsonstr.compose("olympicLevel", olympicLevel);
	_jsonstr.compose("gameType", gameType);
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("isHiLo", isHiLo);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_Betting::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("bringIn", bringIn);
	_jparser.parseByNameThrow("smallBlind", smallBlind);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("blindsLevel", blindsLevel);
	_jparser.parseByNameThrow("nextLevelOrdinal", nextLevelOrdinal);
	if( nextLevelOrdinal )
	{
		_jparser.parseByNameThrow("nextAnte", nextAnte);
		_jparser.parseByNameThrow("nextSmallBlind", nextSmallBlind);
		_jparser.parseByNameThrow("nextLoBet", nextLoBet);
		_jparser.parseByNameThrow("nextHiBet", nextHiBet);
		_jparser.parseByNameThrow("nextBringIn", nextBringIn);
		_jparser.parseByNameThrow("nextLevelStart_t", nextLevelStart_t);
		_jparser.parseByNameThrow("nextLevelStart", nextLevelStart);
	}
	_jparser.parseByNameThrow("olympicLevel", olympicLevel);
	_jparser.parseByNameThrow("gameType", gameType);
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
}

/* static */ void MTLobbyCli::publication::TournSubscr_Betting::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE nextLevelOrdinal = 0;
	UINT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 bringIn; _jparser.validateByNameThrow("bringIn", bringIn);
	AtfValidator::validateInt(_descr, "bringIn", bringIn, _checker, __FILE__, __LINE__);
	UINT32 smallBlind; _jparser.validateByNameThrow("smallBlind", smallBlind);
	AtfValidator::validateInt(_descr, "smallBlind", smallBlind, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	BYTE blindsLevel; _jparser.validateByNameThrow("blindsLevel", blindsLevel);
	AtfValidator::validateInt(_descr, "blindsLevel", blindsLevel, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("nextLevelOrdinal", nextLevelOrdinal);
	AtfValidator::validateInt(_descr, "nextLevelOrdinal", nextLevelOrdinal, _checker, __FILE__, __LINE__);
	if( nextLevelOrdinal )
	{
		UINT32 nextAnte; _jparser.validateByNameThrow("nextAnte", nextAnte);
		AtfValidator::validateInt(_descr, "nextAnte", nextAnte, _checker, __FILE__, __LINE__);
		UINT32 nextSmallBlind; _jparser.validateByNameThrow("nextSmallBlind", nextSmallBlind);
		AtfValidator::validateInt(_descr, "nextSmallBlind", nextSmallBlind, _checker, __FILE__, __LINE__);
		UINT32 nextLoBet; _jparser.validateByNameThrow("nextLoBet", nextLoBet);
		AtfValidator::validateInt(_descr, "nextLoBet", nextLoBet, _checker, __FILE__, __LINE__);
		UINT32 nextHiBet; _jparser.validateByNameThrow("nextHiBet", nextHiBet);
		AtfValidator::validateInt(_descr, "nextHiBet", nextHiBet, _checker, __FILE__, __LINE__);
		UINT32 nextBringIn; _jparser.validateByNameThrow("nextBringIn", nextBringIn);
		AtfValidator::validateInt(_descr, "nextBringIn", nextBringIn, _checker, __FILE__, __LINE__);
		UINT32 nextLevelStart_t; _jparser.validateByNameThrow("nextLevelStart_t", nextLevelStart_t);
		AtfValidator::validateInt(_descr, "nextLevelStart_t", nextLevelStart_t, _checker, __FILE__, __LINE__);
		SrvTime nextLevelStart; _jparser.validateByNameThrow("nextLevelStart", nextLevelStart);
		AtfValidator::validateSrvDateTime(_descr, "nextLevelStart", nextLevelStart, _checker, __FILE__, __LINE__);
	}
	UINT16 olympicLevel; _jparser.validateByNameThrow("olympicLevel", olympicLevel);
	AtfValidator::validateInt(_descr, "olympicLevel", olympicLevel, _checker, __FILE__, __LINE__);
	BYTE gameType; _jparser.validateByNameThrow("gameType", gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	BYTE limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_Betting::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE nextLevelOrdinal = 0;
	UINT32 loBet; _parser.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 bringIn; _parser.parseUINT32(bringIn);
	AtfValidator::validateInt(_descr, "bringIn", bringIn, _checker, __FILE__, __LINE__);
	UINT32 smallBlind; _parser.parseUINT32(smallBlind);
	AtfValidator::validateInt(_descr, "smallBlind", smallBlind, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	BYTE blindsLevel; _parser.parseBYTE(blindsLevel);
	AtfValidator::validateInt(_descr, "blindsLevel", blindsLevel, _checker, __FILE__, __LINE__);
	_parser.parseBYTE(nextLevelOrdinal);
	AtfValidator::validateInt(_descr, "nextLevelOrdinal", nextLevelOrdinal, _checker, __FILE__, __LINE__);
	if( nextLevelOrdinal )
	{
		UINT32 nextAnte; _parser.parseUINT32(nextAnte);
		AtfValidator::validateInt(_descr, "nextAnte", nextAnte, _checker, __FILE__, __LINE__);
		UINT32 nextSmallBlind; _parser.parseUINT32(nextSmallBlind);
		AtfValidator::validateInt(_descr, "nextSmallBlind", nextSmallBlind, _checker, __FILE__, __LINE__);
		UINT32 nextLoBet; _parser.parseUINT32(nextLoBet);
		AtfValidator::validateInt(_descr, "nextLoBet", nextLoBet, _checker, __FILE__, __LINE__);
		UINT32 nextHiBet; _parser.parseUINT32(nextHiBet);
		AtfValidator::validateInt(_descr, "nextHiBet", nextHiBet, _checker, __FILE__, __LINE__);
		UINT32 nextBringIn; _parser.parseUINT32(nextBringIn);
		AtfValidator::validateInt(_descr, "nextBringIn", nextBringIn, _checker, __FILE__, __LINE__);
		UINT32 nextLevelStart_t; _parser.parseUINT32(nextLevelStart_t);
		AtfValidator::validateInt(_descr, "nextLevelStart_t", nextLevelStart_t, _checker, __FILE__, __LINE__);
		SrvTime nextLevelStart; _parser.parseSrvTime(nextLevelStart);
		AtfValidator::validateSrvDateTime(_descr, "nextLevelStart", nextLevelStart, _checker, __FILE__, __LINE__);
	}
	UINT16 olympicLevel; _parser.parseUINT16(olympicLevel);
	AtfValidator::validateInt(_descr, "olympicLevel", olympicLevel, _checker, __FILE__, __LINE__);
	BYTE gameType; _parser.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	BYTE limit; _parser.parseBYTE(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Status
//=================================================================

MTLobbyCli::publication::TournSubscr_Status::TournSubscr_Status()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_Status::TournSubscr_Status(TournSubscr_Status&& _o)
	: status(std::move(_o.status))
	, newStartTimeFlightTourn(std::move(_o.newStartTimeFlightTourn))
	, minutesLateFlightTourn(std::move(_o.minutesLateFlightTourn))
	, createdBy(std::move(_o.createdBy))
	, cancelledBy(std::move(_o.cancelledBy))
	, isBlitzTourn(std::move(_o.isBlitzTourn))
	, timedTournPlayersThreshold(std::move(_o.timedTournPlayersThreshold))
	, sameLevelFlightsAvailable(std::move(_o.sameLevelFlightsAvailable))
	, nextLevelFlightsAvailable(std::move(_o.nextLevelFlightsAvailable))
	, delayedPlaceDelta(std::move(_o.delayedPlaceDelta))
	, activeFlags(std::move(_o.activeFlags))
	, isWinTheButtonTourn(std::move(_o.isWinTheButtonTourn))
{
}

MTLobbyCli::publication::TournSubscr_Status& MTLobbyCli::publication::TournSubscr_Status::operator=(TournSubscr_Status&& _o)
{
	if(this != &_o)
	{
		status = std::move(_o.status);
		newStartTimeFlightTourn = std::move(_o.newStartTimeFlightTourn);
		minutesLateFlightTourn = std::move(_o.minutesLateFlightTourn);
		createdBy = std::move(_o.createdBy);
		cancelledBy = std::move(_o.cancelledBy);
		isBlitzTourn = std::move(_o.isBlitzTourn);
		timedTournPlayersThreshold = std::move(_o.timedTournPlayersThreshold);
		sameLevelFlightsAvailable = std::move(_o.sameLevelFlightsAvailable);
		nextLevelFlightsAvailable = std::move(_o.nextLevelFlightsAvailable);
		delayedPlaceDelta = std::move(_o.delayedPlaceDelta);
		activeFlags = std::move(_o.activeFlags);
		isWinTheButtonTourn = std::move(_o.isWinTheButtonTourn);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_Status::clear()
{
	status = 0;
	newStartTimeFlightTourn.setNull();
	minutesLateFlightTourn = 0;
	createdBy.clear();
	cancelledBy.clear();
	isBlitzTourn = false;
	timedTournPlayersThreshold = 0;
	sameLevelFlightsAvailable = false;
	nextLevelFlightsAvailable = false;
	delayedPlaceDelta = 0;
	activeFlags = 0;
	isWinTheButtonTourn = false;
}

bool MTLobbyCli::publication::TournSubscr_Status::equals(const TournSubscr_Status& _o) const
{
	return status == _o.status &&
		newStartTimeFlightTourn.equals(_o.newStartTimeFlightTourn) &&
		minutesLateFlightTourn == _o.minutesLateFlightTourn &&
		Atf::atfPStringEquals(createdBy, _o.createdBy) &&
		Atf::atfPStringEquals(cancelledBy, _o.cancelledBy) &&
		isBlitzTourn == _o.isBlitzTourn &&
		timedTournPlayersThreshold == _o.timedTournPlayersThreshold &&
		sameLevelFlightsAvailable == _o.sameLevelFlightsAvailable &&
		nextLevelFlightsAvailable == _o.nextLevelFlightsAvailable &&
		delayedPlaceDelta == _o.delayedPlaceDelta &&
		activeFlags == _o.activeFlags &&
		isWinTheButtonTourn == _o.isWinTheButtonTourn;
}

const char *MTLobbyCli::publication::TournSubscr_Status::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("newStartTimeFlightTourn=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, newStartTimeFlightTourn);
	_buf.append(',');
	_buf.append("minutesLateFlightTourn=");
	_buf.appendUint(minutesLateFlightTourn);
	_buf.append(',');
	_buf.append("createdBy=");
	_buf.append(createdBy);
	_buf.append(',');
	_buf.append("cancelledBy=");
	_buf.append(cancelledBy);
	_buf.append(',');
	_buf.append("isBlitzTourn=");
	_buf.appendUint(isBlitzTourn);
	_buf.append(',');
	_buf.append("timedTournPlayersThreshold=");
	_buf.appendUint(timedTournPlayersThreshold);
	_buf.append(',');
	_buf.append("sameLevelFlightsAvailable=");
	_buf.appendUint(sameLevelFlightsAvailable);
	_buf.append(',');
	_buf.append("nextLevelFlightsAvailable=");
	_buf.appendUint(nextLevelFlightsAvailable);
	_buf.append(',');
	_buf.append("delayedPlaceDelta=");
	_buf.appendInt(delayedPlaceDelta);
	_buf.append(',');
	_buf.append("activeFlags=");
	_buf.appendUint(activeFlags);
	_buf.append(',');
	_buf.append("isWinTheButtonTourn=");
	_buf.appendUint(isWinTheButtonTourn);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournSubscr_Status::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "newStartTimeFlightTourn", newStartTimeFlightTourn);
	Atf::XmlElement::encodeAsXmlElement("minutesLateFlightTourn", minutesLateFlightTourn, _buf);
	Atf::XmlElement::encodeAsXmlElement("createdBy", createdBy, _buf);
	Atf::XmlElement::encodeAsXmlElement("cancelledBy", cancelledBy, _buf);
	Atf::XmlElement::encodeAsXmlElement("isBlitzTourn", isBlitzTourn, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournPlayersThreshold", timedTournPlayersThreshold, _buf);
	Atf::XmlElement::encodeAsXmlElement("sameLevelFlightsAvailable", sameLevelFlightsAvailable, _buf);
	Atf::XmlElement::encodeAsXmlElement("nextLevelFlightsAvailable", nextLevelFlightsAvailable, _buf);
	Atf::XmlElement::encodeAsXmlElement("delayedPlaceDelta", delayedPlaceDelta, _buf);
	Atf::XmlElement::encodeAsXmlElement("activeFlags", activeFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("isWinTheButtonTourn", isWinTheButtonTourn, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournSubscr_Status::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("newStartTimeFlightTourn"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, newStartTimeFlightTourn);
		}
		else if (_element.equals("minutesLateFlightTourn"))
		{
			minutesLateFlightTourn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("createdBy"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, createdBy)) return false;
		}
		else if (_element.equals("cancelledBy"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cancelledBy)) return false;
		}
		else if (_element.equals("isBlitzTourn"))
		{
			isBlitzTourn = (*_value.ptr() == '1');
		}
		else if (_element.equals("timedTournPlayersThreshold"))
		{
			timedTournPlayersThreshold = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sameLevelFlightsAvailable"))
		{
			sameLevelFlightsAvailable = (*_value.ptr() == '1');
		}
		else if (_element.equals("nextLevelFlightsAvailable"))
		{
			nextLevelFlightsAvailable = (*_value.ptr() == '1');
		}
		else if (_element.equals("delayedPlaceDelta"))
		{
			delayedPlaceDelta = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("activeFlags"))
		{
			activeFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isWinTheButtonTourn"))
		{
			isWinTheButtonTourn = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournSubscr_Status::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(status);
	_msg.composeSrvTime(newStartTimeFlightTourn);
	_msg.composeUINT32(minutesLateFlightTourn);
	_msg.composeString(createdBy);
	_msg.composeString(cancelledBy);
	_msg.composeBOOL(isBlitzTourn);
	_msg.composeUINT32(timedTournPlayersThreshold);
	_msg.composeBOOL(sameLevelFlightsAvailable);
	_msg.composeBOOL(nextLevelFlightsAvailable);
	_msg.composeINT32(delayedPlaceDelta);
	_msg.composeUINT32(activeFlags);
	_msg.composeBOOL(isWinTheButtonTourn);
}

void MTLobbyCli::publication::TournSubscr_Status::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(status);
	_parser.parseSrvTime(newStartTimeFlightTourn);
	_parser.parseUINT32(minutesLateFlightTourn);
	_parser.parseStringP(createdBy);
	_parser.parseStringP(cancelledBy);
	_parser.parseBOOL(isBlitzTourn);
	_parser.parseUINT32(timedTournPlayersThreshold);
	_parser.parseBOOL(sameLevelFlightsAvailable);
	_parser.parseBOOL(nextLevelFlightsAvailable);
	_parser.parseINT32(delayedPlaceDelta);
	_parser.parseUINT32(activeFlags);
	_parser.parseBOOL(isWinTheButtonTourn);
}

const char *MTLobbyCli::publication::TournSubscr_Status::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("status", status);
	_jsonstr.compose("newStartTimeFlightTourn", newStartTimeFlightTourn);
	_jsonstr.compose("minutesLateFlightTourn", minutesLateFlightTourn);
	_jsonstr.compose("createdBy", createdBy);
	_jsonstr.compose("cancelledBy", cancelledBy);
	_jsonstr.compose("isBlitzTourn", isBlitzTourn);
	_jsonstr.compose("timedTournPlayersThreshold", timedTournPlayersThreshold);
	_jsonstr.compose("sameLevelFlightsAvailable", sameLevelFlightsAvailable);
	_jsonstr.compose("nextLevelFlightsAvailable", nextLevelFlightsAvailable);
	_jsonstr.compose("delayedPlaceDelta", delayedPlaceDelta);
	_jsonstr.compose("activeFlags", activeFlags);
	_jsonstr.compose("isWinTheButtonTourn", isWinTheButtonTourn);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_Status::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("newStartTimeFlightTourn", newStartTimeFlightTourn);
	_jparser.parseByNameThrow("minutesLateFlightTourn", minutesLateFlightTourn);
	_jparser.parseByNameThrow("createdBy", createdBy);
	_jparser.parseByNameThrow("cancelledBy", cancelledBy);
	_jparser.parseByNameThrow("isBlitzTourn", isBlitzTourn);
	_jparser.parseByNameThrow("timedTournPlayersThreshold", timedTournPlayersThreshold);
	_jparser.parseByNameThrow("sameLevelFlightsAvailable", sameLevelFlightsAvailable);
	_jparser.parseByNameThrow("nextLevelFlightsAvailable", nextLevelFlightsAvailable);
	_jparser.parseByNameThrow("delayedPlaceDelta", delayedPlaceDelta);
	_jparser.parseByNameThrow("activeFlags", activeFlags);
	_jparser.parseByNameThrow("isWinTheButtonTourn", isWinTheButtonTourn);
}

/* static */ void MTLobbyCli::publication::TournSubscr_Status::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	SrvTime newStartTimeFlightTourn; _jparser.validateByNameThrow("newStartTimeFlightTourn", newStartTimeFlightTourn);
	AtfValidator::validateSrvDateTime(_descr, "newStartTimeFlightTourn", newStartTimeFlightTourn, _checker, __FILE__, __LINE__);
	UINT32 minutesLateFlightTourn; _jparser.validateByNameThrow("minutesLateFlightTourn", minutesLateFlightTourn);
	AtfValidator::validateInt(_descr, "minutesLateFlightTourn", minutesLateFlightTourn, _checker, __FILE__, __LINE__);
	PString createdBy; _jparser.validateByNameThrow("createdBy", createdBy);
	AtfValidator::validateInt(_descr, "createdBy", createdBy.length(), _checker, __FILE__, __LINE__);
	PString cancelledBy; _jparser.validateByNameThrow("cancelledBy", cancelledBy);
	AtfValidator::validateInt(_descr, "cancelledBy", cancelledBy.length(), _checker, __FILE__, __LINE__);
	bool isBlitzTourn; _jparser.validateByNameThrow("isBlitzTourn", isBlitzTourn);
	AtfValidator::validateInt(_descr, "isBlitzTourn", isBlitzTourn, _checker, __FILE__, __LINE__);
	UINT32 timedTournPlayersThreshold; _jparser.validateByNameThrow("timedTournPlayersThreshold", timedTournPlayersThreshold);
	AtfValidator::validateInt(_descr, "timedTournPlayersThreshold", timedTournPlayersThreshold, _checker, __FILE__, __LINE__);
	bool sameLevelFlightsAvailable; _jparser.validateByNameThrow("sameLevelFlightsAvailable", sameLevelFlightsAvailable);
	AtfValidator::validateInt(_descr, "sameLevelFlightsAvailable", sameLevelFlightsAvailable, _checker, __FILE__, __LINE__);
	bool nextLevelFlightsAvailable; _jparser.validateByNameThrow("nextLevelFlightsAvailable", nextLevelFlightsAvailable);
	AtfValidator::validateInt(_descr, "nextLevelFlightsAvailable", nextLevelFlightsAvailable, _checker, __FILE__, __LINE__);
	INT32 delayedPlaceDelta; _jparser.validateByNameThrow("delayedPlaceDelta", delayedPlaceDelta);
	AtfValidator::validateInt(_descr, "delayedPlaceDelta", delayedPlaceDelta, _checker, __FILE__, __LINE__);
	UINT32 activeFlags; _jparser.validateByNameThrow("activeFlags", activeFlags);
	AtfValidator::validateInt(_descr, "activeFlags", activeFlags, _checker, __FILE__, __LINE__);
	bool isWinTheButtonTourn; _jparser.validateByNameThrow("isWinTheButtonTourn", isWinTheButtonTourn);
	AtfValidator::validateInt(_descr, "isWinTheButtonTourn", isWinTheButtonTourn, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_Status::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	SrvTime newStartTimeFlightTourn; _parser.parseSrvTime(newStartTimeFlightTourn);
	AtfValidator::validateSrvDateTime(_descr, "newStartTimeFlightTourn", newStartTimeFlightTourn, _checker, __FILE__, __LINE__);
	UINT32 minutesLateFlightTourn; _parser.parseUINT32(minutesLateFlightTourn);
	AtfValidator::validateInt(_descr, "minutesLateFlightTourn", minutesLateFlightTourn, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "createdBy"); size_t szCreatedBy = strlen(_dummy);
	AtfValidator::validateInt(_descr, "createdBy", szCreatedBy, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cancelledBy"); size_t szCancelledBy = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cancelledBy", szCancelledBy, _checker, __FILE__, __LINE__);
	bool isBlitzTourn; _parser.parseBOOL(isBlitzTourn);
	AtfValidator::validateInt(_descr, "isBlitzTourn", isBlitzTourn, _checker, __FILE__, __LINE__);
	UINT32 timedTournPlayersThreshold; _parser.parseUINT32(timedTournPlayersThreshold);
	AtfValidator::validateInt(_descr, "timedTournPlayersThreshold", timedTournPlayersThreshold, _checker, __FILE__, __LINE__);
	bool sameLevelFlightsAvailable; _parser.parseBOOL(sameLevelFlightsAvailable);
	AtfValidator::validateInt(_descr, "sameLevelFlightsAvailable", sameLevelFlightsAvailable, _checker, __FILE__, __LINE__);
	bool nextLevelFlightsAvailable; _parser.parseBOOL(nextLevelFlightsAvailable);
	AtfValidator::validateInt(_descr, "nextLevelFlightsAvailable", nextLevelFlightsAvailable, _checker, __FILE__, __LINE__);
	INT32 delayedPlaceDelta; _parser.parseINT32(delayedPlaceDelta);
	AtfValidator::validateInt(_descr, "delayedPlaceDelta", delayedPlaceDelta, _checker, __FILE__, __LINE__);
	UINT32 activeFlags; _parser.parseUINT32(activeFlags);
	AtfValidator::validateInt(_descr, "activeFlags", activeFlags, _checker, __FILE__, __LINE__);
	bool isWinTheButtonTourn; _parser.parseBOOL(isWinTheButtonTourn);
	AtfValidator::validateInt(_descr, "isWinTheButtonTourn", isWinTheButtonTourn, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Break
//=================================================================

MTLobbyCli::publication::TournSubscr_Break::TournSubscr_Break()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_Break::TournSubscr_Break(TournSubscr_Break&& _o)
	: nextBreakStarts(std::move(_o.nextBreakStarts))
	, currentBreakStops(std::move(_o.currentBreakStops))
	, currentBreakDuration(std::move(_o.currentBreakDuration))
	, nextBreakStarts_t(std::move(_o.nextBreakStarts_t))
	, currentBreakStops_t(std::move(_o.currentBreakStops_t))
	, addOnEligibleBreak(std::move(_o.addOnEligibleBreak))
	, blitzTableRound(std::move(_o.blitzTableRound))
	, message(std::move(_o.message))
{
}

MTLobbyCli::publication::TournSubscr_Break& MTLobbyCli::publication::TournSubscr_Break::operator=(TournSubscr_Break&& _o)
{
	if(this != &_o)
	{
		nextBreakStarts = std::move(_o.nextBreakStarts);
		currentBreakStops = std::move(_o.currentBreakStops);
		currentBreakDuration = std::move(_o.currentBreakDuration);
		nextBreakStarts_t = std::move(_o.nextBreakStarts_t);
		currentBreakStops_t = std::move(_o.currentBreakStops_t);
		addOnEligibleBreak = std::move(_o.addOnEligibleBreak);
		blitzTableRound = std::move(_o.blitzTableRound);
		message = std::move(_o.message);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_Break::clear()
{
	nextBreakStarts.setNull();
	currentBreakStops.setNull();
	currentBreakDuration = 0;
	nextBreakStarts_t = 0;
	currentBreakStops_t = 0;
	addOnEligibleBreak = false;
	blitzTableRound = 0;
	message.clear();
}

bool MTLobbyCli::publication::TournSubscr_Break::equals(const TournSubscr_Break& _o) const
{
	return nextBreakStarts.equals(_o.nextBreakStarts) &&
		currentBreakStops.equals(_o.currentBreakStops) &&
		currentBreakDuration == _o.currentBreakDuration &&
		nextBreakStarts_t == _o.nextBreakStarts_t &&
		currentBreakStops_t == _o.currentBreakStops_t &&
		addOnEligibleBreak == _o.addOnEligibleBreak &&
		blitzTableRound == _o.blitzTableRound &&
		message.equals(_o.message);
}

const char *MTLobbyCli::publication::TournSubscr_Break::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("nextBreakStarts=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, nextBreakStarts);
	_buf.append(',');
	_buf.append("currentBreakStops=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, currentBreakStops);
	_buf.append(',');
	_buf.append("currentBreakDuration=");
	_buf.appendUint(currentBreakDuration);
	_buf.append(',');
	_buf.append("nextBreakStarts_t=");
	_buf.appendUint(nextBreakStarts_t);
	_buf.append(',');
	_buf.append("currentBreakStops_t=");
	_buf.appendUint(currentBreakStops_t);
	_buf.append(',');
	_buf.append("addOnEligibleBreak=");
	_buf.appendUint(addOnEligibleBreak);
	_buf.append(',');
	_buf.append("blitzTableRound=");
	_buf.appendUint(blitzTableRound);
	_buf.append(',');
	_buf.append("message=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, message);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournSubscr_Break::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "nextBreakStarts", nextBreakStarts);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "currentBreakStops", currentBreakStops);
	Atf::XmlElement::encodeAsXmlElement("currentBreakDuration", currentBreakDuration, _buf);
	Atf::XmlElement::encodeAsXmlElement("nextBreakStarts_t", nextBreakStarts_t, _buf);
	Atf::XmlElement::encodeAsXmlElement("currentBreakStops_t", currentBreakStops_t, _buf);
	Atf::XmlElement::encodeAsXmlElement("addOnEligibleBreak", addOnEligibleBreak, _buf);
	Atf::XmlElement::encodeAsXmlElement("blitzTableRound", blitzTableRound, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "message", message);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournSubscr_Break::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("nextBreakStarts"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, nextBreakStarts);
		}
		else if (_element.equals("currentBreakStops"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, currentBreakStops);
		}
		else if (_element.equals("currentBreakDuration"))
		{
			currentBreakDuration = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextBreakStarts_t"))
		{
			nextBreakStarts_t = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currentBreakStops_t"))
		{
			currentBreakStops_t = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("addOnEligibleBreak"))
		{
			addOnEligibleBreak = (*_value.ptr() == '1');
		}
		else if (_element.equals("blitzTableRound"))
		{
			blitzTableRound = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("message"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, message);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournSubscr_Break::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(nextBreakStarts);
	_msg.composeSrvTime(currentBreakStops);
	_msg.composeUINT32(currentBreakDuration);
	_msg.composeUINT32(nextBreakStarts_t);
	_msg.composeUINT32(currentBreakStops_t);
	_msg.composeBOOL(addOnEligibleBreak);
	_msg.composeUINT32(blitzTableRound);
	message.compose(_msg);
}

void MTLobbyCli::publication::TournSubscr_Break::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(nextBreakStarts);
	_parser.parseSrvTime(currentBreakStops);
	_parser.parseUINT32(currentBreakDuration);
	_parser.parseUINT32(nextBreakStarts_t);
	_parser.parseUINT32(currentBreakStops_t);
	_parser.parseBOOL(addOnEligibleBreak);
	_parser.parseUINT32(blitzTableRound);
	message.parse(_parser);
}

const char *MTLobbyCli::publication::TournSubscr_Break::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("nextBreakStarts", nextBreakStarts);
	_jsonstr.compose("currentBreakStops", currentBreakStops);
	_jsonstr.compose("currentBreakDuration", currentBreakDuration);
	_jsonstr.compose("nextBreakStarts_t", nextBreakStarts_t);
	_jsonstr.compose("currentBreakStops_t", currentBreakStops_t);
	_jsonstr.compose("addOnEligibleBreak", addOnEligibleBreak);
	_jsonstr.compose("blitzTableRound", blitzTableRound);
	_jsonstr.compose("message", message);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_Break::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("nextBreakStarts", nextBreakStarts);
	_jparser.parseByNameThrow("currentBreakStops", currentBreakStops);
	_jparser.parseByNameThrow("currentBreakDuration", currentBreakDuration);
	_jparser.parseByNameThrow("nextBreakStarts_t", nextBreakStarts_t);
	_jparser.parseByNameThrow("currentBreakStops_t", currentBreakStops_t);
	_jparser.parseByNameThrow("addOnEligibleBreak", addOnEligibleBreak);
	_jparser.parseByNameThrow("blitzTableRound", blitzTableRound);
	_jparser.parseByNameThrow("message", message);
}

/* static */ void MTLobbyCli::publication::TournSubscr_Break::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime nextBreakStarts; _jparser.validateByNameThrow("nextBreakStarts", nextBreakStarts);
	AtfValidator::validateSrvDateTime(_descr, "nextBreakStarts", nextBreakStarts, _checker, __FILE__, __LINE__);
	SrvTime currentBreakStops; _jparser.validateByNameThrow("currentBreakStops", currentBreakStops);
	AtfValidator::validateSrvDateTime(_descr, "currentBreakStops", currentBreakStops, _checker, __FILE__, __LINE__);
	UINT32 currentBreakDuration; _jparser.validateByNameThrow("currentBreakDuration", currentBreakDuration);
	AtfValidator::validateInt(_descr, "currentBreakDuration", currentBreakDuration, _checker, __FILE__, __LINE__);
	UINT32 nextBreakStarts_t; _jparser.validateByNameThrow("nextBreakStarts_t", nextBreakStarts_t);
	AtfValidator::validateInt(_descr, "nextBreakStarts_t", nextBreakStarts_t, _checker, __FILE__, __LINE__);
	UINT32 currentBreakStops_t; _jparser.validateByNameThrow("currentBreakStops_t", currentBreakStops_t);
	AtfValidator::validateInt(_descr, "currentBreakStops_t", currentBreakStops_t, _checker, __FILE__, __LINE__);
	bool addOnEligibleBreak; _jparser.validateByNameThrow("addOnEligibleBreak", addOnEligibleBreak);
	AtfValidator::validateInt(_descr, "addOnEligibleBreak", addOnEligibleBreak, _checker, __FILE__, __LINE__);
	UINT32 blitzTableRound; _jparser.validateByNameThrow("blitzTableRound", blitzTableRound);
	AtfValidator::validateInt(_descr, "blitzTableRound", blitzTableRound, _checker, __FILE__, __LINE__);
	I18nPString message; _jparser.validateByNameThrow("message", message);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_Break::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	SrvTime nextBreakStarts; _parser.parseSrvTime(nextBreakStarts);
	AtfValidator::validateSrvDateTime(_descr, "nextBreakStarts", nextBreakStarts, _checker, __FILE__, __LINE__);
	SrvTime currentBreakStops; _parser.parseSrvTime(currentBreakStops);
	AtfValidator::validateSrvDateTime(_descr, "currentBreakStops", currentBreakStops, _checker, __FILE__, __LINE__);
	UINT32 currentBreakDuration; _parser.parseUINT32(currentBreakDuration);
	AtfValidator::validateInt(_descr, "currentBreakDuration", currentBreakDuration, _checker, __FILE__, __LINE__);
	UINT32 nextBreakStarts_t; _parser.parseUINT32(nextBreakStarts_t);
	AtfValidator::validateInt(_descr, "nextBreakStarts_t", nextBreakStarts_t, _checker, __FILE__, __LINE__);
	UINT32 currentBreakStops_t; _parser.parseUINT32(currentBreakStops_t);
	AtfValidator::validateInt(_descr, "currentBreakStops_t", currentBreakStops_t, _checker, __FILE__, __LINE__);
	bool addOnEligibleBreak; _parser.parseBOOL(addOnEligibleBreak);
	AtfValidator::validateInt(_descr, "addOnEligibleBreak", addOnEligibleBreak, _checker, __FILE__, __LINE__);
	UINT32 blitzTableRound; _parser.parseUINT32(blitzTableRound);
	AtfValidator::validateInt(_descr, "blitzTableRound", blitzTableRound, _checker, __FILE__, __LINE__);
	I18nPString message; message.parse(_parser);
}

//=================================================================
//                    TournSubscr_Awards
//=================================================================

MTLobbyCli::publication::TournSubscr_Awards::TournSubscr_Awards()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_Awards::TournSubscr_Awards(TournSubscr_Awards&& _o)
	: effectivePrizePool(std::move(_o.effectivePrizePool))
	, prizes(std::move(_o.prizes))
	, numTicketsWithTournId(std::move(_o.numTicketsWithTournId))
	, tickets(std::move(_o.tickets))
	, additionalPrize(std::move(_o.additionalPrize))
	, mixTournSatellite(std::move(_o.mixTournSatellite))
{
}

MTLobbyCli::publication::TournSubscr_Awards& MTLobbyCli::publication::TournSubscr_Awards::operator=(TournSubscr_Awards&& _o)
{
	if(this != &_o)
	{
		effectivePrizePool = std::move(_o.effectivePrizePool);
		prizes = std::move(_o.prizes);
		numTicketsWithTournId = std::move(_o.numTicketsWithTournId);
		tickets = std::move(_o.tickets);
		additionalPrize = std::move(_o.additionalPrize);
		mixTournSatellite = std::move(_o.mixTournSatellite);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_Awards::clear()
{
	effectivePrizePool = 0;
	prizes.clear();
	numTicketsWithTournId = 0;
	tickets.clear();
	additionalPrize = 0;
	mixTournSatellite = 0;
}

bool MTLobbyCli::publication::TournSubscr_Awards::equals(const TournSubscr_Awards& _o) const
{
	return effectivePrizePool == _o.effectivePrizePool &&
		prizes.equals(_o.prizes) &&
		numTicketsWithTournId == _o.numTicketsWithTournId &&
		tickets.equals(_o.tickets) &&
		additionalPrize == _o.additionalPrize &&
		mixTournSatellite == _o.mixTournSatellite;
}

const char *MTLobbyCli::publication::TournSubscr_Awards::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("effectivePrizePool=");
	_buf.appendUint(effectivePrizePool);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("numTicketsWithTournId=");
	_buf.appendUint(numTicketsWithTournId);
	_buf.append(',');
	_buf.append("tickets=");
	tickets.toTraceString(_buf);
	_buf.append(',');
	_buf.append("additionalPrize=");
	_buf.appendUint(additionalPrize);
	_buf.append(',');
	_buf.append("mixTournSatellite=");
	_buf.appendUint(mixTournSatellite);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournSubscr_Awards::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("effectivePrizePool", effectivePrizePool, _buf);
	prizes.toXmlString("prizes", _buf);
	Atf::XmlElement::encodeAsXmlElement("numTicketsWithTournId", numTicketsWithTournId, _buf);
	tickets.toXmlString("tickets", _buf);
	Atf::XmlElement::encodeAsXmlElement("additionalPrize", additionalPrize, _buf);
	Atf::XmlElement::encodeAsXmlElement("mixTournSatellite", mixTournSatellite, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournSubscr_Awards::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("effectivePrizePool"))
		{
			effectivePrizePool = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32 , 4 > >::FromXmlString(_value, prizes)) return false;
		}
		else if (_element.equals("numTicketsWithTournId"))
		{
			numTicketsWithTournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tickets"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32 , 4 > >::FromXmlString(_value, tickets)) return false;
		}
		else if (_element.equals("additionalPrize"))
		{
			additionalPrize = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("mixTournSatellite"))
		{
			mixTournSatellite = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournSubscr_Awards::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(effectivePrizePool);
	prizes.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(numTicketsWithTournId);
	tickets.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(additionalPrize);
	_msg.composeBYTE(mixTournSatellite);
}

void MTLobbyCli::publication::TournSubscr_Awards::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(effectivePrizePool);
	prizes.parseMsg(_parser);
	_parser.parseUINT32(numTicketsWithTournId);
	tickets.parseMsg(_parser);
	_parser.parseUINT32(additionalPrize);
	_parser.parseBYTE(mixTournSatellite);
}

const char *MTLobbyCli::publication::TournSubscr_Awards::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("effectivePrizePool", effectivePrizePool);
	_jsonstr.compose("prizes", prizes);
	_jsonstr.compose("numTicketsWithTournId", numTicketsWithTournId);
	_jsonstr.compose("tickets", tickets);
	_jsonstr.compose("additionalPrize", additionalPrize);
	_jsonstr.compose("mixTournSatellite", mixTournSatellite);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_Awards::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("effectivePrizePool", effectivePrizePool);
	_jparser.parseByNameThrow("prizes", prizes);
	_jparser.parseByNameThrow("numTicketsWithTournId", numTicketsWithTournId);
	_jparser.parseByNameThrow("tickets", tickets);
	_jparser.parseByNameThrow("additionalPrize", additionalPrize);
	_jparser.parseByNameThrow("mixTournSatellite", mixTournSatellite);
}

/* static */ void MTLobbyCli::publication::TournSubscr_Awards::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 effectivePrizePool; _jparser.validateByNameThrow("effectivePrizePool", effectivePrizePool);
	AtfValidator::validateInt(_descr, "effectivePrizePool", effectivePrizePool, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > prizes; _jparser.validateByNameThrow("prizes", prizes);
	AtfValidator::validateInt(_descr, "prizes", prizes.size(), _checker, __FILE__, __LINE__);
	UINT32 numTicketsWithTournId; _jparser.validateByNameThrow("numTicketsWithTournId", numTicketsWithTournId);
	AtfValidator::validateInt(_descr, "numTicketsWithTournId", numTicketsWithTournId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > tickets; _jparser.validateByNameThrow("tickets", tickets);
	AtfValidator::validateInt(_descr, "tickets", tickets.size(), _checker, __FILE__, __LINE__);
	UINT32 additionalPrize; _jparser.validateByNameThrow("additionalPrize", additionalPrize);
	AtfValidator::validateInt(_descr, "additionalPrize", additionalPrize, _checker, __FILE__, __LINE__);
	BYTE mixTournSatellite; _jparser.validateByNameThrow("mixTournSatellite", mixTournSatellite);
	AtfValidator::validateInt(_descr, "mixTournSatellite", mixTournSatellite, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_Awards::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 effectivePrizePool; _parser.parseUINT32(effectivePrizePool);
	AtfValidator::validateInt(_descr, "effectivePrizePool", effectivePrizePool, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPrizes = Atf::LAtfVector< UINT32 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
	UINT32 numTicketsWithTournId; _parser.parseUINT32(numTicketsWithTournId);
	AtfValidator::validateInt(_descr, "numTicketsWithTournId", numTicketsWithTournId, _checker, __FILE__, __LINE__);
	int szTickets = Atf::LAtfVector< UINT32 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
	UINT32 additionalPrize; _parser.parseUINT32(additionalPrize);
	AtfValidator::validateInt(_descr, "additionalPrize", additionalPrize, _checker, __FILE__, __LINE__);
	BYTE mixTournSatellite; _parser.parseBYTE(mixTournSatellite);
	AtfValidator::validateInt(_descr, "mixTournSatellite", mixTournSatellite, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_AddOn
//=================================================================

MTLobbyCli::publication::TournSubscr_AddOn::TournSubscr_AddOn()
{
	clear();
}

void MTLobbyCli::publication::TournSubscr_AddOn::clear()
{
	waiting = 0;
}

bool MTLobbyCli::publication::TournSubscr_AddOn::equals(const TournSubscr_AddOn& _o) const
{
	return waiting == _o.waiting;
}

const char *MTLobbyCli::publication::TournSubscr_AddOn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("waiting=");
	_buf.appendUint(waiting);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournSubscr_AddOn::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("waiting", waiting, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournSubscr_AddOn::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("waiting"))
		{
			waiting = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournSubscr_AddOn::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(waiting);
}

void MTLobbyCli::publication::TournSubscr_AddOn::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(waiting);
}

const char *MTLobbyCli::publication::TournSubscr_AddOn::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("waiting", waiting);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_AddOn::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("waiting", waiting);
}

/* static */ void MTLobbyCli::publication::TournSubscr_AddOn::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE waiting; _jparser.validateByNameThrow("waiting", waiting);
	AtfValidator::validateInt(_descr, "waiting", waiting, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_AddOn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE waiting; _parser.parseBYTE(waiting);
	AtfValidator::validateInt(_descr, "waiting", waiting, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_PrizePool
//=================================================================

MTLobbyCli::publication::TournSubscr_PrizePool::TournSubscr_PrizePool()
{
	clear();
}

void MTLobbyCli::publication::TournSubscr_PrizePool::clear()
{
	numUsers = 0;
	prizePoolToPublish = 0;
	totalRebuysDone = 0;
	totalAddonsDone = 0;
	payouts = 0;
	flightIntermediatePayoutPrizePool = 0;
	flightIntermediatePayoutPerUser = 0;
}

bool MTLobbyCli::publication::TournSubscr_PrizePool::equals(const TournSubscr_PrizePool& _o) const
{
	return numUsers == _o.numUsers &&
		prizePoolToPublish == _o.prizePoolToPublish &&
		totalRebuysDone == _o.totalRebuysDone &&
		totalAddonsDone == _o.totalAddonsDone &&
		payouts == _o.payouts &&
		flightIntermediatePayoutPrizePool == _o.flightIntermediatePayoutPrizePool &&
		flightIntermediatePayoutPerUser == _o.flightIntermediatePayoutPerUser;
}

const char *MTLobbyCli::publication::TournSubscr_PrizePool::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numUsers=");
	_buf.appendUint(numUsers);
	_buf.append(',');
	_buf.append("prizePoolToPublish=");
	_buf.appendInt(prizePoolToPublish);
	_buf.append(',');
	_buf.append("totalRebuysDone=");
	_buf.appendUint(totalRebuysDone);
	_buf.append(',');
	_buf.append("totalAddonsDone=");
	_buf.appendUint(totalAddonsDone);
	_buf.append(',');
	_buf.append("payouts=");
	_buf.appendInt(payouts);
	_buf.append(',');
	_buf.append("flightIntermediatePayoutPrizePool=");
	_buf.appendInt(flightIntermediatePayoutPrizePool);
	_buf.append(',');
	_buf.append("flightIntermediatePayoutPerUser=");
	_buf.appendInt(flightIntermediatePayoutPerUser);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournSubscr_PrizePool::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("numUsers", numUsers, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePoolToPublish", prizePoolToPublish, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalRebuysDone", totalRebuysDone, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalAddonsDone", totalAddonsDone, _buf);
	Atf::XmlElement::encodeAsXmlElement("payouts", payouts, _buf);
	Atf::XmlElement::encodeAsXmlElement("flightIntermediatePayoutPrizePool", flightIntermediatePayoutPrizePool, _buf);
	Atf::XmlElement::encodeAsXmlElement("flightIntermediatePayoutPerUser", flightIntermediatePayoutPerUser, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournSubscr_PrizePool::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numUsers"))
		{
			numUsers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolToPublish"))
		{
			prizePoolToPublish = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalRebuysDone"))
		{
			totalRebuysDone = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalAddonsDone"))
		{
			totalAddonsDone = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("payouts"))
		{
			payouts = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flightIntermediatePayoutPrizePool"))
		{
			flightIntermediatePayoutPrizePool = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flightIntermediatePayoutPerUser"))
		{
			flightIntermediatePayoutPerUser = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournSubscr_PrizePool::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(numUsers);
	_msg.composeINT32(prizePoolToPublish);
	_msg.composeUINT32(totalRebuysDone);
	_msg.composeUINT32(totalAddonsDone);
	_msg.composeINT32(payouts);
	_msg.composeINT32(flightIntermediatePayoutPrizePool);
	_msg.composeINT32(flightIntermediatePayoutPerUser);
}

void MTLobbyCli::publication::TournSubscr_PrizePool::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(numUsers);
	_parser.parseINT32(prizePoolToPublish);
	_parser.parseUINT32(totalRebuysDone);
	_parser.parseUINT32(totalAddonsDone);
	_parser.parseINT32(payouts);
	_parser.parseINT32(flightIntermediatePayoutPrizePool);
	_parser.parseINT32(flightIntermediatePayoutPerUser);
}

const char *MTLobbyCli::publication::TournSubscr_PrizePool::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numUsers", numUsers);
	_jsonstr.compose("prizePoolToPublish", prizePoolToPublish);
	_jsonstr.compose("totalRebuysDone", totalRebuysDone);
	_jsonstr.compose("totalAddonsDone", totalAddonsDone);
	_jsonstr.compose("payouts", payouts);
	_jsonstr.compose("flightIntermediatePayoutPrizePool", flightIntermediatePayoutPrizePool);
	_jsonstr.compose("flightIntermediatePayoutPerUser", flightIntermediatePayoutPerUser);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_PrizePool::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numUsers", numUsers);
	_jparser.parseByNameThrow("prizePoolToPublish", prizePoolToPublish);
	_jparser.parseByNameThrow("totalRebuysDone", totalRebuysDone);
	_jparser.parseByNameThrow("totalAddonsDone", totalAddonsDone);
	_jparser.parseByNameThrow("payouts", payouts);
	_jparser.parseByNameThrow("flightIntermediatePayoutPrizePool", flightIntermediatePayoutPrizePool);
	_jparser.parseByNameThrow("flightIntermediatePayoutPerUser", flightIntermediatePayoutPerUser);
}

/* static */ void MTLobbyCli::publication::TournSubscr_PrizePool::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 numUsers; _jparser.validateByNameThrow("numUsers", numUsers);
	AtfValidator::validateInt(_descr, "numUsers", numUsers, _checker, __FILE__, __LINE__);
	INT32 prizePoolToPublish; _jparser.validateByNameThrow("prizePoolToPublish", prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	UINT32 totalRebuysDone; _jparser.validateByNameThrow("totalRebuysDone", totalRebuysDone);
	AtfValidator::validateInt(_descr, "totalRebuysDone", totalRebuysDone, _checker, __FILE__, __LINE__);
	UINT32 totalAddonsDone; _jparser.validateByNameThrow("totalAddonsDone", totalAddonsDone);
	AtfValidator::validateInt(_descr, "totalAddonsDone", totalAddonsDone, _checker, __FILE__, __LINE__);
	INT32 payouts; _jparser.validateByNameThrow("payouts", payouts);
	AtfValidator::validateInt(_descr, "payouts", payouts, _checker, __FILE__, __LINE__);
	INT32 flightIntermediatePayoutPrizePool; _jparser.validateByNameThrow("flightIntermediatePayoutPrizePool", flightIntermediatePayoutPrizePool);
	AtfValidator::validateInt(_descr, "flightIntermediatePayoutPrizePool", flightIntermediatePayoutPrizePool, _checker, __FILE__, __LINE__);
	INT32 flightIntermediatePayoutPerUser; _jparser.validateByNameThrow("flightIntermediatePayoutPerUser", flightIntermediatePayoutPerUser);
	AtfValidator::validateInt(_descr, "flightIntermediatePayoutPerUser", flightIntermediatePayoutPerUser, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_PrizePool::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 numUsers; _parser.parseUINT32(numUsers);
	AtfValidator::validateInt(_descr, "numUsers", numUsers, _checker, __FILE__, __LINE__);
	INT32 prizePoolToPublish; _parser.parseINT32(prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	UINT32 totalRebuysDone; _parser.parseUINT32(totalRebuysDone);
	AtfValidator::validateInt(_descr, "totalRebuysDone", totalRebuysDone, _checker, __FILE__, __LINE__);
	UINT32 totalAddonsDone; _parser.parseUINT32(totalAddonsDone);
	AtfValidator::validateInt(_descr, "totalAddonsDone", totalAddonsDone, _checker, __FILE__, __LINE__);
	INT32 payouts; _parser.parseINT32(payouts);
	AtfValidator::validateInt(_descr, "payouts", payouts, _checker, __FILE__, __LINE__);
	INT32 flightIntermediatePayoutPrizePool; _parser.parseINT32(flightIntermediatePayoutPrizePool);
	AtfValidator::validateInt(_descr, "flightIntermediatePayoutPrizePool", flightIntermediatePayoutPrizePool, _checker, __FILE__, __LINE__);
	INT32 flightIntermediatePayoutPerUser; _parser.parseINT32(flightIntermediatePayoutPerUser);
	AtfValidator::validateInt(_descr, "flightIntermediatePayoutPerUser", flightIntermediatePayoutPerUser, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Bounty
//=================================================================

MTLobbyCli::publication::TournSubscr_Bounty::TournSubscr_Bounty()
{
	clear();
}

void MTLobbyCli::publication::TournSubscr_Bounty::clear()
{
	minBounty = 0;
	maxBounty = 0;
	averageBounty = 0;
}

bool MTLobbyCli::publication::TournSubscr_Bounty::equals(const TournSubscr_Bounty& _o) const
{
	return minBounty == _o.minBounty &&
		maxBounty == _o.maxBounty &&
		averageBounty == _o.averageBounty;
}

const char *MTLobbyCli::publication::TournSubscr_Bounty::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minBounty=");
	_buf.appendUint(minBounty);
	_buf.append(',');
	_buf.append("maxBounty=");
	_buf.appendUint(maxBounty);
	_buf.append(',');
	_buf.append("averageBounty=");
	_buf.appendUint(averageBounty);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournSubscr_Bounty::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("minBounty", minBounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBounty", maxBounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("averageBounty", averageBounty, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournSubscr_Bounty::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("minBounty"))
		{
			minBounty = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBounty"))
		{
			maxBounty = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("averageBounty"))
		{
			averageBounty = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournSubscr_Bounty::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(minBounty);
	_msg.composeUINT32(maxBounty);
	_msg.composeUINT32(averageBounty);
}

void MTLobbyCli::publication::TournSubscr_Bounty::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(minBounty);
	_parser.parseUINT32(maxBounty);
	_parser.parseUINT32(averageBounty);
}

const char *MTLobbyCli::publication::TournSubscr_Bounty::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("minBounty", minBounty);
	_jsonstr.compose("maxBounty", maxBounty);
	_jsonstr.compose("averageBounty", averageBounty);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_Bounty::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("minBounty", minBounty);
	_jparser.parseByNameThrow("maxBounty", maxBounty);
	_jparser.parseByNameThrow("averageBounty", averageBounty);
}

/* static */ void MTLobbyCli::publication::TournSubscr_Bounty::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 minBounty; _jparser.validateByNameThrow("minBounty", minBounty);
	AtfValidator::validateInt(_descr, "minBounty", minBounty, _checker, __FILE__, __LINE__);
	UINT32 maxBounty; _jparser.validateByNameThrow("maxBounty", maxBounty);
	AtfValidator::validateInt(_descr, "maxBounty", maxBounty, _checker, __FILE__, __LINE__);
	UINT32 averageBounty; _jparser.validateByNameThrow("averageBounty", averageBounty);
	AtfValidator::validateInt(_descr, "averageBounty", averageBounty, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_Bounty::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 minBounty; _parser.parseUINT32(minBounty);
	AtfValidator::validateInt(_descr, "minBounty", minBounty, _checker, __FILE__, __LINE__);
	UINT32 maxBounty; _parser.parseUINT32(maxBounty);
	AtfValidator::validateInt(_descr, "maxBounty", maxBounty, _checker, __FILE__, __LINE__);
	UINT32 averageBounty; _parser.parseUINT32(averageBounty);
	AtfValidator::validateInt(_descr, "averageBounty", averageBounty, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_TableBanner
//=================================================================

MTLobbyCli::publication::TournSubscr_TableBanner::TournSubscr_TableBanner()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_TableBanner::TournSubscr_TableBanner(TournSubscr_TableBanner&& _o)
	: counter(std::move(_o.counter))
	, duration(std::move(_o.duration))
	, options(std::move(_o.options))
	, banner(std::move(_o.banner))
	, when(std::move(_o.when))
	, flags(std::move(_o.flags))
	, licenseMask(std::move(_o.licenseMask))
	, observerBanner(std::move(_o.observerBanner))
{
}

MTLobbyCli::publication::TournSubscr_TableBanner& MTLobbyCli::publication::TournSubscr_TableBanner::operator=(TournSubscr_TableBanner&& _o)
{
	if(this != &_o)
	{
		counter = std::move(_o.counter);
		duration = std::move(_o.duration);
		options = std::move(_o.options);
		banner = std::move(_o.banner);
		when = std::move(_o.when);
		flags = std::move(_o.flags);
		licenseMask = std::move(_o.licenseMask);
		observerBanner = std::move(_o.observerBanner);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_TableBanner::clear()
{
	counter = 0;
	duration = 0;
	options = 0;
	banner.clear();
	when.setNull();
	flags = 0;
	licenseMask = 0;
	observerBanner.clear();
}

bool MTLobbyCli::publication::TournSubscr_TableBanner::equals(const TournSubscr_TableBanner& _o) const
{
	return counter == _o.counter &&
		duration == _o.duration &&
		options == _o.options &&
		banner.equals(_o.banner) &&
		when.equals(_o.when) &&
		flags == _o.flags &&
		licenseMask == _o.licenseMask &&
		observerBanner.equals(_o.observerBanner);
}

const char *MTLobbyCli::publication::TournSubscr_TableBanner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("counter=");
	_buf.appendUint(counter);
	_buf.append(',');
	_buf.append("duration=");
	_buf.appendUint(duration);
	_buf.append(',');
	_buf.append("options=");
	_buf.appendUint(options);
	_buf.append(',');
	_buf.append("banner=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, banner);
	_buf.append(',');
	_buf.append("when=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("licenseMask=");
	_buf.appendUint(licenseMask);
	_buf.append(',');
	_buf.append("observerBanner=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, observerBanner);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournSubscr_TableBanner::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("counter", counter, _buf);
	Atf::XmlElement::encodeAsXmlElement("duration", duration, _buf);
	Atf::XmlElement::encodeAsXmlElement("options", options, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "banner", banner);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "when", when);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("licenseMask", licenseMask, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "observerBanner", observerBanner);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournSubscr_TableBanner::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("counter"))
		{
			counter = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("duration"))
		{
			duration = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("options"))
		{
			options = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("banner"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, banner);
		}
		else if (_element.equals("when"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, when);
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("licenseMask"))
		{
			licenseMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("observerBanner"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, observerBanner);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournSubscr_TableBanner::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(counter);
	_msg.composeUINT16(duration);
	_msg.composeUINT32(options);
	banner.compose(_msg);
	_msg.composeSrvTime(when);
	_msg.composeUINT32(flags);
	_msg.composeUINT32(licenseMask);
	observerBanner.compose(_msg);
}

void MTLobbyCli::publication::TournSubscr_TableBanner::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(counter);
	_parser.parseUINT16(duration);
	_parser.parseUINT32(options);
	banner.parse(_parser);
	_parser.parseSrvTime(when);
	_parser.parseUINT32(flags);
	_parser.parseUINT32(licenseMask);
	observerBanner.parse(_parser);
}

const char *MTLobbyCli::publication::TournSubscr_TableBanner::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("counter", counter);
	_jsonstr.compose("duration", duration);
	_jsonstr.compose("options", options);
	_jsonstr.compose("banner", banner);
	_jsonstr.compose("when", when);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("licenseMask", licenseMask);
	_jsonstr.compose("observerBanner", observerBanner);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_TableBanner::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("counter", counter);
	_jparser.parseByNameThrow("duration", duration);
	_jparser.parseByNameThrow("options", options);
	_jparser.parseByNameThrow("banner", banner);
	_jparser.parseByNameThrow("when", when);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("licenseMask", licenseMask);
	_jparser.parseByNameThrow("observerBanner", observerBanner);
}

/* static */ void MTLobbyCli::publication::TournSubscr_TableBanner::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 counter; _jparser.validateByNameThrow("counter", counter);
	AtfValidator::validateInt(_descr, "counter", counter, _checker, __FILE__, __LINE__);
	UINT16 duration; _jparser.validateByNameThrow("duration", duration);
	AtfValidator::validateInt(_descr, "duration", duration, _checker, __FILE__, __LINE__);
	UINT32 options; _jparser.validateByNameThrow("options", options);
	AtfValidator::validateInt(_descr, "options", options, _checker, __FILE__, __LINE__);
	I18nPString banner; _jparser.validateByNameThrow("banner", banner);
	SrvTime when; _jparser.validateByNameThrow("when", when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 licenseMask; _jparser.validateByNameThrow("licenseMask", licenseMask);
	AtfValidator::validateInt(_descr, "licenseMask", licenseMask, _checker, __FILE__, __LINE__);
	I18nPString observerBanner; _jparser.validateByNameThrow("observerBanner", observerBanner);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_TableBanner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 counter; _parser.parseUINT32(counter);
	AtfValidator::validateInt(_descr, "counter", counter, _checker, __FILE__, __LINE__);
	UINT16 duration; _parser.parseUINT16(duration);
	AtfValidator::validateInt(_descr, "duration", duration, _checker, __FILE__, __LINE__);
	UINT32 options; _parser.parseUINT32(options);
	AtfValidator::validateInt(_descr, "options", options, _checker, __FILE__, __LINE__);
	I18nPString banner; banner.parse(_parser);
	SrvTime when; _parser.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 licenseMask; _parser.parseUINT32(licenseMask);
	AtfValidator::validateInt(_descr, "licenseMask", licenseMask, _checker, __FILE__, __LINE__);
	I18nPString observerBanner; observerBanner.parse(_parser);
}

//=================================================================
//                    TournSubscr_OptEarlyStart
//=================================================================

MTLobbyCli::publication::TournSubscr_OptEarlyStart::TournSubscr_OptEarlyStart()
{
	clear();
}

void MTLobbyCli::publication::TournSubscr_OptEarlyStart::clear()
{
	options = 0;
}

bool MTLobbyCli::publication::TournSubscr_OptEarlyStart::equals(const TournSubscr_OptEarlyStart& _o) const
{
	return options == _o.options;
}

const char *MTLobbyCli::publication::TournSubscr_OptEarlyStart::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("options=");
	_buf.appendUint(options);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournSubscr_OptEarlyStart::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("options", options, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournSubscr_OptEarlyStart::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("options"))
		{
			options = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournSubscr_OptEarlyStart::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(options);
}

void MTLobbyCli::publication::TournSubscr_OptEarlyStart::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(options);
}

const char *MTLobbyCli::publication::TournSubscr_OptEarlyStart::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("options", options);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_OptEarlyStart::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("options", options);
}

/* static */ void MTLobbyCli::publication::TournSubscr_OptEarlyStart::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE options; _jparser.validateByNameThrow("options", options);
	AtfValidator::validateInt(_descr, "options", options, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_OptEarlyStart::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE options; _parser.parseBYTE(options);
	AtfValidator::validateInt(_descr, "options", options, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_SpinGoPrize_Vector
//=================================================================

MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::TournSubscr_SpinGoPrize_Vector()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::TournSubscr_SpinGoPrize_Vector(TournSubscr_SpinGoPrize_Vector&& _o)
	: prizes(std::move(_o.prizes))
{
}

MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector& MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::operator=(TournSubscr_SpinGoPrize_Vector&& _o)
{
	if(this != &_o)
	{
		prizes = std::move(_o.prizes);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::clear()
{
	prizes.clear();
}

bool MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::equals(const TournSubscr_SpinGoPrize_Vector& _o) const
{
	return prizes.equals(_o.prizes);
}

const char *MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	prizes.toXmlString("prizes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("prizes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32 , 4 > >::FromXmlString(_value, prizes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	prizes.composeMsg(_msg, _ignoreJSON);
}

void MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::parseMsg(CommMsgParser& _parser)
{
	prizes.parseMsg(_parser);
}

const char *MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("prizes", prizes);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("prizes", prizes);
}

/* static */ void MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< UINT32 > prizes; _jparser.validateByNameThrow("prizes", prizes);
	AtfValidator::validateInt(_descr, "prizes", prizes.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szPrizes = Atf::LAtfVector< UINT32 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_SpinGoPrize_TargetReference
//=================================================================

MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::TournSubscr_SpinGoPrize_TargetReference()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::TournSubscr_SpinGoPrize_TargetReference(TournSubscr_SpinGoPrize_TargetReference&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, instance(std::move(_o.instance))
	, name(std::move(_o.name))
{
}

MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference& MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::operator=(TournSubscr_SpinGoPrize_TargetReference&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		instance = std::move(_o.instance);
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::clear()
{
	tournamentId = 0;
	server.clear();
	instance.clear();
	name.clear();
}

bool MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::equals(const TournSubscr_SpinGoPrize_TargetReference& _o) const
{
	return tournamentId == _o.tournamentId &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(instance, _o.instance) &&
		name.equals(_o.name);
}

const char *MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint64(tournamentId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("instance=");
	_buf.append(instance);
	_buf.append(',');
	_buf.append("name=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, name);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournamentId", tournamentId, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("instance", instance, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "name", name);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournamentId"))
		{
			tournamentId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("instance"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, instance)) return false;
		}
		else if (_element.equals("name"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, name);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(tournamentId);
	_msg.composeString(server);
	_msg.composeString(instance);
	name.compose(_msg);
}

void MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(tournamentId);
	_parser.parseStringP(server);
	_parser.parseStringP(instance);
	name.parse(_parser);
}

const char *MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournamentId", tournamentId);
	_jsonstr.compose("server", server);
	_jsonstr.compose("instance", instance);
	_jsonstr.compose("name", name);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournamentId", tournamentId);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("instance", instance);
	_jparser.parseByNameThrow("name", name);
}

/* static */ void MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 tournamentId; _jparser.validateByNameThrow("tournamentId", tournamentId);
	AtfValidator::validateUint(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString instance; _jparser.validateByNameThrow("instance", instance);
	AtfValidator::validateInt(_descr, "instance", instance.length(), _checker, __FILE__, __LINE__);
	I18nPString name; _jparser.validateByNameThrow("name", name);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT64 tournamentId; _parser.parseUINT64(tournamentId);
	AtfValidator::validateUint(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "instance"); size_t szInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "instance", szInstance, _checker, __FILE__, __LINE__);
	I18nPString name; name.parse(_parser);
}

//=================================================================
//                    TournSubscr_SpinGoPrize
//=================================================================

MTLobbyCli::publication::TournSubscr_SpinGoPrize::TournSubscr_SpinGoPrize()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_SpinGoPrize::TournSubscr_SpinGoPrize(TournSubscr_SpinGoPrize&& _o)
	: spinGoLevels(std::move(_o.spinGoLevels))
	, spinGoMarker(std::move(_o.spinGoMarker))
	, tickets(std::move(_o.tickets))
	, level(std::move(_o.level))
	, targetReferences(std::move(_o.targetReferences))
	, spinGoMaxCashout(std::move(_o.spinGoMaxCashout))
	, spinGoMaxLevels(std::move(_o.spinGoMaxLevels))
	, animationType(std::move(_o.animationType))
	, animationEndTime(std::move(_o.animationEndTime))
	, isJackpot(std::move(_o.isJackpot))
	, winner(std::move(_o.winner))
	, freeBetStake(std::move(_o.freeBetStake))
	, freeBetCurrency(std::move(_o.freeBetCurrency))
	, freeBetsCampaignId(std::move(_o.freeBetsCampaignId))
{
}

MTLobbyCli::publication::TournSubscr_SpinGoPrize& MTLobbyCli::publication::TournSubscr_SpinGoPrize::operator=(TournSubscr_SpinGoPrize&& _o)
{
	if(this != &_o)
	{
		spinGoLevels = std::move(_o.spinGoLevels);
		spinGoMarker = std::move(_o.spinGoMarker);
		tickets = std::move(_o.tickets);
		level = std::move(_o.level);
		targetReferences = std::move(_o.targetReferences);
		spinGoMaxCashout = std::move(_o.spinGoMaxCashout);
		spinGoMaxLevels = std::move(_o.spinGoMaxLevels);
		animationType = std::move(_o.animationType);
		animationEndTime = std::move(_o.animationEndTime);
		isJackpot = std::move(_o.isJackpot);
		winner = std::move(_o.winner);
		freeBetStake = std::move(_o.freeBetStake);
		freeBetCurrency = std::move(_o.freeBetCurrency);
		freeBetsCampaignId = std::move(_o.freeBetsCampaignId);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_SpinGoPrize::clear()
{
	spinGoLevels.clear();
	spinGoMarker = 0;
	tickets.clear();
	level = 0;
	targetReferences.clear();
	spinGoMaxCashout = 0;
	spinGoMaxLevels.clear();
	animationType = 0;
	animationEndTime.setNull();
	isJackpot = false;
	winner.clear();
	freeBetStake = 0;
	freeBetCurrency.clear();
	freeBetsCampaignId = 0;
}

bool MTLobbyCli::publication::TournSubscr_SpinGoPrize::equals(const TournSubscr_SpinGoPrize& _o) const
{
	return spinGoLevels.equals(_o.spinGoLevels) &&
		spinGoMarker == _o.spinGoMarker &&
		tickets.equals(_o.tickets) &&
		level == _o.level &&
		targetReferences.equals(_o.targetReferences) &&
		spinGoMaxCashout == _o.spinGoMaxCashout &&
		spinGoMaxLevels.equals(_o.spinGoMaxLevels) &&
		animationType == _o.animationType &&
		animationEndTime.equals(_o.animationEndTime) &&
		isJackpot == _o.isJackpot &&
		Atf::atfPStringEquals(winner, _o.winner) &&
		freeBetStake == _o.freeBetStake &&
		Atf::atfPStringEquals(freeBetCurrency, _o.freeBetCurrency) &&
		freeBetsCampaignId == _o.freeBetsCampaignId;
}

const char *MTLobbyCli::publication::TournSubscr_SpinGoPrize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("spinGoLevels=");
	spinGoLevels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("spinGoMarker=");
	_buf.appendInt(spinGoMarker);
	_buf.append(',');
	_buf.append("tickets=");
	tickets.toTraceString(_buf);
	_buf.append(',');
	_buf.append("level=");
	_buf.appendUint(level);
	_buf.append(',');
	_buf.append("targetReferences=");
	targetReferences.toTraceString(_buf);
	_buf.append(',');
	_buf.append("spinGoMaxCashout=");
	_buf.appendUint(spinGoMaxCashout);
	_buf.append(',');
	_buf.append("spinGoMaxLevels=");
	spinGoMaxLevels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("animationType=");
	_buf.appendUint(animationType);
	_buf.append(',');
	_buf.append("animationEndTime=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, animationEndTime);
	_buf.append(',');
	_buf.append("isJackpot=");
	_buf.appendUint(isJackpot);
	_buf.append(',');
	_buf.append("winner=");
	_buf.append(winner);
	_buf.append(',');
	_buf.append("freeBetStake=");
	_buf.appendUint(freeBetStake);
	_buf.append(',');
	_buf.append("freeBetCurrency=");
	_buf.append(freeBetCurrency);
	_buf.append(',');
	_buf.append("freeBetsCampaignId=");
	_buf.appendUint(freeBetsCampaignId);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournSubscr_SpinGoPrize::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	spinGoLevels.toXmlString("spinGoLevels", _buf);
	Atf::XmlElement::encodeAsXmlElement("spinGoMarker", spinGoMarker, _buf);
	tickets.toXmlString("tickets", _buf);
	Atf::XmlElement::encodeAsXmlElement("level", level, _buf);
	targetReferences.toXmlString("targetReferences", _buf);
	Atf::XmlElement::encodeAsXmlElement("spinGoMaxCashout", spinGoMaxCashout, _buf);
	spinGoMaxLevels.toXmlString("spinGoMaxLevels", _buf);
	Atf::XmlElement::encodeAsXmlElement("animationType", animationType, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "animationEndTime", animationEndTime);
	Atf::XmlElement::encodeAsXmlElement("isJackpot", isJackpot, _buf);
	Atf::XmlElement::encodeAsXmlElement("winner", winner, _buf);
	Atf::XmlElement::encodeAsXmlElement("freeBetStake", freeBetStake, _buf);
	Atf::XmlElement::encodeAsXmlElement("freeBetCurrency", freeBetCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("freeBetsCampaignId", freeBetsCampaignId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournSubscr_SpinGoPrize::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("spinGoLevels"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64 , 4 > >::FromXmlString(_value, spinGoLevels)) return false;
		}
		else if (_element.equals("spinGoMarker"))
		{
			spinGoMarker = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tickets"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< I18nPString , 4 > >::FromXmlString(_value, tickets)) return false;
		}
		else if (_element.equals("level"))
		{
			level = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("targetReferences"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournSubscr_SpinGoPrize_TargetReference , 4 > >::FromXmlString(_value, targetReferences)) return false;
		}
		else if (_element.equals("spinGoMaxCashout"))
		{
			spinGoMaxCashout = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("spinGoMaxLevels"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournSubscr_SpinGoPrize_Vector , 4 > >::FromXmlString(_value, spinGoMaxLevels)) return false;
		}
		else if (_element.equals("animationType"))
		{
			animationType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("animationEndTime"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, animationEndTime);
		}
		else if (_element.equals("isJackpot"))
		{
			isJackpot = (*_value.ptr() == '1');
		}
		else if (_element.equals("winner"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, winner)) return false;
		}
		else if (_element.equals("freeBetStake"))
		{
			freeBetStake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("freeBetCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, freeBetCurrency)) return false;
		}
		else if (_element.equals("freeBetsCampaignId"))
		{
			freeBetsCampaignId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournSubscr_SpinGoPrize::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	spinGoLevels.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(spinGoMarker);
	tickets.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(level);
	targetReferences.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(spinGoMaxCashout);
	spinGoMaxLevels.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(animationType);
	_msg.composeSrvTime(animationEndTime);
	_msg.composeBOOL(isJackpot);
	_msg.composeString(winner);
	_msg.composeUINT32(freeBetStake);
	_msg.composeString(freeBetCurrency);
	_msg.composeUINT32(freeBetsCampaignId);
}

void MTLobbyCli::publication::TournSubscr_SpinGoPrize::parseMsg(CommMsgParser& _parser)
{
	spinGoLevels.parseMsg(_parser);
	_parser.parseINT32(spinGoMarker);
	tickets.parseMsg(_parser);
	_parser.parseUINT32(level);
	targetReferences.parseMsg(_parser);
	_parser.parseUINT32(spinGoMaxCashout);
	spinGoMaxLevels.parseMsg(_parser);
	_parser.parseUINT32(animationType);
	_parser.parseSrvTime(animationEndTime);
	_parser.parseBOOL(isJackpot);
	_parser.parseStringP(winner);
	_parser.parseUINT32(freeBetStake);
	_parser.parseStringP(freeBetCurrency);
	_parser.parseUINT32(freeBetsCampaignId);
}

const char *MTLobbyCli::publication::TournSubscr_SpinGoPrize::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("spinGoLevels", spinGoLevels);
	_jsonstr.compose("spinGoMarker", spinGoMarker);
	_jsonstr.compose("tickets", tickets);
	_jsonstr.compose("level", level);
	_jsonstr.compose("targetReferences", targetReferences);
	_jsonstr.compose("spinGoMaxCashout", spinGoMaxCashout);
	_jsonstr.compose("spinGoMaxLevels", spinGoMaxLevels);
	_jsonstr.compose("animationType", animationType);
	_jsonstr.compose("animationEndTime", animationEndTime);
	_jsonstr.compose("isJackpot", isJackpot);
	_jsonstr.compose("winner", winner);
	_jsonstr.compose("freeBetStake", freeBetStake);
	_jsonstr.compose("freeBetCurrency", freeBetCurrency);
	_jsonstr.compose("freeBetsCampaignId", freeBetsCampaignId);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_SpinGoPrize::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("spinGoLevels", spinGoLevels);
	_jparser.parseByNameThrow("spinGoMarker", spinGoMarker);
	_jparser.parseByNameThrow("tickets", tickets);
	_jparser.parseByNameThrow("level", level);
	_jparser.parseByNameThrow("targetReferences", targetReferences);
	_jparser.parseByNameThrow("spinGoMaxCashout", spinGoMaxCashout);
	_jparser.parseByNameThrow("spinGoMaxLevels", spinGoMaxLevels);
	_jparser.parseByNameThrow("animationType", animationType);
	_jparser.parseByNameThrow("animationEndTime", animationEndTime);
	_jparser.parseByNameThrow("isJackpot", isJackpot);
	_jparser.parseByNameThrow("winner", winner);
	_jparser.parseByNameThrow("freeBetStake", freeBetStake);
	_jparser.parseByNameThrow("freeBetCurrency", freeBetCurrency);
	_jparser.parseByNameThrow("freeBetsCampaignId", freeBetsCampaignId);
}

/* static */ void MTLobbyCli::publication::TournSubscr_SpinGoPrize::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< INT64 > spinGoLevels; _jparser.validateByNameThrow("spinGoLevels", spinGoLevels);
	AtfValidator::validateInt(_descr, "spinGoLevels", spinGoLevels.size(), _checker, __FILE__, __LINE__);
	INT32 spinGoMarker; _jparser.validateByNameThrow("spinGoMarker", spinGoMarker);
	AtfValidator::validateInt(_descr, "spinGoMarker", spinGoMarker, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< I18nPString > tickets; _jparser.validateByNameThrow("tickets", tickets);
	AtfValidator::validateInt(_descr, "tickets", tickets.size(), _checker, __FILE__, __LINE__);
	UINT32 level; _jparser.validateByNameThrow("level", level);
	AtfValidator::validateInt(_descr, "level", level, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournSubscr_SpinGoPrize_TargetReference > targetReferences; _jparser.validateByNameThrow("targetReferences", targetReferences);
	AtfValidator::validateInt(_descr, "targetReferences", targetReferences.size(), _checker, __FILE__, __LINE__);
	UINT32 spinGoMaxCashout; _jparser.validateByNameThrow("spinGoMaxCashout", spinGoMaxCashout);
	AtfValidator::validateInt(_descr, "spinGoMaxCashout", spinGoMaxCashout, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournSubscr_SpinGoPrize_Vector > spinGoMaxLevels; _jparser.validateByNameThrow("spinGoMaxLevels", spinGoMaxLevels);
	AtfValidator::validateInt(_descr, "spinGoMaxLevels", spinGoMaxLevels.size(), _checker, __FILE__, __LINE__);
	UINT32 animationType; _jparser.validateByNameThrow("animationType", animationType);
	AtfValidator::validateInt(_descr, "animationType", animationType, _checker, __FILE__, __LINE__);
	SrvTime animationEndTime; _jparser.validateByNameThrow("animationEndTime", animationEndTime);
	AtfValidator::validateSrvDateTime(_descr, "animationEndTime", animationEndTime, _checker, __FILE__, __LINE__);
	bool isJackpot; _jparser.validateByNameThrow("isJackpot", isJackpot);
	AtfValidator::validateInt(_descr, "isJackpot", isJackpot, _checker, __FILE__, __LINE__);
	PString winner; _jparser.validateByNameThrow("winner", winner);
	AtfValidator::validateInt(_descr, "winner", winner.length(), _checker, __FILE__, __LINE__);
	UINT32 freeBetStake; _jparser.validateByNameThrow("freeBetStake", freeBetStake);
	AtfValidator::validateInt(_descr, "freeBetStake", freeBetStake, _checker, __FILE__, __LINE__);
	PString freeBetCurrency; _jparser.validateByNameThrow("freeBetCurrency", freeBetCurrency);
	AtfValidator::validateInt(_descr, "freeBetCurrency", freeBetCurrency.length(), _checker, __FILE__, __LINE__);
	UINT32 freeBetsCampaignId; _jparser.validateByNameThrow("freeBetsCampaignId", freeBetsCampaignId);
	AtfValidator::validateInt(_descr, "freeBetsCampaignId", freeBetsCampaignId, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_SpinGoPrize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	PString _descbuf;
	int szSpinGoLevels = Atf::LAtfVector< INT64 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("spinGoLevels"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "spinGoLevels", szSpinGoLevels, _checker, __FILE__, __LINE__);
	INT32 spinGoMarker; _parser.parseINT32(spinGoMarker);
	AtfValidator::validateInt(_descr, "spinGoMarker", spinGoMarker, _checker, __FILE__, __LINE__);
	int szTickets = Atf::LAtfVector< I18nPString , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
	UINT32 level; _parser.parseUINT32(level);
	AtfValidator::validateInt(_descr, "level", level, _checker, __FILE__, __LINE__);
	int szTargetReferences = Atf::LAtfVector< TournSubscr_SpinGoPrize_TargetReference , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("targetReferences"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "targetReferences", szTargetReferences, _checker, __FILE__, __LINE__);
	UINT32 spinGoMaxCashout; _parser.parseUINT32(spinGoMaxCashout);
	AtfValidator::validateInt(_descr, "spinGoMaxCashout", spinGoMaxCashout, _checker, __FILE__, __LINE__);
	int szSpinGoMaxLevels = Atf::LAtfVector< TournSubscr_SpinGoPrize_Vector , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("spinGoMaxLevels"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "spinGoMaxLevels", szSpinGoMaxLevels, _checker, __FILE__, __LINE__);
	UINT32 animationType; _parser.parseUINT32(animationType);
	AtfValidator::validateInt(_descr, "animationType", animationType, _checker, __FILE__, __LINE__);
	SrvTime animationEndTime; _parser.parseSrvTime(animationEndTime);
	AtfValidator::validateSrvDateTime(_descr, "animationEndTime", animationEndTime, _checker, __FILE__, __LINE__);
	bool isJackpot; _parser.parseBOOL(isJackpot);
	AtfValidator::validateInt(_descr, "isJackpot", isJackpot, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "winner"); size_t szWinner = strlen(_dummy);
	AtfValidator::validateInt(_descr, "winner", szWinner, _checker, __FILE__, __LINE__);
	UINT32 freeBetStake; _parser.parseUINT32(freeBetStake);
	AtfValidator::validateInt(_descr, "freeBetStake", freeBetStake, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "freeBetCurrency"); size_t szFreeBetCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "freeBetCurrency", szFreeBetCurrency, _checker, __FILE__, __LINE__);
	UINT32 freeBetsCampaignId; _parser.parseUINT32(freeBetsCampaignId);
	AtfValidator::validateInt(_descr, "freeBetsCampaignId", freeBetsCampaignId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_PerHand
//=================================================================

MTLobbyCli::publication::TournSubscr_PerHand::TournSubscr_PerHand()
{
	clear();
}

void MTLobbyCli::publication::TournSubscr_PerHand::clear()
{
	intervalInHands = false;
	currentHandInLevel = 0;
	totalHandsInLevel = 0;
	handsUntilAllInLevel = 0;
}

bool MTLobbyCli::publication::TournSubscr_PerHand::equals(const TournSubscr_PerHand& _o) const
{
	return intervalInHands == _o.intervalInHands &&
		currentHandInLevel == _o.currentHandInLevel &&
		totalHandsInLevel == _o.totalHandsInLevel &&
		handsUntilAllInLevel == _o.handsUntilAllInLevel;
}

const char *MTLobbyCli::publication::TournSubscr_PerHand::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("intervalInHands=");
	_buf.appendUint(intervalInHands);
	_buf.append(',');
	_buf.append("currentHandInLevel=");
	_buf.appendInt(currentHandInLevel);
	_buf.append(',');
	_buf.append("totalHandsInLevel=");
	_buf.appendInt(totalHandsInLevel);
	_buf.append(',');
	_buf.append("handsUntilAllInLevel=");
	_buf.appendInt(handsUntilAllInLevel);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournSubscr_PerHand::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("intervalInHands", intervalInHands, _buf);
	Atf::XmlElement::encodeAsXmlElement("currentHandInLevel", currentHandInLevel, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalHandsInLevel", totalHandsInLevel, _buf);
	Atf::XmlElement::encodeAsXmlElement("handsUntilAllInLevel", handsUntilAllInLevel, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournSubscr_PerHand::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("intervalInHands"))
		{
			intervalInHands = (*_value.ptr() == '1');
		}
		else if (_element.equals("currentHandInLevel"))
		{
			currentHandInLevel = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalHandsInLevel"))
		{
			totalHandsInLevel = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handsUntilAllInLevel"))
		{
			handsUntilAllInLevel = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournSubscr_PerHand::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(intervalInHands);
	_msg.composeINT32(currentHandInLevel);
	_msg.composeINT32(totalHandsInLevel);
	_msg.composeINT32(handsUntilAllInLevel);
}

void MTLobbyCli::publication::TournSubscr_PerHand::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(intervalInHands);
	_parser.parseINT32(currentHandInLevel);
	_parser.parseINT32(totalHandsInLevel);
	_parser.parseINT32(handsUntilAllInLevel);
}

const char *MTLobbyCli::publication::TournSubscr_PerHand::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("intervalInHands", intervalInHands);
	_jsonstr.compose("currentHandInLevel", currentHandInLevel);
	_jsonstr.compose("totalHandsInLevel", totalHandsInLevel);
	_jsonstr.compose("handsUntilAllInLevel", handsUntilAllInLevel);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_PerHand::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("intervalInHands", intervalInHands);
	_jparser.parseByNameThrow("currentHandInLevel", currentHandInLevel);
	_jparser.parseByNameThrow("totalHandsInLevel", totalHandsInLevel);
	_jparser.parseByNameThrow("handsUntilAllInLevel", handsUntilAllInLevel);
}

/* static */ void MTLobbyCli::publication::TournSubscr_PerHand::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool intervalInHands; _jparser.validateByNameThrow("intervalInHands", intervalInHands);
	AtfValidator::validateInt(_descr, "intervalInHands", intervalInHands, _checker, __FILE__, __LINE__);
	INT32 currentHandInLevel; _jparser.validateByNameThrow("currentHandInLevel", currentHandInLevel);
	AtfValidator::validateInt(_descr, "currentHandInLevel", currentHandInLevel, _checker, __FILE__, __LINE__);
	INT32 totalHandsInLevel; _jparser.validateByNameThrow("totalHandsInLevel", totalHandsInLevel);
	AtfValidator::validateInt(_descr, "totalHandsInLevel", totalHandsInLevel, _checker, __FILE__, __LINE__);
	INT32 handsUntilAllInLevel; _jparser.validateByNameThrow("handsUntilAllInLevel", handsUntilAllInLevel);
	AtfValidator::validateInt(_descr, "handsUntilAllInLevel", handsUntilAllInLevel, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_PerHand::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool intervalInHands; _parser.parseBOOL(intervalInHands);
	AtfValidator::validateInt(_descr, "intervalInHands", intervalInHands, _checker, __FILE__, __LINE__);
	INT32 currentHandInLevel; _parser.parseINT32(currentHandInLevel);
	AtfValidator::validateInt(_descr, "currentHandInLevel", currentHandInLevel, _checker, __FILE__, __LINE__);
	INT32 totalHandsInLevel; _parser.parseINT32(totalHandsInLevel);
	AtfValidator::validateInt(_descr, "totalHandsInLevel", totalHandsInLevel, _checker, __FILE__, __LINE__);
	INT32 handsUntilAllInLevel; _parser.parseINT32(handsUntilAllInLevel);
	AtfValidator::validateInt(_descr, "handsUntilAllInLevel", handsUntilAllInLevel, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_SpinGoSpinner
//=================================================================

MTLobbyCli::publication::TournSubscr_SpinGoSpinner::TournSubscr_SpinGoSpinner()
{
	clear();
}

void MTLobbyCli::publication::TournSubscr_SpinGoSpinner::clear()
{
	time.setNull();
	choice = 0;
	spinner1 = 0;
	spinner2 = 0;
	spinner3 = 0;
	cashout = 0;
	timeout = false;
}

bool MTLobbyCli::publication::TournSubscr_SpinGoSpinner::equals(const TournSubscr_SpinGoSpinner& _o) const
{
	return time.equals(_o.time) &&
		choice == _o.choice &&
		spinner1 == _o.spinner1 &&
		spinner2 == _o.spinner2 &&
		spinner3 == _o.spinner3 &&
		cashout == _o.cashout &&
		timeout == _o.timeout;
}

const char *MTLobbyCli::publication::TournSubscr_SpinGoSpinner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("time=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, time);
	_buf.append(',');
	_buf.append("choice=");
	_buf.appendUint(choice);
	_buf.append(',');
	_buf.append("spinner1=");
	_buf.appendUint(spinner1);
	_buf.append(',');
	_buf.append("spinner2=");
	_buf.appendUint(spinner2);
	_buf.append(',');
	_buf.append("spinner3=");
	_buf.appendUint(spinner3);
	_buf.append(',');
	_buf.append("cashout=");
	_buf.appendUint(cashout);
	_buf.append(',');
	_buf.append("timeout=");
	_buf.appendUint(timeout);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournSubscr_SpinGoSpinner::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "time", time);
	Atf::XmlElement::encodeAsXmlElement("choice", choice, _buf);
	Atf::XmlElement::encodeAsXmlElement("spinner1", spinner1, _buf);
	Atf::XmlElement::encodeAsXmlElement("spinner2", spinner2, _buf);
	Atf::XmlElement::encodeAsXmlElement("spinner3", spinner3, _buf);
	Atf::XmlElement::encodeAsXmlElement("cashout", cashout, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeout", timeout, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournSubscr_SpinGoSpinner::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("time"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, time);
		}
		else if (_element.equals("choice"))
		{
			choice = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("spinner1"))
		{
			spinner1 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("spinner2"))
		{
			spinner2 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("spinner3"))
		{
			spinner3 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cashout"))
		{
			cashout = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timeout"))
		{
			timeout = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournSubscr_SpinGoSpinner::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(time);
	_msg.composeUINT32(choice);
	_msg.composeUINT32(spinner1);
	_msg.composeUINT32(spinner2);
	_msg.composeUINT32(spinner3);
	_msg.composeUINT32(cashout);
	_msg.composeBOOL(timeout);
}

void MTLobbyCli::publication::TournSubscr_SpinGoSpinner::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(time);
	_parser.parseUINT32(choice);
	_parser.parseUINT32(spinner1);
	_parser.parseUINT32(spinner2);
	_parser.parseUINT32(spinner3);
	_parser.parseUINT32(cashout);
	_parser.parseBOOL(timeout);
}

const char *MTLobbyCli::publication::TournSubscr_SpinGoSpinner::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("time", time);
	_jsonstr.compose("choice", choice);
	_jsonstr.compose("spinner1", spinner1);
	_jsonstr.compose("spinner2", spinner2);
	_jsonstr.compose("spinner3", spinner3);
	_jsonstr.compose("cashout", cashout);
	_jsonstr.compose("timeout", timeout);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_SpinGoSpinner::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("time", time);
	_jparser.parseByNameThrow("choice", choice);
	_jparser.parseByNameThrow("spinner1", spinner1);
	_jparser.parseByNameThrow("spinner2", spinner2);
	_jparser.parseByNameThrow("spinner3", spinner3);
	_jparser.parseByNameThrow("cashout", cashout);
	_jparser.parseByNameThrow("timeout", timeout);
}

/* static */ void MTLobbyCli::publication::TournSubscr_SpinGoSpinner::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime time; _jparser.validateByNameThrow("time", time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	UINT32 choice; _jparser.validateByNameThrow("choice", choice);
	AtfValidator::validateInt(_descr, "choice", choice, _checker, __FILE__, __LINE__);
	UINT32 spinner1; _jparser.validateByNameThrow("spinner1", spinner1);
	AtfValidator::validateInt(_descr, "spinner1", spinner1, _checker, __FILE__, __LINE__);
	UINT32 spinner2; _jparser.validateByNameThrow("spinner2", spinner2);
	AtfValidator::validateInt(_descr, "spinner2", spinner2, _checker, __FILE__, __LINE__);
	UINT32 spinner3; _jparser.validateByNameThrow("spinner3", spinner3);
	AtfValidator::validateInt(_descr, "spinner3", spinner3, _checker, __FILE__, __LINE__);
	UINT32 cashout; _jparser.validateByNameThrow("cashout", cashout);
	AtfValidator::validateInt(_descr, "cashout", cashout, _checker, __FILE__, __LINE__);
	bool timeout; _jparser.validateByNameThrow("timeout", timeout);
	AtfValidator::validateInt(_descr, "timeout", timeout, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_SpinGoSpinner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	SrvTime time; _parser.parseSrvTime(time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	UINT32 choice; _parser.parseUINT32(choice);
	AtfValidator::validateInt(_descr, "choice", choice, _checker, __FILE__, __LINE__);
	UINT32 spinner1; _parser.parseUINT32(spinner1);
	AtfValidator::validateInt(_descr, "spinner1", spinner1, _checker, __FILE__, __LINE__);
	UINT32 spinner2; _parser.parseUINT32(spinner2);
	AtfValidator::validateInt(_descr, "spinner2", spinner2, _checker, __FILE__, __LINE__);
	UINT32 spinner3; _parser.parseUINT32(spinner3);
	AtfValidator::validateInt(_descr, "spinner3", spinner3, _checker, __FILE__, __LINE__);
	UINT32 cashout; _parser.parseUINT32(cashout);
	AtfValidator::validateInt(_descr, "cashout", cashout, _checker, __FILE__, __LINE__);
	bool timeout; _parser.parseBOOL(timeout);
	AtfValidator::validateInt(_descr, "timeout", timeout, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Prize_Winner
//=================================================================

MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::TournExtraSubscr_Prize_Winner()
{
	clear();
}

void MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::clear()
{
	amount = 0;
	percent = 0;
}

bool MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::equals(const TournExtraSubscr_Prize_Winner& _o) const
{
	return amount == _o.amount &&
		percent == _o.percent;
}

const char *MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("amount=");
	_buf.appendUint(amount);
	_buf.append(',');
	_buf.append("percent=");
	_buf.appendUint(percent);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("percent", percent, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("amount"))
		{
			amount = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("percent"))
		{
			percent = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(amount);
	_msg.composeBYTE(percent);
}

void MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(amount);
	_parser.parseBYTE(percent);
}

const char *MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("percent", percent);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("percent", percent);
}

/* static */ void MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	BYTE percent; _jparser.validateByNameThrow("percent", percent);
	AtfValidator::validateInt(_descr, "percent", percent, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 amount; _parser.parseUINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	BYTE percent; _parser.parseBYTE(percent);
	AtfValidator::validateInt(_descr, "percent", percent, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Prize_Prize
//=================================================================

MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::TournExtraSubscr_Prize_Prize()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::TournExtraSubscr_Prize_Prize(TournExtraSubscr_Prize_Prize&& _o)
	: min(std::move(_o.min))
	, max(std::move(_o.max))
	, numTickets(std::move(_o.numTickets))
	, winners(std::move(_o.winners))
{
}

MTLobbyCli::publication::TournExtraSubscr_Prize_Prize& MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::operator=(TournExtraSubscr_Prize_Prize&& _o)
{
	if(this != &_o)
	{
		min = std::move(_o.min);
		max = std::move(_o.max);
		numTickets = std::move(_o.numTickets);
		winners = std::move(_o.winners);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::clear()
{
	min = 0;
	max = 0;
	numTickets = 0;
	winners.clear();
}

bool MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::equals(const TournExtraSubscr_Prize_Prize& _o) const
{
	return min == _o.min &&
		max == _o.max &&
		numTickets == _o.numTickets &&
		winners.equals(_o.winners);
}

const char *MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("min=");
	_buf.appendUint(min);
	_buf.append(',');
	_buf.append("max=");
	_buf.appendUint(max);
	_buf.append(',');
	_buf.append("numTickets=");
	_buf.appendUint(numTickets);
	_buf.append(',');
	_buf.append("winners=");
	winners.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("min", min, _buf);
	Atf::XmlElement::encodeAsXmlElement("max", max, _buf);
	Atf::XmlElement::encodeAsXmlElement("numTickets", numTickets, _buf);
	winners.toXmlString("winners", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("min"))
		{
			min = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("max"))
		{
			max = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numTickets"))
		{
			numTickets = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("winners"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournExtraSubscr_Prize_Winner , 4 > >::FromXmlString(_value, winners)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(min);
	_msg.composeUINT32(max);
	_msg.composeUINT32(numTickets);
	winners.composeMsg(_msg, _ignoreJSON);
}

void MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(min);
	_parser.parseUINT32(max);
	_parser.parseUINT32(numTickets);
	winners.parseMsg(_parser);
}

const char *MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("min", min);
	_jsonstr.compose("max", max);
	_jsonstr.compose("numTickets", numTickets);
	_jsonstr.compose("winners", winners);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("min", min);
	_jparser.parseByNameThrow("max", max);
	_jparser.parseByNameThrow("numTickets", numTickets);
	_jparser.parseByNameThrow("winners", winners);
}

/* static */ void MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 min; _jparser.validateByNameThrow("min", min);
	AtfValidator::validateInt(_descr, "min", min, _checker, __FILE__, __LINE__);
	UINT32 max; _jparser.validateByNameThrow("max", max);
	AtfValidator::validateInt(_descr, "max", max, _checker, __FILE__, __LINE__);
	UINT32 numTickets; _jparser.validateByNameThrow("numTickets", numTickets);
	AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournExtraSubscr_Prize_Winner > winners; _jparser.validateByNameThrow("winners", winners);
	AtfValidator::validateInt(_descr, "winners", winners.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 min; _parser.parseUINT32(min);
	AtfValidator::validateInt(_descr, "min", min, _checker, __FILE__, __LINE__);
	UINT32 max; _parser.parseUINT32(max);
	AtfValidator::validateInt(_descr, "max", max, _checker, __FILE__, __LINE__);
	UINT32 numTickets; _parser.parseUINT32(numTickets);
	AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szWinners = Atf::LAtfVector< TournExtraSubscr_Prize_Winner , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("winners"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "winners", szWinners, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Prize
//=================================================================

MTLobbyCli::publication::TournExtraSubscr_Prize::TournExtraSubscr_Prize()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournExtraSubscr_Prize::TournExtraSubscr_Prize(TournExtraSubscr_Prize&& _o)
	: zero(std::move(_o.zero))
	, creditPlayer(std::move(_o.creditPlayer))
	, returnBuyInValue(std::move(_o.returnBuyInValue))
	, rebuyPrice(std::move(_o.rebuyPrice))
	, rebuyRake(std::move(_o.rebuyRake))
	, addOnPrice(std::move(_o.addOnPrice))
	, addOnRake(std::move(_o.addOnRake))
	, prizes(std::move(_o.prizes))
{
}

MTLobbyCli::publication::TournExtraSubscr_Prize& MTLobbyCli::publication::TournExtraSubscr_Prize::operator=(TournExtraSubscr_Prize&& _o)
{
	if(this != &_o)
	{
		zero = std::move(_o.zero);
		creditPlayer = std::move(_o.creditPlayer);
		returnBuyInValue = std::move(_o.returnBuyInValue);
		rebuyPrice = std::move(_o.rebuyPrice);
		rebuyRake = std::move(_o.rebuyRake);
		addOnPrice = std::move(_o.addOnPrice);
		addOnRake = std::move(_o.addOnRake);
		prizes = std::move(_o.prizes);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournExtraSubscr_Prize::clear()
{
	zero = 0;
	creditPlayer = 0;
	returnBuyInValue = 0;
	rebuyPrice = 0;
	rebuyRake = 0;
	addOnPrice = 0;
	addOnRake = 0;
	prizes.clear();
}

bool MTLobbyCli::publication::TournExtraSubscr_Prize::equals(const TournExtraSubscr_Prize& _o) const
{
	return zero == _o.zero &&
		creditPlayer == _o.creditPlayer &&
		returnBuyInValue == _o.returnBuyInValue &&
		rebuyPrice == _o.rebuyPrice &&
		rebuyRake == _o.rebuyRake &&
		addOnPrice == _o.addOnPrice &&
		addOnRake == _o.addOnRake &&
		prizes.equals(_o.prizes);
}

const char *MTLobbyCli::publication::TournExtraSubscr_Prize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("zero=");
	_buf.appendUint(zero);
	_buf.append(',');
	_buf.append("creditPlayer=");
	_buf.appendUint(creditPlayer);
	_buf.append(',');
	_buf.append("returnBuyInValue=");
	_buf.appendUint(returnBuyInValue);
	_buf.append(',');
	_buf.append("rebuyPrice=");
	_buf.appendUint(rebuyPrice);
	_buf.append(',');
	_buf.append("rebuyRake=");
	_buf.appendUint(rebuyRake);
	_buf.append(',');
	_buf.append("addOnPrice=");
	_buf.appendUint(addOnPrice);
	_buf.append(',');
	_buf.append("addOnRake=");
	_buf.appendUint(addOnRake);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournExtraSubscr_Prize::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("zero", zero, _buf);
	Atf::XmlElement::encodeAsXmlElement("creditPlayer", creditPlayer, _buf);
	Atf::XmlElement::encodeAsXmlElement("returnBuyInValue", returnBuyInValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuyPrice", rebuyPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuyRake", rebuyRake, _buf);
	Atf::XmlElement::encodeAsXmlElement("addOnPrice", addOnPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("addOnRake", addOnRake, _buf);
	prizes.toXmlString("prizes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournExtraSubscr_Prize::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("zero"))
		{
			zero = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("creditPlayer"))
		{
			creditPlayer = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("returnBuyInValue"))
		{
			returnBuyInValue = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rebuyPrice"))
		{
			rebuyPrice = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rebuyRake"))
		{
			rebuyRake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("addOnPrice"))
		{
			addOnPrice = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("addOnRake"))
		{
			addOnRake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournExtraSubscr_Prize_Prize , 4 > >::FromXmlString(_value, prizes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournExtraSubscr_Prize::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(zero);
	_msg.composeUINT32(creditPlayer);
	_msg.composeUINT32(returnBuyInValue);
	_msg.composeUINT32(rebuyPrice);
	_msg.composeUINT32(rebuyRake);
	_msg.composeUINT32(addOnPrice);
	_msg.composeUINT32(addOnRake);
	prizes.composeMsg(_msg, _ignoreJSON);
}

void MTLobbyCli::publication::TournExtraSubscr_Prize::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(zero);
	_parser.parseUINT32(creditPlayer);
	_parser.parseUINT32(returnBuyInValue);
	_parser.parseUINT32(rebuyPrice);
	_parser.parseUINT32(rebuyRake);
	_parser.parseUINT32(addOnPrice);
	_parser.parseUINT32(addOnRake);
	prizes.parseMsg(_parser);
}

const char *MTLobbyCli::publication::TournExtraSubscr_Prize::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("zero", zero);
	_jsonstr.compose("creditPlayer", creditPlayer);
	_jsonstr.compose("returnBuyInValue", returnBuyInValue);
	_jsonstr.compose("rebuyPrice", rebuyPrice);
	_jsonstr.compose("rebuyRake", rebuyRake);
	_jsonstr.compose("addOnPrice", addOnPrice);
	_jsonstr.compose("addOnRake", addOnRake);
	_jsonstr.compose("prizes", prizes);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournExtraSubscr_Prize::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("zero", zero);
	_jparser.parseByNameThrow("creditPlayer", creditPlayer);
	_jparser.parseByNameThrow("returnBuyInValue", returnBuyInValue);
	_jparser.parseByNameThrow("rebuyPrice", rebuyPrice);
	_jparser.parseByNameThrow("rebuyRake", rebuyRake);
	_jparser.parseByNameThrow("addOnPrice", addOnPrice);
	_jparser.parseByNameThrow("addOnRake", addOnRake);
	_jparser.parseByNameThrow("prizes", prizes);
}

/* static */ void MTLobbyCli::publication::TournExtraSubscr_Prize::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 zero; _jparser.validateByNameThrow("zero", zero);
	AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
	UINT32 creditPlayer; _jparser.validateByNameThrow("creditPlayer", creditPlayer);
	AtfValidator::validateInt(_descr, "creditPlayer", creditPlayer, _checker, __FILE__, __LINE__);
	UINT32 returnBuyInValue; _jparser.validateByNameThrow("returnBuyInValue", returnBuyInValue);
	AtfValidator::validateInt(_descr, "returnBuyInValue", returnBuyInValue, _checker, __FILE__, __LINE__);
	UINT32 rebuyPrice; _jparser.validateByNameThrow("rebuyPrice", rebuyPrice);
	AtfValidator::validateInt(_descr, "rebuyPrice", rebuyPrice, _checker, __FILE__, __LINE__);
	UINT32 rebuyRake; _jparser.validateByNameThrow("rebuyRake", rebuyRake);
	AtfValidator::validateInt(_descr, "rebuyRake", rebuyRake, _checker, __FILE__, __LINE__);
	UINT32 addOnPrice; _jparser.validateByNameThrow("addOnPrice", addOnPrice);
	AtfValidator::validateInt(_descr, "addOnPrice", addOnPrice, _checker, __FILE__, __LINE__);
	UINT32 addOnRake; _jparser.validateByNameThrow("addOnRake", addOnRake);
	AtfValidator::validateInt(_descr, "addOnRake", addOnRake, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournExtraSubscr_Prize_Prize > prizes; _jparser.validateByNameThrow("prizes", prizes);
	AtfValidator::validateInt(_descr, "prizes", prizes.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournExtraSubscr_Prize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 zero; _parser.parseUINT32(zero);
	AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
	UINT32 creditPlayer; _parser.parseUINT32(creditPlayer);
	AtfValidator::validateInt(_descr, "creditPlayer", creditPlayer, _checker, __FILE__, __LINE__);
	UINT32 returnBuyInValue; _parser.parseUINT32(returnBuyInValue);
	AtfValidator::validateInt(_descr, "returnBuyInValue", returnBuyInValue, _checker, __FILE__, __LINE__);
	UINT32 rebuyPrice; _parser.parseUINT32(rebuyPrice);
	AtfValidator::validateInt(_descr, "rebuyPrice", rebuyPrice, _checker, __FILE__, __LINE__);
	UINT32 rebuyRake; _parser.parseUINT32(rebuyRake);
	AtfValidator::validateInt(_descr, "rebuyRake", rebuyRake, _checker, __FILE__, __LINE__);
	UINT32 addOnPrice; _parser.parseUINT32(addOnPrice);
	AtfValidator::validateInt(_descr, "addOnPrice", addOnPrice, _checker, __FILE__, __LINE__);
	UINT32 addOnRake; _parser.parseUINT32(addOnRake);
	AtfValidator::validateInt(_descr, "addOnRake", addOnRake, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPrizes = Atf::LAtfVector< TournExtraSubscr_Prize_Prize , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Rake_SitesPerCountry
//=================================================================

MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::TournExtraSubscr_Rake_SitesPerCountry()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::TournExtraSubscr_Rake_SitesPerCountry(TournExtraSubscr_Rake_SitesPerCountry&& _o)
	: country(std::move(_o.country))
	, sites(std::move(_o.sites))
{
}

MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry& MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::operator=(TournExtraSubscr_Rake_SitesPerCountry&& _o)
{
	if(this != &_o)
	{
		country = std::move(_o.country);
		sites = std::move(_o.sites);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::clear()
{
	country.clear();
	sites = 0;
}

bool MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::equals(const TournExtraSubscr_Rake_SitesPerCountry& _o) const
{
	return Atf::atfPStringEquals(country, _o.country) &&
		sites == _o.sites;
}

const char *MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("sites=");
	_buf.appendUint(sites);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("sites", sites, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("sites"))
		{
			sites = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(country);
	_msg.composeUINT32(sites);
}

void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(country);
	_parser.parseUINT32(sites);
}

const char *MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("country", country);
	_jsonstr.compose("sites", sites);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("sites", sites);
}

/* static */ void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	UINT32 sites; _jparser.validateByNameThrow("sites", sites);
	AtfValidator::validateInt(_descr, "sites", sites, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	UINT32 sites; _parser.parseUINT32(sites);
	AtfValidator::validateInt(_descr, "sites", sites, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Rake_SitesPerCountryEx
//=================================================================

MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::TournExtraSubscr_Rake_SitesPerCountryEx()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::TournExtraSubscr_Rake_SitesPerCountryEx(TournExtraSubscr_Rake_SitesPerCountryEx&& _o)
	: country(std::move(_o.country))
	, sitesEx(std::move(_o.sitesEx))
{
}

MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx& MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::operator=(TournExtraSubscr_Rake_SitesPerCountryEx&& _o)
{
	if(this != &_o)
	{
		country = std::move(_o.country);
		sitesEx = std::move(_o.sitesEx);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::clear()
{
	country.clear();
	sitesEx.clear();
}

bool MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::equals(const TournExtraSubscr_Rake_SitesPerCountryEx& _o) const
{
	return Atf::atfPStringEquals(country, _o.country) &&
		sitesEx.equals(_o.sitesEx);
}

const char *MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("sitesEx=");
	sitesEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	sitesEx.toXmlString("sitesEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("sitesEx"))
		{
			if(!Atf::AtfTempl< PBitmask >::FromXmlString(_value, sitesEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(country);
	sitesEx.composeMsg(_msg, _ignoreJSON);
}

void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(country);
	sitesEx.parseMsg(_parser);
}

const char *MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("country", country);
	_jsonstr.compose("sitesEx", sitesEx);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("sitesEx", sitesEx);
}

/* static */ void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	PBitmask sitesEx; _jparser.validateByNameThrow("sitesEx", sitesEx);
}

/*static*/ void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PBitmask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sitesEx"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    TournExtraSubscr_Rake
//=================================================================

MTLobbyCli::publication::TournExtraSubscr_Rake::TournExtraSubscr_Rake()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournExtraSubscr_Rake::TournExtraSubscr_Rake(TournExtraSubscr_Rake&& _o)
	: sites4AllCountries(std::move(_o.sites4AllCountries))
	, sitesNoRake(std::move(_o.sitesNoRake))
	, sitesPerCountry(std::move(_o.sitesPerCountry))
	, sites4AllCountriesEx(std::move(_o.sites4AllCountriesEx))
	, sitesNoRakeEx(std::move(_o.sitesNoRakeEx))
	, sitesPerCountryEx(std::move(_o.sitesPerCountryEx))
{
}

MTLobbyCli::publication::TournExtraSubscr_Rake& MTLobbyCli::publication::TournExtraSubscr_Rake::operator=(TournExtraSubscr_Rake&& _o)
{
	if(this != &_o)
	{
		sites4AllCountries = std::move(_o.sites4AllCountries);
		sitesNoRake = std::move(_o.sitesNoRake);
		sitesPerCountry = std::move(_o.sitesPerCountry);
		sites4AllCountriesEx = std::move(_o.sites4AllCountriesEx);
		sitesNoRakeEx = std::move(_o.sitesNoRakeEx);
		sitesPerCountryEx = std::move(_o.sitesPerCountryEx);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournExtraSubscr_Rake::clear()
{
	sites4AllCountries = UINT_MAX;
	sitesNoRake = 0;
	sitesPerCountry.clear();
	sites4AllCountriesEx.clear();
	sitesNoRakeEx.clear();
	sitesPerCountryEx.clear();
}

bool MTLobbyCli::publication::TournExtraSubscr_Rake::equals(const TournExtraSubscr_Rake& _o) const
{
	return sites4AllCountries == _o.sites4AllCountries &&
		sitesNoRake == _o.sitesNoRake &&
		sitesPerCountry.equals(_o.sitesPerCountry) &&
		sites4AllCountriesEx.equals(_o.sites4AllCountriesEx) &&
		sitesNoRakeEx.equals(_o.sitesNoRakeEx) &&
		sitesPerCountryEx.equals(_o.sitesPerCountryEx);
}

const char *MTLobbyCli::publication::TournExtraSubscr_Rake::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sites4AllCountries=");
	_buf.appendUint(sites4AllCountries);
	_buf.append(',');
	_buf.append("sitesNoRake=");
	_buf.appendUint(sitesNoRake);
	_buf.append(',');
	_buf.append("sitesPerCountry=");
	sitesPerCountry.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sites4AllCountriesEx=");
	sites4AllCountriesEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sitesNoRakeEx=");
	sitesNoRakeEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sitesPerCountryEx=");
	sitesPerCountryEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournExtraSubscr_Rake::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("sites4AllCountries", sites4AllCountries, _buf);
	Atf::XmlElement::encodeAsXmlElement("sitesNoRake", sitesNoRake, _buf);
	sitesPerCountry.toXmlString("sitesPerCountry", _buf);
	sites4AllCountriesEx.toXmlString("sites4AllCountriesEx", _buf);
	sitesNoRakeEx.toXmlString("sitesNoRakeEx", _buf);
	sitesPerCountryEx.toXmlString("sitesPerCountryEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournExtraSubscr_Rake::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("sites4AllCountries"))
		{
			sites4AllCountries = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sitesNoRake"))
		{
			sitesNoRake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sitesPerCountry"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournExtraSubscr_Rake_SitesPerCountry , 4 > >::FromXmlString(_value, sitesPerCountry)) return false;
		}
		else if (_element.equals("sites4AllCountriesEx"))
		{
			if(!Atf::AtfTempl< PBitmask >::FromXmlString(_value, sites4AllCountriesEx)) return false;
		}
		else if (_element.equals("sitesNoRakeEx"))
		{
			if(!Atf::AtfTempl< PBitmask >::FromXmlString(_value, sitesNoRakeEx)) return false;
		}
		else if (_element.equals("sitesPerCountryEx"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournExtraSubscr_Rake_SitesPerCountryEx , 4 > >::FromXmlString(_value, sitesPerCountryEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournExtraSubscr_Rake::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(sites4AllCountries);
	_msg.composeUINT32(sitesNoRake);
	sitesPerCountry.composeMsg(_msg, _ignoreJSON);
	sites4AllCountriesEx.composeMsg(_msg, _ignoreJSON);
	sitesNoRakeEx.composeMsg(_msg, _ignoreJSON);
	sitesPerCountryEx.composeMsg(_msg, _ignoreJSON);
}

void MTLobbyCli::publication::TournExtraSubscr_Rake::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sites4AllCountries);
	_parser.parseUINT32(sitesNoRake);
	sitesPerCountry.parseMsg(_parser);
	sites4AllCountriesEx.parseMsg(_parser);
	sitesNoRakeEx.parseMsg(_parser);
	sitesPerCountryEx.parseMsg(_parser);
}

const char *MTLobbyCli::publication::TournExtraSubscr_Rake::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sites4AllCountries", sites4AllCountries);
	_jsonstr.compose("sitesNoRake", sitesNoRake);
	_jsonstr.compose("sitesPerCountry", sitesPerCountry);
	_jsonstr.compose("sites4AllCountriesEx", sites4AllCountriesEx);
	_jsonstr.compose("sitesNoRakeEx", sitesNoRakeEx);
	_jsonstr.compose("sitesPerCountryEx", sitesPerCountryEx);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournExtraSubscr_Rake::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sites4AllCountries", sites4AllCountries);
	_jparser.parseByNameThrow("sitesNoRake", sitesNoRake);
	_jparser.parseByNameThrow("sitesPerCountry", sitesPerCountry);
	_jparser.parseByNameThrow("sites4AllCountriesEx", sites4AllCountriesEx);
	_jparser.parseByNameThrow("sitesNoRakeEx", sitesNoRakeEx);
	_jparser.parseByNameThrow("sitesPerCountryEx", sitesPerCountryEx);
}

/* static */ void MTLobbyCli::publication::TournExtraSubscr_Rake::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 sites4AllCountries; _jparser.validateByNameThrow("sites4AllCountries", sites4AllCountries);
	AtfValidator::validateInt(_descr, "sites4AllCountries", sites4AllCountries, _checker, __FILE__, __LINE__);
	UINT32 sitesNoRake; _jparser.validateByNameThrow("sitesNoRake", sitesNoRake);
	AtfValidator::validateInt(_descr, "sitesNoRake", sitesNoRake, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournExtraSubscr_Rake_SitesPerCountry > sitesPerCountry; _jparser.validateByNameThrow("sitesPerCountry", sitesPerCountry);
	AtfValidator::validateInt(_descr, "sitesPerCountry", sitesPerCountry.size(), _checker, __FILE__, __LINE__);
	PBitmask sites4AllCountriesEx; _jparser.validateByNameThrow("sites4AllCountriesEx", sites4AllCountriesEx);
	PBitmask sitesNoRakeEx; _jparser.validateByNameThrow("sitesNoRakeEx", sitesNoRakeEx);
	Atf::AtfVectorBase< TournExtraSubscr_Rake_SitesPerCountryEx > sitesPerCountryEx; _jparser.validateByNameThrow("sitesPerCountryEx", sitesPerCountryEx);
	AtfValidator::validateInt(_descr, "sitesPerCountryEx", sitesPerCountryEx.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournExtraSubscr_Rake::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 sites4AllCountries; _parser.parseUINT32(sites4AllCountries);
	AtfValidator::validateInt(_descr, "sites4AllCountries", sites4AllCountries, _checker, __FILE__, __LINE__);
	UINT32 sitesNoRake; _parser.parseUINT32(sitesNoRake);
	AtfValidator::validateInt(_descr, "sitesNoRake", sitesNoRake, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSitesPerCountry = Atf::LAtfVector< TournExtraSubscr_Rake_SitesPerCountry , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sitesPerCountry"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sitesPerCountry", szSitesPerCountry, _checker, __FILE__, __LINE__);
	PBitmask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sites4AllCountriesEx"), _fieldsWithUnparsedContent);
	PBitmask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sitesNoRakeEx"), _fieldsWithUnparsedContent);
	int szSitesPerCountryEx = Atf::LAtfVector< TournExtraSubscr_Rake_SitesPerCountryEx , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sitesPerCountryEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sitesPerCountryEx", szSitesPerCountryEx, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournI18nSubscr_Name
//=================================================================

MTLobbyCli::publication::TournI18nSubscr_Name::TournI18nSubscr_Name()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournI18nSubscr_Name::TournI18nSubscr_Name(TournI18nSubscr_Name&& _o)
	: name(std::move(_o.name))
{
}

MTLobbyCli::publication::TournI18nSubscr_Name& MTLobbyCli::publication::TournI18nSubscr_Name::operator=(TournI18nSubscr_Name&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournI18nSubscr_Name::clear()
{
	name.clear();
}

bool MTLobbyCli::publication::TournI18nSubscr_Name::equals(const TournI18nSubscr_Name& _o) const
{
	return Atf::atfPStringEquals(name, _o.name);
}

const char *MTLobbyCli::publication::TournI18nSubscr_Name::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::publication::TournI18nSubscr_Name::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::publication::TournI18nSubscr_Name::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::publication::TournI18nSubscr_Name::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(name);
}

void MTLobbyCli::publication::TournI18nSubscr_Name::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
}

const char *MTLobbyCli::publication::TournI18nSubscr_Name::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	return _buf.c_str();
}

void MTLobbyCli::publication::TournI18nSubscr_Name::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
}

/* static */ void MTLobbyCli::publication::TournI18nSubscr_Name::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::publication::TournI18nSubscr_Name::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CurrencyContextStruct
//=================================================================

MTLobbyCli::cli::CurrencyContextStruct::CurrencyContextStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::CurrencyContextStruct::CurrencyContextStruct(CurrencyContextStruct&& _o)
	: srvTime(std::move(_o.srvTime))
	, convRatesAndMargins(std::move(_o.convRatesAndMargins))
{
}

MTLobbyCli::cli::CurrencyContextStruct& MTLobbyCli::cli::CurrencyContextStruct::operator=(CurrencyContextStruct&& _o)
{
	if(this != &_o)
	{
		srvTime = std::move(_o.srvTime);
		convRatesAndMargins = std::move(_o.convRatesAndMargins);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::CurrencyContextStruct::clear()
{
	srvTime.setNull();
	convRatesAndMargins.clear();
}

bool MTLobbyCli::cli::CurrencyContextStruct::equals(const CurrencyContextStruct& _o) const
{
	return srvTime.equals(_o.srvTime) &&
		convRatesAndMargins.equals(_o.convRatesAndMargins);
}

const char *MTLobbyCli::cli::CurrencyContextStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("srvTime=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, srvTime);
	_buf.append(',');
	_buf.append("convRatesAndMargins=");
	convRatesAndMargins.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::cli::CurrencyContextStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "srvTime", srvTime);
	convRatesAndMargins.toXmlString("convRatesAndMargins", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::cli::CurrencyContextStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("srvTime"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, srvTime);
		}
		else if (_element.equals("convRatesAndMargins"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< Common::AtfShared::ConvRatesAndMarginsStruct, 4 > >::FromXmlString(_value, convRatesAndMargins)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::cli::CurrencyContextStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CurrencyContextStruct())) // not empty
	{
		_body.composeSrvTime(srvTime);
		convRatesAndMargins.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MTLobbyCli::cli::CurrencyContextStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseSrvTime(srvTime);
	convRatesAndMargins.parseMsg(_parser0);
}

const char *MTLobbyCli::cli::CurrencyContextStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("srvTime", srvTime);
	_jsonstr.compose("convRatesAndMargins", convRatesAndMargins);
	return _buf.c_str();
}

void MTLobbyCli::cli::CurrencyContextStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("srvTime", srvTime);
	_jparser.parseByNameThrow("convRatesAndMargins", convRatesAndMargins);
}

/* static */ void MTLobbyCli::cli::CurrencyContextStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	SrvTime srvTime; _jparser.validateByNameThrow("srvTime", srvTime);
	AtfValidator::validateSrvDateTime(_descr, "srvTime", srvTime, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< Common::AtfShared::ConvRatesAndMarginsStruct > convRatesAndMargins; _jparser.validateByNameThrow("convRatesAndMargins", convRatesAndMargins);
	AtfValidator::validateInt(_descr, "convRatesAndMargins", convRatesAndMargins.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::CurrencyContextStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.parseEnded()) return;
	SrvTime srvTime; _parser0.parseSrvTime(srvTime);
	AtfValidator::validateSrvDateTime(_descr, "srvTime", srvTime, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szConvRatesAndMargins = Atf::LAtfVector< Common::AtfShared::ConvRatesAndMarginsStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("convRatesAndMargins"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "convRatesAndMargins", szConvRatesAndMargins, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    OneAccountStruct
//=================================================================

MTLobbyCli::cli::OneAccountStruct::OneAccountStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::OneAccountStruct::OneAccountStruct(OneAccountStruct&& _o)
	: currency(std::move(_o.currency))
	, convRate(std::move(_o.convRate))
	, chips(std::move(_o.chips))
	, tChips(std::move(_o.tChips))
	, chipsDst(std::move(_o.chipsDst))
	, tChipsDst(std::move(_o.tChipsDst))
{
}

MTLobbyCli::cli::OneAccountStruct& MTLobbyCli::cli::OneAccountStruct::operator=(OneAccountStruct&& _o)
{
	if(this != &_o)
	{
		currency = std::move(_o.currency);
		convRate = std::move(_o.convRate);
		chips = std::move(_o.chips);
		tChips = std::move(_o.tChips);
		chipsDst = std::move(_o.chipsDst);
		tChipsDst = std::move(_o.tChipsDst);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::OneAccountStruct::clear()
{
	currency.clear();
	convRate = 0;
	chips = 0;
	tChips = 0;
	chipsDst = 0;
	tChipsDst = 0;
}

bool MTLobbyCli::cli::OneAccountStruct::equals(const OneAccountStruct& _o) const
{
	return Atf::atfPStringEquals(currency, _o.currency) &&
		convRate == _o.convRate &&
		chips == _o.chips &&
		tChips == _o.tChips &&
		chipsDst == _o.chipsDst &&
		tChipsDst == _o.tChipsDst;
}

const char *MTLobbyCli::cli::OneAccountStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("convRate=");
	_buf.appendInt64(convRate);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt(chips);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("chipsDst=");
	_buf.appendInt(chipsDst);
	_buf.append(',');
	_buf.append("tChipsDst=");
	_buf.appendInt(tChipsDst);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::cli::OneAccountStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("convRate", convRate, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("chipsDst", chipsDst, _buf);
	Atf::XmlElement::encodeAsXmlElement("tChipsDst", tChipsDst, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::cli::OneAccountStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("convRate"))
		{
			convRate = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chips"))
		{
			chips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tChips"))
		{
			tChips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chipsDst"))
		{
			chipsDst = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tChipsDst"))
		{
			tChipsDst = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::cli::OneAccountStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(OneAccountStruct())) // not empty
	{
		_body.composeString(currency);
		_body.composeINT64(convRate);
		_body.composeINT32(chips);
		_body.composeINT32(tChips);
		_body.composeINT32(chipsDst);
		_body.composeINT32(tChipsDst);
	}

	_msg.composeMsgBody(_body);
}

void MTLobbyCli::cli::OneAccountStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(convRate);
	_parser0.parseINT32(chips);
	_parser0.parseINT32(tChips);
	_parser0.parseINT32(chipsDst);
	_parser0.parseINT32(tChipsDst);
}

const char *MTLobbyCli::cli::OneAccountStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("convRate", convRate);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("tChips", tChips);
	_jsonstr.compose("chipsDst", chipsDst);
	_jsonstr.compose("tChipsDst", tChipsDst);
	return _buf.c_str();
}

void MTLobbyCli::cli::OneAccountStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("convRate", convRate);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("tChips", tChips);
	_jparser.parseByNameThrow("chipsDst", chipsDst);
	_jparser.parseByNameThrow("tChipsDst", tChipsDst);
}

/* static */ void MTLobbyCli::cli::OneAccountStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT64 convRate; _jparser.validateByNameThrow("convRate", convRate);
	AtfValidator::validateInt(_descr, "convRate", convRate, _checker, __FILE__, __LINE__);
	INT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT32 tChips; _jparser.validateByNameThrow("tChips", tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	INT32 chipsDst; _jparser.validateByNameThrow("chipsDst", chipsDst);
	AtfValidator::validateInt(_descr, "chipsDst", chipsDst, _checker, __FILE__, __LINE__);
	INT32 tChipsDst; _jparser.validateByNameThrow("tChipsDst", tChipsDst);
	AtfValidator::validateInt(_descr, "tChipsDst", tChipsDst, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::OneAccountStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 convRate; _parser0.parseINT64(convRate);
	AtfValidator::validateInt(_descr, "convRate", convRate, _checker, __FILE__, __LINE__);
	INT32 chips; _parser0.parseINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT32 tChips; _parser0.parseINT32(tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	INT32 chipsDst; _parser0.parseINT32(chipsDst);
	AtfValidator::validateInt(_descr, "chipsDst", chipsDst, _checker, __FILE__, __LINE__);
	INT32 tChipsDst; _parser0.parseINT32(tChipsDst);
	AtfValidator::validateInt(_descr, "tChipsDst", tChipsDst, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ClientCurrencyContext
//=================================================================

MTLobbyCli::cli::ClientCurrencyContext::ClientCurrencyContext()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::ClientCurrencyContext::ClientCurrencyContext(ClientCurrencyContext&& _o)
	: currencyDst(std::move(_o.currencyDst))
	, availForSpendingDst(std::move(_o.availForSpendingDst))
	, unclearedDst(std::move(_o.unclearedDst))
	, oneAcct(std::move(_o.oneAcct))
	, flags(std::move(_o.flags))
	, flags2(std::move(_o.flags2))
	, userRollId(std::move(_o.userRollId))
	, rollAmount(std::move(_o.rollAmount))
	, availWithoutConv(std::move(_o.availWithoutConv))
{
}

MTLobbyCli::cli::ClientCurrencyContext& MTLobbyCli::cli::ClientCurrencyContext::operator=(ClientCurrencyContext&& _o)
{
	if(this != &_o)
	{
		currencyDst = std::move(_o.currencyDst);
		availForSpendingDst = std::move(_o.availForSpendingDst);
		unclearedDst = std::move(_o.unclearedDst);
		oneAcct = std::move(_o.oneAcct);
		flags = std::move(_o.flags);
		flags2 = std::move(_o.flags2);
		userRollId = std::move(_o.userRollId);
		rollAmount = std::move(_o.rollAmount);
		availWithoutConv = std::move(_o.availWithoutConv);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::ClientCurrencyContext::clear()
{
	currencyDst.clear();
	availForSpendingDst = 0;
	unclearedDst = 0;
	oneAcct.clear();
	flags = 0;
	flags2 = 0;
	userRollId = 0;
	rollAmount = 0;
	availWithoutConv = 0;
}

bool MTLobbyCli::cli::ClientCurrencyContext::equals(const ClientCurrencyContext& _o) const
{
	return Atf::atfPStringEquals(currencyDst, _o.currencyDst) &&
		availForSpendingDst == _o.availForSpendingDst &&
		unclearedDst == _o.unclearedDst &&
		oneAcct.equals(_o.oneAcct) &&
		flags == _o.flags &&
		flags2 == _o.flags2 &&
		userRollId == _o.userRollId &&
		rollAmount == _o.rollAmount &&
		availWithoutConv == _o.availWithoutConv;
}

const char *MTLobbyCli::cli::ClientCurrencyContext::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currencyDst=");
	_buf.append(currencyDst);
	_buf.append(',');
	_buf.append("availForSpendingDst=");
	_buf.appendInt(availForSpendingDst);
	_buf.append(',');
	_buf.append("unclearedDst=");
	_buf.appendInt(unclearedDst);
	_buf.append(',');
	_buf.append("oneAcct=");
	oneAcct.toTraceString(_buf);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("userRollId=");
	_buf.appendUint(userRollId);
	_buf.append(',');
	_buf.append("rollAmount=");
	_buf.appendInt(rollAmount);
	_buf.append(',');
	_buf.append("availWithoutConv=");
	_buf.appendInt(availWithoutConv);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::cli::ClientCurrencyContext::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("currencyDst", currencyDst, _buf);
	Atf::XmlElement::encodeAsXmlElement("availForSpendingDst", availForSpendingDst, _buf);
	Atf::XmlElement::encodeAsXmlElement("unclearedDst", unclearedDst, _buf);
	oneAcct.toXmlString("oneAcct", _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags2", flags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("userRollId", userRollId, _buf);
	Atf::XmlElement::encodeAsXmlElement("rollAmount", rollAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("availWithoutConv", availWithoutConv, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::cli::ClientCurrencyContext::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("currencyDst"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currencyDst)) return false;
		}
		else if (_element.equals("availForSpendingDst"))
		{
			availForSpendingDst = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("unclearedDst"))
		{
			unclearedDst = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("oneAcct"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< OneAccountStruct, 4 > >::FromXmlString(_value, oneAcct)) return false;
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags2"))
		{
			flags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userRollId"))
		{
			userRollId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rollAmount"))
		{
			rollAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("availWithoutConv"))
		{
			availWithoutConv = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::cli::ClientCurrencyContext::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ClientCurrencyContext())) // not empty
	{
		_body.composeString(currencyDst);
		_body.composeINT32(availForSpendingDst);
		_body.composeINT32(unclearedDst);
		oneAcct.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(flags);
		_body.composeUINT64(flags2);
		_body.composeUINT32(userRollId);
		_body.composeINT32(rollAmount);
		_body.composeINT32(availWithoutConv);
	}

	_msg.composeMsgBody(_body);
}

void MTLobbyCli::cli::ClientCurrencyContext::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currencyDst);
	_parser0.parseINT32(availForSpendingDst);
	_parser0.parseINT32(unclearedDst);
	oneAcct.parseMsg(_parser0);
	_parser0.parseUINT32(flags);
	_parser0.parseUINT64(flags2);
	_parser0.parseUINT32(userRollId);
	_parser0.parseINT32(rollAmount);
	_parser0.parseINT32(availWithoutConv);
}

const char *MTLobbyCli::cli::ClientCurrencyContext::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currencyDst", currencyDst);
	_jsonstr.compose("availForSpendingDst", availForSpendingDst);
	_jsonstr.compose("unclearedDst", unclearedDst);
	_jsonstr.compose("oneAcct", oneAcct);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("flags2", flags2);
	_jsonstr.compose("userRollId", userRollId);
	_jsonstr.compose("rollAmount", rollAmount);
	_jsonstr.compose("availWithoutConv", availWithoutConv);
	return _buf.c_str();
}

void MTLobbyCli::cli::ClientCurrencyContext::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currencyDst", currencyDst);
	_jparser.parseByNameThrow("availForSpendingDst", availForSpendingDst);
	_jparser.parseByNameThrow("unclearedDst", unclearedDst);
	_jparser.parseByNameThrow("oneAcct", oneAcct);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("flags2", flags2);
	_jparser.parseByNameThrow("userRollId", userRollId);
	_jparser.parseByNameThrow("rollAmount", rollAmount);
	_jparser.parseByNameThrow("availWithoutConv", availWithoutConv);
}

/* static */ void MTLobbyCli::cli::ClientCurrencyContext::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currencyDst; _jparser.validateByNameThrow("currencyDst", currencyDst);
	AtfValidator::validateInt(_descr, "currencyDst", currencyDst.length(), _checker, __FILE__, __LINE__);
	INT32 availForSpendingDst; _jparser.validateByNameThrow("availForSpendingDst", availForSpendingDst);
	AtfValidator::validateInt(_descr, "availForSpendingDst", availForSpendingDst, _checker, __FILE__, __LINE__);
	INT32 unclearedDst; _jparser.validateByNameThrow("unclearedDst", unclearedDst);
	AtfValidator::validateInt(_descr, "unclearedDst", unclearedDst, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< OneAccountStruct > oneAcct; _jparser.validateByNameThrow("oneAcct", oneAcct);
	AtfValidator::validateInt(_descr, "oneAcct", oneAcct.size(), _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _jparser.validateByNameThrow("flags2", flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	UINT32 userRollId; _jparser.validateByNameThrow("userRollId", userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
	INT32 rollAmount; _jparser.validateByNameThrow("rollAmount", rollAmount);
	AtfValidator::validateInt(_descr, "rollAmount", rollAmount, _checker, __FILE__, __LINE__);
	INT32 availWithoutConv; _jparser.validateByNameThrow("availWithoutConv", availWithoutConv);
	AtfValidator::validateInt(_descr, "availWithoutConv", availWithoutConv, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::ClientCurrencyContext::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currencyDst"); size_t szCurrencyDst = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currencyDst", szCurrencyDst, _checker, __FILE__, __LINE__);
	INT32 availForSpendingDst; _parser0.parseINT32(availForSpendingDst);
	AtfValidator::validateInt(_descr, "availForSpendingDst", availForSpendingDst, _checker, __FILE__, __LINE__);
	INT32 unclearedDst; _parser0.parseINT32(unclearedDst);
	AtfValidator::validateInt(_descr, "unclearedDst", unclearedDst, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szOneAcct = Atf::LAtfVector< OneAccountStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("oneAcct"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "oneAcct", szOneAcct, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser0.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	UINT32 userRollId; _parser0.parseUINT32(userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
	INT32 rollAmount; _parser0.parseINT32(rollAmount);
	AtfValidator::validateInt(_descr, "rollAmount", rollAmount, _checker, __FILE__, __LINE__);
	INT32 availWithoutConv; _parser0.parseINT32(availWithoutConv);
	AtfValidator::validateInt(_descr, "availWithoutConv", availWithoutConv, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserTicketData
//=================================================================

MTLobbyCli::cli::UserTicketData::UserTicketData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::UserTicketData::UserTicketData(UserTicketData&& _o)
	: admissionId(std::move(_o.admissionId))
	, totalCount(std::move(_o.totalCount))
	, reserved(std::move(_o.reserved))
{
}

MTLobbyCli::cli::UserTicketData& MTLobbyCli::cli::UserTicketData::operator=(UserTicketData&& _o)
{
	if(this != &_o)
	{
		admissionId = std::move(_o.admissionId);
		totalCount = std::move(_o.totalCount);
		reserved = std::move(_o.reserved);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::UserTicketData::clear()
{
	admissionId.clear();
	totalCount = 0;
	reserved = 0;
}

bool MTLobbyCli::cli::UserTicketData::equals(const UserTicketData& _o) const
{
	return Atf::atfPStringEquals(admissionId, _o.admissionId) &&
		totalCount == _o.totalCount &&
		reserved == _o.reserved;
}

const char *MTLobbyCli::cli::UserTicketData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("totalCount=");
	_buf.appendUint(totalCount);
	_buf.append(',');
	_buf.append("reserved=");
	_buf.appendUint(reserved);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::cli::UserTicketData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("admissionId", admissionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalCount", totalCount, _buf);
	Atf::XmlElement::encodeAsXmlElement("reserved", reserved, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::cli::UserTicketData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("admissionId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, admissionId)) return false;
		}
		else if (_element.equals("totalCount"))
		{
			totalCount = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("reserved"))
		{
			reserved = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::cli::UserTicketData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(admissionId);
	_msg.composeUINT32(totalCount);
	_msg.composeUINT32(reserved);
}

void MTLobbyCli::cli::UserTicketData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(admissionId);
	_parser.parseUINT32(totalCount);
	_parser.parseUINT32(reserved);
}

const char *MTLobbyCli::cli::UserTicketData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("admissionId", admissionId);
	_jsonstr.compose("totalCount", totalCount);
	_jsonstr.compose("reserved", reserved);
	return _buf.c_str();
}

void MTLobbyCli::cli::UserTicketData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("admissionId", admissionId);
	_jparser.parseByNameThrow("totalCount", totalCount);
	_jparser.parseByNameThrow("reserved", reserved);
}

/* static */ void MTLobbyCli::cli::UserTicketData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString admissionId; _jparser.validateByNameThrow("admissionId", admissionId);
	AtfValidator::validateInt(_descr, "admissionId", admissionId.length(), _checker, __FILE__, __LINE__);
	UINT32 totalCount; _jparser.validateByNameThrow("totalCount", totalCount);
	AtfValidator::validateInt(_descr, "totalCount", totalCount, _checker, __FILE__, __LINE__);
	UINT32 reserved; _jparser.validateByNameThrow("reserved", reserved);
	AtfValidator::validateInt(_descr, "reserved", reserved, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::UserTicketData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	UINT32 totalCount; _parser.parseUINT32(totalCount);
	AtfValidator::validateInt(_descr, "totalCount", totalCount, _checker, __FILE__, __LINE__);
	UINT32 reserved; _parser.parseUINT32(reserved);
	AtfValidator::validateInt(_descr, "reserved", reserved, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MTL_LOBBY_WHERE_IS_PLAYER
//=================================================================

MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::Protocol_MTL_LOBBY_WHERE_IS_PLAYER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::Protocol_MTL_LOBBY_WHERE_IS_PLAYER(Protocol_MTL_LOBBY_WHERE_IS_PLAYER&& _o)
	: userName(std::move(_o.userName))
{
}

MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER& MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::operator=(Protocol_MTL_LOBBY_WHERE_IS_PLAYER&& _o)
{
	if(this != &_o)
	{
		userName = std::move(_o.userName);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::clear()
{
	userName.clear();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::equals(const Protocol_MTL_LOBBY_WHERE_IS_PLAYER& _o) const
{
	return Atf::atfPStringEquals(userName, _o.userName);
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_WHERE_IS_PLAYER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_WHERE_IS_PLAYER*)_other));
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_WHERE_IS_PLAYER).append(")");
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	return _buf.c_str();
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_WHERE_IS_PLAYER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userName", userName, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userName);
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userName);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userName", userName);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userName", userName);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userName; _jparser.validateByNameThrow("userName", userName);
	AtfValidator::validateIntMax(_descr, "userName", userName.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY
//=================================================================

MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY(Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, place(std::move(_o.place))
	, tableServer(std::move(_o.tableServer))
	, tableObject(std::move(_o.tableObject))
	, flags(std::move(_o.flags))
	, errDescr(std::move(_o.errDescr))
{
}

MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY& MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::operator=(Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		place = std::move(_o.place);
		tableServer = std::move(_o.tableServer);
		tableObject = std::move(_o.tableObject);
		flags = std::move(_o.flags);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::clear()
{
	errCode = 0;
	place = 0;
	tableServer.clear();
	tableObject.clear();
	flags = false;
	errDescr.clear();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::equals(const Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		place == _o.place &&
		Atf::atfPStringEquals(tableServer, _o.tableServer) &&
		Atf::atfPStringEquals(tableObject, _o.tableObject) &&
		flags == _o.flags &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_WHERE_IS_PLAYER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY*)_other));
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_WHERE_IS_PLAYER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_buf.append(',');
		_buf.append("place=");
		_buf.appendUint(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_buf.append(',');
		_buf.append("tableServer=");
		_buf.append(tableServer);
		_buf.append(',');
		_buf.append("tableObject=");
		_buf.append(tableObject);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
	}
	else
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_WHERE_IS_PLAYER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode == WHERE_IS_PLACE )
	{
		Atf::XmlElement::encodeAsXmlElement("place", place, _buf);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		Atf::XmlElement::encodeAsXmlElement("tableServer", tableServer, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableObject", tableObject, _buf);
		Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("place"))
			{
				place = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableServer"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tableServer)) return false;
			}
			else if (_element.equals("tableObject"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tableObject)) return false;
			}
			else if (_element.equals("flags"))
			{
				flags = (*_value.ptr() == '1');
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_msg.composeUINT32(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_msg.composeString(tableServer);
		_msg.composeString(tableObject);
		_msg.composeBOOL(flags);
	}
	else
	{
		_msg.composeString(errDescr);
	}
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_parser.parseUINT32(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_parser.parseStringP(tableServer);
		_parser.parseStringP(tableObject);
		_parser.parseBOOL(flags);
	}
	else
	{
		_parser.parseStringP(errDescr);
	}
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_jsonstr.compose("place", place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_jsonstr.compose("tableServer", tableServer);
		_jsonstr.compose("tableObject", tableObject);
		_jsonstr.compose("flags", flags);
	}
	else
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_jparser.parseByNameThrow("place", place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_jparser.parseByNameThrow("tableServer", tableServer);
		_jparser.parseByNameThrow("tableObject", tableObject);
		_jparser.parseByNameThrow("flags", flags);
	}
	else
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode == WHERE_IS_PLACE )
	{
		UINT32 place; _jparser.validateByNameThrow("place", place);
		AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		PString tableServer; _jparser.validateByNameThrow("tableServer", tableServer);
		AtfValidator::validateInt(_descr, "tableServer", tableServer.length(), _checker, __FILE__, __LINE__);
		PString tableObject; _jparser.validateByNameThrow("tableObject", tableObject);
		AtfValidator::validateInt(_descr, "tableObject", tableObject.length(), _checker, __FILE__, __LINE__);
		bool flags; _jparser.validateByNameThrow("flags", flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode == WHERE_IS_PLACE )
	{
		UINT32 place; _parser.parseUINT32(place);
		AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_parser.parseStringN(_dummy, 0, "tableServer"); size_t szTableServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableServer", szTableServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tableObject"); size_t szTableObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableObject", szTableObject, _checker, __FILE__, __LINE__);
		bool flags; _parser.parseBOOL(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS
//=================================================================

MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS&& _o)
	: userName(std::move(_o.userName))
{
}

MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS& MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::operator=(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS&& _o)
{
	if(this != &_o)
	{
		userName = std::move(_o.userName);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::clear()
{
	userName.clear();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::equals(const Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS& _o) const
{
	return Atf::atfPStringEquals(userName, _o.userName);
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_TOURNAMENT_USER_STATS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS*)_other));
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS).append(")");
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	return _buf.c_str();
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userName", userName, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userName);
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userName);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userName", userName);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userName", userName);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userName; _jparser.validateByNameThrow("userName", userName);
	AtfValidator::validateIntMax(_descr, "userName", userName.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY
//=================================================================

MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, reply(std::move(_o.reply))
{
}

MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY& MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::operator=(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		reply = std::move(_o.reply);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	reply.clear();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::equals(const Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		reply.equals(_o.reply);
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY*)_other));
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("reply=");
		reply.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		reply.toXmlString("reply", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("reply"))
			{
				if(!Atf::AtfTempl< UserStatsReply >::FromXmlString(_value, reply)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		reply.composeMsg(_msg, _ignoreJSON);
	}
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		reply.parseMsg(_parser);
	}
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("reply", reply);
	}
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("reply", reply);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UserStatsReply reply; _jparser.validateByNameThrow("reply", reply);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserStatsReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_REG_INFO
//=================================================================

MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::Protocol_MSG_LOBBY_TOURN_REG_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::Protocol_MSG_LOBBY_TOURN_REG_INFO(Protocol_MSG_LOBBY_TOURN_REG_INFO&& _o)
	: userId(std::move(_o.userId))
	, tournId(std::move(_o.tournId))
	, tournRegInfoFlags(std::move(_o.tournRegInfoFlags))
{
}

MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO& MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::operator=(Protocol_MSG_LOBBY_TOURN_REG_INFO&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		tournId = std::move(_o.tournId);
		tournRegInfoFlags = std::move(_o.tournRegInfoFlags);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::clear()
{
	userId.clear();
	tournId = 0;
	tournRegInfoFlags = 0;
}

bool MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::equals(const Protocol_MSG_LOBBY_TOURN_REG_INFO& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		tournId == _o.tournId &&
		tournRegInfoFlags == _o.tournRegInfoFlags;
}

bool MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TOURN_REG_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TOURN_REG_INFO*)_other));
}

const char *MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_REG_INFO).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("tournRegInfoFlags=");
	_buf.appendUint(tournRegInfoFlags);
	return _buf.c_str();
}

const char *MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TOURN_REG_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournRegInfoFlags", tournRegInfoFlags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournRegInfoFlags"))
			{
				tournRegInfoFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(tournId);
	_msg.composeUINT32(tournRegInfoFlags);
}

void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(tournId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(tournRegInfoFlags);
}

const char *MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("tournRegInfoFlags", tournRegInfoFlags);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("tournId", tournId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tournRegInfoFlags", tournRegInfoFlags);
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 tournRegInfoFlags; _jparser.validateByNameThrow("tournRegInfoFlags", tournRegInfoFlags);
	AtfValidator::validateIntMax(_descr, "tournRegInfoFlags", tournRegInfoFlags, static_cast<UINT32>(TournRegInfoFlags::eTournRegInfoFlags_Last), _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 tournRegInfoFlags; _parser.parseUINT32(tournRegInfoFlags);
	AtfValidator::validateIntMax(_descr, "tournRegInfoFlags", tournRegInfoFlags, static_cast<UINT32>(TournRegInfoFlags::eTournRegInfoFlags_Last), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY
//=================================================================

MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY(Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, currency(std::move(_o.currency))
	, buyInAndRake(std::move(_o.buyInAndRake))
	, enoughMoneyInOtherCurrency(std::move(_o.enoughMoneyInOtherCurrency))
	, tournSpendLimit(std::move(_o.tournSpendLimit))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, fpp(std::move(_o.fpp))
	, admissionId(std::move(_o.admissionId))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, isPwdProtected(std::move(_o.isPwdProtected))
	, userChips(std::move(_o.userChips))
	, userPlayChips(std::move(_o.userPlayChips))
	, userFpp(std::move(_o.userFpp))
	, numTickets(std::move(_o.numTickets))
	, tChips(std::move(_o.tChips))
	, wChips(std::move(_o.wChips))
	, preRegMsg(std::move(_o.preRegMsg))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, currencyContext(std::move(_o.currencyContext))
	, clientCurrencyContext(std::move(_o.clientCurrencyContext))
	, whenStartAbs(std::move(_o.whenStartAbs))
	, tournName(std::move(_o.tournName))
	, playChips64(std::move(_o.playChips64))
	, scalePM(std::move(_o.scalePM))
	, speed(std::move(_o.speed))
	, minPlayers(std::move(_o.minPlayers))
	, maxPlayers(std::move(_o.maxPlayers))
	, maxPerTable(std::move(_o.maxPerTable))
	, tournFlags(std::move(_o.tournFlags))
	, knockout(std::move(_o.knockout))
	, isProportional(std::move(_o.isProportional))
	, admPrice(std::move(_o.admPrice))
	, effectiveAdmissions(std::move(_o.effectiveAdmissions))
	, tournFlags2(std::move(_o.tournFlags2))
{
}

MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY& MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::operator=(Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		currency = std::move(_o.currency);
		buyInAndRake = std::move(_o.buyInAndRake);
		enoughMoneyInOtherCurrency = std::move(_o.enoughMoneyInOtherCurrency);
		tournSpendLimit = std::move(_o.tournSpendLimit);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		fpp = std::move(_o.fpp);
		admissionId = std::move(_o.admissionId);
		isPlayMoney = std::move(_o.isPlayMoney);
		isPwdProtected = std::move(_o.isPwdProtected);
		userChips = std::move(_o.userChips);
		userPlayChips = std::move(_o.userPlayChips);
		userFpp = std::move(_o.userFpp);
		numTickets = std::move(_o.numTickets);
		tChips = std::move(_o.tChips);
		wChips = std::move(_o.wChips);
		preRegMsg = std::move(_o.preRegMsg);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		currencyContext = std::move(_o.currencyContext);
		clientCurrencyContext = std::move(_o.clientCurrencyContext);
		whenStartAbs = std::move(_o.whenStartAbs);
		tournName = std::move(_o.tournName);
		playChips64 = std::move(_o.playChips64);
		scalePM = std::move(_o.scalePM);
		speed = std::move(_o.speed);
		minPlayers = std::move(_o.minPlayers);
		maxPlayers = std::move(_o.maxPlayers);
		maxPerTable = std::move(_o.maxPerTable);
		tournFlags = std::move(_o.tournFlags);
		knockout = std::move(_o.knockout);
		isProportional = std::move(_o.isProportional);
		admPrice = std::move(_o.admPrice);
		effectiveAdmissions = std::move(_o.effectiveAdmissions);
		tournFlags2 = std::move(_o.tournFlags2);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	currency.clear();
	buyInAndRake = 0;
	enoughMoneyInOtherCurrency = false;
	tournSpendLimit.clear();
	buyIn = 0;
	rake = 0;
	fpp = 0;
	admissionId.clear();
	isPlayMoney = 0;
	isPwdProtected = 0;
	userChips = 0;
	userPlayChips = 0;
	userFpp = 0;
	numTickets = 0;
	tChips = 0;
	wChips = 0;
	preRegMsg.clear();
	game = 0;
	isHiLo = 0;
	structure = 0;
	currencyContext.clear();
	clientCurrencyContext.clear();
	whenStartAbs.setNull();
	tournName.clear();
	playChips64 = 0;
	scalePM = 0;
	speed = 0;
	minPlayers = 0;
	maxPlayers = 0;
	maxPerTable = 0;
	tournFlags = 0;
	knockout = 0;
	isProportional = false;
	admPrice = 0;
	effectiveAdmissions.clear();
	tournFlags2 = 0;
}

bool MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::equals(const Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		buyInAndRake == _o.buyInAndRake &&
		enoughMoneyInOtherCurrency == _o.enoughMoneyInOtherCurrency &&
		tournSpendLimit.equals(_o.tournSpendLimit) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		fpp == _o.fpp &&
		Atf::atfPStringEquals(admissionId, _o.admissionId) &&
		isPlayMoney == _o.isPlayMoney &&
		isPwdProtected == _o.isPwdProtected &&
		userChips == _o.userChips &&
		userPlayChips == _o.userPlayChips &&
		userFpp == _o.userFpp &&
		numTickets == _o.numTickets &&
		tChips == _o.tChips &&
		wChips == _o.wChips &&
		Atf::atfPStringEquals(preRegMsg, _o.preRegMsg) &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		currencyContext.equals(_o.currencyContext) &&
		clientCurrencyContext.equals(_o.clientCurrencyContext) &&
		whenStartAbs.equals(_o.whenStartAbs) &&
		Atf::atfPStringEquals(tournName, _o.tournName) &&
		playChips64 == _o.playChips64 &&
		scalePM == _o.scalePM &&
		speed == _o.speed &&
		minPlayers == _o.minPlayers &&
		maxPlayers == _o.maxPlayers &&
		maxPerTable == _o.maxPerTable &&
		tournFlags == _o.tournFlags &&
		knockout == _o.knockout &&
		isProportional == _o.isProportional &&
		admPrice == _o.admPrice &&
		effectiveAdmissions.equals(_o.effectiveAdmissions) &&
		tournFlags2 == _o.tournFlags2;
}

bool MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TOURN_REG_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY*)_other));
}

const char *MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_REG_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode == TOURN_SPEND_LIMIT_EXCEEDED)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("buyInAndRake=");
		_buf.appendUint(buyInAndRake);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
		_buf.append(',');
		_buf.append("tournSpendLimit=");
		tournSpendLimit.toTraceString(_buf);
	}
	else if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("buyInAndRake=");
		_buf.appendUint(buyInAndRake);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
	}
	else
	{
		_buf.append(',');
		_buf.append("buyIn=");
		_buf.appendUint(buyIn);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendUint(rake);
		_buf.append(',');
		_buf.append("fpp=");
		_buf.appendUint(fpp);
		_buf.append(',');
		_buf.append("admissionId=");
		_buf.append(admissionId);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("isPwdProtected=");
		_buf.appendUint(isPwdProtected);
		_buf.append(',');
		_buf.append("userChips=");
		_buf.appendUint(userChips);
		_buf.append(',');
		_buf.append("userPlayChips=");
		_buf.appendUint(userPlayChips);
		_buf.append(',');
		_buf.append("userFpp=");
		_buf.appendUint(userFpp);
		_buf.append(',');
		_buf.append("numTickets=");
		_buf.appendUint(numTickets);
		_buf.append(',');
		_buf.append("tChips=");
		_buf.appendUint(tChips);
		_buf.append(',');
		_buf.append("wChips=");
		_buf.appendUint(wChips);
		_buf.append(',');
		_buf.append("preRegMsg=");
		_buf.append(preRegMsg);
		_buf.append(',');
		_buf.append("game=");
		_buf.appendUint(game);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
		_buf.append(',');
		_buf.append("currencyContext=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(currencyContext, _buf); _buf.append('}');
		_buf.append(',');
		_buf.append("clientCurrencyContext=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientCurrencyContext, _buf); _buf.append('}');
		_buf.append(',');
		_buf.append("whenStartAbs=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStartAbs);
		_buf.append(',');
		_buf.append("tournName=");
		_buf.append(tournName);
		_buf.append(',');
		_buf.append("playChips64=");
		_buf.appendUint64(playChips64);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendInt(scalePM);
		_buf.append(',');
		_buf.append("speed=");
		_buf.appendUint(speed);
		_buf.append(',');
		_buf.append("minPlayers=");
		_buf.appendUint(minPlayers);
		_buf.append(',');
		_buf.append("maxPlayers=");
		_buf.appendUint(maxPlayers);
		_buf.append(',');
		_buf.append("maxPerTable=");
		_buf.appendUint(maxPerTable);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("knockout=");
		_buf.appendUint(knockout);
		_buf.append(',');
		_buf.append("isProportional=");
		_buf.appendUint(isProportional);
		_buf.append(',');
		_buf.append("admPrice=");
		_buf.appendInt64(admPrice);
		_buf.append(',');
		_buf.append("effectiveAdmissions=");
		effectiveAdmissions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournFlags2=");
		_buf.appendInt64(tournFlags2);
		_buf.append(',');
		_buf.append("tournSpendLimit=");
		tournSpendLimit.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TOURN_REG_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode == TOURN_SPEND_LIMIT_EXCEEDED)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("buyInAndRake", buyInAndRake, _buf);
		Atf::XmlElement::encodeAsXmlElement("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _buf);
		tournSpendLimit.toXmlString("tournSpendLimit", _buf);
	}
	else if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("buyInAndRake", buyInAndRake, _buf);
		Atf::XmlElement::encodeAsXmlElement("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
		Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
		Atf::XmlElement::encodeAsXmlElement("fpp", fpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("admissionId", admissionId, _buf);
		Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
		Atf::XmlElement::encodeAsXmlElement("isPwdProtected", isPwdProtected, _buf);
		Atf::XmlElement::encodeAsXmlElement("userChips", userChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("userPlayChips", userPlayChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("userFpp", userFpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("numTickets", numTickets, _buf);
		Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("wChips", wChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("preRegMsg", preRegMsg, _buf);
		Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
		Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
		Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("currencyContext", currencyContext, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientCurrencyContext", clientCurrencyContext, _buf);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenStartAbs", whenStartAbs);
		Atf::XmlElement::encodeAsXmlElement("tournName", tournName, _buf);
		Atf::XmlElement::encodeAsXmlElement("playChips64", playChips64, _buf);
		Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
		Atf::XmlElement::encodeAsXmlElement("speed", speed, _buf);
		Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxPerTable", maxPerTable, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("knockout", knockout, _buf);
		Atf::XmlElement::encodeAsXmlElement("isProportional", isProportional, _buf);
		Atf::XmlElement::encodeAsXmlElement("admPrice", admPrice, _buf);
		effectiveAdmissions.toXmlString("effectiveAdmissions", _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
		tournSpendLimit.toXmlString("tournSpendLimit", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("buyInAndRake"))
			{
				buyInAndRake = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("enoughMoneyInOtherCurrency"))
			{
				enoughMoneyInOtherCurrency = (*_value.ptr() == '1');
			}
			else if (_element.equals("tournSpendLimit"))
			{
				if(!Atf::AtfTempl< TournSpendLimit >::FromXmlString(_value, tournSpendLimit)) return false;
			}
			else if (_element.equals("buyIn"))
			{
				buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rake"))
			{
				rake = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fpp"))
			{
				fpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("admissionId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, admissionId)) return false;
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPwdProtected"))
			{
				isPwdProtected = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userChips"))
			{
				userChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userPlayChips"))
			{
				userPlayChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userFpp"))
			{
				userFpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numTickets"))
			{
				numTickets = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tChips"))
			{
				tChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("wChips"))
			{
				wChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("preRegMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, preRegMsg)) return false;
			}
			else if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isHiLo"))
			{
				isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, currencyContext)) return false;
			}
			else if (_element.equals("clientCurrencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientCurrencyContext)) return false;
			}
			else if (_element.equals("whenStartAbs"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenStartAbs);
			}
			else if (_element.equals("tournName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournName)) return false;
			}
			else if (_element.equals("playChips64"))
			{
				playChips64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("scalePM"))
			{
				scalePM = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("speed"))
			{
				speed = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minPlayers"))
			{
				minPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPlayers"))
			{
				maxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPerTable"))
			{
				maxPerTable = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlags"))
			{
				tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("knockout"))
			{
				knockout = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isProportional"))
			{
				isProportional = (*_value.ptr() == '1');
			}
			else if (_element.equals("admPrice"))
			{
				admPrice = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("effectiveAdmissions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserTicketData, 4 > >::FromXmlString(_value, effectiveAdmissions)) return false;
			}
			else if (_element.equals("tournFlags2"))
			{
				tournFlags2 = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode == TOURN_SPEND_LIMIT_EXCEEDED)
	{
		_msg.composeString(errDescr);
		_msg.composeString(currency);
		_msg.composeUINT32(buyInAndRake);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
		tournSpendLimit.composeMsg(_msg, _ignoreJSON);
	}
	else if( errCode )
	{
		_msg.composeString(errDescr);
		_msg.composeString(currency);
		_msg.composeUINT32(buyInAndRake);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
	}
	else
	{
		_msg.composeUINT32(buyIn);
		_msg.composeUINT32(rake);
		_msg.composeUINT32(fpp);
		_msg.composeString(admissionId);
		_msg.composeBYTE(isPlayMoney);
		_msg.composeBYTE(isPwdProtected);
		_msg.composeUINT32(userChips);
		_msg.composeUINT32(userPlayChips);
		_msg.composeUINT32(userFpp);
		_msg.composeUINT32(numTickets);
		_msg.composeUINT32(tChips);
		_msg.composeUINT32(wChips);
		_msg.composeString(preRegMsg);
		_msg.composeBYTE(game);
		_msg.composeBYTE(isHiLo);
		_msg.composeBYTE(structure);
		_msg.composeString(currency);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
		_msg.composeMsgBody(currencyContext);
		_msg.composeMsgBody(clientCurrencyContext);
		_msg.composeSrvTime(whenStartAbs);
		_msg.composeString(tournName);
		_msg.composeUINT64(playChips64);
		_msg.composeINT32(scalePM);
		_msg.composeBYTE(speed);
		_msg.composeUINT32(minPlayers);
		_msg.composeUINT32(maxPlayers);
		_msg.composeBYTE(maxPerTable);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT32(knockout);
		_msg.composeBOOL(isProportional);
		_msg.composeINT64(admPrice);
		effectiveAdmissions.composeMsg(_msg, _ignoreJSON);
		_msg.composeINT64(tournFlags2);
		tournSpendLimit.composeMsg(_msg, _ignoreJSON);
	}
}

void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode == TOURN_SPEND_LIMIT_EXCEEDED)
	{
		_parser.parseStringP(errDescr);
		_parser.parseStringP(currency);
		_parser.parseUINT32(buyInAndRake);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
		tournSpendLimit.parseMsg(_parser);
	}
	else if( errCode )
	{
		_parser.parseStringP(errDescr);
		_parser.parseStringP(currency);
		_parser.parseUINT32(buyInAndRake);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
	}
	else
	{
		_parser.parseUINT32(buyIn);
		_parser.parseUINT32(rake);
		_parser.parseUINT32(fpp);
		_parser.parseStringP(admissionId);
		_parser.parseBYTE(isPlayMoney);
		_parser.parseBYTE(isPwdProtected);
		_parser.parseUINT32(userChips);
		_parser.parseUINT32(userPlayChips);
		_parser.parseUINT32(userFpp);
		_parser.parseUINT32(numTickets);
		_parser.parseUINT32(tChips);
		_parser.parseUINT32(wChips);
		_parser.parseStringP(preRegMsg);
		_parser.parseBYTE(game);
		_parser.parseBYTE(isHiLo);
		_parser.parseBYTE(structure);
		_parser.parseStringP(currency);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
		_parser.parseMsgBody(currencyContext);
		_parser.parseMsgBody(clientCurrencyContext);
		_parser.parseSrvTime(whenStartAbs);
		_parser.parseStringP(tournName);
		_parser.parseUINT64(playChips64);
		_parser.parseINT32(scalePM);
		_parser.parseBYTE(speed);
		_parser.parseUINT32(minPlayers);
		_parser.parseUINT32(maxPlayers);
		_parser.parseBYTE(maxPerTable);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT32(knockout);
		_parser.parseBOOL(isProportional);
		_parser.parseINT64(admPrice);
		effectiveAdmissions.parseMsg(_parser);
		_parser.parseINT64(tournFlags2);
		if(_parser.parseEnded()) return;
		tournSpendLimit.parseMsg(_parser);
	}
}

const char *MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode == TOURN_SPEND_LIMIT_EXCEEDED)
	{
		_jsonstr.compose("errDescr", errDescr);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("buyInAndRake", buyInAndRake);
		_jsonstr.compose("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		_jsonstr.compose("tournSpendLimit", tournSpendLimit);
	}
	else if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("buyInAndRake", buyInAndRake);
		_jsonstr.compose("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
	}
	else
	{
		_jsonstr.compose("buyIn", buyIn);
		_jsonstr.compose("rake", rake);
		_jsonstr.compose("fpp", fpp);
		_jsonstr.compose("admissionId", admissionId);
		_jsonstr.compose("isPlayMoney", isPlayMoney);
		_jsonstr.compose("isPwdProtected", isPwdProtected);
		_jsonstr.compose("userChips", userChips);
		_jsonstr.compose("userPlayChips", userPlayChips);
		_jsonstr.compose("userFpp", userFpp);
		_jsonstr.compose("numTickets", numTickets);
		_jsonstr.compose("tChips", tChips);
		_jsonstr.compose("wChips", wChips);
		_jsonstr.compose("preRegMsg", preRegMsg);
		_jsonstr.compose("game", game);
		_jsonstr.compose("isHiLo", isHiLo);
		_jsonstr.compose("structure", structure);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		_jsonstr.compose("currencyContext", currencyContext);
		_jsonstr.compose("clientCurrencyContext", clientCurrencyContext);
		_jsonstr.compose("whenStartAbs", whenStartAbs);
		_jsonstr.compose("tournName", tournName);
		_jsonstr.compose("playChips64", playChips64);
		_jsonstr.compose("scalePM", scalePM);
		_jsonstr.compose("speed", speed);
		_jsonstr.compose("minPlayers", minPlayers);
		_jsonstr.compose("maxPlayers", maxPlayers);
		_jsonstr.compose("maxPerTable", maxPerTable);
		_jsonstr.compose("tournFlags", tournFlags);
		_jsonstr.compose("knockout", knockout);
		_jsonstr.compose("isProportional", isProportional);
		_jsonstr.compose("admPrice", admPrice);
		_jsonstr.compose("effectiveAdmissions", effectiveAdmissions);
		_jsonstr.compose("tournFlags2", tournFlags2);
		_jsonstr.compose("tournSpendLimit", tournSpendLimit);
	}
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode == TOURN_SPEND_LIMIT_EXCEEDED)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("buyInAndRake", buyInAndRake);
		_jparser.parseByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		_jparser.parseByNameThrow("tournSpendLimit", tournSpendLimit);
	}
	else if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("buyInAndRake", buyInAndRake);
		_jparser.parseByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
	}
	else
	{
		_jparser.parseByNameThrow("buyIn", buyIn);
		_jparser.parseByNameThrow("rake", rake);
		_jparser.parseByNameThrow("fpp", fpp);
		_jparser.parseByNameThrow("admissionId", admissionId);
		_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
		_jparser.parseByNameThrow("isPwdProtected", isPwdProtected);
		_jparser.parseByNameThrow("userChips", userChips);
		_jparser.parseByNameThrow("userPlayChips", userPlayChips);
		_jparser.parseByNameThrow("userFpp", userFpp);
		_jparser.parseByNameThrow("numTickets", numTickets);
		_jparser.parseByNameThrow("tChips", tChips);
		_jparser.parseByNameThrow("wChips", wChips);
		_jparser.parseByNameThrow("preRegMsg", preRegMsg);
		_jparser.parseByNameThrow("game", game);
		_jparser.parseByNameThrow("isHiLo", isHiLo);
		_jparser.parseByNameThrow("structure", structure);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		_jparser.parseByNameThrow("currencyContext", currencyContext);
		_jparser.parseByNameThrow("clientCurrencyContext", clientCurrencyContext);
		_jparser.parseByNameThrow("whenStartAbs", whenStartAbs);
		_jparser.parseByNameThrow("tournName", tournName);
		_jparser.parseByNameThrow("playChips64", playChips64);
		_jparser.parseByNameThrow("scalePM", scalePM);
		_jparser.parseByNameThrow("speed", speed);
		_jparser.parseByNameThrow("minPlayers", minPlayers);
		_jparser.parseByNameThrow("maxPlayers", maxPlayers);
		_jparser.parseByNameThrow("maxPerTable", maxPerTable);
		_jparser.parseByNameThrow("tournFlags", tournFlags);
		_jparser.parseByNameThrow("knockout", knockout);
		_jparser.parseByNameThrow("isProportional", isProportional);
		_jparser.parseByNameThrow("admPrice", admPrice);
		_jparser.parseByNameThrow("effectiveAdmissions", effectiveAdmissions);
		_jparser.parseByNameThrow("tournFlags2", tournFlags2);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("tournSpendLimit", tournSpendLimit);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode == TOURN_SPEND_LIMIT_EXCEEDED)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		UINT32 buyInAndRake; _jparser.validateByNameThrow("buyInAndRake", buyInAndRake);
		AtfValidator::validateInt(_descr, "buyInAndRake", buyInAndRake, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _jparser.validateByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		TournSpendLimit tournSpendLimit; _jparser.validateByNameThrow("tournSpendLimit", tournSpendLimit);
	}
	else if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		UINT32 buyInAndRake; _jparser.validateByNameThrow("buyInAndRake", buyInAndRake);
		AtfValidator::validateInt(_descr, "buyInAndRake", buyInAndRake, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _jparser.validateByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		UINT32 rake; _jparser.validateByNameThrow("rake", rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 fpp; _jparser.validateByNameThrow("fpp", fpp);
		AtfValidator::validateInt(_descr, "fpp", fpp, _checker, __FILE__, __LINE__);
		PString admissionId; _jparser.validateByNameThrow("admissionId", admissionId);
		AtfValidator::validateInt(_descr, "admissionId", admissionId.length(), _checker, __FILE__, __LINE__);
		BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		BYTE isPwdProtected; _jparser.validateByNameThrow("isPwdProtected", isPwdProtected);
		AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
		UINT32 userChips; _jparser.validateByNameThrow("userChips", userChips);
		AtfValidator::validateInt(_descr, "userChips", userChips, _checker, __FILE__, __LINE__);
		UINT32 userPlayChips; _jparser.validateByNameThrow("userPlayChips", userPlayChips);
		AtfValidator::validateInt(_descr, "userPlayChips", userPlayChips, _checker, __FILE__, __LINE__);
		UINT32 userFpp; _jparser.validateByNameThrow("userFpp", userFpp);
		AtfValidator::validateInt(_descr, "userFpp", userFpp, _checker, __FILE__, __LINE__);
		UINT32 numTickets; _jparser.validateByNameThrow("numTickets", numTickets);
		AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
		UINT32 tChips; _jparser.validateByNameThrow("tChips", tChips);
		AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
		UINT32 wChips; _jparser.validateByNameThrow("wChips", wChips);
		AtfValidator::validateInt(_descr, "wChips", wChips, _checker, __FILE__, __LINE__);
		PString preRegMsg; _jparser.validateByNameThrow("preRegMsg", preRegMsg);
		AtfValidator::validateInt(_descr, "preRegMsg", preRegMsg.length(), _checker, __FILE__, __LINE__);
		BYTE game; _jparser.validateByNameThrow("game", game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _jparser.validateByNameThrow("structure", structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _jparser.validateByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody currencyContext; _jparser.validateByNameThrow("currencyContext", currencyContext);
		AtfValidator::validateInt(_descr, "currencyContext", currencyContext._size(), _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody clientCurrencyContext; _jparser.validateByNameThrow("clientCurrencyContext", clientCurrencyContext);
		AtfValidator::validateInt(_descr, "clientCurrencyContext", clientCurrencyContext._size(), _checker, __FILE__, __LINE__);
		SrvTime whenStartAbs; _jparser.validateByNameThrow("whenStartAbs", whenStartAbs);
		AtfValidator::validateSrvDateTime(_descr, "whenStartAbs", whenStartAbs, _checker, __FILE__, __LINE__);
		PString tournName; _jparser.validateByNameThrow("tournName", tournName);
		AtfValidator::validateInt(_descr, "tournName", tournName.length(), _checker, __FILE__, __LINE__);
		UINT64 playChips64; _jparser.validateByNameThrow("playChips64", playChips64);
		AtfValidator::validateUint(_descr, "playChips64", playChips64, _checker, __FILE__, __LINE__);
		INT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE speed; _jparser.validateByNameThrow("speed", speed);
		AtfValidator::validateInt(_descr, "speed", speed, _checker, __FILE__, __LINE__);
		UINT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		UINT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		BYTE maxPerTable; _jparser.validateByNameThrow("maxPerTable", maxPerTable);
		AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 knockout; _jparser.validateByNameThrow("knockout", knockout);
		AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
		bool isProportional; _jparser.validateByNameThrow("isProportional", isProportional);
		AtfValidator::validateInt(_descr, "isProportional", isProportional, _checker, __FILE__, __LINE__);
		INT64 admPrice; _jparser.validateByNameThrow("admPrice", admPrice);
		AtfValidator::validateInt(_descr, "admPrice", admPrice, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UserTicketData > effectiveAdmissions; _jparser.validateByNameThrow("effectiveAdmissions", effectiveAdmissions);
		AtfValidator::validateInt(_descr, "effectiveAdmissions", effectiveAdmissions.size(), _checker, __FILE__, __LINE__);
		INT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
		AtfValidator::validateInt(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		TournSpendLimit tournSpendLimit; _jparser.validateByNameThrow("tournSpendLimit", tournSpendLimit);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode == TOURN_SPEND_LIMIT_EXCEEDED)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		UINT32 buyInAndRake; _parser.parseUINT32(buyInAndRake);
		AtfValidator::validateInt(_descr, "buyInAndRake", buyInAndRake, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		PString _descbuf;
		TournSpendLimit::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSpendLimit"), _fieldsWithUnparsedContent);
	}
	else if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		UINT32 buyInAndRake; _parser.parseUINT32(buyInAndRake);
		AtfValidator::validateInt(_descr, "buyInAndRake", buyInAndRake, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 buyIn; _parser.parseUINT32(buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		UINT32 rake; _parser.parseUINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 fpp; _parser.parseUINT32(fpp);
		AtfValidator::validateInt(_descr, "fpp", fpp, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
		BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		BYTE isPwdProtected; _parser.parseBYTE(isPwdProtected);
		AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
		UINT32 userChips; _parser.parseUINT32(userChips);
		AtfValidator::validateInt(_descr, "userChips", userChips, _checker, __FILE__, __LINE__);
		UINT32 userPlayChips; _parser.parseUINT32(userPlayChips);
		AtfValidator::validateInt(_descr, "userPlayChips", userPlayChips, _checker, __FILE__, __LINE__);
		UINT32 userFpp; _parser.parseUINT32(userFpp);
		AtfValidator::validateInt(_descr, "userFpp", userFpp, _checker, __FILE__, __LINE__);
		UINT32 numTickets; _parser.parseUINT32(numTickets);
		AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
		UINT32 tChips; _parser.parseUINT32(tChips);
		AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
		UINT32 wChips; _parser.parseUINT32(wChips);
		AtfValidator::validateInt(_descr, "wChips", wChips, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "preRegMsg"); size_t szPreRegMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "preRegMsg", szPreRegMsg, _checker, __FILE__, __LINE__);
		BYTE game; _parser.parseBYTE(game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _parser.parseBYTE(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
		AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
		size_t szClientCurrencyContext; _parser.skipMsgBody(szClientCurrencyContext);  /*clientCurrencyContext*/
		AtfValidator::validateInt(_descr, "clientCurrencyContext", szClientCurrencyContext, _checker, __FILE__, __LINE__);
		SrvTime whenStartAbs; _parser.parseSrvTime(whenStartAbs);
		AtfValidator::validateSrvDateTime(_descr, "whenStartAbs", whenStartAbs, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tournName"); size_t szTournName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournName", szTournName, _checker, __FILE__, __LINE__);
		UINT64 playChips64; _parser.parseUINT64(playChips64);
		AtfValidator::validateUint(_descr, "playChips64", playChips64, _checker, __FILE__, __LINE__);
		INT32 scalePM; _parser.parseINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE speed; _parser.parseBYTE(speed);
		AtfValidator::validateInt(_descr, "speed", speed, _checker, __FILE__, __LINE__);
		UINT32 minPlayers; _parser.parseUINT32(minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		UINT32 maxPlayers; _parser.parseUINT32(maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		BYTE maxPerTable; _parser.parseBYTE(maxPerTable);
		AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 knockout; _parser.parseUINT32(knockout);
		AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
		bool isProportional; _parser.parseBOOL(isProportional);
		AtfValidator::validateInt(_descr, "isProportional", isProportional, _checker, __FILE__, __LINE__);
		INT64 admPrice; _parser.parseINT64(admPrice);
		AtfValidator::validateInt(_descr, "admPrice", admPrice, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szEffectiveAdmissions = Atf::LAtfVector< UserTicketData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("effectiveAdmissions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "effectiveAdmissions", szEffectiveAdmissions, _checker, __FILE__, __LINE__);
		INT64 tournFlags2; _parser.parseINT64(tournFlags2);
		AtfValidator::validateInt(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		TournSpendLimit::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSpendLimit"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_REGISTER_USER
//=================================================================

MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::Protocol_MTL_LOBBY_REGISTER_USER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::Protocol_MTL_LOBBY_REGISTER_USER(Protocol_MTL_LOBBY_REGISTER_USER&& _o)
	: userName(std::move(_o.userName))
	, buyInRM(std::move(_o.buyInRM))
	, buyInPlay(std::move(_o.buyInPlay))
	, buyInFpp(std::move(_o.buyInFpp))
	, tournPwd(std::move(_o.tournPwd))
	, useTicket(std::move(_o.useTicket))
	, buyInT(std::move(_o.buyInT))
	, buyInW(std::move(_o.buyInW))
	, currencyContext(std::move(_o.currencyContext))
	, currency(std::move(_o.currency))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, structure(std::move(_o.structure))
	, startTime(std::move(_o.startTime))
	, clientRegFlags(std::move(_o.clientRegFlags))
{
}

MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER& MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::operator=(Protocol_MTL_LOBBY_REGISTER_USER&& _o)
{
	if(this != &_o)
	{
		userName = std::move(_o.userName);
		buyInRM = std::move(_o.buyInRM);
		buyInPlay = std::move(_o.buyInPlay);
		buyInFpp = std::move(_o.buyInFpp);
		tournPwd = std::move(_o.tournPwd);
		useTicket = std::move(_o.useTicket);
		buyInT = std::move(_o.buyInT);
		buyInW = std::move(_o.buyInW);
		currencyContext = std::move(_o.currencyContext);
		currency = std::move(_o.currency);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		structure = std::move(_o.structure);
		startTime = std::move(_o.startTime);
		clientRegFlags = std::move(_o.clientRegFlags);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::clear()
{
	userName.clear();
	buyInRM = 0;
	buyInPlay = 0;
	buyInFpp = 0;
	tournPwd.clear();
	useTicket = 0;
	buyInT = 0;
	buyInW = 0;
	currencyContext.clear();
	currency.clear();
	game = 0;
	hiLo = 0;
	structure = 0;
	startTime.setNull();
	clientRegFlags = 0;
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::equals(const Protocol_MTL_LOBBY_REGISTER_USER& _o) const
{
	return Atf::atfPStringEquals(userName, _o.userName) &&
		buyInRM == _o.buyInRM &&
		buyInPlay == _o.buyInPlay &&
		buyInFpp == _o.buyInFpp &&
		Atf::atfPStringEquals(tournPwd, _o.tournPwd) &&
		useTicket == _o.useTicket &&
		buyInT == _o.buyInT &&
		buyInW == _o.buyInW &&
		currencyContext.equals(_o.currencyContext) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		startTime.equals(_o.startTime) &&
		clientRegFlags == _o.clientRegFlags;
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_REGISTER_USER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_REGISTER_USER*)_other));
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_REGISTER_USER).append(")");
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	_buf.append(',');
	_buf.append("buyInRM=");
	_buf.appendInt(buyInRM);
	_buf.append(',');
	_buf.append("buyInPlay=");
	_buf.appendInt(buyInPlay);
	_buf.append(',');
	_buf.append("buyInFpp=");
	_buf.appendInt(buyInFpp);
	_buf.append(',');
	_buf.append("tournPwd=");
	_buf.append(tournPwd);
	_buf.append(',');
	_buf.append("useTicket=");
	_buf.appendUint(useTicket);
	_buf.append(',');
	_buf.append("buyInT=");
	_buf.appendInt(buyInT);
	_buf.append(',');
	_buf.append("buyInW=");
	_buf.appendInt(buyInW);
	_buf.append(',');
	_buf.append("currencyContext=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(currencyContext, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("startTime=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, startTime);
	_buf.append(',');
	_buf.append("clientRegFlags=");
	_buf.appendUint(clientRegFlags);
	return _buf.c_str();
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_REGISTER_USER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userName", userName, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInRM", buyInRM, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInPlay", buyInPlay, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInFpp", buyInFpp, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournPwd", tournPwd, _buf);
	Atf::XmlElement::encodeAsXmlElement("useTicket", useTicket, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInT", buyInT, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInW", buyInW, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyContext", currencyContext, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiLo", hiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "startTime", startTime);
	Atf::XmlElement::encodeAsXmlElement("clientRegFlags", clientRegFlags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userName)) return false;
			}
			else if (_element.equals("buyInRM"))
			{
				buyInRM = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInPlay"))
			{
				buyInPlay = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInFpp"))
			{
				buyInFpp = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournPwd"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournPwd)) return false;
			}
			else if (_element.equals("useTicket"))
			{
				useTicket = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInT"))
			{
				buyInT = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInW"))
			{
				buyInW = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, currencyContext)) return false;
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("hiLo"))
			{
				hiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("startTime"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, startTime);
			}
			else if (_element.equals("clientRegFlags"))
			{
				clientRegFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userName);
	_msg.composeINT32(buyInRM);
	_msg.composeINT32(buyInPlay);
	_msg.composeINT32(buyInFpp);
	_msg.composeString(tournPwd);
	_msg.composeBYTE(useTicket);
	_msg.composeINT32(buyInT);
	_msg.composeINT32(buyInW);
	_msg.composeMsgBody(currencyContext);
	_msg.composeString(currency);
	_msg.composeBYTE(game);
	_msg.composeBYTE(hiLo);
	_msg.composeBYTE(structure);
	_msg.composeSrvTime(startTime);
	_msg.composeUINT32(clientRegFlags);
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userName);
	_parser.parseINT32(buyInRM);
	_parser.parseINT32(buyInPlay);
	_parser.parseINT32(buyInFpp);
	_parser.parseStringP(tournPwd);
	_parser.parseBYTE(useTicket);
	_parser.parseINT32(buyInT);
	_parser.parseINT32(buyInW);
	_parser.parseMsgBody(currencyContext);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(currency);
	_parser.parseBYTE(game);
	_parser.parseBYTE(hiLo);
	_parser.parseBYTE(structure);
	_parser.parseSrvTime(startTime);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(clientRegFlags);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userName", userName);
	_jsonstr.compose("buyInRM", buyInRM);
	_jsonstr.compose("buyInPlay", buyInPlay);
	_jsonstr.compose("buyInFpp", buyInFpp);
	_jsonstr.compose("tournPwd", tournPwd);
	_jsonstr.compose("useTicket", useTicket);
	_jsonstr.compose("buyInT", buyInT);
	_jsonstr.compose("buyInW", buyInW);
	_jsonstr.compose("currencyContext", currencyContext);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("game", game);
	_jsonstr.compose("hiLo", hiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("startTime", startTime);
	_jsonstr.compose("clientRegFlags", clientRegFlags);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userName", userName);
	_jparser.parseByNameThrow("buyInRM", buyInRM);
	_jparser.parseByNameThrow("buyInPlay", buyInPlay);
	_jparser.parseByNameThrow("buyInFpp", buyInFpp);
	_jparser.parseByNameThrow("tournPwd", tournPwd);
	_jparser.parseByNameThrow("useTicket", useTicket);
	_jparser.parseByNameThrow("buyInT", buyInT);
	_jparser.parseByNameThrow("buyInW", buyInW);
	_jparser.parseByNameThrow("currencyContext", currencyContext);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("hiLo", hiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("startTime", startTime);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientRegFlags", clientRegFlags);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_REGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userName; _jparser.validateByNameThrow("userName", userName);
	AtfValidator::validateIntMax(_descr, "userName", userName.length(), 20, _checker, __FILE__, __LINE__);
	INT32 buyInRM; _jparser.validateByNameThrow("buyInRM", buyInRM);
	AtfValidator::validateIntRange(_descr, "buyInRM", buyInRM, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 buyInPlay; _jparser.validateByNameThrow("buyInPlay", buyInPlay);
	AtfValidator::validateIntRange(_descr, "buyInPlay", buyInPlay, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 buyInFpp; _jparser.validateByNameThrow("buyInFpp", buyInFpp);
	AtfValidator::validateIntRange(_descr, "buyInFpp", buyInFpp, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString tournPwd; _jparser.validateByNameThrow("tournPwd", tournPwd);
	AtfValidator::validateIntMax(_descr, "tournPwd", tournPwd.length(), 100, _checker, __FILE__, __LINE__);
	BYTE useTicket; _jparser.validateByNameThrow("useTicket", useTicket);
	AtfValidator::validateInt(_descr, "useTicket", useTicket, _checker, __FILE__, __LINE__);
	INT32 buyInT; _jparser.validateByNameThrow("buyInT", buyInT);
	AtfValidator::validateIntRange(_descr, "buyInT", buyInT, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 buyInW; _jparser.validateByNameThrow("buyInW", buyInW);
	AtfValidator::validateIntRange(_descr, "buyInW", buyInW, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody currencyContext; _jparser.validateByNameThrow("currencyContext", currencyContext);
	AtfValidator::validateInt(_descr, "currencyContext", currencyContext._size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), 5, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE hiLo; _jparser.validateByNameThrow("hiLo", hiLo);
	AtfValidator::validateInt(_descr, "hiLo", hiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	SrvTime startTime; _jparser.validateByNameThrow("startTime", startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 clientRegFlags; _jparser.validateByNameThrow("clientRegFlags", clientRegFlags);
	AtfValidator::validateInt(_descr, "clientRegFlags", clientRegFlags, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_REGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	INT32 buyInRM; _parser.parseINT32(buyInRM);
	AtfValidator::validateIntRange(_descr, "buyInRM", buyInRM, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 buyInPlay; _parser.parseINT32(buyInPlay);
	AtfValidator::validateIntRange(_descr, "buyInPlay", buyInPlay, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 buyInFpp; _parser.parseINT32(buyInFpp);
	AtfValidator::validateIntRange(_descr, "buyInFpp", buyInFpp, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tournPwd"); size_t szTournPwd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tournPwd", szTournPwd, 100, _checker, __FILE__, __LINE__);
	BYTE useTicket; _parser.parseBYTE(useTicket);
	AtfValidator::validateInt(_descr, "useTicket", useTicket, _checker, __FILE__, __LINE__);
	INT32 buyInT; _parser.parseINT32(buyInT);
	AtfValidator::validateIntRange(_descr, "buyInT", buyInT, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 buyInW; _parser.parseINT32(buyInW);
	AtfValidator::validateIntRange(_descr, "buyInW", buyInW, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 5, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser.parseBYTE(hiLo);
	AtfValidator::validateInt(_descr, "hiLo", hiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	SrvTime startTime; _parser.parseSrvTime(startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 clientRegFlags; _parser.parseUINT32(clientRegFlags);
	AtfValidator::validateInt(_descr, "clientRegFlags", clientRegFlags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_REGISTER_USER_REPLY
//=================================================================

MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::Protocol_MTL_LOBBY_REGISTER_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::Protocol_MTL_LOBBY_REGISTER_USER_REPLY(Protocol_MTL_LOBBY_REGISTER_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, maxAllins(std::move(_o.maxAllins))
	, registrationMsg(std::move(_o.registrationMsg))
	, seatsAvailable(std::move(_o.seatsAvailable))
	, serverName(std::move(_o.serverName))
	, socialToken(std::move(_o.socialToken))
	, clientNotification(std::move(_o.clientNotification))
{
}

MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY& MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::operator=(Protocol_MTL_LOBBY_REGISTER_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		maxAllins = std::move(_o.maxAllins);
		registrationMsg = std::move(_o.registrationMsg);
		seatsAvailable = std::move(_o.seatsAvailable);
		serverName = std::move(_o.serverName);
		socialToken = std::move(_o.socialToken);
		clientNotification = std::move(_o.clientNotification);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	maxAllins = 0;
	registrationMsg.clear();
	seatsAvailable = false;
	serverName.clear();
	socialToken.clear();
	clientNotification.clear();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::equals(const Protocol_MTL_LOBBY_REGISTER_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		maxAllins == _o.maxAllins &&
		Atf::atfPStringEquals(registrationMsg, _o.registrationMsg) &&
		seatsAvailable == _o.seatsAvailable &&
		Atf::atfPStringEquals(serverName, _o.serverName) &&
		Atf::atfPStringEquals(socialToken, _o.socialToken) &&
		Atf::atfPStringEquals(clientNotification, _o.clientNotification);
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_REGISTER_USER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_REGISTER_USER_REPLY*)_other));
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_REGISTER_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	if( !errCode )
	{
		_buf.append(',');
		_buf.append("maxAllins=");
		_buf.appendInt(maxAllins);
		_buf.append(',');
		_buf.append("registrationMsg=");
		_buf.append(registrationMsg);
		_buf.append(',');
		_buf.append("seatsAvailable=");
		_buf.appendUint(seatsAvailable);
		_buf.append(',');
		_buf.append("serverName=");
		_buf.append(serverName);
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("clientNotification=");
		_buf.append(clientNotification);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_REGISTER_USER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	if( !errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("maxAllins", maxAllins, _buf);
		Atf::XmlElement::encodeAsXmlElement("registrationMsg", registrationMsg, _buf);
		Atf::XmlElement::encodeAsXmlElement("seatsAvailable", seatsAvailable, _buf);
		Atf::XmlElement::encodeAsXmlElement("serverName", serverName, _buf);
		Atf::XmlElement::encodeAsXmlElement("socialToken", socialToken, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientNotification", clientNotification, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("maxAllins"))
			{
				maxAllins = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("registrationMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, registrationMsg)) return false;
			}
			else if (_element.equals("seatsAvailable"))
			{
				seatsAvailable = (*_value.ptr() == '1');
			}
			else if (_element.equals("serverName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, serverName)) return false;
			}
			else if (_element.equals("socialToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
			}
			else if (_element.equals("clientNotification"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clientNotification)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
	if( !errCode )
	{
		_msg.composeINT16(maxAllins);
		_msg.composeString(registrationMsg);
		_msg.composeBOOL(seatsAvailable);
		_msg.composeString(serverName);
		_msg.composeString(socialToken);
		_msg.composeString(clientNotification);
	}
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
	if( !errCode )
	{
		if(_parser.parseEnded()) return;
		_parser.parseINT16(maxAllins);
		_parser.parseStringP(registrationMsg);
		_parser.parseBOOL(seatsAvailable);
		_parser.parseStringP(serverName);
		_parser.parseStringP(socialToken);
		_parser.parseStringP(clientNotification);
	}
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errDescr", errDescr);
	if( !errCode )
	{
		_jsonstr.compose("maxAllins", maxAllins);
		_jsonstr.compose("registrationMsg", registrationMsg);
		_jsonstr.compose("seatsAvailable", seatsAvailable);
		_jsonstr.compose("serverName", serverName);
		_jsonstr.compose("socialToken", socialToken);
		_jsonstr.compose("clientNotification", clientNotification);
	}
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errDescr", errDescr);
	if( !errCode )
	{
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("maxAllins", maxAllins);
		_jparser.parseByNameThrow("registrationMsg", registrationMsg);
		_jparser.parseByNameThrow("seatsAvailable", seatsAvailable);
		_jparser.parseByNameThrow("serverName", serverName);
		_jparser.parseByNameThrow("socialToken", socialToken);
		_jparser.parseByNameThrow("clientNotification", clientNotification);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_REGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
	AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	if( !errCode )
	{
		if(_jparser.parseEnded()) return;
		INT16 maxAllins; _jparser.validateByNameThrow("maxAllins", maxAllins);
		AtfValidator::validateInt(_descr, "maxAllins", maxAllins, _checker, __FILE__, __LINE__);
		PString registrationMsg; _jparser.validateByNameThrow("registrationMsg", registrationMsg);
		AtfValidator::validateInt(_descr, "registrationMsg", registrationMsg.length(), _checker, __FILE__, __LINE__);
		bool seatsAvailable; _jparser.validateByNameThrow("seatsAvailable", seatsAvailable);
		AtfValidator::validateInt(_descr, "seatsAvailable", seatsAvailable, _checker, __FILE__, __LINE__);
		PString serverName; _jparser.validateByNameThrow("serverName", serverName);
		AtfValidator::validateInt(_descr, "serverName", serverName.length(), _checker, __FILE__, __LINE__);
		PString socialToken; _jparser.validateByNameThrow("socialToken", socialToken);
		AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
		PString clientNotification; _jparser.validateByNameThrow("clientNotification", clientNotification);
		AtfValidator::validateInt(_descr, "clientNotification", clientNotification.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_REGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	if( !errCode )
	{
		if(_parser.parseEnded()) return;
		INT16 maxAllins; _parser.parseINT16(maxAllins);
		AtfValidator::validateInt(_descr, "maxAllins", maxAllins, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "registrationMsg"); size_t szRegistrationMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "registrationMsg", szRegistrationMsg, _checker, __FILE__, __LINE__);
		bool seatsAvailable; _parser.parseBOOL(seatsAvailable);
		AtfValidator::validateInt(_descr, "seatsAvailable", seatsAvailable, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverName"); size_t szServerName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverName", szServerName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "clientNotification"); size_t szClientNotification = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clientNotification", szClientNotification, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_UNREGISTER_USER
//=================================================================

MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::Protocol_MTL_LOBBY_UNREGISTER_USER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::Protocol_MTL_LOBBY_UNREGISTER_USER(Protocol_MTL_LOBBY_UNREGISTER_USER&& _o)
	: tournId(std::move(_o.tournId))
	, userName(std::move(_o.userName))
{
}

MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER& MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::operator=(Protocol_MTL_LOBBY_UNREGISTER_USER&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		userName = std::move(_o.userName);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::clear()
{
	tournId = 0;
	userName.clear();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::equals(const Protocol_MTL_LOBBY_UNREGISTER_USER& _o) const
{
	return tournId == _o.tournId &&
		Atf::atfPStringEquals(userName, _o.userName);
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_UNREGISTER_USER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_UNREGISTER_USER*)_other));
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_UNREGISTER_USER).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	return _buf.c_str();
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_UNREGISTER_USER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userName", userName, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournId);
	_msg.composeString(userName);
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
	_parser.parseStringP(userName);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("userName", userName);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("userName", userName);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_UNREGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	PString userName; _jparser.validateByNameThrow("userName", userName);
	AtfValidator::validateIntMax(_descr, "userName", userName.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_UNREGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY
//=================================================================

MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY(Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, refund(std::move(_o.refund))
	, refundPlay(std::move(_o.refundPlay))
	, refundFpp(std::move(_o.refundFpp))
	, refundTChips(std::move(_o.refundTChips))
	, refundWChips(std::move(_o.refundWChips))
	, tournamentCurrency(std::move(_o.tournamentCurrency))
	, refundCurrency(std::move(_o.refundCurrency))
	, refundPlay64(std::move(_o.refundPlay64))
{
}

MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY& MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::operator=(Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		refund = std::move(_o.refund);
		refundPlay = std::move(_o.refundPlay);
		refundFpp = std::move(_o.refundFpp);
		refundTChips = std::move(_o.refundTChips);
		refundWChips = std::move(_o.refundWChips);
		tournamentCurrency = std::move(_o.tournamentCurrency);
		refundCurrency = std::move(_o.refundCurrency);
		refundPlay64 = std::move(_o.refundPlay64);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	refund = 0;
	refundPlay = 0;
	refundFpp = 0;
	refundTChips = 0;
	refundWChips = 0;
	tournamentCurrency.clear();
	refundCurrency.clear();
	refundPlay64 = 0;
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::equals(const Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		refund == _o.refund &&
		refundPlay == _o.refundPlay &&
		refundFpp == _o.refundFpp &&
		refundTChips == _o.refundTChips &&
		refundWChips == _o.refundWChips &&
		Atf::atfPStringEquals(tournamentCurrency, _o.tournamentCurrency) &&
		Atf::atfPStringEquals(refundCurrency, _o.refundCurrency) &&
		refundPlay64 == _o.refundPlay64;
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_UNREGISTER_USER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY*)_other));
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_UNREGISTER_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	if( !errCode )
	{
		_buf.append(',');
		_buf.append("refund=");
		_buf.appendUint(refund);
		_buf.append(',');
		_buf.append("refundPlay=");
		_buf.appendInt(refundPlay);
		_buf.append(',');
		_buf.append("refundFpp=");
		_buf.appendUint(refundFpp);
		_buf.append(',');
		_buf.append("refundTChips=");
		_buf.appendUint(refundTChips);
		_buf.append(',');
		_buf.append("refundWChips=");
		_buf.appendUint(refundWChips);
		_buf.append(',');
		_buf.append("tournamentCurrency=");
		_buf.append(tournamentCurrency);
		_buf.append(',');
		_buf.append("refundCurrency=");
		_buf.append(refundCurrency);
		_buf.append(',');
		_buf.append("refundPlay64=");
		_buf.appendUint64(refundPlay64);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_UNREGISTER_USER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	if( !errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("refund", refund, _buf);
		Atf::XmlElement::encodeAsXmlElement("refundPlay", refundPlay, _buf);
		Atf::XmlElement::encodeAsXmlElement("refundFpp", refundFpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("refundTChips", refundTChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("refundWChips", refundWChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournamentCurrency", tournamentCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("refundCurrency", refundCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("refundPlay64", refundPlay64, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("refund"))
			{
				refund = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("refundPlay"))
			{
				refundPlay = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("refundFpp"))
			{
				refundFpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("refundTChips"))
			{
				refundTChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("refundWChips"))
			{
				refundWChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournamentCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournamentCurrency)) return false;
			}
			else if (_element.equals("refundCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, refundCurrency)) return false;
			}
			else if (_element.equals("refundPlay64"))
			{
				refundPlay64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
	if( !errCode )
	{
		_msg.composeUINT32(refund);
		_msg.composeINT32(refundPlay);
		_msg.composeUINT32(refundFpp);
		_msg.composeUINT32(refundTChips);
		_msg.composeUINT32(refundWChips);
		_msg.composeString(tournamentCurrency);
		_msg.composeString(refundCurrency);
		_msg.composeUINT64(refundPlay64);
	}
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
	if( !errCode )
	{
		_parser.parseUINT32(refund);
		_parser.parseINT32(refundPlay);
		_parser.parseUINT32(refundFpp);
		_parser.parseUINT32(refundTChips);
		_parser.parseUINT32(refundWChips);
		_parser.parseStringP(tournamentCurrency);
		_parser.parseStringP(refundCurrency);
		_parser.parseUINT64(refundPlay64);
	}
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errDescr", errDescr);
	if( !errCode )
	{
		_jsonstr.compose("refund", refund);
		_jsonstr.compose("refundPlay", refundPlay);
		_jsonstr.compose("refundFpp", refundFpp);
		_jsonstr.compose("refundTChips", refundTChips);
		_jsonstr.compose("refundWChips", refundWChips);
		_jsonstr.compose("tournamentCurrency", tournamentCurrency);
		_jsonstr.compose("refundCurrency", refundCurrency);
		_jsonstr.compose("refundPlay64", refundPlay64);
	}
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errDescr", errDescr);
	if( !errCode )
	{
		_jparser.parseByNameThrow("refund", refund);
		_jparser.parseByNameThrow("refundPlay", refundPlay);
		_jparser.parseByNameThrow("refundFpp", refundFpp);
		_jparser.parseByNameThrow("refundTChips", refundTChips);
		_jparser.parseByNameThrow("refundWChips", refundWChips);
		_jparser.parseByNameThrow("tournamentCurrency", tournamentCurrency);
		_jparser.parseByNameThrow("refundCurrency", refundCurrency);
		_jparser.parseByNameThrow("refundPlay64", refundPlay64);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_UNREGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
	AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	if( !errCode )
	{
		UINT32 refund; _jparser.validateByNameThrow("refund", refund);
		AtfValidator::validateInt(_descr, "refund", refund, _checker, __FILE__, __LINE__);
		INT32 refundPlay; _jparser.validateByNameThrow("refundPlay", refundPlay);
		AtfValidator::validateInt(_descr, "refundPlay", refundPlay, _checker, __FILE__, __LINE__);
		UINT32 refundFpp; _jparser.validateByNameThrow("refundFpp", refundFpp);
		AtfValidator::validateInt(_descr, "refundFpp", refundFpp, _checker, __FILE__, __LINE__);
		UINT32 refundTChips; _jparser.validateByNameThrow("refundTChips", refundTChips);
		AtfValidator::validateInt(_descr, "refundTChips", refundTChips, _checker, __FILE__, __LINE__);
		UINT32 refundWChips; _jparser.validateByNameThrow("refundWChips", refundWChips);
		AtfValidator::validateInt(_descr, "refundWChips", refundWChips, _checker, __FILE__, __LINE__);
		PString tournamentCurrency; _jparser.validateByNameThrow("tournamentCurrency", tournamentCurrency);
		AtfValidator::validateInt(_descr, "tournamentCurrency", tournamentCurrency.length(), _checker, __FILE__, __LINE__);
		PString refundCurrency; _jparser.validateByNameThrow("refundCurrency", refundCurrency);
		AtfValidator::validateInt(_descr, "refundCurrency", refundCurrency.length(), _checker, __FILE__, __LINE__);
		UINT64 refundPlay64; _jparser.validateByNameThrow("refundPlay64", refundPlay64);
		AtfValidator::validateUint(_descr, "refundPlay64", refundPlay64, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_UNREGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	if( !errCode )
	{
		UINT32 refund; _parser.parseUINT32(refund);
		AtfValidator::validateInt(_descr, "refund", refund, _checker, __FILE__, __LINE__);
		INT32 refundPlay; _parser.parseINT32(refundPlay);
		AtfValidator::validateInt(_descr, "refundPlay", refundPlay, _checker, __FILE__, __LINE__);
		UINT32 refundFpp; _parser.parseUINT32(refundFpp);
		AtfValidator::validateInt(_descr, "refundFpp", refundFpp, _checker, __FILE__, __LINE__);
		UINT32 refundTChips; _parser.parseUINT32(refundTChips);
		AtfValidator::validateInt(_descr, "refundTChips", refundTChips, _checker, __FILE__, __LINE__);
		UINT32 refundWChips; _parser.parseUINT32(refundWChips);
		AtfValidator::validateInt(_descr, "refundWChips", refundWChips, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tournamentCurrency"); size_t szTournamentCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournamentCurrency", szTournamentCurrency, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "refundCurrency"); size_t szRefundCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "refundCurrency", szRefundCurrency, _checker, __FILE__, __LINE__);
		UINT64 refundPlay64; _parser.parseUINT64(refundPlay64);
		AtfValidator::validateUint(_descr, "refundPlay64", refundPlay64, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ChipGraphRequest
//=================================================================

MTLobbyCli::cli::ChipGraphRequest::ChipGraphRequest()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::ChipGraphRequest::ChipGraphRequest(ChipGraphRequest&& _o)
	: name(std::move(_o.name))
	, time(std::move(_o.time))
{
}

MTLobbyCli::cli::ChipGraphRequest& MTLobbyCli::cli::ChipGraphRequest::operator=(ChipGraphRequest&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		time = std::move(_o.time);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::ChipGraphRequest::clear()
{
	name.clear();
	time = 0;
}

bool MTLobbyCli::cli::ChipGraphRequest::equals(const ChipGraphRequest& _o) const
{
	return Atf::atfPStringEquals(name, _o.name) &&
		time == _o.time;
}

const char *MTLobbyCli::cli::ChipGraphRequest::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("time=");
	_buf.appendUint(time);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::cli::ChipGraphRequest::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("time", time, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::cli::ChipGraphRequest::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("time"))
		{
			time = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::cli::ChipGraphRequest::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ChipGraphRequest())) // not empty
	{
		_body.composeString(name);
		_body.composeUINT32(time);
	}

	_msg.composeMsgBody(_body);
}

void MTLobbyCli::cli::ChipGraphRequest::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(name);
	_parser0.parseUINT32(time);
}

const char *MTLobbyCli::cli::ChipGraphRequest::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	_jsonstr.compose("time", time);
	return _buf.c_str();
}

void MTLobbyCli::cli::ChipGraphRequest::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("time", time);
}

/* static */ void MTLobbyCli::cli::ChipGraphRequest::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateIntMax(_descr, "name", name.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 time; _jparser.validateByNameThrow("time", time);
	AtfValidator::validateInt(_descr, "time", time, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::ChipGraphRequest::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, 20, _checker, __FILE__, __LINE__);
	UINT32 time; _parser0.parseUINT32(time);
	AtfValidator::validateInt(_descr, "time", time, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ChipGraphData
//=================================================================

MTLobbyCli::cli::ChipGraphData::ChipGraphData()
{
	clear();
}

void MTLobbyCli::cli::ChipGraphData::clear()
{
	time = 0;
	val = 0;
}

bool MTLobbyCli::cli::ChipGraphData::equals(const ChipGraphData& _o) const
{
	return time == _o.time &&
		val == _o.val;
}

const char *MTLobbyCli::cli::ChipGraphData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("time=");
	_buf.appendUint(time);
	_buf.append(',');
	_buf.append("val=");
	_buf.appendUint(val);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::cli::ChipGraphData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("time", time, _buf);
	Atf::XmlElement::encodeAsXmlElement("val", val, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::cli::ChipGraphData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("time"))
		{
			time = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("val"))
		{
			val = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::cli::ChipGraphData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(time);
	_msg.composeUINT32(val);
}

void MTLobbyCli::cli::ChipGraphData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(time);
	_parser.parseUINT32(val);
}

const char *MTLobbyCli::cli::ChipGraphData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("time", time);
	_jsonstr.compose("val", val);
	return _buf.c_str();
}

void MTLobbyCli::cli::ChipGraphData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("time", time);
	_jparser.parseByNameThrow("val", val);
}

/* static */ void MTLobbyCli::cli::ChipGraphData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 time; _jparser.validateByNameThrow("time", time);
	AtfValidator::validateInt(_descr, "time", time, _checker, __FILE__, __LINE__);
	UINT32 val; _jparser.validateByNameThrow("val", val);
	AtfValidator::validateInt(_descr, "val", val, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::ChipGraphData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 time; _parser.parseUINT32(time);
	AtfValidator::validateInt(_descr, "time", time, _checker, __FILE__, __LINE__);
	UINT32 val; _parser.parseUINT32(val);
	AtfValidator::validateInt(_descr, "val", val, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ChipGraphReply
//=================================================================

MTLobbyCli::cli::ChipGraphReply::ChipGraphReply()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::ChipGraphReply::ChipGraphReply(ChipGraphReply&& _o)
	: name(std::move(_o.name))
	, data(std::move(_o.data))
{
}

MTLobbyCli::cli::ChipGraphReply& MTLobbyCli::cli::ChipGraphReply::operator=(ChipGraphReply&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		data = std::move(_o.data);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::ChipGraphReply::clear()
{
	name.clear();
	data.clear();
}

bool MTLobbyCli::cli::ChipGraphReply::equals(const ChipGraphReply& _o) const
{
	return Atf::atfPStringEquals(name, _o.name) &&
		data.equals(_o.data);
}

const char *MTLobbyCli::cli::ChipGraphReply::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("data=");
	data.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::cli::ChipGraphReply::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	data.toXmlString("data", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::cli::ChipGraphReply::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("data"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< ChipGraphData, 4 > >::FromXmlString(_value, data)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::cli::ChipGraphReply::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ChipGraphReply())) // not empty
	{
		_body.composeString(name);
		data.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MTLobbyCli::cli::ChipGraphReply::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(name);
	data.parseMsg(_parser0);
}

const char *MTLobbyCli::cli::ChipGraphReply::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	_jsonstr.compose("data", data);
	return _buf.c_str();
}

void MTLobbyCli::cli::ChipGraphReply::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("data", data);
}

/* static */ void MTLobbyCli::cli::ChipGraphReply::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ChipGraphData > data; _jparser.validateByNameThrow("data", data);
	AtfValidator::validateInt(_descr, "data", data.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::ChipGraphReply::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szData = Atf::LAtfVector< ChipGraphData, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("data"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "data", szData, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MTL_GET_CHIP_GRAPH_DATA
//=================================================================

MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::Protocol_MTL_GET_CHIP_GRAPH_DATA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::Protocol_MTL_GET_CHIP_GRAPH_DATA(Protocol_MTL_GET_CHIP_GRAPH_DATA&& _o)
	: requestData(std::move(_o.requestData))
{
}

MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA& MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::operator=(Protocol_MTL_GET_CHIP_GRAPH_DATA&& _o)
{
	if(this != &_o)
	{
		requestData = std::move(_o.requestData);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::clear()
{
	requestData.clear();
}

bool MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::equals(const Protocol_MTL_GET_CHIP_GRAPH_DATA& _o) const
{
	return requestData.equals(_o.requestData);
}

bool MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_GET_CHIP_GRAPH_DATA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_GET_CHIP_GRAPH_DATA*)_other));
}

const char *MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_GET_CHIP_GRAPH_DATA).append(")");
	_buf.append(',');
	_buf.append("requestData=");
	requestData.toTraceString(_buf);
	return _buf.c_str();
}

const char *MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_GET_CHIP_GRAPH_DATA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	requestData.toXmlString("requestData", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestData"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ChipGraphRequest, 4 > >::FromXmlString(_value, requestData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	requestData.composeMsg(_msg, _ignoreJSON);
}

void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::parseMsg(CommMsgParser& _parser)
{
	requestData.parseMsg(_parser);
}

const char *MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestData", requestData);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestData", requestData);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_GET_CHIP_GRAPH_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< ChipGraphRequest > requestData; _jparser.validateByNameThrow("requestData", requestData);
	AtfValidator::validateIntMax(_descr, "requestData", requestData.size(), 500, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_GET_CHIP_GRAPH_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szRequestData = Atf::LAtfVector< ChipGraphRequest, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("requestData"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "requestData", szRequestData, 500, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY
//=================================================================

MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY(Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY&& _o)
	: n(std::move(_o.n))
	, hockeyTime(std::move(_o.hockeyTime))
	, chipGraphData(std::move(_o.chipGraphData))
{
}

MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY& MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::operator=(Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY&& _o)
{
	if(this != &_o)
	{
		n = std::move(_o.n);
		hockeyTime = std::move(_o.hockeyTime);
		chipGraphData = std::move(_o.chipGraphData);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::clear()
{
	n = 0;
	hockeyTime = 0;
	chipGraphData.clear();
}

bool MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::equals(const Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY& _o) const
{
	return n == _o.n &&
		hockeyTime == _o.hockeyTime &&
		chipGraphData.equals(_o.chipGraphData);
}

bool MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_GET_CHIP_GRAPH_DATA_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY*)_other));
}

const char *MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_GET_CHIP_GRAPH_DATA_REPLY).append(")");
	_buf.append(',');
	_buf.append("n=");
	_buf.appendUint(n);
	_buf.append(',');
	_buf.append("hockeyTime=");
	_buf.appendUint(hockeyTime);
	_buf.append(',');
	_buf.append("chipGraphData=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(chipGraphData, _buf); _buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_GET_CHIP_GRAPH_DATA_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("n", n, _buf);
	Atf::XmlElement::encodeAsXmlElement("hockeyTime", hockeyTime, _buf);
	Atf::XmlElement::encodeAsXmlElement("chipGraphData", chipGraphData, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("n"))
			{
				n = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("hockeyTime"))
			{
				hockeyTime = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chipGraphData"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, chipGraphData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(n);
	_msg.composeUINT32(hockeyTime);
	_msg.composeMsgBody(chipGraphData);
}

void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(n);
	_parser.parseUINT32(hockeyTime);
	_parser.parseMsgBody(chipGraphData);
}

const char *MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("n", n);
	_jsonstr.compose("hockeyTime", hockeyTime);
	_jsonstr.compose("chipGraphData", chipGraphData);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("n", n);
	_jparser.parseByNameThrow("hockeyTime", hockeyTime);
	_jparser.parseByNameThrow("chipGraphData", chipGraphData);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_GET_CHIP_GRAPH_DATA_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 n; _jparser.validateByNameThrow("n", n);
	AtfValidator::validateInt(_descr, "n", n, _checker, __FILE__, __LINE__);
	UINT32 hockeyTime; _jparser.validateByNameThrow("hockeyTime", hockeyTime);
	AtfValidator::validateInt(_descr, "hockeyTime", hockeyTime, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody chipGraphData; _jparser.validateByNameThrow("chipGraphData", chipGraphData);
	AtfValidator::validateInt(_descr, "chipGraphData", chipGraphData._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_GET_CHIP_GRAPH_DATA_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 n; _parser.parseUINT32(n);
	AtfValidator::validateInt(_descr, "n", n, _checker, __FILE__, __LINE__);
	UINT32 hockeyTime; _parser.parseUINT32(hockeyTime);
	AtfValidator::validateInt(_descr, "hockeyTime", hockeyTime, _checker, __FILE__, __LINE__);
	size_t szChipGraphData; _parser.skipMsgBody(szChipGraphData);  /*chipGraphData*/
	AtfValidator::validateInt(_descr, "chipGraphData", szChipGraphData, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS
//=================================================================

MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS()
{
	clear();
}

void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::clear()
{
	tournId = 0;
}

bool MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::equals(const Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS& _o) const
{
	return tournId == _o.tournId;
}

bool MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MTL_GET_SAME_LEVEL_FLIGHTS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS*)_other));
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MTL_GET_SAME_LEVEL_FLIGHTS).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	return _buf.c_str();
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MTL_GET_SAME_LEVEL_FLIGHTS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournId);
}

void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MTL_GET_SAME_LEVEL_FLIGHTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MTL_GET_SAME_LEVEL_FLIGHTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TGMFlightData
//=================================================================

MTLobbyCli::cli::TGMFlightData::TGMFlightData()
{
	clear();
}

void MTLobbyCli::cli::TGMFlightData::clear()
{
	tournId = 0;
	startTime.setNull();
	numUsers = 0;
}

bool MTLobbyCli::cli::TGMFlightData::equals(const TGMFlightData& _o) const
{
	return tournId == _o.tournId &&
		startTime.equals(_o.startTime) &&
		numUsers == _o.numUsers;
}

const char *MTLobbyCli::cli::TGMFlightData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("startTime=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, startTime);
	_buf.append(',');
	_buf.append("numUsers=");
	_buf.appendUint(numUsers);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::cli::TGMFlightData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "startTime", startTime);
	Atf::XmlElement::encodeAsXmlElement("numUsers", numUsers, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::cli::TGMFlightData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournId"))
		{
			tournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("startTime"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, startTime);
		}
		else if (_element.equals("numUsers"))
		{
			numUsers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::cli::TGMFlightData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournId);
	_msg.composeSrvTime(startTime);
	_msg.composeUINT32(numUsers);
}

void MTLobbyCli::cli::TGMFlightData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
	_parser.parseSrvTime(startTime);
	_parser.parseUINT32(numUsers);
}

const char *MTLobbyCli::cli::TGMFlightData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("startTime", startTime);
	_jsonstr.compose("numUsers", numUsers);
	return _buf.c_str();
}

void MTLobbyCli::cli::TGMFlightData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("startTime", startTime);
	_jparser.parseByNameThrow("numUsers", numUsers);
}

/* static */ void MTLobbyCli::cli::TGMFlightData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	SrvTime startTime; _jparser.validateByNameThrow("startTime", startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	UINT32 numUsers; _jparser.validateByNameThrow("numUsers", numUsers);
	AtfValidator::validateInt(_descr, "numUsers", numUsers, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::TGMFlightData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	SrvTime startTime; _parser.parseSrvTime(startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	UINT32 numUsers; _parser.parseUINT32(numUsers);
	AtfValidator::validateInt(_descr, "numUsers", numUsers, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY
//=================================================================

MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY(Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, numLevels(std::move(_o.numLevels))
	, flightData(std::move(_o.flightData))
{
}

MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY& MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::operator=(Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		numLevels = std::move(_o.numLevels);
		flightData = std::move(_o.flightData);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	numLevels = 0;
	flightData.clear();
}

bool MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::equals(const Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		numLevels == _o.numLevels &&
		flightData.equals(_o.flightData);
}

bool MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY*)_other));
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("numLevels=");
		_buf.appendUint(numLevels);
		_buf.append(',');
		_buf.append("flightData=");
		flightData.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("numLevels", numLevels, _buf);
		flightData.toXmlString("flightData", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("numLevels"))
			{
				numLevels = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flightData"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TGMFlightData, 4 > >::FromXmlString(_value, flightData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(numLevels);
		flightData.composeMsg(_msg, _ignoreJSON);
	}
}

void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(numLevels);
		flightData.parseMsg(_parser);
	}
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("numLevels", numLevels);
		_jsonstr.compose("flightData", flightData);
	}
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("numLevels", numLevels);
		_jparser.parseByNameThrow("flightData", flightData);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 numLevels; _jparser.validateByNameThrow("numLevels", numLevels);
		AtfValidator::validateInt(_descr, "numLevels", numLevels, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< TGMFlightData > flightData; _jparser.validateByNameThrow("flightData", flightData);
		AtfValidator::validateInt(_descr, "flightData", flightData.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 numLevels; _parser.parseUINT32(numLevels);
		AtfValidator::validateInt(_descr, "numLevels", numLevels, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szFlightData = Atf::LAtfVector< TGMFlightData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("flightData"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "flightData", szFlightData, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MTL_CHANGE_FLIGHT
//=================================================================

MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::Protocol_MSG_MTL_CHANGE_FLIGHT()
{
	clear();
}

void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::clear()
{
	tournId = 0;
}

bool MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::equals(const Protocol_MSG_MTL_CHANGE_FLIGHT& _o) const
{
	return tournId == _o.tournId;
}

bool MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MTL_CHANGE_FLIGHT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MTL_CHANGE_FLIGHT*)_other));
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MTL_CHANGE_FLIGHT).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	return _buf.c_str();
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MTL_CHANGE_FLIGHT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournId);
}

void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MTL_CHANGE_FLIGHT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MTL_CHANGE_FLIGHT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY
//=================================================================

MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY(Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY& MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::operator=(Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::equals(const Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MTL_CHANGE_FLIGHT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY*)_other));
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MTL_CHANGE_FLIGHT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MTL_CHANGE_FLIGHT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MTL_CHANGE_FLIGHT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MTL_CHANGE_FLIGHT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    LightTournData
//=================================================================

MTLobbyCli::cli::LightTournData::LightTournData()
{
	clear();
}

void MTLobbyCli::cli::LightTournData::clear()
{
	status = 0;
	whenStart.setNull();
	prizePoolToPublish = 0;
	prizePoolUnit = 0;
	prizePoolMoneyToPublish = 0;
	numUsersReg = 0;
}

bool MTLobbyCli::cli::LightTournData::equals(const LightTournData& _o) const
{
	return status == _o.status &&
		whenStart.equals(_o.whenStart) &&
		prizePoolToPublish == _o.prizePoolToPublish &&
		prizePoolUnit == _o.prizePoolUnit &&
		prizePoolMoneyToPublish == _o.prizePoolMoneyToPublish &&
		numUsersReg == _o.numUsersReg;
}

const char *MTLobbyCli::cli::LightTournData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("whenStart=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("prizePoolToPublish=");
	_buf.appendInt(prizePoolToPublish);
	_buf.append(',');
	_buf.append("prizePoolUnit=");
	_buf.appendUint(prizePoolUnit);
	_buf.append(',');
	_buf.append("prizePoolMoneyToPublish=");
	_buf.appendInt(prizePoolMoneyToPublish);
	_buf.append(',');
	_buf.append("numUsersReg=");
	_buf.appendUint(numUsersReg);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::cli::LightTournData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenStart", whenStart);
	Atf::XmlElement::encodeAsXmlElement("prizePoolToPublish", prizePoolToPublish, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePoolUnit", prizePoolUnit, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePoolMoneyToPublish", prizePoolMoneyToPublish, _buf);
	Atf::XmlElement::encodeAsXmlElement("numUsersReg", numUsersReg, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::cli::LightTournData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenStart"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenStart);
		}
		else if (_element.equals("prizePoolToPublish"))
		{
			prizePoolToPublish = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolUnit"))
		{
			prizePoolUnit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolMoneyToPublish"))
		{
			prizePoolMoneyToPublish = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numUsersReg"))
		{
			numUsersReg = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::cli::LightTournData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(status);
	_msg.composeSrvTime(whenStart);
	_msg.composeINT32(prizePoolToPublish);
	_msg.composeBYTE(prizePoolUnit);
	_msg.composeINT32(prizePoolMoneyToPublish);
	_msg.composeUINT32(numUsersReg);
}

void MTLobbyCli::cli::LightTournData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(status);
	_parser.parseSrvTime(whenStart);
	_parser.parseINT32(prizePoolToPublish);
	_parser.parseBYTE(prizePoolUnit);
	_parser.parseINT32(prizePoolMoneyToPublish);
	_parser.parseUINT32(numUsersReg);
}

const char *MTLobbyCli::cli::LightTournData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("status", status);
	_jsonstr.compose("whenStart", whenStart);
	_jsonstr.compose("prizePoolToPublish", prizePoolToPublish);
	_jsonstr.compose("prizePoolUnit", prizePoolUnit);
	_jsonstr.compose("prizePoolMoneyToPublish", prizePoolMoneyToPublish);
	_jsonstr.compose("numUsersReg", numUsersReg);
	return _buf.c_str();
}

void MTLobbyCli::cli::LightTournData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("whenStart", whenStart);
	_jparser.parseByNameThrow("prizePoolToPublish", prizePoolToPublish);
	_jparser.parseByNameThrow("prizePoolUnit", prizePoolUnit);
	_jparser.parseByNameThrow("prizePoolMoneyToPublish", prizePoolMoneyToPublish);
	_jparser.parseByNameThrow("numUsersReg", numUsersReg);
}

/* static */ void MTLobbyCli::cli::LightTournData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	SrvTime whenStart; _jparser.validateByNameThrow("whenStart", whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	INT32 prizePoolToPublish; _jparser.validateByNameThrow("prizePoolToPublish", prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	BYTE prizePoolUnit; _jparser.validateByNameThrow("prizePoolUnit", prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	INT32 prizePoolMoneyToPublish; _jparser.validateByNameThrow("prizePoolMoneyToPublish", prizePoolMoneyToPublish);
	AtfValidator::validateInt(_descr, "prizePoolMoneyToPublish", prizePoolMoneyToPublish, _checker, __FILE__, __LINE__);
	UINT32 numUsersReg; _jparser.validateByNameThrow("numUsersReg", numUsersReg);
	AtfValidator::validateInt(_descr, "numUsersReg", numUsersReg, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::cli::LightTournData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	SrvTime whenStart; _parser.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	INT32 prizePoolToPublish; _parser.parseINT32(prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	BYTE prizePoolUnit; _parser.parseBYTE(prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	INT32 prizePoolMoneyToPublish; _parser.parseINT32(prizePoolMoneyToPublish);
	AtfValidator::validateInt(_descr, "prizePoolMoneyToPublish", prizePoolMoneyToPublish, _checker, __FILE__, __LINE__);
	UINT32 numUsersReg; _parser.parseUINT32(numUsersReg);
	AtfValidator::validateInt(_descr, "numUsersReg", numUsersReg, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MTL_LOBBY_WHERE_IS_PLAYER
//=================================================================

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::Protocol_MTL_LOBBY_WHERE_IS_PLAYER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::Protocol_MTL_LOBBY_WHERE_IS_PLAYER(Protocol_MTL_LOBBY_WHERE_IS_PLAYER&& _o)
	: userName(std::move(_o.userName))
{
}

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER& MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::operator=(Protocol_MTL_LOBBY_WHERE_IS_PLAYER&& _o)
{
	if(this != &_o)
	{
		userName = std::move(_o.userName);
	}
	return *this;
}

#endif

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::clear()
{
	userName.clear();
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::equals(const Protocol_MTL_LOBBY_WHERE_IS_PLAYER& _o) const
{
	return Atf::atfPStringEquals(userName, _o.userName);
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_WHERE_IS_PLAYER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_WHERE_IS_PLAYER*)_other));
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_WHERE_IS_PLAYER).append(")");
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	return _buf.c_str();
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_WHERE_IS_PLAYER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userName", userName, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userName);
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userName);
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userName", userName);
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userName", userName);
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userName; _jparser.validateByNameThrow("userName", userName);
	AtfValidator::validateIntMax(_descr, "userName", userName.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY
//=================================================================

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY(Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, place(std::move(_o.place))
	, tableServer(std::move(_o.tableServer))
	, tableObject(std::move(_o.tableObject))
	, flags(std::move(_o.flags))
	, errDescr(std::move(_o.errDescr))
{
}

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY& MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::operator=(Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		place = std::move(_o.place);
		tableServer = std::move(_o.tableServer);
		tableObject = std::move(_o.tableObject);
		flags = std::move(_o.flags);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::clear()
{
	errCode = 0;
	place = 0;
	tableServer.clear();
	tableObject.clear();
	flags = false;
	errDescr.clear();
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::equals(const Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		place == _o.place &&
		Atf::atfPStringEquals(tableServer, _o.tableServer) &&
		Atf::atfPStringEquals(tableObject, _o.tableObject) &&
		flags == _o.flags &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_WHERE_IS_PLAYER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY*)_other));
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_WHERE_IS_PLAYER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_buf.append(',');
		_buf.append("place=");
		_buf.appendUint(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_buf.append(',');
		_buf.append("tableServer=");
		_buf.append(tableServer);
		_buf.append(',');
		_buf.append("tableObject=");
		_buf.append(tableObject);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
	}
	else
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_WHERE_IS_PLAYER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode == WHERE_IS_PLACE )
	{
		Atf::XmlElement::encodeAsXmlElement("place", place, _buf);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		Atf::XmlElement::encodeAsXmlElement("tableServer", tableServer, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableObject", tableObject, _buf);
		Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("place"))
			{
				place = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableServer"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tableServer)) return false;
			}
			else if (_element.equals("tableObject"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tableObject)) return false;
			}
			else if (_element.equals("flags"))
			{
				flags = (*_value.ptr() == '1');
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_msg.composeUINT32(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_msg.composeString(tableServer);
		_msg.composeString(tableObject);
		_msg.composeBOOL(flags);
	}
	else
	{
		_msg.composeString(errDescr);
	}
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_parser.parseUINT32(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_parser.parseStringP(tableServer);
		_parser.parseStringP(tableObject);
		_parser.parseBOOL(flags);
	}
	else
	{
		_parser.parseStringP(errDescr);
	}
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_jsonstr.compose("place", place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_jsonstr.compose("tableServer", tableServer);
		_jsonstr.compose("tableObject", tableObject);
		_jsonstr.compose("flags", flags);
	}
	else
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_jparser.parseByNameThrow("place", place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_jparser.parseByNameThrow("tableServer", tableServer);
		_jparser.parseByNameThrow("tableObject", tableObject);
		_jparser.parseByNameThrow("flags", flags);
	}
	else
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode == WHERE_IS_PLACE )
	{
		UINT32 place; _jparser.validateByNameThrow("place", place);
		AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		PString tableServer; _jparser.validateByNameThrow("tableServer", tableServer);
		AtfValidator::validateInt(_descr, "tableServer", tableServer.length(), _checker, __FILE__, __LINE__);
		PString tableObject; _jparser.validateByNameThrow("tableObject", tableObject);
		AtfValidator::validateInt(_descr, "tableObject", tableObject.length(), _checker, __FILE__, __LINE__);
		bool flags; _jparser.validateByNameThrow("flags", flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode == WHERE_IS_PLACE )
	{
		UINT32 place; _parser.parseUINT32(place);
		AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_parser.parseStringN(_dummy, 0, "tableServer"); size_t szTableServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableServer", szTableServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tableObject"); size_t szTableObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableObject", szTableObject, _checker, __FILE__, __LINE__);
		bool flags; _parser.parseBOOL(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS
//=================================================================

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS&& _o)
	: userName(std::move(_o.userName))
{
}

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS& MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::operator=(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS&& _o)
{
	if(this != &_o)
	{
		userName = std::move(_o.userName);
	}
	return *this;
}

#endif

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::clear()
{
	userName.clear();
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::equals(const Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS& _o) const
{
	return Atf::atfPStringEquals(userName, _o.userName);
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_TOURNAMENT_USER_STATS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS*)_other));
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS).append(")");
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	return _buf.c_str();
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userName", userName, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userName);
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userName);
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userName", userName);
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userName", userName);
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userName; _jparser.validateByNameThrow("userName", userName);
	AtfValidator::validateIntMax(_descr, "userName", userName.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY
//=================================================================

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, reply(std::move(_o.reply))
{
}

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY& MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::operator=(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		reply = std::move(_o.reply);
	}
	return *this;
}

#endif

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	reply.clear();
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::equals(const Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		reply.equals(_o.reply);
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY*)_other));
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("reply=");
		reply.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		reply.toXmlString("reply", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("reply"))
			{
				if(!Atf::AtfTempl< UserStatsReply >::FromXmlString(_value, reply)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		reply.composeMsg(_msg, _ignoreJSON);
	}
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		reply.parseMsg(_parser);
	}
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("reply", reply);
	}
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("reply", reply);
	}
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UserStatsReply reply; _jparser.validateByNameThrow("reply", reply);
	}
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserStatsReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SnapshotStruct
//=================================================================

MTLobbyCli::unauth_cli::SnapshotStruct::SnapshotStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::unauth_cli::SnapshotStruct::SnapshotStruct(SnapshotStruct&& _o)
	: player0(std::move(_o.player0))
	, player1(std::move(_o.player1))
{
}

MTLobbyCli::unauth_cli::SnapshotStruct& MTLobbyCli::unauth_cli::SnapshotStruct::operator=(SnapshotStruct&& _o)
{
	if(this != &_o)
	{
		player0 = std::move(_o.player0);
		player1 = std::move(_o.player1);
	}
	return *this;
}

#endif

void MTLobbyCli::unauth_cli::SnapshotStruct::clear()
{
	player0.clear();
	player1.clear();
}

bool MTLobbyCli::unauth_cli::SnapshotStruct::equals(const SnapshotStruct& _o) const
{
	return Atf::atfPStringEquals(player0, _o.player0) &&
		Atf::atfPStringEquals(player1, _o.player1);
}

const char *MTLobbyCli::unauth_cli::SnapshotStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("player0=");
	_buf.append(player0);
	_buf.append(',');
	_buf.append("player1=");
	_buf.append(player1);
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::unauth_cli::SnapshotStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("player0", player0, _buf);
	Atf::XmlElement::encodeAsXmlElement("player1", player1, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::unauth_cli::SnapshotStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("player0"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, player0)) return false;
		}
		else if (_element.equals("player1"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, player1)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::unauth_cli::SnapshotStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(player0);
	_msg.composeString(player1);
}

void MTLobbyCli::unauth_cli::SnapshotStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(player0);
	_parser.parseStringP(player1);
}

const char *MTLobbyCli::unauth_cli::SnapshotStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("player0", player0);
	_jsonstr.compose("player1", player1);
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::SnapshotStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("player0", player0);
	_jparser.parseByNameThrow("player1", player1);
}

/* static */ void MTLobbyCli::unauth_cli::SnapshotStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString player0; _jparser.validateByNameThrow("player0", player0);
	AtfValidator::validateInt(_descr, "player0", player0.length(), _checker, __FILE__, __LINE__);
	PString player1; _jparser.validateByNameThrow("player1", player1);
	AtfValidator::validateInt(_descr, "player1", player1.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::unauth_cli::SnapshotStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "player0"); size_t szPlayer0 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "player0", szPlayer0, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "player1"); size_t szPlayer1 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "player1", szPlayer1, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT
//=================================================================

MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT()
{
	clear();
}

void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::clear()
{
}

bool MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::equals(const Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT& _o) const
{
	return true;
}

bool MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_OLYMPIC_SNAPSHOT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT*)_other));
}

const char *MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_OLYMPIC_SNAPSHOT).append(")");
	return _buf.c_str();
}

const char *MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_OLYMPIC_SNAPSHOT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::parseMsg(CommMsgParser& _parser)
{
}

const char *MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_OLYMPIC_SNAPSHOT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_OLYMPIC_SNAPSHOT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY
//=================================================================

MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY(Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, snapshotOk(std::move(_o.snapshotOk))
	, snapshotData(std::move(_o.snapshotData))
{
}

MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY& MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::operator=(Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		snapshotOk = std::move(_o.snapshotOk);
		snapshotData = std::move(_o.snapshotData);
	}
	return *this;
}

#endif

void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	snapshotOk = 0;
	snapshotData.clear();
}

bool MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::equals(const Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		snapshotOk == _o.snapshotOk &&
		snapshotData.equals(_o.snapshotData);
}

bool MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY*)_other));
}

const char *MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("snapshotOk=");
		_buf.appendInt(snapshotOk);
		_buf.append(',');
		_buf.append("snapshotData=");
		snapshotData.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("snapshotOk", snapshotOk, _buf);
		snapshotData.toXmlString("snapshotData", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("snapshotOk"))
			{
				snapshotOk = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("snapshotData"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SnapshotStruct, 4 > >::FromXmlString(_value, snapshotData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeINT16(snapshotOk);
		snapshotData.composeMsg(_msg, _ignoreJSON);
	}
}

void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseINT16(snapshotOk);
		snapshotData.parseMsg(_parser);
	}
}

const char *MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("snapshotOk", snapshotOk);
		_jsonstr.compose("snapshotData", snapshotData);
	}
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("snapshotOk", snapshotOk);
		_jparser.parseByNameThrow("snapshotData", snapshotData);
	}
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT16 snapshotOk; _jparser.validateByNameThrow("snapshotOk", snapshotOk);
		AtfValidator::validateInt(_descr, "snapshotOk", snapshotOk, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< SnapshotStruct > snapshotData; _jparser.validateByNameThrow("snapshotData", snapshotData);
		AtfValidator::validateInt(_descr, "snapshotData", snapshotData.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT16 snapshotOk; _parser.parseINT16(snapshotOk);
		AtfValidator::validateInt(_descr, "snapshotOk", snapshotOk, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szSnapshotData = Atf::LAtfVector< SnapshotStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("snapshotData"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "snapshotData", szSnapshotData, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_TOURN_TEXT_INFO
//=================================================================

MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::Protocol_MTL_TOURN_TEXT_INFO()
{
	clear();
}

void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::clear()
{
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::equals(const Protocol_MTL_TOURN_TEXT_INFO& _o) const
{
	return true;
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_TOURN_TEXT_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_TOURN_TEXT_INFO*)_other));
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_TOURN_TEXT_INFO).append(")");
	return _buf.c_str();
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_TOURN_TEXT_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::parseMsg(CommMsgParser& _parser)
{
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_TOURN_TEXT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_TOURN_TEXT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_TOURN_TEXT_INFO_REPLY
//=================================================================

MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::Protocol_MTL_TOURN_TEXT_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::Protocol_MTL_TOURN_TEXT_INFO_REPLY(Protocol_MTL_TOURN_TEXT_INFO_REPLY&& _o)
	: name(std::move(_o.name))
	, messageBoardText(std::move(_o.messageBoardText))
{
}

MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY& MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::operator=(Protocol_MTL_TOURN_TEXT_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		messageBoardText = std::move(_o.messageBoardText);
	}
	return *this;
}

#endif

void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::clear()
{
	name.clear();
	messageBoardText.clear();
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::equals(const Protocol_MTL_TOURN_TEXT_INFO_REPLY& _o) const
{
	return name.equals(_o.name) &&
		messageBoardText.equals(_o.messageBoardText);
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_TOURN_TEXT_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_TOURN_TEXT_INFO_REPLY*)_other));
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_TOURN_TEXT_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("name=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, name);
	_buf.append(',');
	_buf.append("messageBoardText=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, messageBoardText);
	return _buf.c_str();
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_TOURN_TEXT_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "name", name);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "messageBoardText", messageBoardText);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("name"))
			{
				Atf::AtfTempl<I18nPString>::FromXmlString(_value, name);
			}
			else if (_element.equals("messageBoardText"))
			{
				Atf::AtfTempl<I18nPString>::FromXmlString(_value, messageBoardText);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	name.compose(_msg);
	messageBoardText.compose(_msg);
}

void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	name.parse(_parser);
	messageBoardText.parse(_parser);
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	_jsonstr.compose("messageBoardText", messageBoardText);
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("messageBoardText", messageBoardText);
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_TOURN_TEXT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	I18nPString name; _jparser.validateByNameThrow("name", name);
	I18nPString messageBoardText; _jparser.validateByNameThrow("messageBoardText", messageBoardText);
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_TOURN_TEXT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	I18nPString name; name.parse(_parser);
	I18nPString messageBoardText; messageBoardText.parse(_parser);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_WHERE_IS_PLAYER
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::Protocol_MTL_LOBBY_WHERE_IS_PLAYER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::Protocol_MTL_LOBBY_WHERE_IS_PLAYER(Protocol_MTL_LOBBY_WHERE_IS_PLAYER&& _o)
	: userName(std::move(_o.userName))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER& MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::operator=(Protocol_MTL_LOBBY_WHERE_IS_PLAYER&& _o)
{
	if(this != &_o)
	{
		userName = std::move(_o.userName);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::clear()
{
	userName.clear();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::equals(const Protocol_MTL_LOBBY_WHERE_IS_PLAYER& _o) const
{
	return Atf::atfPStringEquals(userName, _o.userName);
}

bool MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_WHERE_IS_PLAYER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_WHERE_IS_PLAYER*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_WHERE_IS_PLAYER).append(")");
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_WHERE_IS_PLAYER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userName", userName, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userName);
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userName);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userName", userName);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userName", userName);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userName; _jparser.validateByNameThrow("userName", userName);
	AtfValidator::validateIntMax(_descr, "userName", userName.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY(Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, place(std::move(_o.place))
	, tableServer(std::move(_o.tableServer))
	, tableObject(std::move(_o.tableObject))
	, flags(std::move(_o.flags))
	, errDescr(std::move(_o.errDescr))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY& MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::operator=(Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		place = std::move(_o.place);
		tableServer = std::move(_o.tableServer);
		tableObject = std::move(_o.tableObject);
		flags = std::move(_o.flags);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::clear()
{
	errCode = 0;
	place = 0;
	tableServer.clear();
	tableObject.clear();
	flags = false;
	errDescr.clear();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::equals(const Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		place == _o.place &&
		Atf::atfPStringEquals(tableServer, _o.tableServer) &&
		Atf::atfPStringEquals(tableObject, _o.tableObject) &&
		flags == _o.flags &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_WHERE_IS_PLAYER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_WHERE_IS_PLAYER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_buf.append(',');
		_buf.append("place=");
		_buf.appendUint(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_buf.append(',');
		_buf.append("tableServer=");
		_buf.append(tableServer);
		_buf.append(',');
		_buf.append("tableObject=");
		_buf.append(tableObject);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
	}
	else
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_WHERE_IS_PLAYER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode == WHERE_IS_PLACE )
	{
		Atf::XmlElement::encodeAsXmlElement("place", place, _buf);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		Atf::XmlElement::encodeAsXmlElement("tableServer", tableServer, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableObject", tableObject, _buf);
		Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("place"))
			{
				place = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableServer"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tableServer)) return false;
			}
			else if (_element.equals("tableObject"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tableObject)) return false;
			}
			else if (_element.equals("flags"))
			{
				flags = (*_value.ptr() == '1');
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_msg.composeUINT32(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_msg.composeString(tableServer);
		_msg.composeString(tableObject);
		_msg.composeBOOL(flags);
	}
	else
	{
		_msg.composeString(errDescr);
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_parser.parseUINT32(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_parser.parseStringP(tableServer);
		_parser.parseStringP(tableObject);
		_parser.parseBOOL(flags);
	}
	else
	{
		_parser.parseStringP(errDescr);
	}
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_jsonstr.compose("place", place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_jsonstr.compose("tableServer", tableServer);
		_jsonstr.compose("tableObject", tableObject);
		_jsonstr.compose("flags", flags);
	}
	else
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_jparser.parseByNameThrow("place", place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_jparser.parseByNameThrow("tableServer", tableServer);
		_jparser.parseByNameThrow("tableObject", tableObject);
		_jparser.parseByNameThrow("flags", flags);
	}
	else
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode == WHERE_IS_PLACE )
	{
		UINT32 place; _jparser.validateByNameThrow("place", place);
		AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		PString tableServer; _jparser.validateByNameThrow("tableServer", tableServer);
		AtfValidator::validateInt(_descr, "tableServer", tableServer.length(), _checker, __FILE__, __LINE__);
		PString tableObject; _jparser.validateByNameThrow("tableObject", tableObject);
		AtfValidator::validateInt(_descr, "tableObject", tableObject.length(), _checker, __FILE__, __LINE__);
		bool flags; _jparser.validateByNameThrow("flags", flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode == WHERE_IS_PLACE )
	{
		UINT32 place; _parser.parseUINT32(place);
		AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_parser.parseStringN(_dummy, 0, "tableServer"); size_t szTableServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableServer", szTableServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tableObject"); size_t szTableObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableObject", szTableObject, _checker, __FILE__, __LINE__);
		bool flags; _parser.parseBOOL(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS&& _o)
	: userName(std::move(_o.userName))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS& MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::operator=(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS&& _o)
{
	if(this != &_o)
	{
		userName = std::move(_o.userName);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::clear()
{
	userName.clear();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::equals(const Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS& _o) const
{
	return Atf::atfPStringEquals(userName, _o.userName);
}

bool MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_TOURNAMENT_USER_STATS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS).append(")");
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userName", userName, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userName);
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userName);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userName", userName);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userName", userName);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userName; _jparser.validateByNameThrow("userName", userName);
	AtfValidator::validateIntMax(_descr, "userName", userName.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, reply(std::move(_o.reply))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY& MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::operator=(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		reply = std::move(_o.reply);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	reply.clear();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::equals(const Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		reply.equals(_o.reply);
}

bool MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("reply=");
		reply.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		reply.toXmlString("reply", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("reply"))
			{
				if(!Atf::AtfTempl< UserStatsReply >::FromXmlString(_value, reply)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		reply.composeMsg(_msg, _ignoreJSON);
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		reply.parseMsg(_parser);
	}
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("reply", reply);
	}
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("reply", reply);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UserStatsReply reply; _jparser.validateByNameThrow("reply", reply);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserStatsReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_CLI_GOTO_TABLE
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::Protocol_MTL_CLI_GOTO_TABLE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::Protocol_MTL_CLI_GOTO_TABLE(Protocol_MTL_CLI_GOTO_TABLE&& _o)
	: server(std::move(_o.server))
	, instance(std::move(_o.instance))
	, playMoney(std::move(_o.playMoney))
	, currency(std::move(_o.currency))
	, chips(std::move(_o.chips))
	, sittingIn(std::move(_o.sittingIn))
	, seat(std::move(_o.seat))
	, reconnect(std::move(_o.reconnect))
	, handId(std::move(_o.handId))
	, stat(std::move(_o.stat))
	, action(std::move(_o.action))
	, rebuys(std::move(_o.rebuys))
	, timeout(std::move(_o.timeout))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE& MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::operator=(Protocol_MTL_CLI_GOTO_TABLE&& _o)
{
	if(this != &_o)
	{
		server = std::move(_o.server);
		instance = std::move(_o.instance);
		playMoney = std::move(_o.playMoney);
		currency = std::move(_o.currency);
		chips = std::move(_o.chips);
		sittingIn = std::move(_o.sittingIn);
		seat = std::move(_o.seat);
		reconnect = std::move(_o.reconnect);
		handId = std::move(_o.handId);
		stat = std::move(_o.stat);
		action = std::move(_o.action);
		rebuys = std::move(_o.rebuys);
		timeout = std::move(_o.timeout);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::clear()
{
	server.clear();
	instance.clear();
	playMoney = false;
	currency.clear();
	chips = 0;
	sittingIn = false;
	seat = 0;
	reconnect = false;
	handId = 0;
	stat = 0;
	action = '0';
	rebuys = 0;
	timeout = 0;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::equals(const Protocol_MTL_CLI_GOTO_TABLE& _o) const
{
	return Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(instance, _o.instance) &&
		playMoney == _o.playMoney &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		chips == _o.chips &&
		sittingIn == _o.sittingIn &&
		seat == _o.seat &&
		reconnect == _o.reconnect &&
		handId == _o.handId &&
		stat == _o.stat &&
		action == _o.action &&
		rebuys == _o.rebuys &&
		timeout == _o.timeout;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_CLI_GOTO_TABLE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_CLI_GOTO_TABLE*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_CLI_GOTO_TABLE).append(")");
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("instance=");
	_buf.append(instance);
	_buf.append(',');
	_buf.append("playMoney=");
	_buf.appendUint(playMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendUint(chips);
	_buf.append(',');
	_buf.append("sittingIn=");
	_buf.appendUint(sittingIn);
	_buf.append(',');
	_buf.append("seat=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("reconnect=");
	_buf.appendUint(reconnect);
	_buf.append(',');
	_buf.append("handId=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("stat=");
	_buf.appendUint(stat);
	_buf.append(',');
	_buf.append("action=");
	_buf.append(action);
	_buf.append(',');
	_buf.append("rebuys=");
	_buf.appendUint(rebuys);
	_buf.append(',');
	_buf.append("timeout=");
	_buf.appendInt(timeout);
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_CLI_GOTO_TABLE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("instance", instance, _buf);
	Atf::XmlElement::encodeAsXmlElement("playMoney", playMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("sittingIn", sittingIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("seat", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("reconnect", reconnect, _buf);
	Atf::XmlElement::encodeAsXmlElement("handId", handId, _buf);
	Atf::XmlElement::encodeAsXmlElement("stat", stat, _buf);
	Atf::XmlElement::encodeAsXmlElement("action", action, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuys", rebuys, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeout", timeout, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else if (_element.equals("instance"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, instance)) return false;
			}
			else if (_element.equals("playMoney"))
			{
				playMoney = (*_value.ptr() == '1');
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("chips"))
			{
				chips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sittingIn"))
			{
				sittingIn = (*_value.ptr() == '1');
			}
			else if (_element.equals("seat"))
			{
				seat = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("reconnect"))
			{
				reconnect = (*_value.ptr() == '1');
			}
			else if (_element.equals("handId"))
			{
				handId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("stat"))
			{
				stat = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("action"))
			{
				action = *_value.ptr();
			}
			else if (_element.equals("rebuys"))
			{
				rebuys = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timeout"))
			{
				timeout = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(server);
	_msg.composeString(instance);
	_msg.composeBOOL(playMoney);
	_msg.composeString(currency);
	_msg.composeUINT32(chips);
	_msg.composeBOOL(sittingIn);
	_msg.composeINT8(seat);
	_msg.composeBOOL(reconnect);
	_msg.composeUINT64(handId);
	_msg.composeUINT32(stat);
	_msg.composeINT8(action);
	_msg.composeUINT16(rebuys);
	_msg.composeINT32(timeout);
}

void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(server);
	_parser.parseStringP(instance);
	_parser.parseBOOL(playMoney);
	_parser.parseStringP(currency);
	_parser.parseUINT32(chips);
	_parser.parseBOOL(sittingIn);
	_parser.parseINT8(seat);
	_parser.parseBOOL(reconnect);
	_parser.parseUINT64(handId);
	_parser.parseUINT32(stat);
	{ INT8 _n; _parser.parseINT8(_n); action = _n; }
	_parser.parseUINT16(rebuys);
	_parser.parseINT32(timeout);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("server", server);
	_jsonstr.compose("instance", instance);
	_jsonstr.compose("playMoney", playMoney);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("sittingIn", sittingIn);
	_jsonstr.compose("seat", seat);
	_jsonstr.compose("reconnect", reconnect);
	_jsonstr.compose("handId", handId);
	_jsonstr.compose("stat", stat);
	_jsonstr.compose("action", action);
	_jsonstr.compose("rebuys", rebuys);
	_jsonstr.compose("timeout", timeout);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("instance", instance);
	_jparser.parseByNameThrow("playMoney", playMoney);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("sittingIn", sittingIn);
	_jparser.parseByNameThrow("seat", seat);
	_jparser.parseByNameThrow("reconnect", reconnect);
	_jparser.parseByNameThrow("handId", handId);
	_jparser.parseByNameThrow("stat", stat);
	_jparser.parseByNameThrow("action", action);
	_jparser.parseByNameThrow("rebuys", rebuys);
	_jparser.parseByNameThrow("timeout", timeout);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_CLI_GOTO_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString instance; _jparser.validateByNameThrow("instance", instance);
	AtfValidator::validateInt(_descr, "instance", instance.length(), _checker, __FILE__, __LINE__);
	bool playMoney; _jparser.validateByNameThrow("playMoney", playMoney);
	AtfValidator::validateInt(_descr, "playMoney", playMoney, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	bool sittingIn; _jparser.validateByNameThrow("sittingIn", sittingIn);
	AtfValidator::validateInt(_descr, "sittingIn", sittingIn, _checker, __FILE__, __LINE__);
	INT8 seat; _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	bool reconnect; _jparser.validateByNameThrow("reconnect", reconnect);
	AtfValidator::validateInt(_descr, "reconnect", reconnect, _checker, __FILE__, __LINE__);
	UINT64 handId; _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	UINT32 stat; _jparser.validateByNameThrow("stat", stat);
	AtfValidator::validateInt(_descr, "stat", stat, _checker, __FILE__, __LINE__);
	char action; _jparser.validateByNameThrow("action", action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	UINT16 rebuys; _jparser.validateByNameThrow("rebuys", rebuys);
	AtfValidator::validateInt(_descr, "rebuys", rebuys, _checker, __FILE__, __LINE__);
	INT32 timeout; _jparser.validateByNameThrow("timeout", timeout);
	AtfValidator::validateInt(_descr, "timeout", timeout, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_CLI_GOTO_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "instance"); size_t szInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "instance", szInstance, _checker, __FILE__, __LINE__);
	bool playMoney; _parser.parseBOOL(playMoney);
	AtfValidator::validateInt(_descr, "playMoney", playMoney, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 chips; _parser.parseUINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	bool sittingIn; _parser.parseBOOL(sittingIn);
	AtfValidator::validateInt(_descr, "sittingIn", sittingIn, _checker, __FILE__, __LINE__);
	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	bool reconnect; _parser.parseBOOL(reconnect);
	AtfValidator::validateInt(_descr, "reconnect", reconnect, _checker, __FILE__, __LINE__);
	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	UINT32 stat; _parser.parseUINT32(stat);
	AtfValidator::validateInt(_descr, "stat", stat, _checker, __FILE__, __LINE__);
	char action; { INT8 _n; _parser.parseINT8(_n); action = _n; }
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	UINT16 rebuys; _parser.parseUINT16(rebuys);
	AtfValidator::validateInt(_descr, "rebuys", rebuys, _checker, __FILE__, __LINE__);
	INT32 timeout; _parser.parseINT32(timeout);
	AtfValidator::validateInt(_descr, "timeout", timeout, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_SITIN
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::Protocol_MTL_USER_SITIN()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::clear()
{
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::equals(const Protocol_MTL_USER_SITIN& _o) const
{
	return true;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_USER_SITIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_USER_SITIN*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_SITIN).append(")");
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_USER_SITIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::parseMsg(CommMsgParser& _parser)
{
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_SITIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_SITIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_SITIN_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::Protocol_MTL_USER_SITIN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::Protocol_MTL_USER_SITIN_REPLY(Protocol_MTL_USER_SITIN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tableServer(std::move(_o.tableServer))
	, tableObject(std::move(_o.tableObject))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, chips(std::move(_o.chips))
	, sittingIn(std::move(_o.sittingIn))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY& MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::operator=(Protocol_MTL_USER_SITIN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tableServer = std::move(_o.tableServer);
		tableObject = std::move(_o.tableObject);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		chips = std::move(_o.chips);
		sittingIn = std::move(_o.sittingIn);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tableServer.clear();
	tableObject.clear();
	isPlayMoney = false;
	currency.clear();
	chips = 0;
	sittingIn = false;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::equals(const Protocol_MTL_USER_SITIN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(tableServer, _o.tableServer) &&
		Atf::atfPStringEquals(tableObject, _o.tableObject) &&
		isPlayMoney == _o.isPlayMoney &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		chips == _o.chips &&
		sittingIn == _o.sittingIn;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_USER_SITIN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_USER_SITIN_REPLY*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_SITIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tableServer=");
		_buf.append(tableServer);
		_buf.append(',');
		_buf.append("tableObject=");
		_buf.append(tableObject);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("chips=");
		_buf.appendUint(chips);
		_buf.append(',');
		_buf.append("sittingIn=");
		_buf.appendUint(sittingIn);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_USER_SITIN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("tableServer", tableServer, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableObject", tableObject, _buf);
		Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
		Atf::XmlElement::encodeAsXmlElement("sittingIn", sittingIn, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("tableServer"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tableServer)) return false;
			}
			else if (_element.equals("tableObject"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tableObject)) return false;
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (*_value.ptr() == '1');
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("chips"))
			{
				chips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sittingIn"))
			{
				sittingIn = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(tableServer);
		_msg.composeString(tableObject);
		_msg.composeBOOL(isPlayMoney);
		_msg.composeString(currency);
		_msg.composeUINT32(chips);
		_msg.composeBOOL(sittingIn);
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(tableServer);
		_parser.parseStringP(tableObject);
		_parser.parseBOOL(isPlayMoney);
		_parser.parseStringP(currency);
		_parser.parseUINT32(chips);
		_parser.parseBOOL(sittingIn);
	}
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("tableServer", tableServer);
		_jsonstr.compose("tableObject", tableObject);
		_jsonstr.compose("isPlayMoney", isPlayMoney);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("chips", chips);
		_jsonstr.compose("sittingIn", sittingIn);
	}
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("tableServer", tableServer);
		_jparser.parseByNameThrow("tableObject", tableObject);
		_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("chips", chips);
		_jparser.parseByNameThrow("sittingIn", sittingIn);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_SITIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString tableServer; _jparser.validateByNameThrow("tableServer", tableServer);
		AtfValidator::validateInt(_descr, "tableServer", tableServer.length(), _checker, __FILE__, __LINE__);
		PString tableObject; _jparser.validateByNameThrow("tableObject", tableObject);
		AtfValidator::validateInt(_descr, "tableObject", tableObject.length(), _checker, __FILE__, __LINE__);
		bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		UINT32 chips; _jparser.validateByNameThrow("chips", chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		bool sittingIn; _jparser.validateByNameThrow("sittingIn", sittingIn);
		AtfValidator::validateInt(_descr, "sittingIn", sittingIn, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_SITIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "tableServer"); size_t szTableServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableServer", szTableServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tableObject"); size_t szTableObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableObject", szTableObject, _checker, __FILE__, __LINE__);
		bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		UINT32 chips; _parser.parseUINT32(chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		bool sittingIn; _parser.parseBOOL(sittingIn);
		AtfValidator::validateInt(_descr, "sittingIn", sittingIn, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_SITOUT
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::Protocol_MTL_USER_SITOUT()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::clear()
{
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::equals(const Protocol_MTL_USER_SITOUT& _o) const
{
	return true;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_USER_SITOUT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_USER_SITOUT*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_SITOUT).append(")");
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_USER_SITOUT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::parseMsg(CommMsgParser& _parser)
{
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_SITOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_SITOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_SITOUT_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::Protocol_MTL_USER_SITOUT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::Protocol_MTL_USER_SITOUT_REPLY(Protocol_MTL_USER_SITOUT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY& MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::operator=(Protocol_MTL_USER_SITOUT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::equals(const Protocol_MTL_USER_SITOUT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_USER_SITOUT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_USER_SITOUT_REPLY*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_SITOUT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_USER_SITOUT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_SITOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_SITOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    P_HomeGamesTourn
//=================================================================

MTLobbyCli::perm_cli::P_HomeGamesTourn::P_HomeGamesTourn()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::P_HomeGamesTourn::P_HomeGamesTourn(P_HomeGamesTourn&& _o)
	: available(std::move(_o.available))
	, startTime(std::move(_o.startTime))
	, clubId(std::move(_o.clubId))
	, clubName(std::move(_o.clubName))
	, tournId(std::move(_o.tournId))
	, name(std::move(_o.name))
	, gameType(std::move(_o.gameType))
	, isHiLo(std::move(_o.isHiLo))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, bounty(std::move(_o.bounty))
	, players(std::move(_o.players))
	, registered(std::move(_o.registered))
	, limit(std::move(_o.limit))
	, currency(std::move(_o.currency))
	, playMoney(std::move(_o.playMoney))
	, playersPerTable(std::move(_o.playersPerTable))
	, state(std::move(_o.state))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
{
}

MTLobbyCli::perm_cli::P_HomeGamesTourn& MTLobbyCli::perm_cli::P_HomeGamesTourn::operator=(P_HomeGamesTourn&& _o)
{
	if(this != &_o)
	{
		available = std::move(_o.available);
		startTime = std::move(_o.startTime);
		clubId = std::move(_o.clubId);
		clubName = std::move(_o.clubName);
		tournId = std::move(_o.tournId);
		name = std::move(_o.name);
		gameType = std::move(_o.gameType);
		isHiLo = std::move(_o.isHiLo);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		bounty = std::move(_o.bounty);
		players = std::move(_o.players);
		registered = std::move(_o.registered);
		limit = std::move(_o.limit);
		currency = std::move(_o.currency);
		playMoney = std::move(_o.playMoney);
		playersPerTable = std::move(_o.playersPerTable);
		state = std::move(_o.state);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::P_HomeGamesTourn::clear()
{
	available = 0;
	startTime.setNull();
	clubId = 0;
	clubName.clear();
	tournId = 0;
	name.clear();
	gameType = 0;
	isHiLo = false;
	buyIn = 0;
	rake = 0;
	bounty = 0;
	players = 0;
	registered = false;
	limit = 0;
	currency.clear();
	playMoney = false;
	playersPerTable = 0;
	state = 0;
	server.clear();
	serverObject.clear();
}

bool MTLobbyCli::perm_cli::P_HomeGamesTourn::equals(const P_HomeGamesTourn& _o) const
{
	return available == _o.available &&
		startTime.equals(_o.startTime) &&
		clubId == _o.clubId &&
		Atf::atfPStringEquals(clubName, _o.clubName) &&
		tournId == _o.tournId &&
		Atf::atfPStringEquals(name, _o.name) &&
		gameType == _o.gameType &&
		isHiLo == _o.isHiLo &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		bounty == _o.bounty &&
		players == _o.players &&
		registered == _o.registered &&
		limit == _o.limit &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		playMoney == _o.playMoney &&
		playersPerTable == _o.playersPerTable &&
		state == _o.state &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObject, _o.serverObject);
}

const char *MTLobbyCli::perm_cli::P_HomeGamesTourn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("available=");
	_buf.appendUint(available);
	if( available )
	{
		_buf.append(',');
		_buf.append("startTime=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, startTime);
		_buf.append(',');
		_buf.append("clubId=");
		_buf.appendUint(clubId);
		_buf.append(',');
		_buf.append("clubName=");
		_buf.append(clubName);
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("name=");
		_buf.append(name);
		_buf.append(',');
		_buf.append("gameType=");
		_buf.appendUint(gameType);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("buyIn=");
		_buf.appendUint(buyIn);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendUint(rake);
		_buf.append(',');
		_buf.append("bounty=");
		_buf.appendUint(bounty);
		_buf.append(',');
		_buf.append("players=");
		_buf.appendUint(players);
		_buf.append(',');
		_buf.append("registered=");
		_buf.appendUint(registered);
		_buf.append(',');
		_buf.append("limit=");
		_buf.appendUint(limit);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("playMoney=");
		_buf.appendUint(playMoney);
		_buf.append(',');
		_buf.append("playersPerTable=");
		_buf.appendUint(playersPerTable);
		_buf.append(',');
		_buf.append("state=");
		_buf.appendUint(state);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::P_HomeGamesTourn::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("available", available, _buf);
	if( available )
	{
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "startTime", startTime);
		Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
		Atf::XmlElement::encodeAsXmlElement("clubName", clubName, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
		Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
		Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
		Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
		Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
		Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
		Atf::XmlElement::encodeAsXmlElement("bounty", bounty, _buf);
		Atf::XmlElement::encodeAsXmlElement("players", players, _buf);
		Atf::XmlElement::encodeAsXmlElement("registered", registered, _buf);
		Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("playMoney", playMoney, _buf);
		Atf::XmlElement::encodeAsXmlElement("playersPerTable", playersPerTable, _buf);
		Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
		Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
		Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::P_HomeGamesTourn::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("available"))
		{
			available = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("startTime"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, startTime);
		}
		else if (_element.equals("clubId"))
		{
			clubId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clubName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clubName)) return false;
		}
		else if (_element.equals("tournId"))
		{
			tournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("gameType"))
		{
			gameType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (*_value.ptr() == '1');
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bounty"))
		{
			bounty = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("players"))
		{
			players = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("registered"))
		{
			registered = (*_value.ptr() == '1');
		}
		else if (_element.equals("limit"))
		{
			limit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("playMoney"))
		{
			playMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("playersPerTable"))
		{
			playersPerTable = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("state"))
		{
			state = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("serverObject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::perm_cli::P_HomeGamesTourn::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(available);
	if( available )
	{
		_msg.composeSrvTime(startTime);
		_msg.composeUINT32(clubId);
		_msg.composeString(clubName);
		_msg.composeUINT32(tournId);
		_msg.composeString(name);
		_msg.composeBYTE(gameType);
		_msg.composeBOOL(isHiLo);
		_msg.composeUINT32(buyIn);
		_msg.composeUINT32(rake);
		_msg.composeUINT32(bounty);
		_msg.composeUINT32(players);
		_msg.composeBOOL(registered);
		_msg.composeBYTE(limit);
		_msg.composeString(currency);
		_msg.composeBOOL(playMoney);
		_msg.composeUINT32(playersPerTable);
		_msg.composeUINT32(state);
		_msg.composeString(server);
		_msg.composeString(serverObject);
	}
}

void MTLobbyCli::perm_cli::P_HomeGamesTourn::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(available);
	if( available )
	{
		_parser.parseSrvTime(startTime);
		_parser.parseUINT32(clubId);
		_parser.parseStringP(clubName);
		_parser.parseUINT32(tournId);
		_parser.parseStringP(name);
		_parser.parseBYTE(gameType);
		_parser.parseBOOL(isHiLo);
		_parser.parseUINT32(buyIn);
		_parser.parseUINT32(rake);
		_parser.parseUINT32(bounty);
		_parser.parseUINT32(players);
		_parser.parseBOOL(registered);
		_parser.parseBYTE(limit);
		_parser.parseStringP(currency);
		_parser.parseBOOL(playMoney);
		_parser.parseUINT32(playersPerTable);
		_parser.parseUINT32(state);
		_parser.parseStringP(server);
		_parser.parseStringP(serverObject);
	}
}

const char *MTLobbyCli::perm_cli::P_HomeGamesTourn::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("available", available);
	if( available )
	{
		_jsonstr.compose("startTime", startTime);
		_jsonstr.compose("clubId", clubId);
		_jsonstr.compose("clubName", clubName);
		_jsonstr.compose("tournId", tournId);
		_jsonstr.compose("name", name);
		_jsonstr.compose("gameType", gameType);
		_jsonstr.compose("isHiLo", isHiLo);
		_jsonstr.compose("buyIn", buyIn);
		_jsonstr.compose("rake", rake);
		_jsonstr.compose("bounty", bounty);
		_jsonstr.compose("players", players);
		_jsonstr.compose("registered", registered);
		_jsonstr.compose("limit", limit);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("playMoney", playMoney);
		_jsonstr.compose("playersPerTable", playersPerTable);
		_jsonstr.compose("state", state);
		_jsonstr.compose("server", server);
		_jsonstr.compose("serverObject", serverObject);
	}
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::P_HomeGamesTourn::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("available", available);
	if( available )
	{
		_jparser.parseByNameThrow("startTime", startTime);
		_jparser.parseByNameThrow("clubId", clubId);
		_jparser.parseByNameThrow("clubName", clubName);
		_jparser.parseByNameThrow("tournId", tournId);
		_jparser.parseByNameThrow("name", name);
		_jparser.parseByNameThrow("gameType", gameType);
		_jparser.parseByNameThrow("isHiLo", isHiLo);
		_jparser.parseByNameThrow("buyIn", buyIn);
		_jparser.parseByNameThrow("rake", rake);
		_jparser.parseByNameThrow("bounty", bounty);
		_jparser.parseByNameThrow("players", players);
		_jparser.parseByNameThrow("registered", registered);
		_jparser.parseByNameThrow("limit", limit);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("playMoney", playMoney);
		_jparser.parseByNameThrow("playersPerTable", playersPerTable);
		_jparser.parseByNameThrow("state", state);
		_jparser.parseByNameThrow("server", server);
		_jparser.parseByNameThrow("serverObject", serverObject);
	}
}

/* static */ void MTLobbyCli::perm_cli::P_HomeGamesTourn::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 available = 0;
	_jparser.validateByNameThrow("available", available);
	AtfValidator::validateInt(_descr, "available", available, _checker, __FILE__, __LINE__);
	if( available )
	{
		SrvTime startTime; _jparser.validateByNameThrow("startTime", startTime);
		AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
		UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
		AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
		PString clubName; _jparser.validateByNameThrow("clubName", clubName);
		AtfValidator::validateInt(_descr, "clubName", clubName.length(), _checker, __FILE__, __LINE__);
		UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		PString name; _jparser.validateByNameThrow("name", name);
		AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
		BYTE gameType; _jparser.validateByNameThrow("gameType", gameType);
		AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
		bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		UINT32 rake; _jparser.validateByNameThrow("rake", rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 bounty; _jparser.validateByNameThrow("bounty", bounty);
		AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
		UINT32 players; _jparser.validateByNameThrow("players", players);
		AtfValidator::validateInt(_descr, "players", players, _checker, __FILE__, __LINE__);
		bool registered; _jparser.validateByNameThrow("registered", registered);
		AtfValidator::validateInt(_descr, "registered", registered, _checker, __FILE__, __LINE__);
		BYTE limit; _jparser.validateByNameThrow("limit", limit);
		AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		bool playMoney; _jparser.validateByNameThrow("playMoney", playMoney);
		AtfValidator::validateInt(_descr, "playMoney", playMoney, _checker, __FILE__, __LINE__);
		UINT32 playersPerTable; _jparser.validateByNameThrow("playersPerTable", playersPerTable);
		AtfValidator::validateInt(_descr, "playersPerTable", playersPerTable, _checker, __FILE__, __LINE__);
		UINT32 state; _jparser.validateByNameThrow("state", state);
		AtfValidator::validateInt(_descr, "state", state, _checker, __FILE__, __LINE__);
		PString server; _jparser.validateByNameThrow("server", server);
		AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
		PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
		AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MTLobbyCli::perm_cli::P_HomeGamesTourn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 available = 0;
	_parser.parseUINT32(available);
	AtfValidator::validateInt(_descr, "available", available, _checker, __FILE__, __LINE__);
	if( available )
	{
		SrvTime startTime; _parser.parseSrvTime(startTime);
		AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
		UINT32 clubId; _parser.parseUINT32(clubId);
		AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
		BYTE gameType; _parser.parseBYTE(gameType);
		AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
		bool isHiLo; _parser.parseBOOL(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		UINT32 buyIn; _parser.parseUINT32(buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		UINT32 rake; _parser.parseUINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 bounty; _parser.parseUINT32(bounty);
		AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
		UINT32 players; _parser.parseUINT32(players);
		AtfValidator::validateInt(_descr, "players", players, _checker, __FILE__, __LINE__);
		bool registered; _parser.parseBOOL(registered);
		AtfValidator::validateInt(_descr, "registered", registered, _checker, __FILE__, __LINE__);
		BYTE limit; _parser.parseBYTE(limit);
		AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool playMoney; _parser.parseBOOL(playMoney);
		AtfValidator::validateInt(_descr, "playMoney", playMoney, _checker, __FILE__, __LINE__);
		UINT32 playersPerTable; _parser.parseUINT32(playersPerTable);
		AtfValidator::validateInt(_descr, "playersPerTable", playersPerTable, _checker, __FILE__, __LINE__);
		UINT32 state; _parser.parseUINT32(state);
		AtfValidator::validateInt(_descr, "state", state, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    P_FlightTourn
//=================================================================

MTLobbyCli::perm_cli::P_FlightTourn::P_FlightTourn()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::P_FlightTourn::P_FlightTourn(P_FlightTourn&& _o)
	: available(std::move(_o.available))
	, name(std::move(_o.name))
	, server(std::move(_o.server))
{
}

MTLobbyCli::perm_cli::P_FlightTourn& MTLobbyCli::perm_cli::P_FlightTourn::operator=(P_FlightTourn&& _o)
{
	if(this != &_o)
	{
		available = std::move(_o.available);
		name = std::move(_o.name);
		server = std::move(_o.server);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::P_FlightTourn::clear()
{
	available = false;
	name.clear();
	server.clear();
}

bool MTLobbyCli::perm_cli::P_FlightTourn::equals(const P_FlightTourn& _o) const
{
	return available == _o.available &&
		name.equals(_o.name) &&
		Atf::atfPStringEquals(server, _o.server);
}

const char *MTLobbyCli::perm_cli::P_FlightTourn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("available=");
	_buf.appendUint(available);
	if( available )
	{
		_buf.append(',');
		_buf.append("name=");
		Atf::AtfTempl<I18nPString>::ToTraceString(_buf, name);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::P_FlightTourn::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("available", available, _buf);
	if( available )
	{
		Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "name", name);
		Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::P_FlightTourn::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("available"))
		{
			available = (*_value.ptr() == '1');
		}
		else if (_element.equals("name"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, name);
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MTLobbyCli::perm_cli::P_FlightTourn::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(available);
	if( available )
	{
		name.compose(_msg);
		_msg.composeString(server);
	}
}

void MTLobbyCli::perm_cli::P_FlightTourn::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(available);
	if( available )
	{
		name.parse(_parser);
		_parser.parseStringP(server);
	}
}

const char *MTLobbyCli::perm_cli::P_FlightTourn::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("available", available);
	if( available )
	{
		_jsonstr.compose("name", name);
		_jsonstr.compose("server", server);
	}
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::P_FlightTourn::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("available", available);
	if( available )
	{
		_jparser.parseByNameThrow("name", name);
		_jparser.parseByNameThrow("server", server);
	}
}

/* static */ void MTLobbyCli::perm_cli::P_FlightTourn::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool available = false;
	_jparser.validateByNameThrow("available", available);
	AtfValidator::validateInt(_descr, "available", available, _checker, __FILE__, __LINE__);
	if( available )
	{
		I18nPString name; _jparser.validateByNameThrow("name", name);
		PString server; _jparser.validateByNameThrow("server", server);
		AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MTLobbyCli::perm_cli::P_FlightTourn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	bool available = false;
	_parser.parseBOOL(available);
	AtfValidator::validateInt(_descr, "available", available, _checker, __FILE__, __LINE__);
	if( available )
	{
		I18nPString name; name.parse(_parser);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                Protocol_MTL_CLI_GOTO_FINISH
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::Protocol_MTL_CLI_GOTO_FINISH()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::Protocol_MTL_CLI_GOTO_FINISH(Protocol_MTL_CLI_GOTO_FINISH&& _o)
	: place(std::move(_o.place))
	, message(std::move(_o.message))
	, socialToken(std::move(_o.socialToken))
	, nextHomeGamesTourn(std::move(_o.nextHomeGamesTourn))
	, nextFlightTourn(std::move(_o.nextFlightTourn))
	, ownBounty(std::move(_o.ownBounty))
	, flags(std::move(_o.flags))
	, award(std::move(_o.award))
	, bountyWon(std::move(_o.bountyWon))
	, reEntryDeadline(std::move(_o.reEntryDeadline))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH& MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::operator=(Protocol_MTL_CLI_GOTO_FINISH&& _o)
{
	if(this != &_o)
	{
		place = std::move(_o.place);
		message = std::move(_o.message);
		socialToken = std::move(_o.socialToken);
		nextHomeGamesTourn = std::move(_o.nextHomeGamesTourn);
		nextFlightTourn = std::move(_o.nextFlightTourn);
		ownBounty = std::move(_o.ownBounty);
		flags = std::move(_o.flags);
		award = std::move(_o.award);
		bountyWon = std::move(_o.bountyWon);
		reEntryDeadline = std::move(_o.reEntryDeadline);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::clear()
{
	place = 0;
	message.clear();
	socialToken.clear();
	nextHomeGamesTourn.clear();
	nextFlightTourn.clear();
	ownBounty = 0;
	flags = 0;
	award = 0;
	bountyWon = 0;
	reEntryDeadline.setNull();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::equals(const Protocol_MTL_CLI_GOTO_FINISH& _o) const
{
	return place == _o.place &&
		Atf::atfPStringEquals(message, _o.message) &&
		Atf::atfPStringEquals(socialToken, _o.socialToken) &&
		nextHomeGamesTourn.equals(_o.nextHomeGamesTourn) &&
		nextFlightTourn.equals(_o.nextFlightTourn) &&
		ownBounty == _o.ownBounty &&
		flags == _o.flags &&
		award == _o.award &&
		bountyWon == _o.bountyWon &&
		reEntryDeadline.equals(_o.reEntryDeadline);
}

bool MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_CLI_GOTO_FINISH != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_CLI_GOTO_FINISH*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_CLI_GOTO_FINISH).append(")");
	_buf.append(',');
	_buf.append("place=");
	_buf.appendUint(place);
	_buf.append(',');
	_buf.append("message=");
	_buf.append(message);
	_buf.append(',');
	_buf.append("socialToken=");
	_buf.append(socialToken);
	_buf.append(',');
	_buf.append("nextHomeGamesTourn=");
	nextHomeGamesTourn.toTraceString(_buf);
	_buf.append(',');
	_buf.append("nextFlightTourn=");
	nextFlightTourn.toTraceString(_buf);
	_buf.append(',');
	_buf.append("ownBounty=");
	_buf.appendUint(ownBounty);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("award=");
	_buf.appendUint(award);
	_buf.append(',');
	_buf.append("bountyWon=");
	_buf.appendUint(bountyWon);
	_buf.append(',');
	_buf.append("reEntryDeadline=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, reEntryDeadline);
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_CLI_GOTO_FINISH).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("place", place, _buf);
	Atf::XmlElement::encodeAsXmlElement("message", message, _buf);
	Atf::XmlElement::encodeAsXmlElement("socialToken", socialToken, _buf);
	nextHomeGamesTourn.toXmlString("nextHomeGamesTourn", _buf);
	nextFlightTourn.toXmlString("nextFlightTourn", _buf);
	Atf::XmlElement::encodeAsXmlElement("ownBounty", ownBounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("award", award, _buf);
	Atf::XmlElement::encodeAsXmlElement("bountyWon", bountyWon, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "reEntryDeadline", reEntryDeadline);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("place"))
			{
				place = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("message"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, message)) return false;
			}
			else if (_element.equals("socialToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
			}
			else if (_element.equals("nextHomeGamesTourn"))
			{
				if(!Atf::AtfTempl< P_HomeGamesTourn >::FromXmlString(_value, nextHomeGamesTourn)) return false;
			}
			else if (_element.equals("nextFlightTourn"))
			{
				if(!Atf::AtfTempl< P_FlightTourn >::FromXmlString(_value, nextFlightTourn)) return false;
			}
			else if (_element.equals("ownBounty"))
			{
				ownBounty = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("award"))
			{
				award = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bountyWon"))
			{
				bountyWon = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("reEntryDeadline"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, reEntryDeadline);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(place);
	_msg.composeString(message);
	_msg.composeString(socialToken);
	nextHomeGamesTourn.composeMsg(_msg, _ignoreJSON);
	nextFlightTourn.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(ownBounty);
	_msg.composeUINT32(flags);
	_msg.composeUINT32(award);
	_msg.composeUINT32(bountyWon);
	_msg.composeSrvTime(reEntryDeadline);
}

void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(place);
	_parser.parseStringP(message);
	_parser.parseStringP(socialToken);
	nextHomeGamesTourn.parseMsg(_parser);
	nextFlightTourn.parseMsg(_parser);
	_parser.parseUINT32(ownBounty);
	_parser.parseUINT32(flags);
	_parser.parseUINT32(award);
	_parser.parseUINT32(bountyWon);
	if(_parser.parseEnded()) return;
	_parser.parseSrvTime(reEntryDeadline);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("place", place);
	_jsonstr.compose("message", message);
	_jsonstr.compose("socialToken", socialToken);
	_jsonstr.compose("nextHomeGamesTourn", nextHomeGamesTourn);
	_jsonstr.compose("nextFlightTourn", nextFlightTourn);
	_jsonstr.compose("ownBounty", ownBounty);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("award", award);
	_jsonstr.compose("bountyWon", bountyWon);
	_jsonstr.compose("reEntryDeadline", reEntryDeadline);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("place", place);
	_jparser.parseByNameThrow("message", message);
	_jparser.parseByNameThrow("socialToken", socialToken);
	_jparser.parseByNameThrow("nextHomeGamesTourn", nextHomeGamesTourn);
	_jparser.parseByNameThrow("nextFlightTourn", nextFlightTourn);
	_jparser.parseByNameThrow("ownBounty", ownBounty);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("award", award);
	_jparser.parseByNameThrow("bountyWon", bountyWon);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("reEntryDeadline", reEntryDeadline);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_CLI_GOTO_FINISH";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 place; _jparser.validateByNameThrow("place", place);
	AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	PString message; _jparser.validateByNameThrow("message", message);
	AtfValidator::validateInt(_descr, "message", message.length(), _checker, __FILE__, __LINE__);
	PString socialToken; _jparser.validateByNameThrow("socialToken", socialToken);
	AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
	P_HomeGamesTourn nextHomeGamesTourn; _jparser.validateByNameThrow("nextHomeGamesTourn", nextHomeGamesTourn);
	P_FlightTourn nextFlightTourn; _jparser.validateByNameThrow("nextFlightTourn", nextFlightTourn);
	UINT32 ownBounty; _jparser.validateByNameThrow("ownBounty", ownBounty);
	AtfValidator::validateInt(_descr, "ownBounty", ownBounty, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 award; _jparser.validateByNameThrow("award", award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	UINT32 bountyWon; _jparser.validateByNameThrow("bountyWon", bountyWon);
	AtfValidator::validateInt(_descr, "bountyWon", bountyWon, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	SrvTime reEntryDeadline; _jparser.validateByNameThrow("reEntryDeadline", reEntryDeadline);
	AtfValidator::validateSrvDateTime(_descr, "reEntryDeadline", reEntryDeadline, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_CLI_GOTO_FINISH";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 place; _parser.parseUINT32(place);
	AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "message"); size_t szMessage = strlen(_dummy);
	AtfValidator::validateInt(_descr, "message", szMessage, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
	AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
	PString _descbuf;
	P_HomeGamesTourn::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("nextHomeGamesTourn"), _fieldsWithUnparsedContent);
	P_FlightTourn::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("nextFlightTourn"), _fieldsWithUnparsedContent);
	UINT32 ownBounty; _parser.parseUINT32(ownBounty);
	AtfValidator::validateInt(_descr, "ownBounty", ownBounty, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 award; _parser.parseUINT32(award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	UINT32 bountyWon; _parser.parseUINT32(bountyWon);
	AtfValidator::validateInt(_descr, "bountyWon", bountyWon, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	SrvTime reEntryDeadline; _parser.parseSrvTime(reEntryDeadline);
	AtfValidator::validateSrvDateTime(_descr, "reEntryDeadline", reEntryDeadline, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_REBUY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::Protocol_MTL_USER_REBUY()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::clear()
{
	numRebuys = 0;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::equals(const Protocol_MTL_USER_REBUY& _o) const
{
	return numRebuys == _o.numRebuys;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_USER_REBUY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_USER_REBUY*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_REBUY).append(")");
	_buf.append(',');
	_buf.append("numRebuys=");
	_buf.appendUint(numRebuys);
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_USER_REBUY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("numRebuys", numRebuys, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("numRebuys"))
			{
				numRebuys = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(numRebuys);
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(numRebuys);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numRebuys", numRebuys);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("numRebuys", numRebuys);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_REBUY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	BYTE numRebuys; _jparser.validateByNameThrow("numRebuys", numRebuys);
	AtfValidator::validateIntMax(_descr, "numRebuys", numRebuys, 10, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_REBUY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	BYTE numRebuys; _parser.parseBYTE(numRebuys);
	AtfValidator::validateIntMax(_descr, "numRebuys", numRebuys, 10, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_REBUY_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::Protocol_MTL_USER_REBUY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::Protocol_MTL_USER_REBUY_REPLY(Protocol_MTL_USER_REBUY_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, errMsgBody(std::move(_o.errMsgBody))
	, chipsRecieved(std::move(_o.chipsRecieved))
	, realMoneySpent(std::move(_o.realMoneySpent))
	, playMoneySpent(std::move(_o.playMoneySpent))
	, fppSpent(std::move(_o.fppSpent))
	, tChipsSpent(std::move(_o.tChipsSpent))
	, wMoneySpent(std::move(_o.wMoneySpent))
	, isAamsTicket(std::move(_o.isAamsTicket))
	, aamsTicket(std::move(_o.aamsTicket))
	, playChipsSpent64(std::move(_o.playChipsSpent64))
	, rebuysDone(std::move(_o.rebuysDone))
	, addonsDone(std::move(_o.addonsDone))
	, rebuysRemaining(std::move(_o.rebuysRemaining))
	, tournSpendLimit(std::move(_o.tournSpendLimit))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY& MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::operator=(Protocol_MTL_USER_REBUY_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		errMsgBody = std::move(_o.errMsgBody);
		chipsRecieved = std::move(_o.chipsRecieved);
		realMoneySpent = std::move(_o.realMoneySpent);
		playMoneySpent = std::move(_o.playMoneySpent);
		fppSpent = std::move(_o.fppSpent);
		tChipsSpent = std::move(_o.tChipsSpent);
		wMoneySpent = std::move(_o.wMoneySpent);
		isAamsTicket = std::move(_o.isAamsTicket);
		aamsTicket = std::move(_o.aamsTicket);
		playChipsSpent64 = std::move(_o.playChipsSpent64);
		rebuysDone = std::move(_o.rebuysDone);
		addonsDone = std::move(_o.addonsDone);
		rebuysRemaining = std::move(_o.rebuysRemaining);
		tournSpendLimit = std::move(_o.tournSpendLimit);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	errMsgBody.clear();
	chipsRecieved = 0;
	realMoneySpent = 0;
	playMoneySpent = 0;
	fppSpent = 0;
	tChipsSpent = 0;
	wMoneySpent = 0;
	isAamsTicket = 0;
	aamsTicket.clear();
	playChipsSpent64 = 0;
	rebuysDone = 0;
	addonsDone = 0;
	rebuysRemaining = 0;
	tournSpendLimit.clear();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::equals(const Protocol_MTL_USER_REBUY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		errMsgBody.equals(_o.errMsgBody) &&
		chipsRecieved == _o.chipsRecieved &&
		realMoneySpent == _o.realMoneySpent &&
		playMoneySpent == _o.playMoneySpent &&
		fppSpent == _o.fppSpent &&
		tChipsSpent == _o.tChipsSpent &&
		wMoneySpent == _o.wMoneySpent &&
		isAamsTicket == _o.isAamsTicket &&
		Atf::atfPStringEquals(aamsTicket, _o.aamsTicket) &&
		playChipsSpent64 == _o.playChipsSpent64 &&
		rebuysDone == _o.rebuysDone &&
		addonsDone == _o.addonsDone &&
		rebuysRemaining == _o.rebuysRemaining &&
		tournSpendLimit.equals(_o.tournSpendLimit);
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_USER_REBUY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_USER_REBUY_REPLY*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_REBUY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("errMsgBody=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(errMsgBody, _buf); _buf.append('}');
	}
	else
	{
		_buf.append(',');
		_buf.append("chipsRecieved=");
		_buf.appendUint(chipsRecieved);
		_buf.append(',');
		_buf.append("realMoneySpent=");
		_buf.appendUint(realMoneySpent);
		_buf.append(',');
		_buf.append("playMoneySpent=");
		_buf.appendUint(playMoneySpent);
		_buf.append(',');
		_buf.append("fppSpent=");
		_buf.appendUint(fppSpent);
		_buf.append(',');
		_buf.append("tChipsSpent=");
		_buf.appendUint(tChipsSpent);
		_buf.append(',');
		_buf.append("wMoneySpent=");
		_buf.appendUint(wMoneySpent);
		_buf.append(',');
		_buf.append("isAamsTicket=");
		_buf.appendUint(isAamsTicket);
		_buf.append(',');
		_buf.append("aamsTicket=");
		_buf.append(aamsTicket);
		_buf.append(',');
		_buf.append("playChipsSpent64=");
		_buf.appendInt64(playChipsSpent64);
		_buf.append(',');
		_buf.append("rebuysDone=");
		_buf.appendUint(rebuysDone);
		_buf.append(',');
		_buf.append("addonsDone=");
		_buf.appendUint(addonsDone);
		_buf.append(',');
		_buf.append("rebuysRemaining=");
		_buf.appendInt(rebuysRemaining);
		_buf.append(',');
		_buf.append("tournSpendLimit=");
		tournSpendLimit.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_USER_REBUY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
		Atf::XmlElement::encodeAsXmlElement("errMsgBody", errMsgBody, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("chipsRecieved", chipsRecieved, _buf);
		Atf::XmlElement::encodeAsXmlElement("realMoneySpent", realMoneySpent, _buf);
		Atf::XmlElement::encodeAsXmlElement("playMoneySpent", playMoneySpent, _buf);
		Atf::XmlElement::encodeAsXmlElement("fppSpent", fppSpent, _buf);
		Atf::XmlElement::encodeAsXmlElement("tChipsSpent", tChipsSpent, _buf);
		Atf::XmlElement::encodeAsXmlElement("wMoneySpent", wMoneySpent, _buf);
		Atf::XmlElement::encodeAsXmlElement("isAamsTicket", isAamsTicket, _buf);
		Atf::XmlElement::encodeAsXmlElement("aamsTicket", aamsTicket, _buf);
		Atf::XmlElement::encodeAsXmlElement("playChipsSpent64", playChipsSpent64, _buf);
		Atf::XmlElement::encodeAsXmlElement("rebuysDone", rebuysDone, _buf);
		Atf::XmlElement::encodeAsXmlElement("addonsDone", addonsDone, _buf);
		Atf::XmlElement::encodeAsXmlElement("rebuysRemaining", rebuysRemaining, _buf);
		tournSpendLimit.toXmlString("tournSpendLimit", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("errMsgBody"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, errMsgBody)) return false;
			}
			else if (_element.equals("chipsRecieved"))
			{
				chipsRecieved = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("realMoneySpent"))
			{
				realMoneySpent = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playMoneySpent"))
			{
				playMoneySpent = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppSpent"))
			{
				fppSpent = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tChipsSpent"))
			{
				tChipsSpent = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("wMoneySpent"))
			{
				wMoneySpent = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isAamsTicket"))
			{
				isAamsTicket = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("aamsTicket"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, aamsTicket)) return false;
			}
			else if (_element.equals("playChipsSpent64"))
			{
				playChipsSpent64 = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuysDone"))
			{
				rebuysDone = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("addonsDone"))
			{
				addonsDone = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuysRemaining"))
			{
				rebuysRemaining = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournSpendLimit"))
			{
				if(!Atf::AtfTempl< TournSpendLimit >::FromXmlString(_value, tournSpendLimit)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
		_msg.composeMsgBody(errMsgBody);
	}
	else
	{
		_msg.composeUINT32(chipsRecieved);
		_msg.composeUINT32(realMoneySpent);
		_msg.composeUINT32(playMoneySpent);
		_msg.composeUINT32(fppSpent);
		_msg.composeUINT32(tChipsSpent);
		_msg.composeUINT32(wMoneySpent);
		_msg.composeUINT32(isAamsTicket);
		_msg.composeString(aamsTicket);
		_msg.composeINT64(playChipsSpent64);
		_msg.composeUINT16(rebuysDone);
		_msg.composeUINT16(addonsDone);
		_msg.composeINT16(rebuysRemaining);
		tournSpendLimit.composeMsg(_msg, _ignoreJSON);
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
		_parser.parseMsgBody(errMsgBody);
	}
	else
	{
		_parser.parseUINT32(chipsRecieved);
		_parser.parseUINT32(realMoneySpent);
		_parser.parseUINT32(playMoneySpent);
		_parser.parseUINT32(fppSpent);
		_parser.parseUINT32(tChipsSpent);
		_parser.parseUINT32(wMoneySpent);
		_parser.parseUINT32(isAamsTicket);
		_parser.parseStringP(aamsTicket);
		_parser.parseINT64(playChipsSpent64);
		_parser.parseUINT16(rebuysDone);
		_parser.parseUINT16(addonsDone);
		_parser.parseINT16(rebuysRemaining);
		if(_parser.parseEnded()) return;
		tournSpendLimit.parseMsg(_parser);
	}
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
		_jsonstr.compose("errMsgBody", errMsgBody);
	}
	else
	{
		_jsonstr.compose("chipsRecieved", chipsRecieved);
		_jsonstr.compose("realMoneySpent", realMoneySpent);
		_jsonstr.compose("playMoneySpent", playMoneySpent);
		_jsonstr.compose("fppSpent", fppSpent);
		_jsonstr.compose("tChipsSpent", tChipsSpent);
		_jsonstr.compose("wMoneySpent", wMoneySpent);
		_jsonstr.compose("isAamsTicket", isAamsTicket);
		_jsonstr.compose("aamsTicket", aamsTicket);
		_jsonstr.compose("playChipsSpent64", playChipsSpent64);
		_jsonstr.compose("rebuysDone", rebuysDone);
		_jsonstr.compose("addonsDone", addonsDone);
		_jsonstr.compose("rebuysRemaining", rebuysRemaining);
		_jsonstr.compose("tournSpendLimit", tournSpendLimit);
	}
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
		_jparser.parseByNameThrow("errMsgBody", errMsgBody);
	}
	else
	{
		_jparser.parseByNameThrow("chipsRecieved", chipsRecieved);
		_jparser.parseByNameThrow("realMoneySpent", realMoneySpent);
		_jparser.parseByNameThrow("playMoneySpent", playMoneySpent);
		_jparser.parseByNameThrow("fppSpent", fppSpent);
		_jparser.parseByNameThrow("tChipsSpent", tChipsSpent);
		_jparser.parseByNameThrow("wMoneySpent", wMoneySpent);
		_jparser.parseByNameThrow("isAamsTicket", isAamsTicket);
		_jparser.parseByNameThrow("aamsTicket", aamsTicket);
		_jparser.parseByNameThrow("playChipsSpent64", playChipsSpent64);
		_jparser.parseByNameThrow("rebuysDone", rebuysDone);
		_jparser.parseByNameThrow("addonsDone", addonsDone);
		_jparser.parseByNameThrow("rebuysRemaining", rebuysRemaining);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("tournSpendLimit", tournSpendLimit);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_REBUY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody errMsgBody; _jparser.validateByNameThrow("errMsgBody", errMsgBody);
		AtfValidator::validateInt(_descr, "errMsgBody", errMsgBody._size(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 chipsRecieved; _jparser.validateByNameThrow("chipsRecieved", chipsRecieved);
		AtfValidator::validateInt(_descr, "chipsRecieved", chipsRecieved, _checker, __FILE__, __LINE__);
		UINT32 realMoneySpent; _jparser.validateByNameThrow("realMoneySpent", realMoneySpent);
		AtfValidator::validateInt(_descr, "realMoneySpent", realMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 playMoneySpent; _jparser.validateByNameThrow("playMoneySpent", playMoneySpent);
		AtfValidator::validateInt(_descr, "playMoneySpent", playMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 fppSpent; _jparser.validateByNameThrow("fppSpent", fppSpent);
		AtfValidator::validateInt(_descr, "fppSpent", fppSpent, _checker, __FILE__, __LINE__);
		UINT32 tChipsSpent; _jparser.validateByNameThrow("tChipsSpent", tChipsSpent);
		AtfValidator::validateInt(_descr, "tChipsSpent", tChipsSpent, _checker, __FILE__, __LINE__);
		UINT32 wMoneySpent; _jparser.validateByNameThrow("wMoneySpent", wMoneySpent);
		AtfValidator::validateInt(_descr, "wMoneySpent", wMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 isAamsTicket; _jparser.validateByNameThrow("isAamsTicket", isAamsTicket);
		AtfValidator::validateInt(_descr, "isAamsTicket", isAamsTicket, _checker, __FILE__, __LINE__);
		PString aamsTicket; _jparser.validateByNameThrow("aamsTicket", aamsTicket);
		AtfValidator::validateInt(_descr, "aamsTicket", aamsTicket.length(), _checker, __FILE__, __LINE__);
		INT64 playChipsSpent64; _jparser.validateByNameThrow("playChipsSpent64", playChipsSpent64);
		AtfValidator::validateInt(_descr, "playChipsSpent64", playChipsSpent64, _checker, __FILE__, __LINE__);
		UINT16 rebuysDone; _jparser.validateByNameThrow("rebuysDone", rebuysDone);
		AtfValidator::validateInt(_descr, "rebuysDone", rebuysDone, _checker, __FILE__, __LINE__);
		UINT16 addonsDone; _jparser.validateByNameThrow("addonsDone", addonsDone);
		AtfValidator::validateInt(_descr, "addonsDone", addonsDone, _checker, __FILE__, __LINE__);
		INT16 rebuysRemaining; _jparser.validateByNameThrow("rebuysRemaining", rebuysRemaining);
		AtfValidator::validateInt(_descr, "rebuysRemaining", rebuysRemaining, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		TournSpendLimit tournSpendLimit; _jparser.validateByNameThrow("tournSpendLimit", tournSpendLimit);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_REBUY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errCode = 0;
	_parser.parseBYTE(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		size_t szErrMsgBody; _parser.skipMsgBody(szErrMsgBody);  /*errMsgBody*/
		AtfValidator::validateInt(_descr, "errMsgBody", szErrMsgBody, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 chipsRecieved; _parser.parseUINT32(chipsRecieved);
		AtfValidator::validateInt(_descr, "chipsRecieved", chipsRecieved, _checker, __FILE__, __LINE__);
		UINT32 realMoneySpent; _parser.parseUINT32(realMoneySpent);
		AtfValidator::validateInt(_descr, "realMoneySpent", realMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 playMoneySpent; _parser.parseUINT32(playMoneySpent);
		AtfValidator::validateInt(_descr, "playMoneySpent", playMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 fppSpent; _parser.parseUINT32(fppSpent);
		AtfValidator::validateInt(_descr, "fppSpent", fppSpent, _checker, __FILE__, __LINE__);
		UINT32 tChipsSpent; _parser.parseUINT32(tChipsSpent);
		AtfValidator::validateInt(_descr, "tChipsSpent", tChipsSpent, _checker, __FILE__, __LINE__);
		UINT32 wMoneySpent; _parser.parseUINT32(wMoneySpent);
		AtfValidator::validateInt(_descr, "wMoneySpent", wMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 isAamsTicket; _parser.parseUINT32(isAamsTicket);
		AtfValidator::validateInt(_descr, "isAamsTicket", isAamsTicket, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "aamsTicket"); size_t szAamsTicket = strlen(_dummy);
		AtfValidator::validateInt(_descr, "aamsTicket", szAamsTicket, _checker, __FILE__, __LINE__);
		INT64 playChipsSpent64; _parser.parseINT64(playChipsSpent64);
		AtfValidator::validateInt(_descr, "playChipsSpent64", playChipsSpent64, _checker, __FILE__, __LINE__);
		UINT16 rebuysDone; _parser.parseUINT16(rebuysDone);
		AtfValidator::validateInt(_descr, "rebuysDone", rebuysDone, _checker, __FILE__, __LINE__);
		UINT16 addonsDone; _parser.parseUINT16(addonsDone);
		AtfValidator::validateInt(_descr, "addonsDone", addonsDone, _checker, __FILE__, __LINE__);
		INT16 rebuysRemaining; _parser.parseINT16(rebuysRemaining);
		AtfValidator::validateInt(_descr, "rebuysRemaining", rebuysRemaining, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		PString _descbuf;
		TournSpendLimit::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSpendLimit"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_ADDON
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::Protocol_MTL_USER_ADDON()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::clear()
{
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::equals(const Protocol_MTL_USER_ADDON& _o) const
{
	return true;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_USER_ADDON != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_USER_ADDON*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_ADDON).append(")");
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_USER_ADDON).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::parseMsg(CommMsgParser& _parser)
{
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_ADDON";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_ADDON";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_ADDON_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::Protocol_MTL_USER_ADDON_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::Protocol_MTL_USER_ADDON_REPLY(Protocol_MTL_USER_ADDON_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, errMsgBody(std::move(_o.errMsgBody))
	, chipsRecieved(std::move(_o.chipsRecieved))
	, realMoneySpent(std::move(_o.realMoneySpent))
	, playMoneySpent(std::move(_o.playMoneySpent))
	, fppSpent(std::move(_o.fppSpent))
	, tChipsSpent(std::move(_o.tChipsSpent))
	, wMoneySpent(std::move(_o.wMoneySpent))
	, isAamsTicket(std::move(_o.isAamsTicket))
	, aamsTicket(std::move(_o.aamsTicket))
	, playChipsSpent64(std::move(_o.playChipsSpent64))
	, rebuysDone(std::move(_o.rebuysDone))
	, addonsDone(std::move(_o.addonsDone))
	, rebuysRemaining(std::move(_o.rebuysRemaining))
	, tournSpendLimit(std::move(_o.tournSpendLimit))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY& MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::operator=(Protocol_MTL_USER_ADDON_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		errMsgBody = std::move(_o.errMsgBody);
		chipsRecieved = std::move(_o.chipsRecieved);
		realMoneySpent = std::move(_o.realMoneySpent);
		playMoneySpent = std::move(_o.playMoneySpent);
		fppSpent = std::move(_o.fppSpent);
		tChipsSpent = std::move(_o.tChipsSpent);
		wMoneySpent = std::move(_o.wMoneySpent);
		isAamsTicket = std::move(_o.isAamsTicket);
		aamsTicket = std::move(_o.aamsTicket);
		playChipsSpent64 = std::move(_o.playChipsSpent64);
		rebuysDone = std::move(_o.rebuysDone);
		addonsDone = std::move(_o.addonsDone);
		rebuysRemaining = std::move(_o.rebuysRemaining);
		tournSpendLimit = std::move(_o.tournSpendLimit);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	errMsgBody.clear();
	chipsRecieved = 0;
	realMoneySpent = 0;
	playMoneySpent = 0;
	fppSpent = 0;
	tChipsSpent = 0;
	wMoneySpent = 0;
	isAamsTicket = 0;
	aamsTicket.clear();
	playChipsSpent64 = 0;
	rebuysDone = 0;
	addonsDone = 0;
	rebuysRemaining = 0;
	tournSpendLimit.clear();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::equals(const Protocol_MTL_USER_ADDON_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		errMsgBody.equals(_o.errMsgBody) &&
		chipsRecieved == _o.chipsRecieved &&
		realMoneySpent == _o.realMoneySpent &&
		playMoneySpent == _o.playMoneySpent &&
		fppSpent == _o.fppSpent &&
		tChipsSpent == _o.tChipsSpent &&
		wMoneySpent == _o.wMoneySpent &&
		isAamsTicket == _o.isAamsTicket &&
		Atf::atfPStringEquals(aamsTicket, _o.aamsTicket) &&
		playChipsSpent64 == _o.playChipsSpent64 &&
		rebuysDone == _o.rebuysDone &&
		addonsDone == _o.addonsDone &&
		rebuysRemaining == _o.rebuysRemaining &&
		tournSpendLimit.equals(_o.tournSpendLimit);
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_USER_ADDON_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_USER_ADDON_REPLY*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_ADDON_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("errMsgBody=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(errMsgBody, _buf); _buf.append('}');
	}
	else
	{
		_buf.append(',');
		_buf.append("chipsRecieved=");
		_buf.appendUint(chipsRecieved);
		_buf.append(',');
		_buf.append("realMoneySpent=");
		_buf.appendUint(realMoneySpent);
		_buf.append(',');
		_buf.append("playMoneySpent=");
		_buf.appendUint(playMoneySpent);
		_buf.append(',');
		_buf.append("fppSpent=");
		_buf.appendUint(fppSpent);
		_buf.append(',');
		_buf.append("tChipsSpent=");
		_buf.appendUint(tChipsSpent);
		_buf.append(',');
		_buf.append("wMoneySpent=");
		_buf.appendUint(wMoneySpent);
		_buf.append(',');
		_buf.append("isAamsTicket=");
		_buf.appendUint(isAamsTicket);
		_buf.append(',');
		_buf.append("aamsTicket=");
		_buf.append(aamsTicket);
		_buf.append(',');
		_buf.append("playChipsSpent64=");
		_buf.appendInt64(playChipsSpent64);
		_buf.append(',');
		_buf.append("rebuysDone=");
		_buf.appendUint(rebuysDone);
		_buf.append(',');
		_buf.append("addonsDone=");
		_buf.appendUint(addonsDone);
		_buf.append(',');
		_buf.append("rebuysRemaining=");
		_buf.appendInt(rebuysRemaining);
		_buf.append(',');
		_buf.append("tournSpendLimit=");
		tournSpendLimit.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_USER_ADDON_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
		Atf::XmlElement::encodeAsXmlElement("errMsgBody", errMsgBody, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("chipsRecieved", chipsRecieved, _buf);
		Atf::XmlElement::encodeAsXmlElement("realMoneySpent", realMoneySpent, _buf);
		Atf::XmlElement::encodeAsXmlElement("playMoneySpent", playMoneySpent, _buf);
		Atf::XmlElement::encodeAsXmlElement("fppSpent", fppSpent, _buf);
		Atf::XmlElement::encodeAsXmlElement("tChipsSpent", tChipsSpent, _buf);
		Atf::XmlElement::encodeAsXmlElement("wMoneySpent", wMoneySpent, _buf);
		Atf::XmlElement::encodeAsXmlElement("isAamsTicket", isAamsTicket, _buf);
		Atf::XmlElement::encodeAsXmlElement("aamsTicket", aamsTicket, _buf);
		Atf::XmlElement::encodeAsXmlElement("playChipsSpent64", playChipsSpent64, _buf);
		Atf::XmlElement::encodeAsXmlElement("rebuysDone", rebuysDone, _buf);
		Atf::XmlElement::encodeAsXmlElement("addonsDone", addonsDone, _buf);
		Atf::XmlElement::encodeAsXmlElement("rebuysRemaining", rebuysRemaining, _buf);
		tournSpendLimit.toXmlString("tournSpendLimit", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("errMsgBody"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, errMsgBody)) return false;
			}
			else if (_element.equals("chipsRecieved"))
			{
				chipsRecieved = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("realMoneySpent"))
			{
				realMoneySpent = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playMoneySpent"))
			{
				playMoneySpent = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppSpent"))
			{
				fppSpent = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tChipsSpent"))
			{
				tChipsSpent = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("wMoneySpent"))
			{
				wMoneySpent = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isAamsTicket"))
			{
				isAamsTicket = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("aamsTicket"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, aamsTicket)) return false;
			}
			else if (_element.equals("playChipsSpent64"))
			{
				playChipsSpent64 = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuysDone"))
			{
				rebuysDone = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("addonsDone"))
			{
				addonsDone = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuysRemaining"))
			{
				rebuysRemaining = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournSpendLimit"))
			{
				if(!Atf::AtfTempl< TournSpendLimit >::FromXmlString(_value, tournSpendLimit)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
		_msg.composeMsgBody(errMsgBody);
	}
	else
	{
		_msg.composeUINT32(chipsRecieved);
		_msg.composeUINT32(realMoneySpent);
		_msg.composeUINT32(playMoneySpent);
		_msg.composeUINT32(fppSpent);
		_msg.composeUINT32(tChipsSpent);
		_msg.composeUINT32(wMoneySpent);
		_msg.composeUINT32(isAamsTicket);
		_msg.composeString(aamsTicket);
		_msg.composeINT64(playChipsSpent64);
		_msg.composeUINT16(rebuysDone);
		_msg.composeUINT16(addonsDone);
		_msg.composeINT16(rebuysRemaining);
		tournSpendLimit.composeMsg(_msg, _ignoreJSON);
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
		_parser.parseMsgBody(errMsgBody);
	}
	else
	{
		_parser.parseUINT32(chipsRecieved);
		_parser.parseUINT32(realMoneySpent);
		_parser.parseUINT32(playMoneySpent);
		_parser.parseUINT32(fppSpent);
		_parser.parseUINT32(tChipsSpent);
		_parser.parseUINT32(wMoneySpent);
		_parser.parseUINT32(isAamsTicket);
		_parser.parseStringP(aamsTicket);
		_parser.parseINT64(playChipsSpent64);
		_parser.parseUINT16(rebuysDone);
		_parser.parseUINT16(addonsDone);
		_parser.parseINT16(rebuysRemaining);
		if(_parser.parseEnded()) return;
		tournSpendLimit.parseMsg(_parser);
	}
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
		_jsonstr.compose("errMsgBody", errMsgBody);
	}
	else
	{
		_jsonstr.compose("chipsRecieved", chipsRecieved);
		_jsonstr.compose("realMoneySpent", realMoneySpent);
		_jsonstr.compose("playMoneySpent", playMoneySpent);
		_jsonstr.compose("fppSpent", fppSpent);
		_jsonstr.compose("tChipsSpent", tChipsSpent);
		_jsonstr.compose("wMoneySpent", wMoneySpent);
		_jsonstr.compose("isAamsTicket", isAamsTicket);
		_jsonstr.compose("aamsTicket", aamsTicket);
		_jsonstr.compose("playChipsSpent64", playChipsSpent64);
		_jsonstr.compose("rebuysDone", rebuysDone);
		_jsonstr.compose("addonsDone", addonsDone);
		_jsonstr.compose("rebuysRemaining", rebuysRemaining);
		_jsonstr.compose("tournSpendLimit", tournSpendLimit);
	}
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
		_jparser.parseByNameThrow("errMsgBody", errMsgBody);
	}
	else
	{
		_jparser.parseByNameThrow("chipsRecieved", chipsRecieved);
		_jparser.parseByNameThrow("realMoneySpent", realMoneySpent);
		_jparser.parseByNameThrow("playMoneySpent", playMoneySpent);
		_jparser.parseByNameThrow("fppSpent", fppSpent);
		_jparser.parseByNameThrow("tChipsSpent", tChipsSpent);
		_jparser.parseByNameThrow("wMoneySpent", wMoneySpent);
		_jparser.parseByNameThrow("isAamsTicket", isAamsTicket);
		_jparser.parseByNameThrow("aamsTicket", aamsTicket);
		_jparser.parseByNameThrow("playChipsSpent64", playChipsSpent64);
		_jparser.parseByNameThrow("rebuysDone", rebuysDone);
		_jparser.parseByNameThrow("addonsDone", addonsDone);
		_jparser.parseByNameThrow("rebuysRemaining", rebuysRemaining);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("tournSpendLimit", tournSpendLimit);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_ADDON_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody errMsgBody; _jparser.validateByNameThrow("errMsgBody", errMsgBody);
		AtfValidator::validateInt(_descr, "errMsgBody", errMsgBody._size(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 chipsRecieved; _jparser.validateByNameThrow("chipsRecieved", chipsRecieved);
		AtfValidator::validateInt(_descr, "chipsRecieved", chipsRecieved, _checker, __FILE__, __LINE__);
		UINT32 realMoneySpent; _jparser.validateByNameThrow("realMoneySpent", realMoneySpent);
		AtfValidator::validateInt(_descr, "realMoneySpent", realMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 playMoneySpent; _jparser.validateByNameThrow("playMoneySpent", playMoneySpent);
		AtfValidator::validateInt(_descr, "playMoneySpent", playMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 fppSpent; _jparser.validateByNameThrow("fppSpent", fppSpent);
		AtfValidator::validateInt(_descr, "fppSpent", fppSpent, _checker, __FILE__, __LINE__);
		UINT32 tChipsSpent; _jparser.validateByNameThrow("tChipsSpent", tChipsSpent);
		AtfValidator::validateInt(_descr, "tChipsSpent", tChipsSpent, _checker, __FILE__, __LINE__);
		UINT32 wMoneySpent; _jparser.validateByNameThrow("wMoneySpent", wMoneySpent);
		AtfValidator::validateInt(_descr, "wMoneySpent", wMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 isAamsTicket; _jparser.validateByNameThrow("isAamsTicket", isAamsTicket);
		AtfValidator::validateInt(_descr, "isAamsTicket", isAamsTicket, _checker, __FILE__, __LINE__);
		PString aamsTicket; _jparser.validateByNameThrow("aamsTicket", aamsTicket);
		AtfValidator::validateInt(_descr, "aamsTicket", aamsTicket.length(), _checker, __FILE__, __LINE__);
		INT64 playChipsSpent64; _jparser.validateByNameThrow("playChipsSpent64", playChipsSpent64);
		AtfValidator::validateInt(_descr, "playChipsSpent64", playChipsSpent64, _checker, __FILE__, __LINE__);
		UINT16 rebuysDone; _jparser.validateByNameThrow("rebuysDone", rebuysDone);
		AtfValidator::validateInt(_descr, "rebuysDone", rebuysDone, _checker, __FILE__, __LINE__);
		UINT16 addonsDone; _jparser.validateByNameThrow("addonsDone", addonsDone);
		AtfValidator::validateInt(_descr, "addonsDone", addonsDone, _checker, __FILE__, __LINE__);
		INT16 rebuysRemaining; _jparser.validateByNameThrow("rebuysRemaining", rebuysRemaining);
		AtfValidator::validateInt(_descr, "rebuysRemaining", rebuysRemaining, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		TournSpendLimit tournSpendLimit; _jparser.validateByNameThrow("tournSpendLimit", tournSpendLimit);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_ADDON_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errCode = 0;
	_parser.parseBYTE(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		size_t szErrMsgBody; _parser.skipMsgBody(szErrMsgBody);  /*errMsgBody*/
		AtfValidator::validateInt(_descr, "errMsgBody", szErrMsgBody, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 chipsRecieved; _parser.parseUINT32(chipsRecieved);
		AtfValidator::validateInt(_descr, "chipsRecieved", chipsRecieved, _checker, __FILE__, __LINE__);
		UINT32 realMoneySpent; _parser.parseUINT32(realMoneySpent);
		AtfValidator::validateInt(_descr, "realMoneySpent", realMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 playMoneySpent; _parser.parseUINT32(playMoneySpent);
		AtfValidator::validateInt(_descr, "playMoneySpent", playMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 fppSpent; _parser.parseUINT32(fppSpent);
		AtfValidator::validateInt(_descr, "fppSpent", fppSpent, _checker, __FILE__, __LINE__);
		UINT32 tChipsSpent; _parser.parseUINT32(tChipsSpent);
		AtfValidator::validateInt(_descr, "tChipsSpent", tChipsSpent, _checker, __FILE__, __LINE__);
		UINT32 wMoneySpent; _parser.parseUINT32(wMoneySpent);
		AtfValidator::validateInt(_descr, "wMoneySpent", wMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 isAamsTicket; _parser.parseUINT32(isAamsTicket);
		AtfValidator::validateInt(_descr, "isAamsTicket", isAamsTicket, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "aamsTicket"); size_t szAamsTicket = strlen(_dummy);
		AtfValidator::validateInt(_descr, "aamsTicket", szAamsTicket, _checker, __FILE__, __LINE__);
		INT64 playChipsSpent64; _parser.parseINT64(playChipsSpent64);
		AtfValidator::validateInt(_descr, "playChipsSpent64", playChipsSpent64, _checker, __FILE__, __LINE__);
		UINT16 rebuysDone; _parser.parseUINT16(rebuysDone);
		AtfValidator::validateInt(_descr, "rebuysDone", rebuysDone, _checker, __FILE__, __LINE__);
		UINT16 addonsDone; _parser.parseUINT16(addonsDone);
		AtfValidator::validateInt(_descr, "addonsDone", addonsDone, _checker, __FILE__, __LINE__);
		INT16 rebuysRemaining; _parser.parseINT16(rebuysRemaining);
		AtfValidator::validateInt(_descr, "rebuysRemaining", rebuysRemaining, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		PString _descbuf;
		TournSpendLimit::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSpendLimit"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_DECLINE_REBUY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::Protocol_MTL_USER_DECLINE_REBUY()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::clear()
{
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::equals(const Protocol_MTL_USER_DECLINE_REBUY& _o) const
{
	return true;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_USER_DECLINE_REBUY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_USER_DECLINE_REBUY*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_DECLINE_REBUY).append(")");
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_USER_DECLINE_REBUY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::parseMsg(CommMsgParser& _parser)
{
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_DECLINE_REBUY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_DECLINE_REBUY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_SET_IMREADY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::Protocol_MTL_SET_IMREADY()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::clear()
{
}

bool MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::equals(const Protocol_MTL_SET_IMREADY& _o) const
{
	return true;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_SET_IMREADY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_SET_IMREADY*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_SET_IMREADY).append(")");
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_SET_IMREADY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::parseMsg(CommMsgParser& _parser)
{
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_SET_IMREADY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_SET_IMREADY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_SET_IMREADY_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::Protocol_MTL_SET_IMREADY_REPLY()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::clear()
{
	errCode = 0;
	userReady = false;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::equals(const Protocol_MTL_SET_IMREADY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		userReady == _o.userReady;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_SET_IMREADY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_SET_IMREADY_REPLY*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_SET_IMREADY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("userReady=");
	_buf.appendUint(userReady);
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_SET_IMREADY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("userReady", userReady, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userReady"))
			{
				userReady = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeBOOL(userReady);
}

void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseBOOL(userReady);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("userReady", userReady);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("userReady", userReady);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_SET_IMREADY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	bool userReady; _jparser.validateByNameThrow("userReady", userReady);
	AtfValidator::validateInt(_descr, "userReady", userReady, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_SET_IMREADY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	bool userReady; _parser.parseBOOL(userReady);
	AtfValidator::validateInt(_descr, "userReady", userReady, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_GET_IMREADY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::Protocol_MTL_GET_IMREADY()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::clear()
{
}

bool MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::equals(const Protocol_MTL_GET_IMREADY& _o) const
{
	return true;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_GET_IMREADY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_GET_IMREADY*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_GET_IMREADY).append(")");
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_GET_IMREADY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::parseMsg(CommMsgParser& _parser)
{
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_GET_IMREADY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_GET_IMREADY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_GET_IMREADY_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::Protocol_MTL_GET_IMREADY_REPLY()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::clear()
{
	errCode = 0;
	userReady = false;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::equals(const Protocol_MTL_GET_IMREADY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		userReady == _o.userReady;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_GET_IMREADY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_GET_IMREADY_REPLY*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_GET_IMREADY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("userReady=");
	_buf.appendUint(userReady);
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_GET_IMREADY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("userReady", userReady, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userReady"))
			{
				userReady = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeBOOL(userReady);
}

void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseBOOL(userReady);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("userReady", userReady);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("userReady", userReady);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_GET_IMREADY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	bool userReady; _jparser.validateByNameThrow("userReady", userReady);
	AtfValidator::validateInt(_descr, "userReady", userReady, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_GET_IMREADY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	bool userReady; _parser.parseBOOL(userReady);
	AtfValidator::validateInt(_descr, "userReady", userReady, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::clear()
{
	stacksReloaded = 0;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::equals(const Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY& _o) const
{
	return stacksReloaded == _o.stacksReloaded;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_USER_AUTO_RELOAD_STACKS_NOTIFY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_AUTO_RELOAD_STACKS_NOTIFY).append(")");
	_buf.append(',');
	_buf.append("stacksReloaded=");
	_buf.appendUint(stacksReloaded);
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_USER_AUTO_RELOAD_STACKS_NOTIFY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("stacksReloaded", stacksReloaded, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("stacksReloaded"))
			{
				stacksReloaded = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(stacksReloaded);
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(stacksReloaded);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("stacksReloaded", stacksReloaded);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("stacksReloaded", stacksReloaded);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_AUTO_RELOAD_STACKS_NOTIFY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 stacksReloaded; _jparser.validateByNameThrow("stacksReloaded", stacksReloaded);
	AtfValidator::validateInt(_descr, "stacksReloaded", stacksReloaded, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_AUTO_RELOAD_STACKS_NOTIFY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 stacksReloaded; _parser.parseUINT32(stacksReloaded);
	AtfValidator::validateInt(_descr, "stacksReloaded", stacksReloaded, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_RELOAD_STACKS
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::Protocol_MTL_USER_RELOAD_STACKS()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::clear()
{
	reqStacks = 0;
	isSyncReload = false;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::equals(const Protocol_MTL_USER_RELOAD_STACKS& _o) const
{
	return reqStacks == _o.reqStacks &&
		isSyncReload == _o.isSyncReload;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_USER_RELOAD_STACKS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_USER_RELOAD_STACKS*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_RELOAD_STACKS).append(")");
	_buf.append(',');
	_buf.append("reqStacks=");
	_buf.appendInt(reqStacks);
	_buf.append(',');
	_buf.append("isSyncReload=");
	_buf.appendUint(isSyncReload);
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_USER_RELOAD_STACKS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("reqStacks", reqStacks, _buf);
	Atf::XmlElement::encodeAsXmlElement("isSyncReload", isSyncReload, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reqStacks"))
			{
				reqStacks = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isSyncReload"))
			{
				isSyncReload = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(reqStacks);
	_msg.composeBOOL(isSyncReload);
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(reqStacks);
	_parser.parseBOOL(isSyncReload);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reqStacks", reqStacks);
	_jsonstr.compose("isSyncReload", isSyncReload);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reqStacks", reqStacks);
	_jparser.parseByNameThrow("isSyncReload", isSyncReload);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_RELOAD_STACKS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 reqStacks; _jparser.validateByNameThrow("reqStacks", reqStacks);
	AtfValidator::validateIntRange(_descr, "reqStacks", reqStacks, 0, 100, _checker, __FILE__, __LINE__);
	bool isSyncReload; _jparser.validateByNameThrow("isSyncReload", isSyncReload);
	AtfValidator::validateInt(_descr, "isSyncReload", isSyncReload, _checker, __FILE__, __LINE__);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_RELOAD_STACKS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 reqStacks; _parser.parseINT32(reqStacks);
	AtfValidator::validateIntRange(_descr, "reqStacks", reqStacks, 0, 100, _checker, __FILE__, __LINE__);
	bool isSyncReload; _parser.parseBOOL(isSyncReload);
	AtfValidator::validateInt(_descr, "isSyncReload", isSyncReload, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_RELOAD_STACKS_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::Protocol_MTL_USER_RELOAD_STACKS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::Protocol_MTL_USER_RELOAD_STACKS_REPLY(Protocol_MTL_USER_RELOAD_STACKS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, errMsgBody(std::move(_o.errMsgBody))
	, unusedStacks(std::move(_o.unusedStacks))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY& MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::operator=(Protocol_MTL_USER_RELOAD_STACKS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		errMsgBody = std::move(_o.errMsgBody);
		unusedStacks = std::move(_o.unusedStacks);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	errMsgBody.clear();
	unusedStacks = 0;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::equals(const Protocol_MTL_USER_RELOAD_STACKS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		errMsgBody.equals(_o.errMsgBody) &&
		unusedStacks == _o.unusedStacks;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_USER_RELOAD_STACKS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_USER_RELOAD_STACKS_REPLY*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_RELOAD_STACKS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("errMsgBody=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(errMsgBody, _buf); _buf.append('}');
	}
	else
	{
		_buf.append(',');
		_buf.append("unusedStacks=");
		_buf.appendUint(unusedStacks);
	}
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_USER_RELOAD_STACKS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
		Atf::XmlElement::encodeAsXmlElement("errMsgBody", errMsgBody, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("unusedStacks", unusedStacks, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("errMsgBody"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, errMsgBody)) return false;
			}
			else if (_element.equals("unusedStacks"))
			{
				unusedStacks = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
		_msg.composeMsgBody(errMsgBody);
	}
	else
	{
		_msg.composeUINT32(unusedStacks);
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
		_parser.parseMsgBody(errMsgBody);
	}
	else
	{
		_parser.parseUINT32(unusedStacks);
	}
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
		_jsonstr.compose("errMsgBody", errMsgBody);
	}
	else
	{
		_jsonstr.compose("unusedStacks", unusedStacks);
	}
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
		_jparser.parseByNameThrow("errMsgBody", errMsgBody);
	}
	else
	{
		_jparser.parseByNameThrow("unusedStacks", unusedStacks);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_RELOAD_STACKS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody errMsgBody; _jparser.validateByNameThrow("errMsgBody", errMsgBody);
		AtfValidator::validateInt(_descr, "errMsgBody", errMsgBody._size(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 unusedStacks; _jparser.validateByNameThrow("unusedStacks", unusedStacks);
		AtfValidator::validateInt(_descr, "unusedStacks", unusedStacks, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_RELOAD_STACKS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errCode = 0;
	_parser.parseBYTE(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		size_t szErrMsgBody; _parser.skipMsgBody(szErrMsgBody);  /*errMsgBody*/
		AtfValidator::validateInt(_descr, "errMsgBody", szErrMsgBody, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 unusedStacks; _parser.parseUINT32(unusedStacks);
		AtfValidator::validateInt(_descr, "unusedStacks", unusedStacks, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::clear()
{
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::equals(const Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED& _o) const
{
	return true;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED*)_other));
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED).append(")");
	return _buf.c_str();
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::parseMsg(CommMsgParser& _parser)
{
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* MTLobbyCli::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_TOURN_REG_INFO: _obj = new cli::Protocol_MSG_LOBBY_TOURN_REG_INFO(); break;
			case MSG_LOBBY_TOURN_REG_INFO_REPLY: _obj = new cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY(); break;
			case MSG_MTL_CHANGE_FLIGHT: _obj = new cli::Protocol_MSG_MTL_CHANGE_FLIGHT(); break;
			case MSG_MTL_CHANGE_FLIGHT_REPLY: _obj = new cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY(); break;
			case MSG_MTL_GET_SAME_LEVEL_FLIGHTS: _obj = new cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS(); break;
			case MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY: _obj = new cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY(); break;
			case MTL_GET_CHIP_GRAPH_DATA: _obj = new cli::Protocol_MTL_GET_CHIP_GRAPH_DATA(); break;
			case MTL_GET_CHIP_GRAPH_DATA_REPLY: _obj = new cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY(); break;
			case MTL_LOBBY_REGISTER_USER: _obj = new cli::Protocol_MTL_LOBBY_REGISTER_USER(); break;
			case MTL_LOBBY_REGISTER_USER_REPLY: _obj = new cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY(); break;
			case MTL_LOBBY_TOURNAMENT_USER_STATS: _obj = new cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS(); break;
			case MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY: _obj = new cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY(); break;
			case MTL_LOBBY_UNREGISTER_USER: _obj = new cli::Protocol_MTL_LOBBY_UNREGISTER_USER(); break;
			case MTL_LOBBY_UNREGISTER_USER_REPLY: _obj = new cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY(); break;
			case MTL_LOBBY_WHERE_IS_PLAYER: _obj = new cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER(); break;
			case MTL_LOBBY_WHERE_IS_PLAYER_REPLY: _obj = new cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY(); break;
		}
	}
	else if(!strcmp(_nameSpace, "perm_cli"))
	{
		switch(_msgId)
		{
			case MTL_CLI_GOTO_FINISH: _obj = new perm_cli::Protocol_MTL_CLI_GOTO_FINISH(); break;
			case MTL_CLI_GOTO_TABLE: _obj = new perm_cli::Protocol_MTL_CLI_GOTO_TABLE(); break;
			case MTL_GET_IMREADY: _obj = new perm_cli::Protocol_MTL_GET_IMREADY(); break;
			case MTL_GET_IMREADY_REPLY: _obj = new perm_cli::Protocol_MTL_GET_IMREADY_REPLY(); break;
			case MTL_LOBBY_TOURNAMENT_USER_STATS: _obj = new perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS(); break;
			case MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY: _obj = new perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY(); break;
			case MTL_LOBBY_WHERE_IS_PLAYER: _obj = new perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER(); break;
			case MTL_LOBBY_WHERE_IS_PLAYER_REPLY: _obj = new perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY(); break;
			case MTL_SET_IMREADY: _obj = new perm_cli::Protocol_MTL_SET_IMREADY(); break;
			case MTL_SET_IMREADY_REPLY: _obj = new perm_cli::Protocol_MTL_SET_IMREADY_REPLY(); break;
			case MTL_USER_ADDON: _obj = new perm_cli::Protocol_MTL_USER_ADDON(); break;
			case MTL_USER_ADDON_REPLY: _obj = new perm_cli::Protocol_MTL_USER_ADDON_REPLY(); break;
			case MTL_USER_AUTO_RELOAD_STACKS_NOTIFY: _obj = new perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY(); break;
			case MTL_USER_DECLINE_REBUY: _obj = new perm_cli::Protocol_MTL_USER_DECLINE_REBUY(); break;
			case MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED: _obj = new perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED(); break;
			case MTL_USER_REBUY: _obj = new perm_cli::Protocol_MTL_USER_REBUY(); break;
			case MTL_USER_REBUY_REPLY: _obj = new perm_cli::Protocol_MTL_USER_REBUY_REPLY(); break;
			case MTL_USER_RELOAD_STACKS: _obj = new perm_cli::Protocol_MTL_USER_RELOAD_STACKS(); break;
			case MTL_USER_RELOAD_STACKS_REPLY: _obj = new perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY(); break;
			case MTL_USER_SITIN: _obj = new perm_cli::Protocol_MTL_USER_SITIN(); break;
			case MTL_USER_SITIN_REPLY: _obj = new perm_cli::Protocol_MTL_USER_SITIN_REPLY(); break;
			case MTL_USER_SITOUT: _obj = new perm_cli::Protocol_MTL_USER_SITOUT(); break;
			case MTL_USER_SITOUT_REPLY: _obj = new perm_cli::Protocol_MTL_USER_SITOUT_REPLY(); break;
		}
	}
	else if(!strcmp(_nameSpace, "unauth_cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_OLYMPIC_SNAPSHOT: _obj = new unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT(); break;
			case MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY: _obj = new unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY(); break;
			case MTL_LOBBY_TOURNAMENT_USER_STATS: _obj = new unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS(); break;
			case MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY: _obj = new unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY(); break;
			case MTL_LOBBY_WHERE_IS_PLAYER: _obj = new unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER(); break;
			case MTL_LOBBY_WHERE_IS_PLAYER_REPLY: _obj = new unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY(); break;
			case MTL_TOURN_TEXT_INFO: _obj = new unauth_cli::Protocol_MTL_TOURN_TEXT_INFO(); break;
			case MTL_TOURN_TEXT_INFO_REPLY: _obj = new unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool MTLobbyCli::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_TOURN_REG_INFO: cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TOURN_REG_INFO_REPLY: cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MTL_CHANGE_FLIGHT: cli::Protocol_MSG_MTL_CHANGE_FLIGHT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MTL_CHANGE_FLIGHT_REPLY: cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MTL_GET_SAME_LEVEL_FLIGHTS: cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY: cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_GET_CHIP_GRAPH_DATA: cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_GET_CHIP_GRAPH_DATA_REPLY: cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_REGISTER_USER: cli::Protocol_MTL_LOBBY_REGISTER_USER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_REGISTER_USER_REPLY: cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS: cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY: cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_UNREGISTER_USER: cli::Protocol_MTL_LOBBY_UNREGISTER_USER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_UNREGISTER_USER_REPLY: cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER: cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER_REPLY: cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "perm_cli"))
	{
		switch(_msgId)
		{
			case MTL_CLI_GOTO_FINISH: perm_cli::Protocol_MTL_CLI_GOTO_FINISH::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_CLI_GOTO_TABLE: perm_cli::Protocol_MTL_CLI_GOTO_TABLE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_GET_IMREADY: perm_cli::Protocol_MTL_GET_IMREADY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_GET_IMREADY_REPLY: perm_cli::Protocol_MTL_GET_IMREADY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS: perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY: perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER: perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER_REPLY: perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_SET_IMREADY: perm_cli::Protocol_MTL_SET_IMREADY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_SET_IMREADY_REPLY: perm_cli::Protocol_MTL_SET_IMREADY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_ADDON: perm_cli::Protocol_MTL_USER_ADDON::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_ADDON_REPLY: perm_cli::Protocol_MTL_USER_ADDON_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_AUTO_RELOAD_STACKS_NOTIFY: perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_DECLINE_REBUY: perm_cli::Protocol_MTL_USER_DECLINE_REBUY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED: perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_REBUY: perm_cli::Protocol_MTL_USER_REBUY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_REBUY_REPLY: perm_cli::Protocol_MTL_USER_REBUY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_RELOAD_STACKS: perm_cli::Protocol_MTL_USER_RELOAD_STACKS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_RELOAD_STACKS_REPLY: perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_SITIN: perm_cli::Protocol_MTL_USER_SITIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_SITIN_REPLY: perm_cli::Protocol_MTL_USER_SITIN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_SITOUT: perm_cli::Protocol_MTL_USER_SITOUT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_SITOUT_REPLY: perm_cli::Protocol_MTL_USER_SITOUT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "unauth_cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_OLYMPIC_SNAPSHOT: unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY: unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS: unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY: unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER: unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER_REPLY: unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_TOURN_TEXT_INFO: unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_TOURN_TEXT_INFO_REPLY: unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool MTLobbyCli::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_TOURN_REG_INFO: cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TOURN_REG_INFO_REPLY: cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MTL_CHANGE_FLIGHT: cli::Protocol_MSG_MTL_CHANGE_FLIGHT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MTL_CHANGE_FLIGHT_REPLY: cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MTL_GET_SAME_LEVEL_FLIGHTS: cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY: cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_GET_CHIP_GRAPH_DATA: cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_GET_CHIP_GRAPH_DATA_REPLY: cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_REGISTER_USER: cli::Protocol_MTL_LOBBY_REGISTER_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_REGISTER_USER_REPLY: cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS: cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY: cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_UNREGISTER_USER: cli::Protocol_MTL_LOBBY_UNREGISTER_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_UNREGISTER_USER_REPLY: cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER: cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER_REPLY: cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "perm_cli"))
	{
		switch(_msgId)
		{
			case MTL_CLI_GOTO_FINISH: perm_cli::Protocol_MTL_CLI_GOTO_FINISH::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_CLI_GOTO_TABLE: perm_cli::Protocol_MTL_CLI_GOTO_TABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_GET_IMREADY: perm_cli::Protocol_MTL_GET_IMREADY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_GET_IMREADY_REPLY: perm_cli::Protocol_MTL_GET_IMREADY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS: perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY: perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER: perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER_REPLY: perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_SET_IMREADY: perm_cli::Protocol_MTL_SET_IMREADY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_SET_IMREADY_REPLY: perm_cli::Protocol_MTL_SET_IMREADY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_ADDON: perm_cli::Protocol_MTL_USER_ADDON::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_ADDON_REPLY: perm_cli::Protocol_MTL_USER_ADDON_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_AUTO_RELOAD_STACKS_NOTIFY: perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_DECLINE_REBUY: perm_cli::Protocol_MTL_USER_DECLINE_REBUY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED: perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_REBUY: perm_cli::Protocol_MTL_USER_REBUY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_REBUY_REPLY: perm_cli::Protocol_MTL_USER_REBUY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_RELOAD_STACKS: perm_cli::Protocol_MTL_USER_RELOAD_STACKS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_RELOAD_STACKS_REPLY: perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_SITIN: perm_cli::Protocol_MTL_USER_SITIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_SITIN_REPLY: perm_cli::Protocol_MTL_USER_SITIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_SITOUT: perm_cli::Protocol_MTL_USER_SITOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_SITOUT_REPLY: perm_cli::Protocol_MTL_USER_SITOUT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "unauth_cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_OLYMPIC_SNAPSHOT: unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY: unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS: unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY: unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER: unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER_REPLY: unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_TOURN_TEXT_INFO: unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_TOURN_TEXT_INFO_REPLY: unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

