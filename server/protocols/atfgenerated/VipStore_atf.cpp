/**
 * VipStore_atf.cpp
 *
 * This file was auto-generated from VipStore_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: VipStore_atf.txt
 */
 
#include "VipStore_atf.h"

//=================================================================
//                    VipStoreAlternateClientAddress
//=================================================================

VipStore::cli::VipStoreAlternateClientAddress::VipStoreAlternateClientAddress()
{
	clear();
}

void VipStore::cli::VipStoreAlternateClientAddress::clear()
{
	addrId = 0;
	userId.clear();
	fullName.clear();
	addr1.clear();
	addr2.clear();
	city.clear();
	state.clear();
	country.clear();
	code.clear();
	phone.clear();
	fiscalCode.clear();
}

bool VipStore::cli::VipStoreAlternateClientAddress::equals(const VipStoreAlternateClientAddress& _o) const
{
	return addrId == _o.addrId &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(fullName, _o.fullName) &&
		Atf::atfPStringEquals(addr1, _o.addr1) &&
		Atf::atfPStringEquals(addr2, _o.addr2) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(country, _o.country) &&
		Atf::atfPStringEquals(code, _o.code) &&
		Atf::atfPStringEquals(phone, _o.phone) &&
		Atf::atfPStringEquals(fiscalCode, _o.fiscalCode);
}

const char *VipStore::cli::VipStoreAlternateClientAddress::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("addrId=");
	_buf.appendUint(addrId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("fullName=");
	_buf.append(fullName);
	_buf.append(',');
	_buf.append("addr1=");
	_buf.append(addr1);
	_buf.append(',');
	_buf.append("addr2=");
	_buf.append(addr2);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("code=");
	_buf.append(code);
	_buf.append(',');
	_buf.append("phone=");
	_buf.append(phone);
	_buf.append(',');
	_buf.append("fiscalCode=");
	_buf.append(fiscalCode);
	_buf.append('}');
	return _buf.c_str();
}

const char *VipStore::cli::VipStoreAlternateClientAddress::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("addrId", addrId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("fullName", fullName, _buf);
	Atf::XmlElement::encodeAsXmlElement("addr1", addr1, _buf);
	Atf::XmlElement::encodeAsXmlElement("addr2", addr2, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("code", code, _buf);
	Atf::XmlElement::encodeAsXmlElement("phone", phone, _buf);
	Atf::XmlElement::encodeAsXmlElement("fiscalCode", fiscalCode, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool VipStore::cli::VipStoreAlternateClientAddress::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("addrId"))
		{
			addrId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("fullName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, fullName)) return false;
		}
		else if (_element.equals("addr1"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, addr1)) return false;
		}
		else if (_element.equals("addr2"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, addr2)) return false;
		}
		else if (_element.equals("city"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
		}
		else if (_element.equals("state"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("code"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, code)) return false;
		}
		else if (_element.equals("phone"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, phone)) return false;
		}
		else if (_element.equals("fiscalCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, fiscalCode)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void VipStore::cli::VipStoreAlternateClientAddress::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(addrId);
	_msg.composeString(userId);
	_msg.composeString(fullName);
	_msg.composeString(addr1);
	_msg.composeString(addr2);
	_msg.composeString(city);
	_msg.composeString(state);
	_msg.composeString(country);
	_msg.composeString(code);
	_msg.composeString(phone);
	_msg.composeString(fiscalCode);
}

void VipStore::cli::VipStoreAlternateClientAddress::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(addrId);
	_parser.parseStringP(userId);
	_parser.parseStringP(fullName);
	_parser.parseStringP(addr1);
	_parser.parseStringP(addr2);
	_parser.parseStringP(city);
	_parser.parseStringP(state);
	_parser.parseStringP(country);
	_parser.parseStringP(code);
	_parser.parseStringP(phone);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(fiscalCode);
}

const char *VipStore::cli::VipStoreAlternateClientAddress::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("addrId", addrId);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("fullName", fullName);
	_jsonstr.compose("addr1", addr1);
	_jsonstr.compose("addr2", addr2);
	_jsonstr.compose("city", city);
	_jsonstr.compose("state", state);
	_jsonstr.compose("country", country);
	_jsonstr.compose("code", code);
	_jsonstr.compose("phone", phone);
	_jsonstr.compose("fiscalCode", fiscalCode);
	return _buf.c_str();
}

void VipStore::cli::VipStoreAlternateClientAddress::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("addrId", addrId);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("fullName", fullName);
	_jparser.parseByNameThrow("addr1", addr1);
	_jparser.parseByNameThrow("addr2", addr2);
	_jparser.parseByNameThrow("city", city);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("code", code);
	_jparser.parseByNameThrow("phone", phone);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("fiscalCode", fiscalCode);
}

/* static */ void VipStore::cli::VipStoreAlternateClientAddress::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 addrId; _jparser.validateByNameThrow("addrId", addrId);
	AtfValidator::validateInt(_descr, "addrId", addrId, _checker, __FILE__, __LINE__);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 20, _checker, __FILE__, __LINE__);
	PString fullName; _jparser.validateByNameThrow("fullName", fullName);
	AtfValidator::validateIntMax(_descr, "fullName", fullName.length(), 321, _checker, __FILE__, __LINE__);
	PString addr1; _jparser.validateByNameThrow("addr1", addr1);
	AtfValidator::validateIntMax(_descr, "addr1", addr1.length(), 321, _checker, __FILE__, __LINE__);
	PString addr2; _jparser.validateByNameThrow("addr2", addr2);
	AtfValidator::validateIntMax(_descr, "addr2", addr2.length(), 80, _checker, __FILE__, __LINE__);
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateIntMax(_descr, "city", city.length(), 81, _checker, __FILE__, __LINE__);
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateIntMax(_descr, "state", state.length(), 20, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), 20, _checker, __FILE__, __LINE__);
	PString code; _jparser.validateByNameThrow("code", code);
	AtfValidator::validateIntMax(_descr, "code", code.length(), 10, _checker, __FILE__, __LINE__);
	PString phone; _jparser.validateByNameThrow("phone", phone);
	AtfValidator::validateIntMax(_descr, "phone", phone.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString fiscalCode; _jparser.validateByNameThrow("fiscalCode", fiscalCode);
	AtfValidator::validateIntMax(_descr, "fiscalCode", fiscalCode.length(), 100, _checker, __FILE__, __LINE__);
}

/*static*/ void VipStore::cli::VipStoreAlternateClientAddress::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 addrId; _parser.parseUINT32(addrId);
	AtfValidator::validateInt(_descr, "addrId", addrId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "fullName"); size_t szFullName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fullName", szFullName, 321, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "addr1"); size_t szAddr1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "addr1", szAddr1, 321, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "addr2"); size_t szAddr2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "addr2", szAddr2, 80, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, 81, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "code"); size_t szCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "code", szCode, 10, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phone", szPhone, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "fiscalCode"); size_t szFiscalCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fiscalCode", szFiscalCode, 100, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    FppStoreOrder
//=================================================================

VipStore::cli::FppStoreOrder::FppStoreOrder()
{
	clear();
}

void VipStore::cli::FppStoreOrder::clear()
{
	orderId = 0;
	price = 0;
	userId.clear();
	itemDescr.clear();
	status.clear();
	trackingId.clear();
	comment.clear();
	when.setNull();
	specs.clear();
	itemId = 0;
	shipper.clear();
	trackingUrl.clear();
	itemQuantity = 0;
	cartId = 0;
	fulfillmentId = 0;
	altAddr.clear();
	flags = 0;
}

bool VipStore::cli::FppStoreOrder::equals(const FppStoreOrder& _o) const
{
	return orderId == _o.orderId &&
		price == _o.price &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(itemDescr, _o.itemDescr) &&
		Atf::atfPStringEquals(status, _o.status) &&
		Atf::atfPStringEquals(trackingId, _o.trackingId) &&
		Atf::atfPStringEquals(comment, _o.comment) &&
		when.equals(_o.when) &&
		specs.equals(_o.specs) &&
		itemId == _o.itemId &&
		Atf::atfPStringEquals(shipper, _o.shipper) &&
		Atf::atfPStringEquals(trackingUrl, _o.trackingUrl) &&
		itemQuantity == _o.itemQuantity &&
		cartId == _o.cartId &&
		fulfillmentId == _o.fulfillmentId &&
		altAddr.equals(_o.altAddr) &&
		flags == _o.flags;
}

const char *VipStore::cli::FppStoreOrder::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("orderId=");
	_buf.appendUint(orderId);
	_buf.append(',');
	_buf.append("price=");
	_buf.appendUint(price);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("itemDescr=");
	_buf.append(itemDescr);
	_buf.append(',');
	_buf.append("status=");
	_buf.append(status);
	_buf.append(',');
	_buf.append("trackingId=");
	_buf.append(trackingId);
	_buf.append(',');
	_buf.append("comment=");
	_buf.append(comment);
	_buf.append(',');
	_buf.append("when=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("specs=");
	specs.toTraceString(_buf);
	_buf.append(',');
	_buf.append("itemId=");
	_buf.appendUint(itemId);
	_buf.append(',');
	_buf.append("shipper=");
	_buf.append(shipper);
	_buf.append(',');
	_buf.append("trackingUrl=");
	_buf.append(trackingUrl);
	_buf.append(',');
	_buf.append("itemQuantity=");
	_buf.appendUint(itemQuantity);
	_buf.append(',');
	_buf.append("cartId=");
	_buf.appendUint(cartId);
	_buf.append(',');
	_buf.append("fulfillmentId=");
	_buf.appendUint(fulfillmentId);
	_buf.append(',');
	_buf.append("altAddr=");
	altAddr.toTraceString(_buf);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append('}');
	return _buf.c_str();
}

const char *VipStore::cli::FppStoreOrder::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("orderId", orderId, _buf);
	Atf::XmlElement::encodeAsXmlElement("price", price, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("itemDescr", itemDescr, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("trackingId", trackingId, _buf);
	Atf::XmlElement::encodeAsXmlElement("comment", comment, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "when", when);
	specs.toXmlString("specs", _buf);
	Atf::XmlElement::encodeAsXmlElement("itemId", itemId, _buf);
	Atf::XmlElement::encodeAsXmlElement("shipper", shipper, _buf);
	Atf::XmlElement::encodeAsXmlElement("trackingUrl", trackingUrl, _buf);
	Atf::XmlElement::encodeAsXmlElement("itemQuantity", itemQuantity, _buf);
	Atf::XmlElement::encodeAsXmlElement("cartId", cartId, _buf);
	Atf::XmlElement::encodeAsXmlElement("fulfillmentId", fulfillmentId, _buf);
	altAddr.toXmlString("altAddr", _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool VipStore::cli::FppStoreOrder::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("orderId"))
		{
			orderId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("price"))
		{
			price = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("itemDescr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, itemDescr)) return false;
		}
		else if (_element.equals("status"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, status)) return false;
		}
		else if (_element.equals("trackingId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, trackingId)) return false;
		}
		else if (_element.equals("comment"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, comment)) return false;
		}
		else if (_element.equals("when"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, when);
		}
		else if (_element.equals("specs"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, specs)) return false;
		}
		else if (_element.equals("itemId"))
		{
			itemId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("shipper"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, shipper)) return false;
		}
		else if (_element.equals("trackingUrl"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, trackingUrl)) return false;
		}
		else if (_element.equals("itemQuantity"))
		{
			itemQuantity = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cartId"))
		{
			cartId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fulfillmentId"))
		{
			fulfillmentId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("altAddr"))
		{
			if(!Atf::AtfTempl< VipStoreAlternateClientAddress >::FromXmlString(_value, altAddr)) return false;
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void VipStore::cli::FppStoreOrder::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(orderId);
	_msg.composeUINT32(price);
	_msg.composeString(userId);
	_msg.composeString(itemDescr);
	_msg.composeString(status);
	_msg.composeString(trackingId);
	_msg.composeString(comment);
	_msg.composeSrvTime(when);
	specs.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(itemId);
	_msg.composeString(shipper);
	_msg.composeString(trackingUrl);
	_msg.composeUINT32(itemQuantity);
	_msg.composeUINT32(cartId);
	_msg.composeUINT32(fulfillmentId);
	altAddr.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(flags);
}

void VipStore::cli::FppStoreOrder::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(orderId);
	_parser.parseUINT32(price);
	_parser.parseStringP(userId);
	_parser.parseStringP(itemDescr);
	_parser.parseStringP(status);
	_parser.parseStringP(trackingId);
	_parser.parseStringP(comment);
	_parser.parseSrvTime(when);
	specs.parseMsg(_parser);
	_parser.parseUINT32(itemId);
	_parser.parseStringP(shipper);
	_parser.parseStringP(trackingUrl);
	_parser.parseUINT32(itemQuantity);
	_parser.parseUINT32(cartId);
	_parser.parseUINT32(fulfillmentId);
	altAddr.parseMsg(_parser);
	_parser.parseUINT32(flags);
}

const char *VipStore::cli::FppStoreOrder::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("orderId", orderId);
	_jsonstr.compose("price", price);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("itemDescr", itemDescr);
	_jsonstr.compose("status", status);
	_jsonstr.compose("trackingId", trackingId);
	_jsonstr.compose("comment", comment);
	_jsonstr.compose("when", when);
	_jsonstr.compose("specs", specs);
	_jsonstr.compose("itemId", itemId);
	_jsonstr.compose("shipper", shipper);
	_jsonstr.compose("trackingUrl", trackingUrl);
	_jsonstr.compose("itemQuantity", itemQuantity);
	_jsonstr.compose("cartId", cartId);
	_jsonstr.compose("fulfillmentId", fulfillmentId);
	_jsonstr.compose("altAddr", altAddr);
	_jsonstr.compose("flags", flags);
	return _buf.c_str();
}

void VipStore::cli::FppStoreOrder::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("orderId", orderId);
	_jparser.parseByNameThrow("price", price);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("itemDescr", itemDescr);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("trackingId", trackingId);
	_jparser.parseByNameThrow("comment", comment);
	_jparser.parseByNameThrow("when", when);
	_jparser.parseByNameThrow("specs", specs);
	_jparser.parseByNameThrow("itemId", itemId);
	_jparser.parseByNameThrow("shipper", shipper);
	_jparser.parseByNameThrow("trackingUrl", trackingUrl);
	_jparser.parseByNameThrow("itemQuantity", itemQuantity);
	_jparser.parseByNameThrow("cartId", cartId);
	_jparser.parseByNameThrow("fulfillmentId", fulfillmentId);
	_jparser.parseByNameThrow("altAddr", altAddr);
	_jparser.parseByNameThrow("flags", flags);
}

/* static */ void VipStore::cli::FppStoreOrder::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 orderId; _jparser.validateByNameThrow("orderId", orderId);
	AtfValidator::validateInt(_descr, "orderId", orderId, _checker, __FILE__, __LINE__);
	UINT32 price; _jparser.validateByNameThrow("price", price);
	AtfValidator::validateInt(_descr, "price", price, _checker, __FILE__, __LINE__);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	PString itemDescr; _jparser.validateByNameThrow("itemDescr", itemDescr);
	AtfValidator::validateInt(_descr, "itemDescr", itemDescr.length(), _checker, __FILE__, __LINE__);
	PString status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status.length(), _checker, __FILE__, __LINE__);
	PString trackingId; _jparser.validateByNameThrow("trackingId", trackingId);
	AtfValidator::validateInt(_descr, "trackingId", trackingId.length(), _checker, __FILE__, __LINE__);
	PString comment; _jparser.validateByNameThrow("comment", comment);
	AtfValidator::validateInt(_descr, "comment", comment.length(), _checker, __FILE__, __LINE__);
	CommSrvTime when; _jparser.validateByNameThrow("when", when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > specs; _jparser.validateByNameThrow("specs", specs);
	AtfValidator::validateInt(_descr, "specs", specs.size(), _checker, __FILE__, __LINE__);
	UINT32 itemId; _jparser.validateByNameThrow("itemId", itemId);
	AtfValidator::validateInt(_descr, "itemId", itemId, _checker, __FILE__, __LINE__);
	PString shipper; _jparser.validateByNameThrow("shipper", shipper);
	AtfValidator::validateInt(_descr, "shipper", shipper.length(), _checker, __FILE__, __LINE__);
	PString trackingUrl; _jparser.validateByNameThrow("trackingUrl", trackingUrl);
	AtfValidator::validateInt(_descr, "trackingUrl", trackingUrl.length(), _checker, __FILE__, __LINE__);
	UINT32 itemQuantity; _jparser.validateByNameThrow("itemQuantity", itemQuantity);
	AtfValidator::validateInt(_descr, "itemQuantity", itemQuantity, _checker, __FILE__, __LINE__);
	UINT32 cartId; _jparser.validateByNameThrow("cartId", cartId);
	AtfValidator::validateInt(_descr, "cartId", cartId, _checker, __FILE__, __LINE__);
	UINT32 fulfillmentId; _jparser.validateByNameThrow("fulfillmentId", fulfillmentId);
	AtfValidator::validateInt(_descr, "fulfillmentId", fulfillmentId, _checker, __FILE__, __LINE__);
	VipStoreAlternateClientAddress altAddr; _jparser.validateByNameThrow("altAddr", altAddr);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
}

/*static*/ void VipStore::cli::FppStoreOrder::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 orderId; _parser.parseUINT32(orderId);
	AtfValidator::validateInt(_descr, "orderId", orderId, _checker, __FILE__, __LINE__);
	UINT32 price; _parser.parseUINT32(price);
	AtfValidator::validateInt(_descr, "price", price, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "itemDescr"); size_t szItemDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "itemDescr", szItemDescr, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "status"); size_t szStatus = strlen(_dummy);
	AtfValidator::validateInt(_descr, "status", szStatus, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "trackingId"); size_t szTrackingId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "trackingId", szTrackingId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateInt(_descr, "comment", szComment, _checker, __FILE__, __LINE__);
	CommSrvTime when; _parser.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSpecs = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("specs"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "specs", szSpecs, _checker, __FILE__, __LINE__);
	UINT32 itemId; _parser.parseUINT32(itemId);
	AtfValidator::validateInt(_descr, "itemId", itemId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "shipper"); size_t szShipper = strlen(_dummy);
	AtfValidator::validateInt(_descr, "shipper", szShipper, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "trackingUrl"); size_t szTrackingUrl = strlen(_dummy);
	AtfValidator::validateInt(_descr, "trackingUrl", szTrackingUrl, _checker, __FILE__, __LINE__);
	UINT32 itemQuantity; _parser.parseUINT32(itemQuantity);
	AtfValidator::validateInt(_descr, "itemQuantity", itemQuantity, _checker, __FILE__, __LINE__);
	UINT32 cartId; _parser.parseUINT32(cartId);
	AtfValidator::validateInt(_descr, "cartId", cartId, _checker, __FILE__, __LINE__);
	UINT32 fulfillmentId; _parser.parseUINT32(fulfillmentId);
	AtfValidator::validateInt(_descr, "fulfillmentId", fulfillmentId, _checker, __FILE__, __LINE__);
	VipStoreAlternateClientAddress::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("altAddr"), _fieldsWithUnparsedContent);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    OrderHistoryDigestData
//=================================================================

VipStore::cli::OrderHistoryDigestData::OrderHistoryDigestData()
{
	clear();
}

void VipStore::cli::OrderHistoryDigestData::clear()
{
	itemId = 0;
	numPurchased = 0;
}

bool VipStore::cli::OrderHistoryDigestData::equals(const OrderHistoryDigestData& _o) const
{
	return itemId == _o.itemId &&
		numPurchased == _o.numPurchased;
}

const char *VipStore::cli::OrderHistoryDigestData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("itemId=");
	_buf.appendUint(itemId);
	_buf.append(',');
	_buf.append("numPurchased=");
	_buf.appendUint(numPurchased);
	_buf.append('}');
	return _buf.c_str();
}

const char *VipStore::cli::OrderHistoryDigestData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("itemId", itemId, _buf);
	Atf::XmlElement::encodeAsXmlElement("numPurchased", numPurchased, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool VipStore::cli::OrderHistoryDigestData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("itemId"))
		{
			itemId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numPurchased"))
		{
			numPurchased = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void VipStore::cli::OrderHistoryDigestData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(itemId);
	_msg.composeUINT32(numPurchased);
}

void VipStore::cli::OrderHistoryDigestData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(itemId);
	_parser.parseUINT32(numPurchased);
}

const char *VipStore::cli::OrderHistoryDigestData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("itemId", itemId);
	_jsonstr.compose("numPurchased", numPurchased);
	return _buf.c_str();
}

void VipStore::cli::OrderHistoryDigestData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("itemId", itemId);
	_jparser.parseByNameThrow("numPurchased", numPurchased);
}

/* static */ void VipStore::cli::OrderHistoryDigestData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 itemId; _jparser.validateByNameThrow("itemId", itemId);
	AtfValidator::validateInt(_descr, "itemId", itemId, _checker, __FILE__, __LINE__);
	UINT32 numPurchased; _jparser.validateByNameThrow("numPurchased", numPurchased);
	AtfValidator::validateInt(_descr, "numPurchased", numPurchased, _checker, __FILE__, __LINE__);
}

/*static*/ void VipStore::cli::OrderHistoryDigestData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 itemId; _parser.parseUINT32(itemId);
	AtfValidator::validateInt(_descr, "itemId", itemId, _checker, __FILE__, __LINE__);
	UINT32 numPurchased; _parser.parseUINT32(numPurchased);
	AtfValidator::validateInt(_descr, "numPurchased", numPurchased, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2
//=================================================================

VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2()
{
	clear();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2::clear()
{
	notUsedStr.clear();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2::equals(const Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr);
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_VIPSTORE_USER_ORDER_HISTORY2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2*)_other));
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_VIPSTORE_USER_ORDER_HISTORY2).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_VIPSTORE_USER_ORDER_HISTORY2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	return _buf.c_str();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_USER_ORDER_HISTORY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_USER_ORDER_HISTORY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY
//=================================================================

VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY()
{
	clear();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY::clear()
{
	errCode = 0;
	errStr.clear();
	orders.clear();
	preMidgrationOrders.clear();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY::equals(const Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		orders.equals(_o.orders) &&
		preMidgrationOrders.equals(_o.preMidgrationOrders);
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY*)_other));
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("orders=");
		orders.toTraceString(_buf);
		_buf.append(',');
		_buf.append("preMidgrationOrders=");
		preMidgrationOrders.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		orders.toXmlString("orders", _buf);
		preMidgrationOrders.toXmlString("preMidgrationOrders", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("orders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< FppStoreOrder, 4 > >::FromXmlString(_value, orders)) return false;
			}
			else if (_element.equals("preMidgrationOrders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< FppStoreOrder, 4 > >::FromXmlString(_value, preMidgrationOrders)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		orders.composeMsg(_msg, _ignoreJSON);
		preMidgrationOrders.composeMsg(_msg, _ignoreJSON);
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		orders.parseMsg(_parser);
		preMidgrationOrders.parseMsg(_parser);
	}
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("orders", orders);
		_jsonstr.compose("preMidgrationOrders", preMidgrationOrders);
	}
	return _buf.c_str();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("orders", orders);
		_jparser.parseByNameThrow("preMidgrationOrders", preMidgrationOrders);
	}
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< FppStoreOrder > orders; _jparser.validateByNameThrow("orders", orders);
		AtfValidator::validateInt(_descr, "orders", orders.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< FppStoreOrder > preMidgrationOrders; _jparser.validateByNameThrow("preMidgrationOrders", preMidgrationOrders);
		AtfValidator::validateInt(_descr, "preMidgrationOrders", preMidgrationOrders.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szOrders = Atf::LAtfVector< FppStoreOrder, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("orders"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "orders", szOrders, _checker, __FILE__, __LINE__);
		int szPreMidgrationOrders = Atf::LAtfVector< FppStoreOrder, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("preMidgrationOrders"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "preMidgrationOrders", szPreMidgrationOrders, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST
//=================================================================

VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST()
{
	clear();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST::clear()
{
	userid.clear();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST::equals(const Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST& _o) const
{
	return Atf::atfPStringEquals(userid, _o.userid);
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST*)_other));
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST).append(")");
	_buf.append(',');
	_buf.append("userid=");
	_buf.append(userid);
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userid", userid, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userid"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userid)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userid);
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userid);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userid", userid);
	return _buf.c_str();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userid", userid);
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userid; _jparser.validateByNameThrow("userid", userid);
	AtfValidator::validateIntMax(_descr, "userid", userid.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userid"); size_t szUserid = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userid", szUserid, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY
//=================================================================

VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY()
{
	clear();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY::clear()
{
	errCode = 0;
	errStr.clear();
	data.clear();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY::equals(const Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		data.equals(_o.data);
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY*)_other));
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("data=");
		data.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		data.toXmlString("data", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("data"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< OrderHistoryDigestData, 4 > >::FromXmlString(_value, data)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		data.composeMsg(_msg, _ignoreJSON);
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		data.parseMsg(_parser);
	}
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("data", data);
	}
	return _buf.c_str();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("data", data);
	}
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< OrderHistoryDigestData > data; _jparser.validateByNameThrow("data", data);
		AtfValidator::validateInt(_descr, "data", data.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szData = Atf::LAtfVector< OrderHistoryDigestData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("data"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "data", szData, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM
//=================================================================

VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM()
{
	clear();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM::clear()
{
	notUsedStr.clear();
	itemId = 0;
	couponCode.clear();
	itemQuantity = 0;
	alternateAddress.clear();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM::equals(const Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		itemId == _o.itemId &&
		Atf::atfPStringEquals(couponCode, _o.couponCode) &&
		itemQuantity == _o.itemQuantity &&
		alternateAddress.equals(_o.alternateAddress);
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_VIPSTORE_PREPURCHASE_ITEM != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM*)_other));
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_VIPSTORE_PREPURCHASE_ITEM).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("itemId=");
	_buf.appendUint(itemId);
	_buf.append(',');
	_buf.append("couponCode=");
	_buf.append(couponCode);
	_buf.append(',');
	_buf.append("itemQuantity=");
	_buf.appendUint(itemQuantity);
	_buf.append(',');
	_buf.append("alternateAddress=");
	alternateAddress.toTraceString(_buf);
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_VIPSTORE_PREPURCHASE_ITEM).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("itemId", itemId, _buf);
	Atf::XmlElement::encodeAsXmlElement("couponCode", couponCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("itemQuantity", itemQuantity, _buf);
	alternateAddress.toXmlString("alternateAddress", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("itemId"))
			{
				itemId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("couponCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, couponCode)) return false;
			}
			else if (_element.equals("itemQuantity"))
			{
				itemQuantity = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("alternateAddress"))
			{
				if(!Atf::AtfTempl< VipStoreAlternateClientAddress >::FromXmlString(_value, alternateAddress)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(itemId);
	_msg.composeString(couponCode);
	_msg.composeUINT32(itemQuantity);
	alternateAddress.composeMsg(_msg, _ignoreJSON);
}

void VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(itemId);
	_parser.parseStringP(couponCode);
	_parser.parseUINT32(itemQuantity);
	if(_parser.parseEnded()) return;
	alternateAddress.parseMsg(_parser);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("itemId", itemId);
	_jsonstr.compose("couponCode", couponCode);
	_jsonstr.compose("itemQuantity", itemQuantity);
	_jsonstr.compose("alternateAddress", alternateAddress);
	return _buf.c_str();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("itemId", itemId);
	_jparser.parseByNameThrow("couponCode", couponCode);
	_jparser.parseByNameThrow("itemQuantity", itemQuantity);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("alternateAddress", alternateAddress);
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_PREPURCHASE_ITEM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 itemId; _jparser.validateByNameThrow("itemId", itemId);
	AtfValidator::validateInt(_descr, "itemId", itemId, _checker, __FILE__, __LINE__);
	PString couponCode; _jparser.validateByNameThrow("couponCode", couponCode);
	AtfValidator::validateIntMax(_descr, "couponCode", couponCode.length(), 40, _checker, __FILE__, __LINE__);
	UINT32 itemQuantity; _jparser.validateByNameThrow("itemQuantity", itemQuantity);
	AtfValidator::validateIntRange(_descr, "itemQuantity", itemQuantity, 1, 2000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	VipStoreAlternateClientAddress alternateAddress; _jparser.validateByNameThrow("alternateAddress", alternateAddress);
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_PREPURCHASE_ITEM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 itemId; _parser.parseUINT32(itemId);
	AtfValidator::validateInt(_descr, "itemId", itemId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "couponCode"); size_t szCouponCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "couponCode", szCouponCode, 40, _checker, __FILE__, __LINE__);
	UINT32 itemQuantity; _parser.parseUINT32(itemQuantity);
	AtfValidator::validateIntRange(_descr, "itemQuantity", itemQuantity, 1, 2000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	VipStoreAlternateClientAddress::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("alternateAddress"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY
//=================================================================

VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY()
{
	clear();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY::clear()
{
	errCode = 0;
	errStr.clear();
	itemCost = 0;
	couponDiscount = 0;
	refund = 0;
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY::equals(const Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		itemCost == _o.itemCost &&
		couponDiscount == _o.couponDiscount &&
		refund == _o.refund;
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY*)_other));
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("itemCost=");
		_buf.appendUint(itemCost);
		_buf.append(',');
		_buf.append("couponDiscount=");
		_buf.appendUint(couponDiscount);
		_buf.append(',');
		_buf.append("refund=");
		_buf.appendUint(refund);
	}
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("itemCost", itemCost, _buf);
		Atf::XmlElement::encodeAsXmlElement("couponDiscount", couponDiscount, _buf);
		Atf::XmlElement::encodeAsXmlElement("refund", refund, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("itemCost"))
			{
				itemCost = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("couponDiscount"))
			{
				couponDiscount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("refund"))
			{
				refund = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeUINT32(itemCost);
		_msg.composeUINT32(couponDiscount);
		_msg.composeUINT32(refund);
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseUINT32(itemCost);
		_parser.parseUINT32(couponDiscount);
		_parser.parseUINT32(refund);
	}
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("itemCost", itemCost);
		_jsonstr.compose("couponDiscount", couponDiscount);
		_jsonstr.compose("refund", refund);
	}
	return _buf.c_str();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("itemCost", itemCost);
		_jparser.parseByNameThrow("couponDiscount", couponDiscount);
		_jparser.parseByNameThrow("refund", refund);
	}
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 itemCost; _jparser.validateByNameThrow("itemCost", itemCost);
		AtfValidator::validateInt(_descr, "itemCost", itemCost, _checker, __FILE__, __LINE__);
		UINT32 couponDiscount; _jparser.validateByNameThrow("couponDiscount", couponDiscount);
		AtfValidator::validateInt(_descr, "couponDiscount", couponDiscount, _checker, __FILE__, __LINE__);
		UINT32 refund; _jparser.validateByNameThrow("refund", refund);
		AtfValidator::validateInt(_descr, "refund", refund, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 itemCost; _parser.parseUINT32(itemCost);
		AtfValidator::validateInt(_descr, "itemCost", itemCost, _checker, __FILE__, __LINE__);
		UINT32 couponDiscount; _parser.parseUINT32(couponDiscount);
		AtfValidator::validateInt(_descr, "couponDiscount", couponDiscount, _checker, __FILE__, __LINE__);
		UINT32 refund; _parser.parseUINT32(refund);
		AtfValidator::validateInt(_descr, "refund", refund, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_VIPSTORE_PURCHASE_ITEM
//=================================================================

VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM::Protocol_MSG_VIPSTORE_PURCHASE_ITEM()
{
	clear();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM::clear()
{
	parsedUserId.clear();
	itemId = 0;
	specs.clear();
	userPhone.clear();
	couponCode.clear();
	itemQuantity = 0;
	alternateAddress.clear();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM::equals(const Protocol_MSG_VIPSTORE_PURCHASE_ITEM& _o) const
{
	return Atf::atfPStringEquals(parsedUserId, _o.parsedUserId) &&
		itemId == _o.itemId &&
		specs.equals(_o.specs) &&
		Atf::atfPStringEquals(userPhone, _o.userPhone) &&
		Atf::atfPStringEquals(couponCode, _o.couponCode) &&
		itemQuantity == _o.itemQuantity &&
		alternateAddress.equals(_o.alternateAddress);
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_VIPSTORE_PURCHASE_ITEM != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_VIPSTORE_PURCHASE_ITEM*)_other));
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_VIPSTORE_PURCHASE_ITEM).append(")");
	_buf.append(',');
	_buf.append("parsedUserId=");
	_buf.append(parsedUserId);
	_buf.append(',');
	_buf.append("itemId=");
	_buf.appendUint(itemId);
	_buf.append(',');
	_buf.append("specs=");
	specs.toTraceString(_buf);
	_buf.append(',');
	_buf.append("userPhone=");
	_buf.append(userPhone);
	_buf.append(',');
	_buf.append("couponCode=");
	_buf.append(couponCode);
	_buf.append(',');
	_buf.append("itemQuantity=");
	_buf.appendUint(itemQuantity);
	_buf.append(',');
	_buf.append("alternateAddress=");
	alternateAddress.toTraceString(_buf);
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_VIPSTORE_PURCHASE_ITEM).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("parsedUserId", parsedUserId, _buf);
	Atf::XmlElement::encodeAsXmlElement("itemId", itemId, _buf);
	specs.toXmlString("specs", _buf);
	Atf::XmlElement::encodeAsXmlElement("userPhone", userPhone, _buf);
	Atf::XmlElement::encodeAsXmlElement("couponCode", couponCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("itemQuantity", itemQuantity, _buf);
	alternateAddress.toXmlString("alternateAddress", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("parsedUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, parsedUserId)) return false;
			}
			else if (_element.equals("itemId"))
			{
				itemId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("specs"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, specs)) return false;
			}
			else if (_element.equals("userPhone"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userPhone)) return false;
			}
			else if (_element.equals("couponCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, couponCode)) return false;
			}
			else if (_element.equals("itemQuantity"))
			{
				itemQuantity = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("alternateAddress"))
			{
				if(!Atf::AtfTempl< VipStoreAlternateClientAddress >::FromXmlString(_value, alternateAddress)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(parsedUserId);
	_msg.composeUINT32(itemId);
	specs.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(userPhone);
	_msg.composeString(couponCode);
	_msg.composeUINT32(itemQuantity);
	alternateAddress.composeMsg(_msg, _ignoreJSON);
}

void VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(parsedUserId);
	_parser.parseUINT32(itemId);
	specs.parseMsg(_parser);
	_parser.parseStringP(userPhone);
	_parser.parseStringP(couponCode);
	_parser.parseUINT32(itemQuantity);
	if(_parser.parseEnded()) return;
	alternateAddress.parseMsg(_parser);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("parsedUserId", parsedUserId);
	_jsonstr.compose("itemId", itemId);
	_jsonstr.compose("specs", specs);
	_jsonstr.compose("userPhone", userPhone);
	_jsonstr.compose("couponCode", couponCode);
	_jsonstr.compose("itemQuantity", itemQuantity);
	_jsonstr.compose("alternateAddress", alternateAddress);
	return _buf.c_str();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("parsedUserId", parsedUserId);
	_jparser.parseByNameThrow("itemId", itemId);
	_jparser.parseByNameThrow("specs", specs);
	_jparser.parseByNameThrow("userPhone", userPhone);
	_jparser.parseByNameThrow("couponCode", couponCode);
	_jparser.parseByNameThrow("itemQuantity", itemQuantity);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("alternateAddress", alternateAddress);
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_PURCHASE_ITEM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString parsedUserId; _jparser.validateByNameThrow("parsedUserId", parsedUserId);
	AtfValidator::validateIntMax(_descr, "parsedUserId", parsedUserId.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 itemId; _jparser.validateByNameThrow("itemId", itemId);
	AtfValidator::validateInt(_descr, "itemId", itemId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > specs; _jparser.validateByNameThrow("specs", specs);
	AtfValidator::validateIntMax(_descr, "specs", specs.size(), 1024, _checker, __FILE__, __LINE__);
	PString userPhone; _jparser.validateByNameThrow("userPhone", userPhone);
	AtfValidator::validateIntMax(_descr, "userPhone", userPhone.length(), 100, _checker, __FILE__, __LINE__);
	PString couponCode; _jparser.validateByNameThrow("couponCode", couponCode);
	AtfValidator::validateIntMax(_descr, "couponCode", couponCode.length(), 40, _checker, __FILE__, __LINE__);
	UINT32 itemQuantity; _jparser.validateByNameThrow("itemQuantity", itemQuantity);
	AtfValidator::validateIntRange(_descr, "itemQuantity", itemQuantity, 1, 2000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	VipStoreAlternateClientAddress alternateAddress; _jparser.validateByNameThrow("alternateAddress", alternateAddress);
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_PURCHASE_ITEM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "parsedUserId"); size_t szParsedUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "parsedUserId", szParsedUserId, 20, _checker, __FILE__, __LINE__);
	UINT32 itemId; _parser.parseUINT32(itemId);
	AtfValidator::validateInt(_descr, "itemId", itemId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSpecs = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("specs"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "specs", szSpecs, 1024, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userPhone"); size_t szUserPhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userPhone", szUserPhone, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "couponCode"); size_t szCouponCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "couponCode", szCouponCode, 40, _checker, __FILE__, __LINE__);
	UINT32 itemQuantity; _parser.parseUINT32(itemQuantity);
	AtfValidator::validateIntRange(_descr, "itemQuantity", itemQuantity, 1, 2000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	VipStoreAlternateClientAddress::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("alternateAddress"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY
//=================================================================

VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY()
{
	clear();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY::clear()
{
	errCode = 0;
	errStr.clear();
	fppBalance = 0;
	totalCost = 0;
	discount = 0;
	couponRemainder = 0;
	giftCardSpecialType = 0;
	isInstantBonus = false;
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY::equals(const Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		fppBalance == _o.fppBalance &&
		totalCost == _o.totalCost &&
		discount == _o.discount &&
		couponRemainder == _o.couponRemainder &&
		giftCardSpecialType == _o.giftCardSpecialType &&
		isInstantBonus == _o.isInstantBonus;
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_VIPSTORE_PURCHASE_ITEM_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY*)_other));
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_VIPSTORE_PURCHASE_ITEM_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("fppBalance=");
		_buf.appendUint64(fppBalance);
		_buf.append(',');
		_buf.append("totalCost=");
		_buf.appendUint(totalCost);
		_buf.append(',');
		_buf.append("discount=");
		_buf.appendUint(discount);
		_buf.append(',');
		_buf.append("couponRemainder=");
		_buf.appendUint(couponRemainder);
		_buf.append(',');
		_buf.append("giftCardSpecialType=");
		_buf.appendUint(giftCardSpecialType);
		_buf.append(',');
		_buf.append("isInstantBonus=");
		_buf.appendUint(isInstantBonus);
	}
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_VIPSTORE_PURCHASE_ITEM_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("fppBalance", fppBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("totalCost", totalCost, _buf);
		Atf::XmlElement::encodeAsXmlElement("discount", discount, _buf);
		Atf::XmlElement::encodeAsXmlElement("couponRemainder", couponRemainder, _buf);
		Atf::XmlElement::encodeAsXmlElement("giftCardSpecialType", giftCardSpecialType, _buf);
		Atf::XmlElement::encodeAsXmlElement("isInstantBonus", isInstantBonus, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("fppBalance"))
			{
				fppBalance = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("totalCost"))
			{
				totalCost = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("discount"))
			{
				discount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("couponRemainder"))
			{
				couponRemainder = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("giftCardSpecialType"))
			{
				giftCardSpecialType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isInstantBonus"))
			{
				isInstantBonus = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeUINT64(fppBalance);
		_msg.composeUINT32(totalCost);
		_msg.composeUINT32(discount);
		_msg.composeUINT32(couponRemainder);
		_msg.composeUINT32(giftCardSpecialType);
		_msg.composeBOOL(isInstantBonus);
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseUINT64(fppBalance);
		_parser.parseUINT32(totalCost);
		_parser.parseUINT32(discount);
		_parser.parseUINT32(couponRemainder);
		_parser.parseUINT32(giftCardSpecialType);
		_parser.parseBOOL(isInstantBonus);
	}
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("fppBalance", fppBalance);
		_jsonstr.compose("totalCost", totalCost);
		_jsonstr.compose("discount", discount);
		_jsonstr.compose("couponRemainder", couponRemainder);
		_jsonstr.compose("giftCardSpecialType", giftCardSpecialType);
		_jsonstr.compose("isInstantBonus", isInstantBonus);
	}
	return _buf.c_str();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("fppBalance", fppBalance);
		_jparser.parseByNameThrow("totalCost", totalCost);
		_jparser.parseByNameThrow("discount", discount);
		_jparser.parseByNameThrow("couponRemainder", couponRemainder);
		_jparser.parseByNameThrow("giftCardSpecialType", giftCardSpecialType);
		_jparser.parseByNameThrow("isInstantBonus", isInstantBonus);
	}
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_PURCHASE_ITEM_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 fppBalance; _jparser.validateByNameThrow("fppBalance", fppBalance);
		AtfValidator::validateUint(_descr, "fppBalance", fppBalance, _checker, __FILE__, __LINE__);
		UINT32 totalCost; _jparser.validateByNameThrow("totalCost", totalCost);
		AtfValidator::validateInt(_descr, "totalCost", totalCost, _checker, __FILE__, __LINE__);
		UINT32 discount; _jparser.validateByNameThrow("discount", discount);
		AtfValidator::validateInt(_descr, "discount", discount, _checker, __FILE__, __LINE__);
		UINT32 couponRemainder; _jparser.validateByNameThrow("couponRemainder", couponRemainder);
		AtfValidator::validateInt(_descr, "couponRemainder", couponRemainder, _checker, __FILE__, __LINE__);
		UINT32 giftCardSpecialType; _jparser.validateByNameThrow("giftCardSpecialType", giftCardSpecialType);
		AtfValidator::validateInt(_descr, "giftCardSpecialType", giftCardSpecialType, _checker, __FILE__, __LINE__);
		bool isInstantBonus; _jparser.validateByNameThrow("isInstantBonus", isInstantBonus);
		AtfValidator::validateInt(_descr, "isInstantBonus", isInstantBonus, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_PURCHASE_ITEM_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 fppBalance; _parser.parseUINT64(fppBalance);
		AtfValidator::validateUint(_descr, "fppBalance", fppBalance, _checker, __FILE__, __LINE__);
		UINT32 totalCost; _parser.parseUINT32(totalCost);
		AtfValidator::validateInt(_descr, "totalCost", totalCost, _checker, __FILE__, __LINE__);
		UINT32 discount; _parser.parseUINT32(discount);
		AtfValidator::validateInt(_descr, "discount", discount, _checker, __FILE__, __LINE__);
		UINT32 couponRemainder; _parser.parseUINT32(couponRemainder);
		AtfValidator::validateInt(_descr, "couponRemainder", couponRemainder, _checker, __FILE__, __LINE__);
		UINT32 giftCardSpecialType; _parser.parseUINT32(giftCardSpecialType);
		AtfValidator::validateInt(_descr, "giftCardSpecialType", giftCardSpecialType, _checker, __FILE__, __LINE__);
		bool isInstantBonus; _parser.parseBOOL(isInstantBonus);
		AtfValidator::validateInt(_descr, "isInstantBonus", isInstantBonus, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    InvItemStockCli2
//=================================================================

VipStore::cli::InvItemStockCli2::InvItemStockCli2()
{
	clear();
}

void VipStore::cli::InvItemStockCli2::clear()
{
	available = false;
	stockCount = 0;
	unlimitedStock = false;
	specs.clear();
}

bool VipStore::cli::InvItemStockCli2::equals(const InvItemStockCli2& _o) const
{
	return available == _o.available &&
		stockCount == _o.stockCount &&
		unlimitedStock == _o.unlimitedStock &&
		specs.equals(_o.specs);
}

const char *VipStore::cli::InvItemStockCli2::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("available=");
	_buf.appendUint(available);
	_buf.append(',');
	_buf.append("stockCount=");
	_buf.appendInt(stockCount);
	_buf.append(',');
	_buf.append("unlimitedStock=");
	_buf.appendUint(unlimitedStock);
	_buf.append(',');
	_buf.append("specs=");
	specs.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *VipStore::cli::InvItemStockCli2::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("available", available, _buf);
	Atf::XmlElement::encodeAsXmlElement("stockCount", stockCount, _buf);
	Atf::XmlElement::encodeAsXmlElement("unlimitedStock", unlimitedStock, _buf);
	specs.toXmlString("specs", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool VipStore::cli::InvItemStockCli2::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("available"))
		{
			available = (*_value.ptr() == '1');
		}
		else if (_element.equals("stockCount"))
		{
			stockCount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("unlimitedStock"))
		{
			unlimitedStock = (*_value.ptr() == '1');
		}
		else if (_element.equals("specs"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, specs)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void VipStore::cli::InvItemStockCli2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(InvItemStockCli2())) // not empty
	{
		_body.composeBOOL(available);
		_body.composeINT32(stockCount);
		_body.composeBOOL(unlimitedStock);
		specs.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void VipStore::cli::InvItemStockCli2::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(available);
	_parser0.parseINT32(stockCount);
	_parser0.parseBOOL(unlimitedStock);
	specs.parseMsg(_parser0);
}

const char *VipStore::cli::InvItemStockCli2::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("available", available);
	_jsonstr.compose("stockCount", stockCount);
	_jsonstr.compose("unlimitedStock", unlimitedStock);
	_jsonstr.compose("specs", specs);
	return _buf.c_str();
}

void VipStore::cli::InvItemStockCli2::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("available", available);
	_jparser.parseByNameThrow("stockCount", stockCount);
	_jparser.parseByNameThrow("unlimitedStock", unlimitedStock);
	_jparser.parseByNameThrow("specs", specs);
}

/* static */ void VipStore::cli::InvItemStockCli2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool available; _jparser.validateByNameThrow("available", available);
	AtfValidator::validateInt(_descr, "available", available, _checker, __FILE__, __LINE__);
	INT32 stockCount; _jparser.validateByNameThrow("stockCount", stockCount);
	AtfValidator::validateInt(_descr, "stockCount", stockCount, _checker, __FILE__, __LINE__);
	bool unlimitedStock; _jparser.validateByNameThrow("unlimitedStock", unlimitedStock);
	AtfValidator::validateInt(_descr, "unlimitedStock", unlimitedStock, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > specs; _jparser.validateByNameThrow("specs", specs);
	AtfValidator::validateInt(_descr, "specs", specs.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void VipStore::cli::InvItemStockCli2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool available; _parser0.parseBOOL(available);
	AtfValidator::validateInt(_descr, "available", available, _checker, __FILE__, __LINE__);
	INT32 stockCount; _parser0.parseINT32(stockCount);
	AtfValidator::validateInt(_descr, "stockCount", stockCount, _checker, __FILE__, __LINE__);
	bool unlimitedStock; _parser0.parseBOOL(unlimitedStock);
	AtfValidator::validateInt(_descr, "unlimitedStock", unlimitedStock, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSpecs = Atf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("specs"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "specs", szSpecs, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2
//=================================================================

VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2()
{
	clear();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2::clear()
{
	itemId = 0;
	specialType = 0;
	unusedCouponCode.clear();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2::equals(const Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2& _o) const
{
	return itemId == _o.itemId &&
		specialType == _o.specialType &&
		Atf::atfPStringEquals(unusedCouponCode, _o.unusedCouponCode);
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_VIPSTORE_INV_GET_ITEM_STOCK2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2*)_other));
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_VIPSTORE_INV_GET_ITEM_STOCK2).append(")");
	_buf.append(',');
	_buf.append("itemId=");
	_buf.appendUint(itemId);
	_buf.append(',');
	_buf.append("specialType=");
	_buf.appendUint(specialType);
	_buf.append(',');
	_buf.append("unusedCouponCode=");
	_buf.append(unusedCouponCode);
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_VIPSTORE_INV_GET_ITEM_STOCK2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("itemId", itemId, _buf);
	Atf::XmlElement::encodeAsXmlElement("specialType", specialType, _buf);
	Atf::XmlElement::encodeAsXmlElement("unusedCouponCode", unusedCouponCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("itemId"))
			{
				itemId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("specialType"))
			{
				specialType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("unusedCouponCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, unusedCouponCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(itemId);
	_msg.composeUINT32(specialType);
	_msg.composeString(unusedCouponCode);
}

void VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(itemId);
	_parser.parseUINT32(specialType);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(unusedCouponCode);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("itemId", itemId);
	_jsonstr.compose("specialType", specialType);
	_jsonstr.compose("unusedCouponCode", unusedCouponCode);
	return _buf.c_str();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("itemId", itemId);
	_jparser.parseByNameThrow("specialType", specialType);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("unusedCouponCode", unusedCouponCode);
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_INV_GET_ITEM_STOCK2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 itemId; _jparser.validateByNameThrow("itemId", itemId);
	AtfValidator::validateInt(_descr, "itemId", itemId, _checker, __FILE__, __LINE__);
	UINT32 specialType; _jparser.validateByNameThrow("specialType", specialType);
	AtfValidator::validateIntRange(_descr, "specialType", specialType, eFppStoreRegular, eFppStoreRegular, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString unusedCouponCode; _jparser.validateByNameThrow("unusedCouponCode", unusedCouponCode);
	AtfValidator::validateIntMax(_descr, "unusedCouponCode", unusedCouponCode.length(), 21, _checker, __FILE__, __LINE__);
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_INV_GET_ITEM_STOCK2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 itemId; _parser.parseUINT32(itemId);
	AtfValidator::validateInt(_descr, "itemId", itemId, _checker, __FILE__, __LINE__);
	UINT32 specialType; _parser.parseUINT32(specialType);
	AtfValidator::validateIntRange(_descr, "specialType", specialType, eFppStoreRegular, eFppStoreRegular, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "unusedCouponCode"); size_t szUnusedCouponCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedCouponCode", szUnusedCouponCode, 21, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY
//=================================================================

VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY()
{
	clear();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY::clear()
{
	errCode = 0;
	errStr.clear();
	stocks.clear();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY::equals(const Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		stocks.equals(_o.stocks);
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY*)_other));
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("stocks=");
		stocks.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		stocks.toXmlString("stocks", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("stocks"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< InvItemStockCli2, 4 > >::FromXmlString(_value, stocks)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		stocks.composeMsg(_msg, _ignoreJSON);
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		stocks.parseMsg(_parser);
	}
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("stocks", stocks);
	}
	return _buf.c_str();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("stocks", stocks);
	}
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< InvItemStockCli2 > stocks; _jparser.validateByNameThrow("stocks", stocks);
		AtfValidator::validateInt(_descr, "stocks", stocks.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szStocks = Atf::LAtfVector< InvItemStockCli2, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("stocks"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "stocks", szStocks, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER
//=================================================================

VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER()
{
	clear();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER::clear()
{
	parsedUserId.clear();
	orderId = 0;
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER::equals(const Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER& _o) const
{
	return Atf::atfPStringEquals(parsedUserId, _o.parsedUserId) &&
		orderId == _o.orderId;
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_VIPSTORE_USER_CANCEL_ORDER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER*)_other));
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_VIPSTORE_USER_CANCEL_ORDER).append(")");
	_buf.append(',');
	_buf.append("parsedUserId=");
	_buf.append(parsedUserId);
	_buf.append(',');
	_buf.append("orderId=");
	_buf.appendUint(orderId);
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_VIPSTORE_USER_CANCEL_ORDER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("parsedUserId", parsedUserId, _buf);
	Atf::XmlElement::encodeAsXmlElement("orderId", orderId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("parsedUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, parsedUserId)) return false;
			}
			else if (_element.equals("orderId"))
			{
				orderId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(parsedUserId);
	_msg.composeUINT32(orderId);
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(parsedUserId);
	_parser.parseUINT32(orderId);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("parsedUserId", parsedUserId);
	_jsonstr.compose("orderId", orderId);
	return _buf.c_str();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("parsedUserId", parsedUserId);
	_jparser.parseByNameThrow("orderId", orderId);
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_USER_CANCEL_ORDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString parsedUserId; _jparser.validateByNameThrow("parsedUserId", parsedUserId);
	AtfValidator::validateIntMax(_descr, "parsedUserId", parsedUserId.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 orderId; _jparser.validateByNameThrow("orderId", orderId);
	AtfValidator::validateInt(_descr, "orderId", orderId, _checker, __FILE__, __LINE__);
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_USER_CANCEL_ORDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "parsedUserId"); size_t szParsedUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "parsedUserId", szParsedUserId, 20, _checker, __FILE__, __LINE__);
	UINT32 orderId; _parser.parseUINT32(orderId);
	AtfValidator::validateInt(_descr, "orderId", orderId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY
//=================================================================

VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY()
{
	clear();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY::clear()
{
	errCode = 0;
	errStr.clear();
	userIntId = 0;
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY::equals(const Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		userIntId == _o.userIntId;
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY*)_other));
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userIntId=");
		_buf.appendUint(userIntId);
	}
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeUINT32(userIntId);
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseUINT32(userIntId);
	}
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("userIntId", userIntId);
	}
	return _buf.c_str();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("userIntId", userIntId);
	}
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 userIntId; _parser.parseUINT32(userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS
//=================================================================

VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS()
{
	clear();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS::clear()
{
	parsedUserId.clear();
	orderIds.clear();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS::equals(const Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS& _o) const
{
	return Atf::atfPStringEquals(parsedUserId, _o.parsedUserId) &&
		orderIds.equals(_o.orderIds);
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_VIPSTORE_USER_CANCEL_ORDERS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS*)_other));
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_VIPSTORE_USER_CANCEL_ORDERS).append(")");
	_buf.append(',');
	_buf.append("parsedUserId=");
	_buf.append(parsedUserId);
	_buf.append(',');
	_buf.append("orderIds=");
	orderIds.toTraceString(_buf);
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_VIPSTORE_USER_CANCEL_ORDERS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("parsedUserId", parsedUserId, _buf);
	orderIds.toXmlString("orderIds", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("parsedUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, parsedUserId)) return false;
			}
			else if (_element.equals("orderIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, orderIds)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(parsedUserId);
	orderIds.composeMsg(_msg, _ignoreJSON);
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(parsedUserId);
	orderIds.parseMsg(_parser);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("parsedUserId", parsedUserId);
	_jsonstr.compose("orderIds", orderIds);
	return _buf.c_str();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("parsedUserId", parsedUserId);
	_jparser.parseByNameThrow("orderIds", orderIds);
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_USER_CANCEL_ORDERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString parsedUserId; _jparser.validateByNameThrow("parsedUserId", parsedUserId);
	AtfValidator::validateIntMax(_descr, "parsedUserId", parsedUserId.length(), 20, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > orderIds; _jparser.validateByNameThrow("orderIds", orderIds);
	AtfValidator::validateIntMax(_descr, "orderIds", orderIds.size(), 1024, _checker, __FILE__, __LINE__);
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_USER_CANCEL_ORDERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "parsedUserId"); size_t szParsedUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "parsedUserId", szParsedUserId, 20, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szOrderIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("orderIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "orderIds", szOrderIds, 1024, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY
//=================================================================

VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY()
{
	clear();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY::clear()
{
	errCode = 0;
	errStr.clear();
	userIntId = 0;
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY::equals(const Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		userIntId == _o.userIntId;
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY*)_other));
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userIntId=");
		_buf.appendUint(userIntId);
	}
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeUINT32(userIntId);
	}
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseUINT32(userIntId);
	}
}

const char *VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("userIntId", userIntId);
	}
	return _buf.c_str();
}

void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("userIntId", userIntId);
	}
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void VipStore::cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 userIntId; _parser.parseUINT32(userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES
//=================================================================

VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES()
{
	clear();
}

void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES::clear()
{
}

bool VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES::equals(const Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES& _o) const
{
	return true;
}

bool VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES::equals(Atf::MessageProtocol* _other) const
{
	if (VIPSTORE_GET_USER_ALT_ADDRESSES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES*)_other));
}

const char *VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(VIPSTORE_GET_USER_ALT_ADDRESSES).append(")");
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(VIPSTORE_GET_USER_ALT_ADDRESSES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES::parseMsg(CommMsgParser& _parser)
{
}

const char *VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "VIPSTORE_GET_USER_ALT_ADDRESSES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "VIPSTORE_GET_USER_ALT_ADDRESSES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY
//=================================================================

VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY()
{
	clear();
}

void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY::clear()
{
	errCode = 0;
	errStr.clear();
	maxSuggestedAltAddrLimit = 0;
	altAddresses.clear();
}

bool VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY::equals(const Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		maxSuggestedAltAddrLimit == _o.maxSuggestedAltAddrLimit &&
		altAddresses.equals(_o.altAddresses);
}

bool VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY*)_other));
}

const char *VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("maxSuggestedAltAddrLimit=");
		_buf.appendUint(maxSuggestedAltAddrLimit);
		_buf.append(',');
		_buf.append("altAddresses=");
		altAddresses.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("maxSuggestedAltAddrLimit", maxSuggestedAltAddrLimit, _buf);
		altAddresses.toXmlString("altAddresses", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("maxSuggestedAltAddrLimit"))
			{
				maxSuggestedAltAddrLimit = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("altAddresses"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< VipStoreAlternateClientAddress, 4 > >::FromXmlString(_value, altAddresses)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeUINT32(maxSuggestedAltAddrLimit);
		altAddresses.composeMsg(_msg, _ignoreJSON);
	}
}

void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseUINT32(maxSuggestedAltAddrLimit);
		altAddresses.parseMsg(_parser);
	}
}

const char *VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("maxSuggestedAltAddrLimit", maxSuggestedAltAddrLimit);
		_jsonstr.compose("altAddresses", altAddresses);
	}
	return _buf.c_str();
}

void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("maxSuggestedAltAddrLimit", maxSuggestedAltAddrLimit);
		_jparser.parseByNameThrow("altAddresses", altAddresses);
	}
}

/*static*/ void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 maxSuggestedAltAddrLimit; _jparser.validateByNameThrow("maxSuggestedAltAddrLimit", maxSuggestedAltAddrLimit);
		AtfValidator::validateInt(_descr, "maxSuggestedAltAddrLimit", maxSuggestedAltAddrLimit, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< VipStoreAlternateClientAddress > altAddresses; _jparser.validateByNameThrow("altAddresses", altAddresses);
		AtfValidator::validateInt(_descr, "altAddresses", altAddresses.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 maxSuggestedAltAddrLimit; _parser.parseUINT32(maxSuggestedAltAddrLimit);
		AtfValidator::validateInt(_descr, "maxSuggestedAltAddrLimit", maxSuggestedAltAddrLimit, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szAltAddresses = Atf::LAtfVector< VipStoreAlternateClientAddress, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("altAddresses"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "altAddresses", szAltAddresses, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2
//=================================================================

VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2()
{
	clear();
}

void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2::clear()
{
	unusedStr.clear();
}

bool VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2::equals(const Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2& _o) const
{
	return Atf::atfPStringEquals(unusedStr, _o.unusedStr);
}

bool VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2::equals(Atf::MessageProtocol* _other) const
{
	if (VIPSTORE_GET_USER_ALT_ADDRESSES2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2*)_other));
}

const char *VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(VIPSTORE_GET_USER_ALT_ADDRESSES2).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(VIPSTORE_GET_USER_ALT_ADDRESSES2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("unusedStr", unusedStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("unusedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, unusedStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(unusedStr);
}

void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(unusedStr);
}

const char *VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("unusedStr", unusedStr);
	return _buf.c_str();
}

void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("unusedStr", unusedStr);
}

/*static*/ void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "VIPSTORE_GET_USER_ALT_ADDRESSES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString unusedStr; _jparser.validateByNameThrow("unusedStr", unusedStr);
	AtfValidator::validateIntMax(_descr, "unusedStr", unusedStr.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "VIPSTORE_GET_USER_ALT_ADDRESSES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY
//=================================================================

VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY()
{
	clear();
}

void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY::clear()
{
	errCode = 0;
	errStr.clear();
	maxSuggestedAltAddrLimit = 0;
	altAddresses.clear();
}

bool VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY::equals(const Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		maxSuggestedAltAddrLimit == _o.maxSuggestedAltAddrLimit &&
		altAddresses.equals(_o.altAddresses);
}

bool VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY*)_other));
}

const char *VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("maxSuggestedAltAddrLimit=");
		_buf.appendUint(maxSuggestedAltAddrLimit);
		_buf.append(',');
		_buf.append("altAddresses=");
		altAddresses.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("maxSuggestedAltAddrLimit", maxSuggestedAltAddrLimit, _buf);
		altAddresses.toXmlString("altAddresses", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("maxSuggestedAltAddrLimit"))
			{
				maxSuggestedAltAddrLimit = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("altAddresses"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< VipStoreAlternateClientAddress, 4 > >::FromXmlString(_value, altAddresses)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeUINT32(maxSuggestedAltAddrLimit);
		altAddresses.composeMsg(_msg, _ignoreJSON);
	}
}

void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseUINT32(maxSuggestedAltAddrLimit);
		altAddresses.parseMsg(_parser);
	}
}

const char *VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("maxSuggestedAltAddrLimit", maxSuggestedAltAddrLimit);
		_jsonstr.compose("altAddresses", altAddresses);
	}
	return _buf.c_str();
}

void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("maxSuggestedAltAddrLimit", maxSuggestedAltAddrLimit);
		_jparser.parseByNameThrow("altAddresses", altAddresses);
	}
}

/*static*/ void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 maxSuggestedAltAddrLimit; _jparser.validateByNameThrow("maxSuggestedAltAddrLimit", maxSuggestedAltAddrLimit);
		AtfValidator::validateInt(_descr, "maxSuggestedAltAddrLimit", maxSuggestedAltAddrLimit, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< VipStoreAlternateClientAddress > altAddresses; _jparser.validateByNameThrow("altAddresses", altAddresses);
		AtfValidator::validateInt(_descr, "altAddresses", altAddresses.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void VipStore::cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 maxSuggestedAltAddrLimit; _parser.parseUINT32(maxSuggestedAltAddrLimit);
		AtfValidator::validateInt(_descr, "maxSuggestedAltAddrLimit", maxSuggestedAltAddrLimit, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szAltAddresses = Atf::LAtfVector< VipStoreAlternateClientAddress, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("altAddresses"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "altAddresses", szAltAddresses, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS
//=================================================================

VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS()
{
	clear();
}

void VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS::clear()
{
	addrId = 0;
}

bool VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS::equals(const Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS& _o) const
{
	return addrId == _o.addrId;
}

bool VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS::equals(Atf::MessageProtocol* _other) const
{
	if (VIPSTORE_OBSOLETE_USER_ALT_ADDRESS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS*)_other));
}

const char *VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(VIPSTORE_OBSOLETE_USER_ALT_ADDRESS).append(")");
	_buf.append(',');
	_buf.append("addrId=");
	_buf.appendUint(addrId);
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(VIPSTORE_OBSOLETE_USER_ALT_ADDRESS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("addrId", addrId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("addrId"))
			{
				addrId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(addrId);
}

void VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(addrId);
}

const char *VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("addrId", addrId);
	return _buf.c_str();
}

void VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("addrId", addrId);
}

/*static*/ void VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "VIPSTORE_OBSOLETE_USER_ALT_ADDRESS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 addrId; _jparser.validateByNameThrow("addrId", addrId);
	AtfValidator::validateInt(_descr, "addrId", addrId, _checker, __FILE__, __LINE__);
}

/*static*/ void VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "VIPSTORE_OBSOLETE_USER_ALT_ADDRESS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 addrId; _parser.parseUINT32(addrId);
	AtfValidator::validateInt(_descr, "addrId", addrId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY
//=================================================================

VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY()
{
	clear();
}

void VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY::clear()
{
	errCode = 0;
	errStr.clear();
}

bool VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY::equals(const Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr);
}

bool VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY*)_other));
}

const char *VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

const char *VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

const char *VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	return _buf.c_str();
}

void VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
}

/*static*/ void VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void VipStore::cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* VipStore::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_VIPSTORE_INV_GET_ITEM_STOCK2: _obj = new cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2(); break;
			case MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY: _obj = new cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY(); break;
			case MSG_VIPSTORE_PREPURCHASE_ITEM: _obj = new cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM(); break;
			case MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY: _obj = new cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY(); break;
			case MSG_VIPSTORE_PURCHASE_ITEM: _obj = new cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM(); break;
			case MSG_VIPSTORE_PURCHASE_ITEM_REPLY: _obj = new cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY(); break;
			case MSG_VIPSTORE_USER_CANCEL_ORDER: _obj = new cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER(); break;
			case MSG_VIPSTORE_USER_CANCEL_ORDERS: _obj = new cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS(); break;
			case MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY: _obj = new cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY(); break;
			case MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY: _obj = new cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY(); break;
			case MSG_VIPSTORE_USER_ORDER_HISTORY2: _obj = new cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2(); break;
			case MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY: _obj = new cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY(); break;
			case MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST: _obj = new cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST(); break;
			case MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY: _obj = new cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY(); break;
			case VIPSTORE_GET_USER_ALT_ADDRESSES: _obj = new cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES(); break;
			case VIPSTORE_GET_USER_ALT_ADDRESSES2: _obj = new cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2(); break;
			case VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY: _obj = new cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY(); break;
			case VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY: _obj = new cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY(); break;
			case VIPSTORE_OBSOLETE_USER_ALT_ADDRESS: _obj = new cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS(); break;
			case VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY: _obj = new cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool VipStore::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_VIPSTORE_INV_GET_ITEM_STOCK2: cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY: cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_PREPURCHASE_ITEM: cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY: cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_PURCHASE_ITEM: cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_PURCHASE_ITEM_REPLY: cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_USER_CANCEL_ORDER: cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_USER_CANCEL_ORDERS: cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY: cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY: cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_USER_ORDER_HISTORY2: cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY: cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST: cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY: cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case VIPSTORE_GET_USER_ALT_ADDRESSES: cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case VIPSTORE_GET_USER_ALT_ADDRESSES2: cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY: cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY: cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case VIPSTORE_OBSOLETE_USER_ALT_ADDRESS: cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY: cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool VipStore::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_VIPSTORE_INV_GET_ITEM_STOCK2: cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY: cli::Protocol_MSG_VIPSTORE_INV_GET_ITEM_STOCK2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_PREPURCHASE_ITEM: cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY: cli::Protocol_MSG_VIPSTORE_PREPURCHASE_ITEM_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_PURCHASE_ITEM: cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_PURCHASE_ITEM_REPLY: cli::Protocol_MSG_VIPSTORE_PURCHASE_ITEM_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_USER_CANCEL_ORDER: cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_USER_CANCEL_ORDERS: cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY: cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDERS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY: cli::Protocol_MSG_VIPSTORE_USER_CANCEL_ORDER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_USER_ORDER_HISTORY2: cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY: cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST: cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY: cli::Protocol_MSG_VIPSTORE_USER_ORDER_HISTORY_DIGEST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case VIPSTORE_GET_USER_ALT_ADDRESSES: cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case VIPSTORE_GET_USER_ALT_ADDRESSES2: cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY: cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY: cli::Protocol_VIPSTORE_GET_USER_ALT_ADDRESSES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case VIPSTORE_OBSOLETE_USER_ALT_ADDRESS: cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY: cli::Protocol_VIPSTORE_OBSOLETE_USER_ALT_ADDRESS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

