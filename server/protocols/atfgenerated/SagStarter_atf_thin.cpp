/**
 * SagStarter_atf_thin.cpp
 *
 * This file was auto-generated from SagStarter_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin SagStarter_atf.txt
 */
 
#include "SagStarter_atf_thin.h"

//=================================================================
//                Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID
//=================================================================

SagStarterThin::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID()
{
	clear();
}

void SagStarterThin::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::clear()
{
	scriptId = 0;
	numGames = 0;
	tournRegInfoFlags = 0;
	variantId = esvBase;
}

bool SagStarterThin::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::equals(const Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID& _o) const
{
	return scriptId == _o.scriptId &&
		numGames == _o.numGames &&
		tournRegInfoFlags == _o.tournRegInfoFlags &&
		variantId == _o.variantId;
}

const char *SagStarterThin::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID).append(")");
	_buf.append(',');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	_buf.append(',');
	_buf.append("numGames=");
	_buf.appendUint(numGames);
	_buf.append(',');
	_buf.append("tournRegInfoFlags=");
	_buf.appendUint(tournRegInfoFlags);
	_buf.append(',');
	_buf.append("variantId=");
	_buf.appendUint(variantId);
	return _buf.c_str();
}

void SagStarterThin::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(scriptId);
	_msg.composeBYTE(numGames);
	_msg.composeUINT32(tournRegInfoFlags);
	_msg.composeBYTE(variantId);
}

void SagStarterThin::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(scriptId);
	_parser.parseBYTE(numGames);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(tournRegInfoFlags);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(variantId);
}

/*static*/ void SagStarterThin::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 scriptId; _parser.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	BYTE numGames; _parser.parseBYTE(numGames);
	AtfValidator::validateIntRange(_descr, "numGames", numGames, 0, ATF_SAG_MAX_REG_GAMES, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 tournRegInfoFlags; _parser.parseUINT32(tournRegInfoFlags);
	AtfValidator::validateInt(_descr, "tournRegInfoFlags", tournRegInfoFlags, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE variantId; _parser.parseBYTE(variantId);
	AtfValidator::validateIntRange(_descr, "variantId", variantId, 0, 1, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID
//=================================================================

SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID(Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID&& _o)
	: ri(std::move(_o.ri))
	, variantId(std::move(_o.variantId))
{
}

SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID& SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::operator=(Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID&& _o)
{
	if(this != &_o)
	{
		ri = std::move(_o.ri);
		variantId = std::move(_o.variantId);
	}
	return *this;
}

#endif

void SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::clear()
{
	ri.clear();
	variantId = esvBase;
}

bool SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::equals(const Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID& _o) const
{
	return ri.equals(_o.ri) &&
		variantId == _o.variantId;
}

const char *SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID).append(")");
	_buf.append(',');
	_buf.append("ri=");
	ri.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variantId=");
	_buf.appendUint(variantId);
	return _buf.c_str();
}

void SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::composeMsg(CommMsgBody& _msg) const
{
	ri.composeMsg(_msg);
	_msg.composeBYTE(variantId);
}

void SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::parseMsg(CommMsgParser& _parser)
{
	ri.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(variantId);
}

/*static*/ void SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common::RegisterWithScriptId::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ri"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	BYTE variantId; _parser.parseBYTE(variantId);
	AtfValidator::validateIntRange(_descr, "variantId", variantId, 0, 1, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserTicketDataATF
//=================================================================

SagStarterThin::cli::UserTicketDataATF::UserTicketDataATF()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SagStarterThin::cli::UserTicketDataATF::UserTicketDataATF(UserTicketDataATF&& _o)
	: admissionId(std::move(_o.admissionId))
	, totalCount(std::move(_o.totalCount))
	, reserved(std::move(_o.reserved))
{
}

SagStarterThin::cli::UserTicketDataATF& SagStarterThin::cli::UserTicketDataATF::operator=(UserTicketDataATF&& _o)
{
	if(this != &_o)
	{
		admissionId = std::move(_o.admissionId);
		totalCount = std::move(_o.totalCount);
		reserved = std::move(_o.reserved);
	}
	return *this;
}

#endif

void SagStarterThin::cli::UserTicketDataATF::clear()
{
	admissionId.clear();
	totalCount = 0;
	reserved = 0;
}

bool SagStarterThin::cli::UserTicketDataATF::equals(const UserTicketDataATF& _o) const
{
	return admissionId.equals(_o.admissionId) &&
		totalCount == _o.totalCount &&
		reserved == _o.reserved;
}

const char *SagStarterThin::cli::UserTicketDataATF::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("totalCount=");
	_buf.appendUint(totalCount);
	_buf.append(',');
	_buf.append("reserved=");
	_buf.appendUint(reserved);
	_buf.append('}');
	return _buf.c_str();
}

void SagStarterThin::cli::UserTicketDataATF::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(admissionId);
	_msg.composeUINT32(totalCount);
	_msg.composeUINT32(reserved);
}

void SagStarterThin::cli::UserTicketDataATF::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(admissionId);
	_parser.parseUINT32(totalCount);
	_parser.parseUINT32(reserved);
}

/*static*/ void SagStarterThin::cli::UserTicketDataATF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	UINT32 totalCount; _parser.parseUINT32(totalCount);
	AtfValidator::validateInt(_descr, "totalCount", totalCount, _checker, __FILE__, __LINE__);
	UINT32 reserved; _parser.parseUINT32(reserved);
	AtfValidator::validateInt(_descr, "reserved", reserved, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY
//=================================================================

SagStarterThin::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SagStarterThin::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY(Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errMsg(std::move(_o.errMsg))
	, buyin(std::move(_o.buyin))
	, rake(std::move(_o.rake))
	, fppBuyin(std::move(_o.fppBuyin))
	, admission(std::move(_o.admission))
	, pm(std::move(_o.pm))
	, pwd(std::move(_o.pwd))
	, chips(std::move(_o.chips))
	, playChips32(std::move(_o.playChips32))
	, fpp(std::move(_o.fpp))
	, tickets(std::move(_o.tickets))
	, tchips(std::move(_o.tchips))
	, notused(std::move(_o.notused))
	, preRegistrMessage(std::move(_o.preRegistrMessage))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, currency(std::move(_o.currency))
	, enoughMoneyInOtherCurrency(std::move(_o.enoughMoneyInOtherCurrency))
	, currencyContext(std::move(_o.currencyContext))
	, clientCurrencyContext(std::move(_o.clientCurrencyContext))
	, whenStartAbs(std::move(_o.whenStartAbs))
	, name(std::move(_o.name))
	, playChips(std::move(_o.playChips))
	, scalePM(std::move(_o.scalePM))
	, speedDisplay(std::move(_o.speedDisplay))
	, minPlayers(std::move(_o.minPlayers))
	, maxPlayers(std::move(_o.maxPlayers))
	, maxPerTable(std::move(_o.maxPerTable))
	, tournFlags(std::move(_o.tournFlags))
	, knockout(std::move(_o.knockout))
	, boolValue(std::move(_o.boolValue))
	, admissionPrice(std::move(_o.admissionPrice))
	, effectiveAdmissions(std::move(_o.effectiveAdmissions))
	, tournFlags2(std::move(_o.tournFlags2))
{
}

SagStarterThin::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY& SagStarterThin::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::operator=(Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errMsg = std::move(_o.errMsg);
		buyin = std::move(_o.buyin);
		rake = std::move(_o.rake);
		fppBuyin = std::move(_o.fppBuyin);
		admission = std::move(_o.admission);
		pm = std::move(_o.pm);
		pwd = std::move(_o.pwd);
		chips = std::move(_o.chips);
		playChips32 = std::move(_o.playChips32);
		fpp = std::move(_o.fpp);
		tickets = std::move(_o.tickets);
		tchips = std::move(_o.tchips);
		notused = std::move(_o.notused);
		preRegistrMessage = std::move(_o.preRegistrMessage);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		currency = std::move(_o.currency);
		enoughMoneyInOtherCurrency = std::move(_o.enoughMoneyInOtherCurrency);
		currencyContext = std::move(_o.currencyContext);
		clientCurrencyContext = std::move(_o.clientCurrencyContext);
		whenStartAbs = std::move(_o.whenStartAbs);
		name = std::move(_o.name);
		playChips = std::move(_o.playChips);
		scalePM = std::move(_o.scalePM);
		speedDisplay = std::move(_o.speedDisplay);
		minPlayers = std::move(_o.minPlayers);
		maxPlayers = std::move(_o.maxPlayers);
		maxPerTable = std::move(_o.maxPerTable);
		tournFlags = std::move(_o.tournFlags);
		knockout = std::move(_o.knockout);
		boolValue = std::move(_o.boolValue);
		admissionPrice = std::move(_o.admissionPrice);
		effectiveAdmissions = std::move(_o.effectiveAdmissions);
		tournFlags2 = std::move(_o.tournFlags2);
	}
	return *this;
}

#endif

void SagStarterThin::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
	buyin = 0;
	rake = 0;
	fppBuyin = 0;
	admission.clear();
	pm = 0;
	pwd = 0;
	chips = 0;
	playChips32 = 0;
	fpp = 0;
	tickets = 0;
	tchips = 0;
	notused = 0;
	preRegistrMessage.clear();
	game = 0;
	isHiLo = 0;
	structure = 0;
	currency.clear();
	enoughMoneyInOtherCurrency = false;
	currencyContext.clear();
	clientCurrencyContext.clear();
	whenStartAbs.setNull();
	name.clear();
	playChips = 0;
	scalePM = 0;
	speedDisplay = 0;
	minPlayers = 0;
	maxPlayers = 0;
	maxPerTable = 0;
	tournFlags = 0;
	knockout = 0;
	boolValue = false;
	admissionPrice = 0;
	effectiveAdmissions.clear();
	tournFlags2 = 0;
}

bool SagStarterThin::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::equals(const Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errMsg.equals(_o.errMsg) &&
		buyin == _o.buyin &&
		rake == _o.rake &&
		fppBuyin == _o.fppBuyin &&
		admission.equals(_o.admission) &&
		pm == _o.pm &&
		pwd == _o.pwd &&
		chips == _o.chips &&
		playChips32 == _o.playChips32 &&
		fpp == _o.fpp &&
		tickets == _o.tickets &&
		tchips == _o.tchips &&
		notused == _o.notused &&
		preRegistrMessage.equals(_o.preRegistrMessage) &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		currency.equals(_o.currency) &&
		enoughMoneyInOtherCurrency == _o.enoughMoneyInOtherCurrency &&
		currencyContext.equals(_o.currencyContext) &&
		clientCurrencyContext.equals(_o.clientCurrencyContext) &&
		whenStartAbs.equals(_o.whenStartAbs) &&
		name.equals(_o.name) &&
		playChips == _o.playChips &&
		scalePM == _o.scalePM &&
		speedDisplay == _o.speedDisplay &&
		minPlayers == _o.minPlayers &&
		maxPlayers == _o.maxPlayers &&
		maxPerTable == _o.maxPerTable &&
		tournFlags == _o.tournFlags &&
		knockout == _o.knockout &&
		boolValue == _o.boolValue &&
		admissionPrice == _o.admissionPrice &&
		effectiveAdmissions.equals(_o.effectiveAdmissions) &&
		tournFlags2 == _o.tournFlags2;
}

const char *SagStarterThin::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_REG_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	else
	{
		_buf.append(',');
		_buf.append("buyin=");
		_buf.appendUint(buyin);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendUint(rake);
		_buf.append(',');
		_buf.append("fppBuyin=");
		_buf.appendUint(fppBuyin);
		_buf.append(',');
		_buf.append("admission=");
		_buf.append(admission);
		_buf.append(',');
		_buf.append("pm=");
		_buf.appendUint(pm);
		_buf.append(',');
		_buf.append("pwd=");
		_buf.appendUint(pwd);
		_buf.append(',');
		_buf.append("chips=");
		_buf.appendUint(chips);
		_buf.append(',');
		_buf.append("playChips32=");
		_buf.appendUint(playChips32);
		_buf.append(',');
		_buf.append("fpp=");
		_buf.appendUint(fpp);
		_buf.append(',');
		_buf.append("tickets=");
		_buf.appendUint(tickets);
		_buf.append(',');
		_buf.append("tchips=");
		_buf.appendUint(tchips);
		_buf.append(',');
		_buf.append("notused=");
		_buf.appendUint(notused);
		_buf.append(',');
		_buf.append("preRegistrMessage=");
		_buf.append(preRegistrMessage);
		_buf.append(',');
		_buf.append("game=");
		_buf.appendUint(game);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
		_buf.append(',');
		_buf.append("currencyContext=");
		currencyContext.toTraceString(_buf);
		_buf.append(',');
		_buf.append("clientCurrencyContext=");
		clientCurrencyContext.toTraceString(_buf);
		_buf.append(',');
		_buf.append("whenStartAbs=");
		ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStartAbs);
		_buf.append(',');
		_buf.append("name=");
		_buf.append(name);
		_buf.append(',');
		_buf.append("playChips=");
		_buf.appendUint64(playChips);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendUint(scalePM);
		_buf.append(',');
		_buf.append("speedDisplay=");
		_buf.appendUint(speedDisplay);
		_buf.append(',');
		_buf.append("minPlayers=");
		_buf.appendUint(minPlayers);
		_buf.append(',');
		_buf.append("maxPlayers=");
		_buf.appendUint(maxPlayers);
		_buf.append(',');
		_buf.append("maxPerTable=");
		_buf.appendUint(maxPerTable);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("knockout=");
		_buf.appendUint(knockout);
		_buf.append(',');
		_buf.append("boolValue=");
		_buf.appendUint(boolValue);
		_buf.append(',');
		_buf.append("admissionPrice=");
		_buf.appendInt64(admissionPrice);
		_buf.append(',');
		_buf.append("effectiveAdmissions=");
		effectiveAdmissions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournFlags2=");
		_buf.appendUint64(tournFlags2);
	}
	return _buf.c_str();
}

void SagStarterThin::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_msg.composeString(errMsg);
	}
	else
	{
		_msg.composeUINT32(buyin);
		_msg.composeUINT32(rake);
		_msg.composeUINT32(fppBuyin);
		_msg.composeString(admission);
		_msg.composeBYTE(pm);
		_msg.composeBYTE(pwd);
		_msg.composeUINT32(chips);
		_msg.composeUINT32(playChips32);
		_msg.composeUINT32(fpp);
		_msg.composeUINT32(tickets);
		_msg.composeUINT32(tchips);
		_msg.composeUINT32(notused);
		_msg.composeString(preRegistrMessage);
		_msg.composeBYTE(game);
		_msg.composeBYTE(isHiLo);
		_msg.composeBYTE(structure);
		_msg.composeString(currency);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
		_msg.composeMsgBody(currencyContext);
		_msg.composeMsgBody(clientCurrencyContext);
		_msg.composeSrvTime(whenStartAbs);
		_msg.composeString(name);
		_msg.composeUINT64(playChips);
		_msg.composeUINT32(scalePM);
		_msg.composeBYTE(speedDisplay);
		_msg.composeUINT32(minPlayers);
		_msg.composeUINT32(maxPlayers);
		_msg.composeBYTE(maxPerTable);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT32(knockout);
		_msg.composeBOOL(boolValue);
		_msg.composeINT64(admissionPrice);
		effectiveAdmissions.composeMsg(_msg);
		_msg.composeUINT64(tournFlags2);
	}
}

void SagStarterThin::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_parser.parseStringP(errMsg);
	}
	else
	{
		_parser.parseUINT32(buyin);
		_parser.parseUINT32(rake);
		_parser.parseUINT32(fppBuyin);
		_parser.parseStringP(admission);
		_parser.parseBYTE(pm);
		_parser.parseBYTE(pwd);
		_parser.parseUINT32(chips);
		_parser.parseUINT32(playChips32);
		_parser.parseUINT32(fpp);
		_parser.parseUINT32(tickets);
		_parser.parseUINT32(tchips);
		_parser.parseUINT32(notused);
		_parser.parseStringP(preRegistrMessage);
		_parser.parseBYTE(game);
		_parser.parseBYTE(isHiLo);
		_parser.parseBYTE(structure);
		_parser.parseStringP(currency);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
		_parser.parseMsgBody(currencyContext);
		_parser.parseMsgBody(clientCurrencyContext);
		_parser.parseSrvTime(whenStartAbs);
		_parser.parseStringP(name);
		_parser.parseUINT64(playChips);
		_parser.parseUINT32(scalePM);
		_parser.parseBYTE(speedDisplay);
		_parser.parseUINT32(minPlayers);
		_parser.parseUINT32(maxPlayers);
		_parser.parseBYTE(maxPerTable);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT32(knockout);
		_parser.parseBOOL(boolValue);
		_parser.parseINT64(admissionPrice);
		effectiveAdmissions.parseMsg(_parser);
		_parser.parseUINT64(tournFlags2);
	}
}

/*static*/ void SagStarterThin::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != DBM_NO_ERROR )
	{
		_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 buyin; _parser.parseUINT32(buyin);
		AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
		UINT32 rake; _parser.parseUINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 fppBuyin; _parser.parseUINT32(fppBuyin);
		AtfValidator::validateInt(_descr, "fppBuyin", fppBuyin, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "admission"); size_t szAdmission = strlen(_dummy);
		AtfValidator::validateInt(_descr, "admission", szAdmission, _checker, __FILE__, __LINE__);
		BYTE pm; _parser.parseBYTE(pm);
		AtfValidator::validateInt(_descr, "pm", pm, _checker, __FILE__, __LINE__);
		BYTE pwd; _parser.parseBYTE(pwd);
		AtfValidator::validateInt(_descr, "pwd", pwd, _checker, __FILE__, __LINE__);
		UINT32 chips; _parser.parseUINT32(chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		UINT32 playChips32; _parser.parseUINT32(playChips32);
		AtfValidator::validateInt(_descr, "playChips32", playChips32, _checker, __FILE__, __LINE__);
		UINT32 fpp; _parser.parseUINT32(fpp);
		AtfValidator::validateInt(_descr, "fpp", fpp, _checker, __FILE__, __LINE__);
		UINT32 tickets; _parser.parseUINT32(tickets);
		AtfValidator::validateInt(_descr, "tickets", tickets, _checker, __FILE__, __LINE__);
		UINT32 tchips; _parser.parseUINT32(tchips);
		AtfValidator::validateInt(_descr, "tchips", tchips, _checker, __FILE__, __LINE__);
		UINT32 notused; _parser.parseUINT32(notused);
		AtfValidator::validateInt(_descr, "notused", notused, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "preRegistrMessage"); size_t szPreRegistrMessage = strlen(_dummy);
		AtfValidator::validateInt(_descr, "preRegistrMessage", szPreRegistrMessage, _checker, __FILE__, __LINE__);
		BYTE game; _parser.parseBYTE(game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _parser.parseBYTE(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
		AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
		size_t szClientCurrencyContext; _parser.skipMsgBody(szClientCurrencyContext);  /*clientCurrencyContext*/
		AtfValidator::validateInt(_descr, "clientCurrencyContext", szClientCurrencyContext, _checker, __FILE__, __LINE__);
		SrvTime whenStartAbs; _parser.parseSrvTime(whenStartAbs);
		AtfValidator::validateSrvDateTime(_descr, "whenStartAbs", whenStartAbs, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
		UINT64 playChips; _parser.parseUINT64(playChips);
		AtfValidator::validateUint(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
		UINT32 scalePM; _parser.parseUINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE speedDisplay; _parser.parseBYTE(speedDisplay);
		AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
		UINT32 minPlayers; _parser.parseUINT32(minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		UINT32 maxPlayers; _parser.parseUINT32(maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		BYTE maxPerTable; _parser.parseBYTE(maxPerTable);
		AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 knockout; _parser.parseUINT32(knockout);
		AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
		bool boolValue; _parser.parseBOOL(boolValue);
		AtfValidator::validateInt(_descr, "boolValue", boolValue, _checker, __FILE__, __LINE__);
		INT64 admissionPrice; _parser.parseINT64(admissionPrice);
		AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szEffectiveAdmissions = ThinAtf::LAtfVector< UserTicketDataATF, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("effectiveAdmissions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "effectiveAdmissions", szEffectiveAdmissions, _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    WhereIsBodyATF
//=================================================================

SagStarterThin::cli::WhereIsBodyATF::WhereIsBodyATF()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SagStarterThin::cli::WhereIsBodyATF::WhereIsBodyATF(WhereIsBodyATF&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, serverName(std::move(_o.serverName))
	, serverObjectName(std::move(_o.serverObjectName))
	, clubId(std::move(_o.clubId))
	, tournFlags(std::move(_o.tournFlags))
	, isAvail(std::move(_o.isAvail))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, speedDisplay(std::move(_o.speedDisplay))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, scalePM(std::move(_o.scalePM))
	, knockout(std::move(_o.knockout))
	, minPlayers(std::move(_o.minPlayers))
	, maxPlayers(std::move(_o.maxPlayers))
	, maxPerTable(std::move(_o.maxPerTable))
	, awardSchemaProportional(std::move(_o.awardSchemaProportional))
	, whenStartAbs(std::move(_o.whenStartAbs))
	, whenStartAbsInt(std::move(_o.whenStartAbsInt))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, tournMask(std::move(_o.tournMask))
	, tournMask2(std::move(_o.tournMask2))
	, tournMask3(std::move(_o.tournMask3))
	, tournMask4(std::move(_o.tournMask4))
	, admission(std::move(_o.admission))
	, admissionPrice(std::move(_o.admissionPrice))
	, tournFlags2(std::move(_o.tournFlags2))
{
}

SagStarterThin::cli::WhereIsBodyATF& SagStarterThin::cli::WhereIsBodyATF::operator=(WhereIsBodyATF&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		serverName = std::move(_o.serverName);
		serverObjectName = std::move(_o.serverObjectName);
		clubId = std::move(_o.clubId);
		tournFlags = std::move(_o.tournFlags);
		isAvail = std::move(_o.isAvail);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		speedDisplay = std::move(_o.speedDisplay);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		scalePM = std::move(_o.scalePM);
		knockout = std::move(_o.knockout);
		minPlayers = std::move(_o.minPlayers);
		maxPlayers = std::move(_o.maxPlayers);
		maxPerTable = std::move(_o.maxPerTable);
		awardSchemaProportional = std::move(_o.awardSchemaProportional);
		whenStartAbs = std::move(_o.whenStartAbs);
		whenStartAbsInt = std::move(_o.whenStartAbsInt);
		fppBuyIn = std::move(_o.fppBuyIn);
		tournMask = std::move(_o.tournMask);
		tournMask2 = std::move(_o.tournMask2);
		tournMask3 = std::move(_o.tournMask3);
		tournMask4 = std::move(_o.tournMask4);
		admission = std::move(_o.admission);
		admissionPrice = std::move(_o.admissionPrice);
		tournFlags2 = std::move(_o.tournFlags2);
	}
	return *this;
}

#endif

void SagStarterThin::cli::WhereIsBodyATF::clear()
{
	tournamentId = 0;
	serverName.clear();
	serverObjectName.clear();
	clubId = 0;
	tournFlags = 0;
	isAvail = false;
	game = 0;
	isHiLo = 0;
	structure = 0;
	speedDisplay = 0;
	isPlayMoney = 0;
	currency.clear();
	buyIn = 0;
	rake = 0;
	scalePM = 0;
	knockout = 0;
	minPlayers = 0;
	maxPlayers = 0;
	maxPerTable = 0;
	awardSchemaProportional = false;
	whenStartAbs.setNull();
	whenStartAbsInt = 0;
	fppBuyIn = 0;
	tournMask = 0;
	tournMask2 = 0;
	tournMask3 = 0;
	tournMask4 = 0;
	admission.clear();
	admissionPrice = 0;
	tournFlags2 = 0;
}

bool SagStarterThin::cli::WhereIsBodyATF::equals(const WhereIsBodyATF& _o) const
{
	return tournamentId == _o.tournamentId &&
		serverName.equals(_o.serverName) &&
		serverObjectName.equals(_o.serverObjectName) &&
		clubId == _o.clubId &&
		tournFlags == _o.tournFlags &&
		isAvail == _o.isAvail &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		speedDisplay == _o.speedDisplay &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		scalePM == _o.scalePM &&
		knockout == _o.knockout &&
		minPlayers == _o.minPlayers &&
		maxPlayers == _o.maxPlayers &&
		maxPerTable == _o.maxPerTable &&
		awardSchemaProportional == _o.awardSchemaProportional &&
		whenStartAbs.equals(_o.whenStartAbs) &&
		whenStartAbsInt == _o.whenStartAbsInt &&
		fppBuyIn == _o.fppBuyIn &&
		tournMask == _o.tournMask &&
		tournMask2 == _o.tournMask2 &&
		tournMask3 == _o.tournMask3 &&
		tournMask4 == _o.tournMask4 &&
		admission.equals(_o.admission) &&
		admissionPrice == _o.admissionPrice &&
		tournFlags2 == _o.tournFlags2;
}

const char *SagStarterThin::cli::WhereIsBodyATF::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("serverName=");
	_buf.append(serverName);
	_buf.append(',');
	_buf.append("serverObjectName=");
	_buf.append(serverObjectName);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("isAvail=");
	_buf.appendUint(isAvail);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("speedDisplay=");
	_buf.appendUint(speedDisplay);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append(',');
	_buf.append("knockout=");
	_buf.appendUint(knockout);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("maxPerTable=");
	_buf.appendUint(maxPerTable);
	_buf.append(',');
	_buf.append("awardSchemaProportional=");
	_buf.appendUint(awardSchemaProportional);
	_buf.append(',');
	_buf.append("whenStartAbs=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStartAbs);
	_buf.append(',');
	_buf.append("whenStartAbsInt=");
	_buf.appendUint(whenStartAbsInt);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("tournMask=");
	_buf.appendUint(tournMask);
	_buf.append(',');
	_buf.append("tournMask2=");
	_buf.appendUint(tournMask2);
	_buf.append(',');
	_buf.append("tournMask3=");
	_buf.appendUint(tournMask3);
	_buf.append(',');
	_buf.append("tournMask4=");
	_buf.appendUint(tournMask4);
	_buf.append(',');
	_buf.append("admission=");
	_buf.append(admission);
	_buf.append(',');
	_buf.append("admissionPrice=");
	_buf.appendInt64(admissionPrice);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendInt64(tournFlags2);
	_buf.append('}');
	return _buf.c_str();
}

void SagStarterThin::cli::WhereIsBodyATF::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(WhereIsBodyATF())) // not empty
	{
		_body.composeUINT32(tournamentId);
		_body.composeString(serverName);
		_body.composeString(serverObjectName);
		_body.composeUINT32(clubId);
		_body.composeUINT32(tournFlags);
		_body.composeBOOL(isAvail);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(structure);
		_body.composeBYTE(speedDisplay);
		_body.composeBYTE(isPlayMoney);
		_body.composeString(currency);
		_body.composeUINT32(buyIn);
		_body.composeUINT32(rake);
		_body.composeINT32(scalePM);
		_body.composeUINT32(knockout);
		_body.composeUINT32(minPlayers);
		_body.composeUINT32(maxPlayers);
		_body.composeUINT32(maxPerTable);
		_body.composeBOOL(awardSchemaProportional);
		_body.composeSrvTime(whenStartAbs);
		_body.composeUINT32(whenStartAbsInt);
		_body.composeUINT32(fppBuyIn);
		_body.composeUINT32(tournMask);
		_body.composeUINT32(tournMask2);
		_body.composeUINT32(tournMask3);
		_body.composeUINT32(tournMask4);
		_body.composeString(admission);
		_body.composeINT64(admissionPrice);
		_body.composeINT64(tournFlags2);
	}

	_msg.composeMsgBody(_body);
}

void SagStarterThin::cli::WhereIsBodyATF::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournamentId);
	_parser0.parseStringP(serverName);
	_parser0.parseStringP(serverObjectName);
	_parser0.parseUINT32(clubId);
	_parser0.parseUINT32(tournFlags);
	_parser0.parseBOOL(isAvail);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(speedDisplay);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(buyIn);
	_parser0.parseUINT32(rake);
	_parser0.parseINT32(scalePM);
	_parser0.parseUINT32(knockout);
	_parser0.parseUINT32(minPlayers);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseUINT32(maxPerTable);
	_parser0.parseBOOL(awardSchemaProportional);
	_parser0.parseSrvTime(whenStartAbs);
	_parser0.parseUINT32(whenStartAbsInt);
	_parser0.parseUINT32(fppBuyIn);
	_parser0.parseUINT32(tournMask);
	_parser0.parseUINT32(tournMask2);
	_parser0.parseUINT32(tournMask3);
	_parser0.parseUINT32(tournMask4);
	_parser0.parseStringP(admission);
	_parser0.parseINT64(admissionPrice);
	_parser0.parseINT64(tournFlags2);
}

/*static*/ void SagStarterThin::cli::WhereIsBodyATF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tournamentId; _parser0.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverName"); size_t szServerName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverName", szServerName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObjectName"); size_t szServerObjectName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObjectName", szServerObjectName, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser0.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser0.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	bool isAvail; _parser0.parseBOOL(isAvail);
	AtfValidator::validateInt(_descr, "isAvail", isAvail, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _parser0.parseBYTE(speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	INT32 scalePM; _parser0.parseINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 knockout; _parser0.parseUINT32(knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser0.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 maxPerTable; _parser0.parseUINT32(maxPerTable);
	AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
	bool awardSchemaProportional; _parser0.parseBOOL(awardSchemaProportional);
	AtfValidator::validateInt(_descr, "awardSchemaProportional", awardSchemaProportional, _checker, __FILE__, __LINE__);
	SrvTime whenStartAbs; _parser0.parseSrvTime(whenStartAbs);
	AtfValidator::validateSrvDateTime(_descr, "whenStartAbs", whenStartAbs, _checker, __FILE__, __LINE__);
	UINT32 whenStartAbsInt; _parser0.parseUINT32(whenStartAbsInt);
	AtfValidator::validateInt(_descr, "whenStartAbsInt", whenStartAbsInt, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser0.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _parser0.parseUINT32(tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _parser0.parseUINT32(tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _parser0.parseUINT32(tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _parser0.parseUINT32(tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "admission"); size_t szAdmission = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admission", szAdmission, _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _parser0.parseINT64(admissionPrice);
	AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	INT64 tournFlags2; _parser0.parseINT64(tournFlags2);
	AtfValidator::validateInt(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY
//=================================================================

SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY(Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errMsg(std::move(_o.errMsg))
	, allInOption(std::move(_o.allInOption))
	, locale(std::move(_o.locale))
	, tournId(std::move(_o.tournId))
	, seatAvail(std::move(_o.seatAvail))
	, serverName(std::move(_o.serverName))
	, socialToken(std::move(_o.socialToken))
	, whereIsBody(std::move(_o.whereIsBody))
	, aamsTicket(std::move(_o.aamsTicket))
	, clientNotification(std::move(_o.clientNotification))
{
}

SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY& SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::operator=(Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errMsg = std::move(_o.errMsg);
		allInOption = std::move(_o.allInOption);
		locale = std::move(_o.locale);
		tournId = std::move(_o.tournId);
		seatAvail = std::move(_o.seatAvail);
		serverName = std::move(_o.serverName);
		socialToken = std::move(_o.socialToken);
		whereIsBody = std::move(_o.whereIsBody);
		aamsTicket = std::move(_o.aamsTicket);
		clientNotification = std::move(_o.clientNotification);
	}
	return *this;
}

#endif

void SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
	allInOption = 0;
	locale.clear();
	tournId = 0;
	seatAvail = false;
	serverName.clear();
	socialToken.clear();
	whereIsBody.clear();
	aamsTicket.clear();
	clientNotification.clear();
}

bool SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::equals(const Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errMsg.equals(_o.errMsg) &&
		allInOption == _o.allInOption &&
		locale.equals(_o.locale) &&
		tournId == _o.tournId &&
		seatAvail == _o.seatAvail &&
		serverName.equals(_o.serverName) &&
		socialToken.equals(_o.socialToken) &&
		whereIsBody.equals(_o.whereIsBody) &&
		aamsTicket.equals(_o.aamsTicket) &&
		clientNotification.equals(_o.clientNotification);
}

const char *SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	if( errCode == DBM_NO_ERROR )
	{
		_buf.append(',');
		_buf.append("allInOption=");
		_buf.appendInt(allInOption);
		_buf.append(',');
		_buf.append("locale=");
		_buf.append(locale);
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("seatAvail=");
		_buf.appendUint(seatAvail);
		_buf.append(',');
		_buf.append("serverName=");
		_buf.append(serverName);
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("whereIsBody=");
		whereIsBody.toTraceString(_buf);
		_buf.append(',');
		_buf.append("aamsTicket=");
		_buf.append(aamsTicket);
		_buf.append(',');
		_buf.append("clientNotification=");
		_buf.append(clientNotification);
	}
	return _buf.c_str();
}

void SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errMsg);
	if( errCode == DBM_NO_ERROR )
	{
		_msg.composeINT16(allInOption);
		_msg.composeString(locale);
		_msg.composeUINT32(tournId);
		_msg.composeBOOL(seatAvail);
		_msg.composeString(serverName);
		_msg.composeString(socialToken);
		whereIsBody.composeMsg(_msg);
		_msg.composeString(aamsTicket);
		_msg.composeString(clientNotification);
	}
}

void SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errMsg);
	if( errCode == DBM_NO_ERROR )
	{
		_parser.parseINT16(allInOption);
		_parser.parseStringP(locale);
		_parser.parseUINT32(tournId);
		_parser.parseBOOL(seatAvail);
		_parser.parseStringP(serverName);
		_parser.parseStringP(socialToken);
		whereIsBody.parseMsg(_parser);
		_parser.parseStringP(aamsTicket);
		_parser.parseStringP(clientNotification);
	}
}

/*static*/ void SagStarterThin::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	if( errCode == DBM_NO_ERROR )
	{
		INT16 allInOption; _parser.parseINT16(allInOption);
		AtfValidator::validateInt(_descr, "allInOption", allInOption, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "locale"); size_t szLocale = strlen(_dummy);
		AtfValidator::validateInt(_descr, "locale", szLocale, _checker, __FILE__, __LINE__);
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		bool seatAvail; _parser.parseBOOL(seatAvail);
		AtfValidator::validateInt(_descr, "seatAvail", seatAvail, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverName"); size_t szServerName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverName", szServerName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		PString _descbuf;
		WhereIsBodyATF::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("whereIsBody"), _fieldsWithUnparsedContent);
		_parser.parseStringN(_dummy, 0, "aamsTicket"); size_t szAamsTicket = strlen(_dummy);
		AtfValidator::validateInt(_descr, "aamsTicket", szAamsTicket, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "clientNotification"); size_t szClientNotification = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clientNotification", szClientNotification, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SagWinnerInfo
//=================================================================

SagStarterThin::cli::SagWinnerInfo::SagWinnerInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SagStarterThin::cli::SagWinnerInfo::SagWinnerInfo(SagWinnerInfo&& _o)
	: userId(std::move(_o.userId))
	, payoutTicketTypeId(std::move(_o.payoutTicketTypeId))
	, userImageId(std::move(_o.userImageId))
	, award(std::move(_o.award))
	, targetRef(std::move(_o.targetRef))
	, targetName(std::move(_o.targetName))
	, ticketName(std::move(_o.ticketName))
{
}

SagStarterThin::cli::SagWinnerInfo& SagStarterThin::cli::SagWinnerInfo::operator=(SagWinnerInfo&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		payoutTicketTypeId = std::move(_o.payoutTicketTypeId);
		userImageId = std::move(_o.userImageId);
		award = std::move(_o.award);
		targetRef = std::move(_o.targetRef);
		targetName = std::move(_o.targetName);
		ticketName = std::move(_o.ticketName);
	}
	return *this;
}

#endif

void SagStarterThin::cli::SagWinnerInfo::clear()
{
	userId.clear();
	payoutTicketTypeId = 0;
	userImageId = 0;
	award = 0;
	targetRef.clear();
	targetName.clear();
	ticketName.clear();
}

bool SagStarterThin::cli::SagWinnerInfo::equals(const SagWinnerInfo& _o) const
{
	return userId.equals(_o.userId) &&
		payoutTicketTypeId == _o.payoutTicketTypeId &&
		userImageId == _o.userImageId &&
		award == _o.award &&
		targetRef.equals(_o.targetRef) &&
		targetName.equals(_o.targetName) &&
		ticketName.equals(_o.ticketName);
}

const char *SagStarterThin::cli::SagWinnerInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("payoutTicketTypeId=");
	_buf.appendUint(payoutTicketTypeId);
	_buf.append(',');
	_buf.append("userImageId=");
	_buf.appendUint(userImageId);
	_buf.append(',');
	_buf.append("award=");
	_buf.appendInt(award);
	_buf.append(',');
	_buf.append("targetRef=");
	_buf.append(targetRef);
	_buf.append(',');
	_buf.append("targetName=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, targetName);
	_buf.append(',');
	_buf.append("ticketName=");
	_buf.append(ticketName);
	_buf.append('}');
	return _buf.c_str();
}

void SagStarterThin::cli::SagWinnerInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SagWinnerInfo())) // not empty
	{
		_body.composeString(userId);
		_body.composeUINT32(payoutTicketTypeId);
		_body.composeUINT32(userImageId);
		_body.composeINT32(award);
		_body.composeString(targetRef);
		targetName.compose(_body);
		_body.composeString(ticketName);
	}

	_msg.composeMsgBody(_body);
}

void SagStarterThin::cli::SagWinnerInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(userId);
	_parser0.parseUINT32(payoutTicketTypeId);
	_parser0.parseUINT32(userImageId);
	_parser0.parseINT32(award);
	_parser0.parseStringP(targetRef);
	targetName.parse(_parser0);
	_parser0.parseStringP(ticketName);
}

/*static*/ void SagStarterThin::cli::SagWinnerInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	UINT32 payoutTicketTypeId; _parser0.parseUINT32(payoutTicketTypeId);
	AtfValidator::validateInt(_descr, "payoutTicketTypeId", payoutTicketTypeId, _checker, __FILE__, __LINE__);
	UINT32 userImageId; _parser0.parseUINT32(userImageId);
	AtfValidator::validateInt(_descr, "userImageId", userImageId, _checker, __FILE__, __LINE__);
	INT32 award; _parser0.parseINT32(award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "targetRef"); size_t szTargetRef = strlen(_dummy);
	AtfValidator::validateInt(_descr, "targetRef", szTargetRef, _checker, __FILE__, __LINE__);
	I18nPString targetName; targetName.parse(_parser0);
	_parser0.parseStringN(_dummy, 0, "ticketName"); size_t szTicketName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketName", szTicketName, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SagDataExCli
//=================================================================

SagStarterThin::cli::SagDataExCli::SagDataExCli()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SagStarterThin::cli::SagDataExCli::SagDataExCli(SagDataExCli&& _o)
	: active(std::move(_o.active))
	, visibilityMask32(std::move(_o.visibilityMask32))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, currency(std::move(_o.currency))
	, scalePM(std::move(_o.scalePM))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, speed(std::move(_o.speed))
	, finished(std::move(_o.finished))
	, levelMark(std::move(_o.levelMark))
	, winners(std::move(_o.winners))
	, visibilityMask(std::move(_o.visibilityMask))
{
}

SagStarterThin::cli::SagDataExCli& SagStarterThin::cli::SagDataExCli::operator=(SagDataExCli&& _o)
{
	if(this != &_o)
	{
		active = std::move(_o.active);
		visibilityMask32 = std::move(_o.visibilityMask32);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		currency = std::move(_o.currency);
		scalePM = std::move(_o.scalePM);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		speed = std::move(_o.speed);
		finished = std::move(_o.finished);
		levelMark = std::move(_o.levelMark);
		winners = std::move(_o.winners);
		visibilityMask = std::move(_o.visibilityMask);
	}
	return *this;
}

#endif

void SagStarterThin::cli::SagDataExCli::clear()
{
	active = false;
	visibilityMask32 = 0;
	buyIn = 0;
	rake = 0;
	currency = 0;
	scalePM = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	speed = 0;
	finished.setNull();
	levelMark = 0;
	winners.clear();
	visibilityMask.clear();
}

bool SagStarterThin::cli::SagDataExCli::equals(const SagDataExCli& _o) const
{
	return active == _o.active &&
		visibilityMask32 == _o.visibilityMask32 &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		currency == _o.currency &&
		scalePM == _o.scalePM &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		speed == _o.speed &&
		finished.equals(_o.finished) &&
		levelMark == _o.levelMark &&
		winners.equals(_o.winners) &&
		visibilityMask.equals(_o.visibilityMask);
}

const char *SagStarterThin::cli::SagDataExCli::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("active=");
	_buf.appendUint(active);
	_buf.append(',');
	_buf.append("visibilityMask32=");
	_buf.appendInt(visibilityMask32);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt(rake);
	_buf.append(',');
	_buf.append("currency=");
	_buf.appendInt(currency);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("speed=");
	_buf.appendUint(speed);
	_buf.append(',');
	_buf.append("finished=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, finished);
	_buf.append(',');
	_buf.append("levelMark=");
	_buf.appendInt(levelMark);
	_buf.append(',');
	_buf.append("winners=");
	winners.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMask=");
	visibilityMask.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void SagStarterThin::cli::SagDataExCli::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(active);
	_msg.composeINT32(visibilityMask32);
	_msg.composeINT32(buyIn);
	_msg.composeINT32(rake);
	_msg.composeINT32(currency);
	_msg.composeINT32(scalePM);
	_msg.composeBYTE(game);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(structure);
	_msg.composeBYTE(speed);
	_msg.composeSrvTime(finished);
	_msg.composeINT32(levelMark);
	winners.composeMsg(_msg);
	visibilityMask.composeMsg(_msg);
}

void SagStarterThin::cli::SagDataExCli::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(active);
	_parser.parseINT32(visibilityMask32);
	_parser.parseINT32(buyIn);
	_parser.parseINT32(rake);
	_parser.parseINT32(currency);
	_parser.parseINT32(scalePM);
	_parser.parseBYTE(game);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(structure);
	_parser.parseBYTE(speed);
	_parser.parseSrvTime(finished);
	_parser.parseINT32(levelMark);
	winners.parseMsg(_parser);
	visibilityMask.parseMsg(_parser);
}

/*static*/ void SagStarterThin::cli::SagDataExCli::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool active; _parser.parseBOOL(active);
	AtfValidator::validateInt(_descr, "active", active, _checker, __FILE__, __LINE__);
	INT32 visibilityMask32; _parser.parseINT32(visibilityMask32);
	AtfValidator::validateInt(_descr, "visibilityMask32", visibilityMask32, _checker, __FILE__, __LINE__);
	INT32 buyIn; _parser.parseINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT32 rake; _parser.parseINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	INT32 currency; _parser.parseINT32(currency);
	AtfValidator::validateInt(_descr, "currency", currency, _checker, __FILE__, __LINE__);
	INT32 scalePM; _parser.parseINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE speed; _parser.parseBYTE(speed);
	AtfValidator::validateInt(_descr, "speed", speed, _checker, __FILE__, __LINE__);
	SrvTime finished; _parser.parseSrvTime(finished);
	AtfValidator::validateSrvDateTime(_descr, "finished", finished, _checker, __FILE__, __LINE__);
	INT32 levelMark; _parser.parseINT32(levelMark);
	AtfValidator::validateInt(_descr, "levelMark", levelMark, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szWinners = ThinAtf::LAtfVector< SagWinnerInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("winners"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "winners", szWinners, _checker, __FILE__, __LINE__);
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("visibilityMask"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    SagTournFinishInfo
//=================================================================

SagStarterThin::srv::SagTournFinishInfo::SagTournFinishInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SagStarterThin::srv::SagTournFinishInfo::SagTournFinishInfo(SagTournFinishInfo&& _o)
	: tournId(std::move(_o.tournId))
	, finished(std::move(_o.finished))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, winners(std::move(_o.winners))
{
}

SagStarterThin::srv::SagTournFinishInfo& SagStarterThin::srv::SagTournFinishInfo::operator=(SagTournFinishInfo&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		finished = std::move(_o.finished);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		winners = std::move(_o.winners);
	}
	return *this;
}

#endif

void SagStarterThin::srv::SagTournFinishInfo::clear()
{
	tournId = 0;
	finished.setNull();
	buyIn = 0;
	rake = 0;
	winners.clear();
}

bool SagStarterThin::srv::SagTournFinishInfo::equals(const SagTournFinishInfo& _o) const
{
	return tournId == _o.tournId &&
		finished.equals(_o.finished) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		winners.equals(_o.winners);
}

const char *SagStarterThin::srv::SagTournFinishInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("finished=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, finished);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt(rake);
	_buf.append(',');
	_buf.append("winners=");
	winners.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void SagStarterThin::srv::SagTournFinishInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SagTournFinishInfo())) // not empty
	{
		_body.composeUINT32(tournId);
		_body.composeSrvTime(finished);
		_body.composeINT32(buyIn);
		_body.composeINT32(rake);
		winners.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void SagStarterThin::srv::SagTournFinishInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournId);
	_parser0.parseSrvTime(finished);
	_parser0.parseINT32(buyIn);
	_parser0.parseINT32(rake);
	winners.parseMsg(_parser0);
}

/*static*/ void SagStarterThin::srv::SagTournFinishInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 tournId; _parser0.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	SrvTime finished; _parser0.parseSrvTime(finished);
	AtfValidator::validateSrvDateTime(_descr, "finished", finished, _checker, __FILE__, __LINE__);
	INT32 buyIn; _parser0.parseINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT32 rake; _parser0.parseINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szWinners = ThinAtf::LAtfVector< cli::SagWinnerInfo, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("winners"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "winners", szWinners, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool SagStarterThin::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_TOURN_REG_INFO_REPLY: cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID: cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY: cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID: cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

