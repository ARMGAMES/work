/**
 * shadowlobby_atf.cpp
 *
 * This file was auto-generated from shadowlobby_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor shadowlobby_atf.txt
 */
 
#include "shadowlobby_atf.h"

//=================================================================
//                    TableType2
//=================================================================

ShadowLobby::publication::TableType2::TableType2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ShadowLobby::publication::TableType2::TableType2(TableType2&& _o)
	: tableTypeId(std::move(_o.tableTypeId))
	, siteVisibilityMask(std::move(_o.siteVisibilityMask))
	, brandVisibilityMask(std::move(_o.brandVisibilityMask))
	, invertCountryFilter(std::move(_o.invertCountryFilter))
	, countryFilter(std::move(_o.countryFilter))
	, quickLobbyVisible(std::move(_o.quickLobbyVisible))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, cap(std::move(_o.cap))
	, ante(std::move(_o.ante))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, playerPerTable(std::move(_o.playerPerTable))
	, scalePM(std::move(_o.scalePM))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, seatFinderId(std::move(_o.seatFinderId))
	, poolBlockMinHands(std::move(_o.poolBlockMinHands))
	, poolBlockTimePenalty(std::move(_o.poolBlockTimePenalty))
	, passwordProtected(std::move(_o.passwordProtected))
	, morphLobby(std::move(_o.morphLobby))
	, tableStakes(std::move(_o.tableStakes))
	, variableAntes(std::move(_o.variableAntes))
	, isHybridSingle(std::move(_o.isHybridSingle))
	, siteVisibilityMaskEx(std::move(_o.siteVisibilityMaskEx))
	, tableFlags2(std::move(_o.tableFlags2))
{
}

ShadowLobby::publication::TableType2& ShadowLobby::publication::TableType2::operator=(TableType2&& _o)
{
	if(this != &_o)
	{
		tableTypeId = std::move(_o.tableTypeId);
		siteVisibilityMask = std::move(_o.siteVisibilityMask);
		brandVisibilityMask = std::move(_o.brandVisibilityMask);
		invertCountryFilter = std::move(_o.invertCountryFilter);
		countryFilter = std::move(_o.countryFilter);
		quickLobbyVisible = std::move(_o.quickLobbyVisible);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		cap = std::move(_o.cap);
		ante = std::move(_o.ante);
		minChipsLimit = std::move(_o.minChipsLimit);
		maxBuyIn = std::move(_o.maxBuyIn);
		playerPerTable = std::move(_o.playerPerTable);
		scalePM = std::move(_o.scalePM);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		seatFinderId = std::move(_o.seatFinderId);
		poolBlockMinHands = std::move(_o.poolBlockMinHands);
		poolBlockTimePenalty = std::move(_o.poolBlockTimePenalty);
		passwordProtected = std::move(_o.passwordProtected);
		morphLobby = std::move(_o.morphLobby);
		tableStakes = std::move(_o.tableStakes);
		variableAntes = std::move(_o.variableAntes);
		isHybridSingle = std::move(_o.isHybridSingle);
		siteVisibilityMaskEx = std::move(_o.siteVisibilityMaskEx);
		tableFlags2 = std::move(_o.tableFlags2);
	}
	return *this;
}

#endif

void ShadowLobby::publication::TableType2::clear()
{
	tableTypeId = 0;
	siteVisibilityMask = 0;
	brandVisibilityMask = 0;
	invertCountryFilter = false;
	countryFilter.clear();
	quickLobbyVisible = false;
	game = 0;
	structure = 0;
	isHiLo = 0;
	isPlayMoney = 0;
	currency.clear();
	loBet = 0;
	hiBet = 0;
	cap = 0;
	ante = 0;
	minChipsLimit = 0;
	maxBuyIn = 0;
	playerPerTable = 0;
	scalePM = 0;
	defaultBuyIn = 0;
	seatFinderId = 0;
	poolBlockMinHands = 0;
	poolBlockTimePenalty.clear();
	passwordProtected = false;
	morphLobby = false;
	tableStakes.clear();
	variableAntes.clear();
	isHybridSingle = false;
	siteVisibilityMaskEx.clear();
	tableFlags2 = 0;
}

bool ShadowLobby::publication::TableType2::equals(const TableType2& _o) const
{
	return tableTypeId == _o.tableTypeId &&
		siteVisibilityMask == _o.siteVisibilityMask &&
		brandVisibilityMask == _o.brandVisibilityMask &&
		invertCountryFilter == _o.invertCountryFilter &&
		countryFilter.equals(_o.countryFilter) &&
		quickLobbyVisible == _o.quickLobbyVisible &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		isPlayMoney == _o.isPlayMoney &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		cap == _o.cap &&
		ante == _o.ante &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		playerPerTable == _o.playerPerTable &&
		scalePM == _o.scalePM &&
		defaultBuyIn == _o.defaultBuyIn &&
		seatFinderId == _o.seatFinderId &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		poolBlockTimePenalty.equals(_o.poolBlockTimePenalty) &&
		passwordProtected == _o.passwordProtected &&
		morphLobby == _o.morphLobby &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		isHybridSingle == _o.isHybridSingle &&
		siteVisibilityMaskEx.equals(_o.siteVisibilityMaskEx) &&
		tableFlags2 == _o.tableFlags2;
}

const char *ShadowLobby::publication::TableType2::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableTypeId=");
	_buf.appendUint(tableTypeId);
	_buf.append(',');
	_buf.append("siteVisibilityMask=");
	_buf.appendUint(siteVisibilityMask);
	_buf.append(',');
	_buf.append("brandVisibilityMask=");
	_buf.appendUint(brandVisibilityMask);
	_buf.append(',');
	_buf.append("invertCountryFilter=");
	_buf.appendUint(invertCountryFilter);
	_buf.append(',');
	_buf.append("countryFilter=");
	countryFilter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("quickLobbyVisible=");
	_buf.appendUint(quickLobbyVisible);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendUint(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("playerPerTable=");
	_buf.appendUint(playerPerTable);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendUint(defaultBuyIn);
	_buf.append(',');
	_buf.append("seatFinderId=");
	_buf.appendUint(seatFinderId);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("poolBlockTimePenalty=");
	poolBlockTimePenalty.toTraceString(_buf);
	_buf.append(',');
	_buf.append("passwordProtected=");
	_buf.appendUint(passwordProtected);
	_buf.append(',');
	_buf.append("morphLobby=");
	_buf.appendUint(morphLobby);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isHybridSingle=");
	_buf.appendUint(isHybridSingle);
	_buf.append(',');
	_buf.append("siteVisibilityMaskEx=");
	siteVisibilityMaskEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append('}');
	return _buf.c_str();
}

const char *ShadowLobby::publication::TableType2::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tableTypeId", tableTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteVisibilityMask", siteVisibilityMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandVisibilityMask", brandVisibilityMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("invertCountryFilter", invertCountryFilter, _buf);
	countryFilter.toXmlString("countryFilter", _buf);
	Atf::XmlElement::encodeAsXmlElement("quickLobbyVisible", quickLobbyVisible, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("cap", cap, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("minChipsLimit", minChipsLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerPerTable", playerPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("defaultBuyIn", defaultBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("seatFinderId", seatFinderId, _buf);
	Atf::XmlElement::encodeAsXmlElement("poolBlockMinHands", poolBlockMinHands, _buf);
	poolBlockTimePenalty.toXmlString("poolBlockTimePenalty", _buf);
	Atf::XmlElement::encodeAsXmlElement("passwordProtected", passwordProtected, _buf);
	Atf::XmlElement::encodeAsXmlElement("morphLobby", morphLobby, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	variableAntes.toXmlString("variableAntes", _buf);
	Atf::XmlElement::encodeAsXmlElement("isHybridSingle", isHybridSingle, _buf);
	siteVisibilityMaskEx.toXmlString("siteVisibilityMaskEx", _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags2", tableFlags2, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool ShadowLobby::publication::TableType2::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tableTypeId"))
		{
			tableTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("siteVisibilityMask"))
		{
			siteVisibilityMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandVisibilityMask"))
		{
			brandVisibilityMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("invertCountryFilter"))
		{
			invertCountryFilter = (*_value.ptr() == '1');
		}
		else if (_element.equals("countryFilter"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString , 4 > >::FromXmlString(_value, countryFilter)) return false;
		}
		else if (_element.equals("quickLobbyVisible"))
		{
			quickLobbyVisible = (*_value.ptr() == '1');
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("loBet"))
		{
			loBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cap"))
		{
			cap = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minChipsLimit"))
		{
			minChipsLimit = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playerPerTable"))
		{
			playerPerTable = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("defaultBuyIn"))
		{
			defaultBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("seatFinderId"))
		{
			seatFinderId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("poolBlockMinHands"))
		{
			poolBlockMinHands = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("poolBlockTimePenalty"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32 , 4 > >::FromXmlString(_value, poolBlockTimePenalty)) return false;
		}
		else if (_element.equals("passwordProtected"))
		{
			passwordProtected = (*_value.ptr() == '1');
		}
		else if (_element.equals("morphLobby"))
		{
			morphLobby = (*_value.ptr() == '1');
		}
		else if (_element.equals("tableStakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
		}
		else if (_element.equals("variableAntes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64 , 4 > >::FromXmlString(_value, variableAntes)) return false;
		}
		else if (_element.equals("isHybridSingle"))
		{
			isHybridSingle = (*_value.ptr() == '1');
		}
		else if (_element.equals("siteVisibilityMaskEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, siteVisibilityMaskEx)) return false;
		}
		else if (_element.equals("tableFlags2"))
		{
			tableFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void ShadowLobby::publication::TableType2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tableTypeId);
	_msg.composeUINT32(siteVisibilityMask);
	_msg.composeUINT32(brandVisibilityMask);
	_msg.composeBOOL(invertCountryFilter);
	countryFilter.composeMsg(_msg, _ignoreJSON);
	_msg.composeBOOL(quickLobbyVisible);
	_msg.composeBYTE(game);
	_msg.composeBYTE(structure);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeString(currency);
	_msg.composeUINT32(loBet);
	_msg.composeUINT32(hiBet);
	_msg.composeUINT32(cap);
	_msg.composeUINT32(ante);
	_msg.composeUINT32(minChipsLimit);
	_msg.composeUINT32(maxBuyIn);
	_msg.composeBYTE(playerPerTable);
	_msg.composeUINT32(scalePM);
	_msg.composeUINT32(defaultBuyIn);
	_msg.composeUINT32(seatFinderId);
	_msg.composeINT32(poolBlockMinHands);
	poolBlockTimePenalty.composeMsg(_msg, _ignoreJSON);
	_msg.composeBOOL(passwordProtected);
	_msg.composeBOOL(morphLobby);
	tableStakes.composeMsg(_msg, _ignoreJSON);
	variableAntes.composeMsg(_msg, _ignoreJSON);
	_msg.composeBOOL(isHybridSingle);
	siteVisibilityMaskEx.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT64(tableFlags2);
}

void ShadowLobby::publication::TableType2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableTypeId);
	_parser.parseUINT32(siteVisibilityMask);
	_parser.parseUINT32(brandVisibilityMask);
	_parser.parseBOOL(invertCountryFilter);
	countryFilter.parseMsg(_parser);
	_parser.parseBOOL(quickLobbyVisible);
	_parser.parseBYTE(game);
	_parser.parseBYTE(structure);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseStringP(currency);
	_parser.parseUINT32(loBet);
	_parser.parseUINT32(hiBet);
	_parser.parseUINT32(cap);
	_parser.parseUINT32(ante);
	_parser.parseUINT32(minChipsLimit);
	_parser.parseUINT32(maxBuyIn);
	_parser.parseBYTE(playerPerTable);
	_parser.parseUINT32(scalePM);
	_parser.parseUINT32(defaultBuyIn);
	_parser.parseUINT32(seatFinderId);
	_parser.parseINT32(poolBlockMinHands);
	poolBlockTimePenalty.parseMsg(_parser);
	_parser.parseBOOL(passwordProtected);
	_parser.parseBOOL(morphLobby);
	if(_parser.parseEnded()) return;
	tableStakes.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	variableAntes.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isHybridSingle);
	if(_parser.parseEnded()) return;
	siteVisibilityMaskEx.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableFlags2);
}

const char *ShadowLobby::publication::TableType2::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableTypeId", tableTypeId);
	_jsonstr.compose("siteVisibilityMask", siteVisibilityMask);
	_jsonstr.compose("brandVisibilityMask", brandVisibilityMask);
	_jsonstr.compose("invertCountryFilter", invertCountryFilter);
	_jsonstr.compose("countryFilter", countryFilter);
	_jsonstr.compose("quickLobbyVisible", quickLobbyVisible);
	_jsonstr.compose("game", game);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("cap", cap);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("minChipsLimit", minChipsLimit);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("playerPerTable", playerPerTable);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("defaultBuyIn", defaultBuyIn);
	_jsonstr.compose("seatFinderId", seatFinderId);
	_jsonstr.compose("poolBlockMinHands", poolBlockMinHands);
	_jsonstr.compose("poolBlockTimePenalty", poolBlockTimePenalty);
	_jsonstr.compose("passwordProtected", passwordProtected);
	_jsonstr.compose("morphLobby", morphLobby);
	_jsonstr.compose("tableStakes", tableStakes);
	_jsonstr.compose("variableAntes", variableAntes);
	_jsonstr.compose("isHybridSingle", isHybridSingle);
	_jsonstr.compose("siteVisibilityMaskEx", siteVisibilityMaskEx);
	_jsonstr.compose("tableFlags2", tableFlags2);
	return _buf.c_str();
}

void ShadowLobby::publication::TableType2::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableTypeId", tableTypeId);
	_jparser.parseByNameThrow("siteVisibilityMask", siteVisibilityMask);
	_jparser.parseByNameThrow("brandVisibilityMask", brandVisibilityMask);
	_jparser.parseByNameThrow("invertCountryFilter", invertCountryFilter);
	_jparser.parseByNameThrow("countryFilter", countryFilter);
	_jparser.parseByNameThrow("quickLobbyVisible", quickLobbyVisible);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("cap", cap);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("minChipsLimit", minChipsLimit);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("playerPerTable", playerPerTable);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("defaultBuyIn", defaultBuyIn);
	_jparser.parseByNameThrow("seatFinderId", seatFinderId);
	_jparser.parseByNameThrow("poolBlockMinHands", poolBlockMinHands);
	_jparser.parseByNameThrow("poolBlockTimePenalty", poolBlockTimePenalty);
	_jparser.parseByNameThrow("passwordProtected", passwordProtected);
	_jparser.parseByNameThrow("morphLobby", morphLobby);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("variableAntes", variableAntes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("isHybridSingle", isHybridSingle);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("siteVisibilityMaskEx", siteVisibilityMaskEx);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableFlags2", tableFlags2);
}

/* static */ void ShadowLobby::publication::TableType2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tableTypeId; _jparser.validateByNameThrow("tableTypeId", tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	UINT32 siteVisibilityMask; _jparser.validateByNameThrow("siteVisibilityMask", siteVisibilityMask);
	AtfValidator::validateInt(_descr, "siteVisibilityMask", siteVisibilityMask, _checker, __FILE__, __LINE__);
	UINT32 brandVisibilityMask; _jparser.validateByNameThrow("brandVisibilityMask", brandVisibilityMask);
	AtfValidator::validateInt(_descr, "brandVisibilityMask", brandVisibilityMask, _checker, __FILE__, __LINE__);
	bool invertCountryFilter; _jparser.validateByNameThrow("invertCountryFilter", invertCountryFilter);
	AtfValidator::validateInt(_descr, "invertCountryFilter", invertCountryFilter, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > countryFilter; _jparser.validateByNameThrow("countryFilter", countryFilter);
	AtfValidator::validateInt(_descr, "countryFilter", countryFilter.size(), _checker, __FILE__, __LINE__);
	bool quickLobbyVisible; _jparser.validateByNameThrow("quickLobbyVisible", quickLobbyVisible);
	AtfValidator::validateInt(_descr, "quickLobbyVisible", quickLobbyVisible, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 cap; _jparser.validateByNameThrow("cap", cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	UINT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _jparser.validateByNameThrow("minChipsLimit", minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	BYTE playerPerTable; _jparser.validateByNameThrow("playerPerTable", playerPerTable);
	AtfValidator::validateInt(_descr, "playerPerTable", playerPerTable, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _jparser.validateByNameThrow("defaultBuyIn", defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT32 seatFinderId; _jparser.validateByNameThrow("seatFinderId", seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _jparser.validateByNameThrow("poolBlockMinHands", poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > poolBlockTimePenalty; _jparser.validateByNameThrow("poolBlockTimePenalty", poolBlockTimePenalty);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", poolBlockTimePenalty.size(), _checker, __FILE__, __LINE__);
	bool passwordProtected; _jparser.validateByNameThrow("passwordProtected", passwordProtected);
	AtfValidator::validateInt(_descr, "passwordProtected", passwordProtected, _checker, __FILE__, __LINE__);
	bool morphLobby; _jparser.validateByNameThrow("morphLobby", morphLobby);
	AtfValidator::validateInt(_descr, "morphLobby", morphLobby, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< INT64 > variableAntes; _jparser.validateByNameThrow("variableAntes", variableAntes);
	AtfValidator::validateInt(_descr, "variableAntes", variableAntes.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool isHybridSingle; _jparser.validateByNameThrow("isHybridSingle", isHybridSingle);
	AtfValidator::validateInt(_descr, "isHybridSingle", isHybridSingle, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask siteVisibilityMaskEx; _jparser.validateByNameThrow("siteVisibilityMaskEx", siteVisibilityMaskEx);
	if(_jparser.parseEnded()) return;
	UINT64 tableFlags2; _jparser.validateByNameThrow("tableFlags2", tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
}

/*static*/ void ShadowLobby::publication::TableType2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 tableTypeId; _parser.parseUINT32(tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	UINT32 siteVisibilityMask; _parser.parseUINT32(siteVisibilityMask);
	AtfValidator::validateInt(_descr, "siteVisibilityMask", siteVisibilityMask, _checker, __FILE__, __LINE__);
	UINT32 brandVisibilityMask; _parser.parseUINT32(brandVisibilityMask);
	AtfValidator::validateInt(_descr, "brandVisibilityMask", brandVisibilityMask, _checker, __FILE__, __LINE__);
	bool invertCountryFilter; _parser.parseBOOL(invertCountryFilter);
	AtfValidator::validateInt(_descr, "invertCountryFilter", invertCountryFilter, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCountryFilter = Atf::LAtfVector< PString , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("countryFilter"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "countryFilter", szCountryFilter, _checker, __FILE__, __LINE__);
	bool quickLobbyVisible; _parser.parseBOOL(quickLobbyVisible);
	AtfValidator::validateInt(_descr, "quickLobbyVisible", quickLobbyVisible, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 cap; _parser.parseUINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _parser.parseUINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser.parseUINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	BYTE playerPerTable; _parser.parseBYTE(playerPerTable);
	AtfValidator::validateInt(_descr, "playerPerTable", playerPerTable, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _parser.parseUINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	int szPoolBlockTimePenalty = Atf::LAtfVector< INT32 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("poolBlockTimePenalty"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", szPoolBlockTimePenalty, _checker, __FILE__, __LINE__);
	bool passwordProtected; _parser.parseBOOL(passwordProtected);
	AtfValidator::validateInt(_descr, "passwordProtected", passwordProtected, _checker, __FILE__, __LINE__);
	bool morphLobby; _parser.parseBOOL(morphLobby);
	AtfValidator::validateInt(_descr, "morphLobby", morphLobby, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	TableCommon::TableStakes::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	int szVariableAntes = Atf::LAtfVector< INT64 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool isHybridSingle; _parser.parseBOOL(isHybridSingle);
	AtfValidator::validateInt(_descr, "isHybridSingle", isHybridSingle, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("siteVisibilityMaskEx"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT64 tableFlags2; _parser.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TableSubscr_Static
//=================================================================

ShadowLobby::publication::TableSubscr_Static::TableSubscr_Static()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ShadowLobby::publication::TableSubscr_Static::TableSubscr_Static(TableSubscr_Static&& _o)
	: _obsolete_1(std::move(_o._obsolete_1))
	, name(std::move(_o.name))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, tableFlags(std::move(_o.tableFlags))
	, isOneOnOne(std::move(_o.isOneOnOne))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, playerPerTable(std::move(_o.playerPerTable))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, _obsolete_2(std::move(_o._obsolete_2))
	, _obsolete_3(std::move(_o._obsolete_3))
	, structure(std::move(_o.structure))
	, typeName(std::move(_o.typeName))
	, _obsolete_4(std::move(_o._obsolete_4))
	, chatLang(std::move(_o.chatLang))
	, currency(std::move(_o.currency))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, _obsolete_5(std::move(_o._obsolete_5))
	, countryFilter(std::move(_o.countryFilter))
	, cap(std::move(_o.cap))
	, iconIndex(std::move(_o.iconIndex))
	, filterIndex(std::move(_o.filterIndex))
	, tableInstanceFlag(std::move(_o.tableInstanceFlag))
	, _obsolete_6(std::move(_o._obsolete_6))
	, tableFlags2(std::move(_o.tableFlags2))
	, tableTypeId(std::move(_o.tableTypeId))
	, scalePM(std::move(_o.scalePM))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, tableId(std::move(_o.tableId))
	, brandVisibilityMask(std::move(_o.brandVisibilityMask))
	, _obsolete_7(std::move(_o._obsolete_7))
	, criteria(std::move(_o.criteria))
	, tableStakes(std::move(_o.tableStakes))
	, varAnte(std::move(_o.varAnte))
	, siteVisibilityMask(std::move(_o.siteVisibilityMask))
{
}

ShadowLobby::publication::TableSubscr_Static& ShadowLobby::publication::TableSubscr_Static::operator=(TableSubscr_Static&& _o)
{
	if(this != &_o)
	{
		_obsolete_1 = std::move(_o._obsolete_1);
		name = std::move(_o.name);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		tableFlags = std::move(_o.tableFlags);
		isOneOnOne = std::move(_o.isOneOnOne);
		isPlayMoney = std::move(_o.isPlayMoney);
		playerPerTable = std::move(_o.playerPerTable);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		_obsolete_2 = std::move(_o._obsolete_2);
		_obsolete_3 = std::move(_o._obsolete_3);
		structure = std::move(_o.structure);
		typeName = std::move(_o.typeName);
		_obsolete_4 = std::move(_o._obsolete_4);
		chatLang = std::move(_o.chatLang);
		currency = std::move(_o.currency);
		minChipsLimit = std::move(_o.minChipsLimit);
		maxBuyIn = std::move(_o.maxBuyIn);
		_obsolete_5 = std::move(_o._obsolete_5);
		countryFilter = std::move(_o.countryFilter);
		cap = std::move(_o.cap);
		iconIndex = std::move(_o.iconIndex);
		filterIndex = std::move(_o.filterIndex);
		tableInstanceFlag = std::move(_o.tableInstanceFlag);
		_obsolete_6 = std::move(_o._obsolete_6);
		tableFlags2 = std::move(_o.tableFlags2);
		tableTypeId = std::move(_o.tableTypeId);
		scalePM = std::move(_o.scalePM);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		tableId = std::move(_o.tableId);
		brandVisibilityMask = std::move(_o.brandVisibilityMask);
		_obsolete_7 = std::move(_o._obsolete_7);
		criteria = std::move(_o.criteria);
		tableStakes = std::move(_o.tableStakes);
		varAnte = std::move(_o.varAnte);
		siteVisibilityMask = std::move(_o.siteVisibilityMask);
	}
	return *this;
}

#endif

void ShadowLobby::publication::TableSubscr_Static::clear()
{
	_obsolete_1 = 0;
	name.clear();
	server.clear();
	serverObject.clear();
	tableFlags = 0;
	isOneOnOne = 0;
	isPlayMoney = 0;
	playerPerTable = 0;
	game = 0;
	isHiLo = 0;
	_obsolete_2 = 0;
	_obsolete_3 = 0;
	structure = 0;
	typeName.clear();
	_obsolete_4 = 0;
	chatLang = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	_obsolete_5 = 0;
	countryFilter.clear();
	cap = 0;
	iconIndex = 0;
	filterIndex = 0;
	tableInstanceFlag = 0;
	_obsolete_6 = false;
	tableFlags2 = 0;
	tableTypeId = 0;
	scalePM = 0;
	defaultBuyIn = 0;
	tableId = 0;
	brandVisibilityMask = 0;
	_obsolete_7 = 0;
	criteria.clear();
	tableStakes.clear();
	varAnte.clear();
	siteVisibilityMask.clear();
}

bool ShadowLobby::publication::TableSubscr_Static::equals(const TableSubscr_Static& _o) const
{
	return _obsolete_1 == _o._obsolete_1 &&
		Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObject, _o.serverObject) &&
		tableFlags == _o.tableFlags &&
		isOneOnOne == _o.isOneOnOne &&
		isPlayMoney == _o.isPlayMoney &&
		playerPerTable == _o.playerPerTable &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		_obsolete_2 == _o._obsolete_2 &&
		_obsolete_3 == _o._obsolete_3 &&
		structure == _o.structure &&
		Atf::atfPStringEquals(typeName, _o.typeName) &&
		_obsolete_4 == _o._obsolete_4 &&
		chatLang == _o.chatLang &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		_obsolete_5 == _o._obsolete_5 &&
		countryFilter.equals(_o.countryFilter) &&
		cap == _o.cap &&
		iconIndex == _o.iconIndex &&
		filterIndex == _o.filterIndex &&
		tableInstanceFlag == _o.tableInstanceFlag &&
		_obsolete_6 == _o._obsolete_6 &&
		tableFlags2 == _o.tableFlags2 &&
		tableTypeId == _o.tableTypeId &&
		scalePM == _o.scalePM &&
		defaultBuyIn == _o.defaultBuyIn &&
		tableId == _o.tableId &&
		brandVisibilityMask == _o.brandVisibilityMask &&
		_obsolete_7 == _o._obsolete_7 &&
		Atf::atfPStringEquals(criteria, _o.criteria) &&
		tableStakes.equals(_o.tableStakes) &&
		varAnte.equals(_o.varAnte) &&
		siteVisibilityMask.equals(_o.siteVisibilityMask);
}

const char *ShadowLobby::publication::TableSubscr_Static::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("_obsolete_1=");
	_buf.appendUint(_obsolete_1);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("isOneOnOne=");
	_buf.appendUint(isOneOnOne);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("playerPerTable=");
	_buf.appendUint(playerPerTable);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("_obsolete_2=");
	_buf.appendUint(_obsolete_2);
	_buf.append(',');
	_buf.append("_obsolete_3=");
	_buf.appendUint(_obsolete_3);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("typeName=");
	_buf.append(typeName);
	_buf.append(',');
	_buf.append("_obsolete_4=");
	_buf.appendUint(_obsolete_4);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendUint(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("_obsolete_5=");
	_buf.appendUint(_obsolete_5);
	_buf.append(',');
	_buf.append("countryFilter=");
	countryFilter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("iconIndex=");
	_buf.appendUint(iconIndex);
	_buf.append(',');
	_buf.append("filterIndex=");
	_buf.appendUint(filterIndex);
	_buf.append(',');
	_buf.append("tableInstanceFlag=");
	_buf.appendUint(tableInstanceFlag);
	_buf.append(',');
	_buf.append("_obsolete_6=");
	_buf.appendUint(_obsolete_6);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append(',');
	_buf.append("tableTypeId=");
	_buf.appendUint(tableTypeId);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendUint(defaultBuyIn);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("brandVisibilityMask=");
	_buf.appendUint(brandVisibilityMask);
	_buf.append(',');
	_buf.append("_obsolete_7=");
	_buf.appendInt(_obsolete_7);
	_buf.append(',');
	_buf.append("criteria=");
	_buf.append(criteria);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("varAnte=");
	varAnte.toTraceString(_buf);
	_buf.append(',');
	_buf.append("siteVisibilityMask=");
	siteVisibilityMask.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *ShadowLobby::publication::TableSubscr_Static::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("_obsolete_1", _obsolete_1, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags", tableFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("isOneOnOne", isOneOnOne, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerPerTable", playerPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("_obsolete_2", _obsolete_2, _buf);
	Atf::XmlElement::encodeAsXmlElement("_obsolete_3", _obsolete_3, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("typeName", typeName, _buf);
	Atf::XmlElement::encodeAsXmlElement("_obsolete_4", _obsolete_4, _buf);
	Atf::XmlElement::encodeAsXmlElement("chatLang", chatLang, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("minChipsLimit", minChipsLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("_obsolete_5", _obsolete_5, _buf);
	countryFilter.toXmlString("countryFilter", _buf);
	Atf::XmlElement::encodeAsXmlElement("cap", cap, _buf);
	Atf::XmlElement::encodeAsXmlElement("iconIndex", iconIndex, _buf);
	Atf::XmlElement::encodeAsXmlElement("filterIndex", filterIndex, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableInstanceFlag", tableInstanceFlag, _buf);
	Atf::XmlElement::encodeAsXmlElement("_obsolete_6", _obsolete_6, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags2", tableFlags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableTypeId", tableTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("defaultBuyIn", defaultBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandVisibilityMask", brandVisibilityMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("_obsolete_7", _obsolete_7, _buf);
	Atf::XmlElement::encodeAsXmlElement("criteria", criteria, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	varAnte.toXmlString("varAnte", _buf);
	siteVisibilityMask.toXmlString("siteVisibilityMask", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool ShadowLobby::publication::TableSubscr_Static::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("_obsolete_1"))
		{
			_obsolete_1 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("serverObject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
		}
		else if (_element.equals("tableFlags"))
		{
			tableFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isOneOnOne"))
		{
			isOneOnOne = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playerPerTable"))
		{
			playerPerTable = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("_obsolete_2"))
		{
			_obsolete_2 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("_obsolete_3"))
		{
			_obsolete_3 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("typeName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, typeName)) return false;
		}
		else if (_element.equals("_obsolete_4"))
		{
			_obsolete_4 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chatLang"))
		{
			chatLang = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("minChipsLimit"))
		{
			minChipsLimit = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("_obsolete_5"))
		{
			_obsolete_5 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("countryFilter"))
		{
			if(!Atf::AtfTempl< Common::AtfShared::LegacyCountryVisibilityFilter >::FromXmlString(_value, countryFilter)) return false;
		}
		else if (_element.equals("cap"))
		{
			cap = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("iconIndex"))
		{
			iconIndex = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("filterIndex"))
		{
			filterIndex = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableInstanceFlag"))
		{
			tableInstanceFlag = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("_obsolete_6"))
		{
			_obsolete_6 = (*_value.ptr() == '1');
		}
		else if (_element.equals("tableFlags2"))
		{
			tableFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableTypeId"))
		{
			tableTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("defaultBuyIn"))
		{
			defaultBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableId"))
		{
			tableId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandVisibilityMask"))
		{
			brandVisibilityMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("_obsolete_7"))
		{
			_obsolete_7 = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("criteria"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, criteria)) return false;
		}
		else if (_element.equals("tableStakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
		}
		else if (_element.equals("varAnte"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64 , 4 > >::FromXmlString(_value, varAnte)) return false;
		}
		else if (_element.equals("siteVisibilityMask"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, siteVisibilityMask)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void ShadowLobby::publication::TableSubscr_Static::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(_obsolete_1);
	_msg.composeString(name);
	_msg.composeString(server);
	_msg.composeString(serverObject);
	_msg.composeUINT32(tableFlags);
	_msg.composeBYTE(isOneOnOne);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeBYTE(playerPerTable);
	_msg.composeBYTE(game);
	_msg.composeBYTE(isHiLo);
	_msg.composeUINT32(_obsolete_2);
	_msg.composeUINT32(_obsolete_3);
	_msg.composeBYTE(structure);
	_msg.composeString(typeName);
	_msg.composeUINT32(_obsolete_4);
	_msg.composeUINT16(chatLang);
	_msg.composeString(currency);
	_msg.composeUINT32(minChipsLimit);
	_msg.composeUINT32(maxBuyIn);
	_msg.composeUINT32(_obsolete_5);
	countryFilter.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(cap);
	_msg.composeBYTE(iconIndex);
	_msg.composeBYTE(filterIndex);
	_msg.composeUINT32(tableInstanceFlag);
	_msg.composeBOOL(_obsolete_6);
	_msg.composeUINT64(tableFlags2);
	_msg.composeUINT32(tableTypeId);
	_msg.composeUINT32(scalePM);
	_msg.composeUINT32(defaultBuyIn);
	_msg.composeUINT64(tableId);
	_msg.composeUINT32(brandVisibilityMask);
	_msg.composeINT32(_obsolete_7);
	_msg.composeString(criteria);
	tableStakes.composeMsg(_msg, _ignoreJSON);
	varAnte.composeMsg(_msg, _ignoreJSON);
	siteVisibilityMask.composeMsg(_msg, _ignoreJSON);
}

void ShadowLobby::publication::TableSubscr_Static::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(_obsolete_1);
	_parser.parseStringP(name);
	_parser.parseStringP(server);
	_parser.parseStringP(serverObject);
	_parser.parseUINT32(tableFlags);
	_parser.parseBYTE(isOneOnOne);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseBYTE(playerPerTable);
	_parser.parseBYTE(game);
	_parser.parseBYTE(isHiLo);
	_parser.parseUINT32(_obsolete_2);
	_parser.parseUINT32(_obsolete_3);
	_parser.parseBYTE(structure);
	_parser.parseStringP(typeName);
	_parser.parseUINT32(_obsolete_4);
	_parser.parseUINT16(chatLang);
	_parser.parseStringP(currency);
	_parser.parseUINT32(minChipsLimit);
	_parser.parseUINT32(maxBuyIn);
	_parser.parseUINT32(_obsolete_5);
	countryFilter.parseMsg(_parser);
	_parser.parseUINT32(cap);
	_parser.parseBYTE(iconIndex);
	_parser.parseBYTE(filterIndex);
	_parser.parseUINT32(tableInstanceFlag);
	_parser.parseBOOL(_obsolete_6);
	_parser.parseUINT64(tableFlags2);
	_parser.parseUINT32(tableTypeId);
	_parser.parseUINT32(scalePM);
	_parser.parseUINT32(defaultBuyIn);
	_parser.parseUINT64(tableId);
	_parser.parseUINT32(brandVisibilityMask);
	_parser.parseINT32(_obsolete_7);
	_parser.parseStringP(criteria);
	tableStakes.parseMsg(_parser);
	varAnte.parseMsg(_parser);
	siteVisibilityMask.parseMsg(_parser);
}

const char *ShadowLobby::publication::TableSubscr_Static::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("_obsolete_1", _obsolete_1);
	_jsonstr.compose("name", name);
	_jsonstr.compose("server", server);
	_jsonstr.compose("serverObject", serverObject);
	_jsonstr.compose("tableFlags", tableFlags);
	_jsonstr.compose("isOneOnOne", isOneOnOne);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("playerPerTable", playerPerTable);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("_obsolete_2", _obsolete_2);
	_jsonstr.compose("_obsolete_3", _obsolete_3);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("typeName", typeName);
	_jsonstr.compose("_obsolete_4", _obsolete_4);
	_jsonstr.compose("chatLang", chatLang);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("minChipsLimit", minChipsLimit);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("_obsolete_5", _obsolete_5);
	_jsonstr.compose("countryFilter", countryFilter);
	_jsonstr.compose("cap", cap);
	_jsonstr.compose("iconIndex", iconIndex);
	_jsonstr.compose("filterIndex", filterIndex);
	_jsonstr.compose("tableInstanceFlag", tableInstanceFlag);
	_jsonstr.compose("_obsolete_6", _obsolete_6);
	_jsonstr.compose("tableFlags2", tableFlags2);
	_jsonstr.compose("tableTypeId", tableTypeId);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("defaultBuyIn", defaultBuyIn);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("brandVisibilityMask", brandVisibilityMask);
	_jsonstr.compose("_obsolete_7", _obsolete_7);
	_jsonstr.compose("criteria", criteria);
	_jsonstr.compose("tableStakes", tableStakes);
	_jsonstr.compose("varAnte", varAnte);
	_jsonstr.compose("siteVisibilityMask", siteVisibilityMask);
	return _buf.c_str();
}

void ShadowLobby::publication::TableSubscr_Static::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("_obsolete_1", _obsolete_1);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("serverObject", serverObject);
	_jparser.parseByNameThrow("tableFlags", tableFlags);
	_jparser.parseByNameThrow("isOneOnOne", isOneOnOne);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("playerPerTable", playerPerTable);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("_obsolete_2", _obsolete_2);
	_jparser.parseByNameThrow("_obsolete_3", _obsolete_3);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("typeName", typeName);
	_jparser.parseByNameThrow("_obsolete_4", _obsolete_4);
	_jparser.parseByNameThrow("chatLang", chatLang);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("minChipsLimit", minChipsLimit);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("_obsolete_5", _obsolete_5);
	_jparser.parseByNameThrow("countryFilter", countryFilter);
	_jparser.parseByNameThrow("cap", cap);
	_jparser.parseByNameThrow("iconIndex", iconIndex);
	_jparser.parseByNameThrow("filterIndex", filterIndex);
	_jparser.parseByNameThrow("tableInstanceFlag", tableInstanceFlag);
	_jparser.parseByNameThrow("_obsolete_6", _obsolete_6);
	_jparser.parseByNameThrow("tableFlags2", tableFlags2);
	_jparser.parseByNameThrow("tableTypeId", tableTypeId);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("defaultBuyIn", defaultBuyIn);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("brandVisibilityMask", brandVisibilityMask);
	_jparser.parseByNameThrow("_obsolete_7", _obsolete_7);
	_jparser.parseByNameThrow("criteria", criteria);
	_jparser.parseByNameThrow("tableStakes", tableStakes);
	_jparser.parseByNameThrow("varAnte", varAnte);
	_jparser.parseByNameThrow("siteVisibilityMask", siteVisibilityMask);
}

/* static */ void ShadowLobby::publication::TableSubscr_Static::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 _obsolete_1; _jparser.validateByNameThrow("_obsolete_1", _obsolete_1);
	AtfValidator::validateInt(_descr, "_obsolete_1", _obsolete_1, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
	AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _jparser.validateByNameThrow("tableFlags", tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	BYTE isOneOnOne; _jparser.validateByNameThrow("isOneOnOne", isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE playerPerTable; _jparser.validateByNameThrow("playerPerTable", playerPerTable);
	AtfValidator::validateInt(_descr, "playerPerTable", playerPerTable, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_2; _jparser.validateByNameThrow("_obsolete_2", _obsolete_2);
	AtfValidator::validateInt(_descr, "_obsolete_2", _obsolete_2, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_3; _jparser.validateByNameThrow("_obsolete_3", _obsolete_3);
	AtfValidator::validateInt(_descr, "_obsolete_3", _obsolete_3, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	PString typeName; _jparser.validateByNameThrow("typeName", typeName);
	AtfValidator::validateInt(_descr, "typeName", typeName.length(), _checker, __FILE__, __LINE__);
	UINT32 _obsolete_4; _jparser.validateByNameThrow("_obsolete_4", _obsolete_4);
	AtfValidator::validateInt(_descr, "_obsolete_4", _obsolete_4, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _jparser.validateByNameThrow("chatLang", chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _jparser.validateByNameThrow("minChipsLimit", minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_5; _jparser.validateByNameThrow("_obsolete_5", _obsolete_5);
	AtfValidator::validateInt(_descr, "_obsolete_5", _obsolete_5, _checker, __FILE__, __LINE__);
	Common::AtfShared::LegacyCountryVisibilityFilter countryFilter; _jparser.validateByNameThrow("countryFilter", countryFilter);
	UINT32 cap; _jparser.validateByNameThrow("cap", cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	BYTE iconIndex; _jparser.validateByNameThrow("iconIndex", iconIndex);
	AtfValidator::validateInt(_descr, "iconIndex", iconIndex, _checker, __FILE__, __LINE__);
	BYTE filterIndex; _jparser.validateByNameThrow("filterIndex", filterIndex);
	AtfValidator::validateInt(_descr, "filterIndex", filterIndex, _checker, __FILE__, __LINE__);
	UINT32 tableInstanceFlag; _jparser.validateByNameThrow("tableInstanceFlag", tableInstanceFlag);
	AtfValidator::validateInt(_descr, "tableInstanceFlag", tableInstanceFlag, _checker, __FILE__, __LINE__);
	bool _obsolete_6; _jparser.validateByNameThrow("_obsolete_6", _obsolete_6);
	AtfValidator::validateInt(_descr, "_obsolete_6", _obsolete_6, _checker, __FILE__, __LINE__);
	UINT64 tableFlags2; _jparser.validateByNameThrow("tableFlags2", tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	UINT32 tableTypeId; _jparser.validateByNameThrow("tableTypeId", tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _jparser.validateByNameThrow("defaultBuyIn", defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	UINT32 brandVisibilityMask; _jparser.validateByNameThrow("brandVisibilityMask", brandVisibilityMask);
	AtfValidator::validateInt(_descr, "brandVisibilityMask", brandVisibilityMask, _checker, __FILE__, __LINE__);
	INT32 _obsolete_7; _jparser.validateByNameThrow("_obsolete_7", _obsolete_7);
	AtfValidator::validateInt(_descr, "_obsolete_7", _obsolete_7, _checker, __FILE__, __LINE__);
	PString criteria; _jparser.validateByNameThrow("criteria", criteria);
	AtfValidator::validateInt(_descr, "criteria", criteria.length(), _checker, __FILE__, __LINE__);
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
	Atf::AtfVectorBase< INT64 > varAnte; _jparser.validateByNameThrow("varAnte", varAnte);
	AtfValidator::validateInt(_descr, "varAnte", varAnte.size(), _checker, __FILE__, __LINE__);
	PSiteMask siteVisibilityMask; _jparser.validateByNameThrow("siteVisibilityMask", siteVisibilityMask);
}

/*static*/ void ShadowLobby::publication::TableSubscr_Static::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 _obsolete_1; _parser.parseUINT32(_obsolete_1);
	AtfValidator::validateInt(_descr, "_obsolete_1", _obsolete_1, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _parser.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	BYTE isOneOnOne; _parser.parseBYTE(isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE playerPerTable; _parser.parseBYTE(playerPerTable);
	AtfValidator::validateInt(_descr, "playerPerTable", playerPerTable, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_2; _parser.parseUINT32(_obsolete_2);
	AtfValidator::validateInt(_descr, "_obsolete_2", _obsolete_2, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_3; _parser.parseUINT32(_obsolete_3);
	AtfValidator::validateInt(_descr, "_obsolete_3", _obsolete_3, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "typeName"); size_t szTypeName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "typeName", szTypeName, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_4; _parser.parseUINT32(_obsolete_4);
	AtfValidator::validateInt(_descr, "_obsolete_4", _obsolete_4, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _parser.parseUINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser.parseUINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_5; _parser.parseUINT32(_obsolete_5);
	AtfValidator::validateInt(_descr, "_obsolete_5", _obsolete_5, _checker, __FILE__, __LINE__);
	PString _descbuf;
	Common::AtfShared::LegacyCountryVisibilityFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("countryFilter"), _fieldsWithUnparsedContent);
	UINT32 cap; _parser.parseUINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	BYTE iconIndex; _parser.parseBYTE(iconIndex);
	AtfValidator::validateInt(_descr, "iconIndex", iconIndex, _checker, __FILE__, __LINE__);
	BYTE filterIndex; _parser.parseBYTE(filterIndex);
	AtfValidator::validateInt(_descr, "filterIndex", filterIndex, _checker, __FILE__, __LINE__);
	UINT32 tableInstanceFlag; _parser.parseUINT32(tableInstanceFlag);
	AtfValidator::validateInt(_descr, "tableInstanceFlag", tableInstanceFlag, _checker, __FILE__, __LINE__);
	bool _obsolete_6; _parser.parseBOOL(_obsolete_6);
	AtfValidator::validateInt(_descr, "_obsolete_6", _obsolete_6, _checker, __FILE__, __LINE__);
	UINT64 tableFlags2; _parser.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	UINT32 tableTypeId; _parser.parseUINT32(tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _parser.parseUINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	UINT32 brandVisibilityMask; _parser.parseUINT32(brandVisibilityMask);
	AtfValidator::validateInt(_descr, "brandVisibilityMask", brandVisibilityMask, _checker, __FILE__, __LINE__);
	INT32 _obsolete_7; _parser.parseINT32(_obsolete_7);
	AtfValidator::validateInt(_descr, "_obsolete_7", _obsolete_7, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "criteria"); size_t szCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "criteria", szCriteria, _checker, __FILE__, __LINE__);
	TableCommon::TableStakes::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	int szVarAnte = Atf::LAtfVector< INT64 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("varAnte"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "varAnte", szVarAnte, _checker, __FILE__, __LINE__);
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("siteVisibilityMask"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    TableSubscr_Status
//=================================================================

ShadowLobby::publication::TableSubscr_Status::TableSubscr_Status()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ShadowLobby::publication::TableSubscr_Status::TableSubscr_Status(TableSubscr_Status&& _o)
	: players(std::move(_o.players))
	, waitingList(std::move(_o.waitingList))
	, playersPerFlop(std::move(_o.playersPerFlop))
	, averagePot(std::move(_o.averagePot))
	, handsPerHour(std::move(_o.handsPerHour))
	, publPropFlag(std::move(_o.publPropFlag))
	, averageStack(std::move(_o.averageStack))
	, vpip(std::move(_o.vpip))
	, fppFactor(std::move(_o.fppFactor))
	, active(std::move(_o.active))
{
}

ShadowLobby::publication::TableSubscr_Status& ShadowLobby::publication::TableSubscr_Status::operator=(TableSubscr_Status&& _o)
{
	if(this != &_o)
	{
		players = std::move(_o.players);
		waitingList = std::move(_o.waitingList);
		playersPerFlop = std::move(_o.playersPerFlop);
		averagePot = std::move(_o.averagePot);
		handsPerHour = std::move(_o.handsPerHour);
		publPropFlag = std::move(_o.publPropFlag);
		averageStack = std::move(_o.averageStack);
		vpip = std::move(_o.vpip);
		fppFactor = std::move(_o.fppFactor);
		active = std::move(_o.active);
	}
	return *this;
}

#endif

void ShadowLobby::publication::TableSubscr_Status::clear()
{
	players = 0;
	waitingList = 0;
	playersPerFlop = 0;
	averagePot = 0;
	handsPerHour = 0;
	publPropFlag = 0;
	averageStack = 0;
	vpip = 0;
	fppFactor.clear();
	active = false;
}

bool ShadowLobby::publication::TableSubscr_Status::equals(const TableSubscr_Status& _o) const
{
	return players == _o.players &&
		waitingList == _o.waitingList &&
		playersPerFlop == _o.playersPerFlop &&
		averagePot == _o.averagePot &&
		handsPerHour == _o.handsPerHour &&
		publPropFlag == _o.publPropFlag &&
		averageStack == _o.averageStack &&
		vpip == _o.vpip &&
		fppFactor.equals(_o.fppFactor) &&
		active == _o.active;
}

const char *ShadowLobby::publication::TableSubscr_Status::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("players=");
	_buf.appendUint(players);
	_buf.append(',');
	_buf.append("waitingList=");
	_buf.appendUint(waitingList);
	_buf.append(',');
	_buf.append("playersPerFlop=");
	_buf.appendUint(playersPerFlop);
	_buf.append(',');
	_buf.append("averagePot=");
	_buf.appendUint(averagePot);
	_buf.append(',');
	_buf.append("handsPerHour=");
	_buf.appendUint(handsPerHour);
	_buf.append(',');
	_buf.append("publPropFlag=");
	_buf.appendUint(publPropFlag);
	_buf.append(',');
	_buf.append("averageStack=");
	_buf.appendUint(averageStack);
	_buf.append(',');
	_buf.append("vpip=");
	_buf.appendUint(vpip);
	_buf.append(',');
	_buf.append("fppFactor=");
	fppFactor.toTraceString(_buf);
	_buf.append(',');
	_buf.append("active=");
	_buf.appendUint(active);
	_buf.append('}');
	return _buf.c_str();
}

const char *ShadowLobby::publication::TableSubscr_Status::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("players", players, _buf);
	Atf::XmlElement::encodeAsXmlElement("waitingList", waitingList, _buf);
	Atf::XmlElement::encodeAsXmlElement("playersPerFlop", playersPerFlop, _buf);
	Atf::XmlElement::encodeAsXmlElement("averagePot", averagePot, _buf);
	Atf::XmlElement::encodeAsXmlElement("handsPerHour", handsPerHour, _buf);
	Atf::XmlElement::encodeAsXmlElement("publPropFlag", publPropFlag, _buf);
	Atf::XmlElement::encodeAsXmlElement("averageStack", averageStack, _buf);
	Atf::XmlElement::encodeAsXmlElement("vpip", vpip, _buf);
	fppFactor.toXmlString("fppFactor", _buf);
	Atf::XmlElement::encodeAsXmlElement("active", active, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool ShadowLobby::publication::TableSubscr_Status::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("players"))
		{
			players = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("waitingList"))
		{
			waitingList = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playersPerFlop"))
		{
			playersPerFlop = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("averagePot"))
		{
			averagePot = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handsPerHour"))
		{
			handsPerHour = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("publPropFlag"))
		{
			publPropFlag = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("averageStack"))
		{
			averageStack = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("vpip"))
		{
			vpip = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppFactor"))
		{
			if(!Atf::AtfTempl< TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType >::FromXmlString(_value, fppFactor)) return false;
		}
		else if (_element.equals("active"))
		{
			active = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void ShadowLobby::publication::TableSubscr_Status::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(players);
	_msg.composeBYTE(waitingList);
	_msg.composeBYTE(playersPerFlop);
	_msg.composeUINT32(averagePot);
	_msg.composeUINT16(handsPerHour);
	_msg.composeBYTE(publPropFlag);
	_msg.composeUINT32(averageStack);
	_msg.composeBYTE(vpip);
	fppFactor.composeMsg(_msg, _ignoreJSON);
	_msg.composeBOOL(active);
}

void ShadowLobby::publication::TableSubscr_Status::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(players);
	_parser.parseBYTE(waitingList);
	_parser.parseBYTE(playersPerFlop);
	_parser.parseUINT32(averagePot);
	_parser.parseUINT16(handsPerHour);
	_parser.parseBYTE(publPropFlag);
	_parser.parseUINT32(averageStack);
	_parser.parseBYTE(vpip);
	fppFactor.parseMsg(_parser);
	_parser.parseBOOL(active);
}

const char *ShadowLobby::publication::TableSubscr_Status::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("players", players);
	_jsonstr.compose("waitingList", waitingList);
	_jsonstr.compose("playersPerFlop", playersPerFlop);
	_jsonstr.compose("averagePot", averagePot);
	_jsonstr.compose("handsPerHour", handsPerHour);
	_jsonstr.compose("publPropFlag", publPropFlag);
	_jsonstr.compose("averageStack", averageStack);
	_jsonstr.compose("vpip", vpip);
	_jsonstr.compose("fppFactor", fppFactor);
	_jsonstr.compose("active", active);
	return _buf.c_str();
}

void ShadowLobby::publication::TableSubscr_Status::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("players", players);
	_jparser.parseByNameThrow("waitingList", waitingList);
	_jparser.parseByNameThrow("playersPerFlop", playersPerFlop);
	_jparser.parseByNameThrow("averagePot", averagePot);
	_jparser.parseByNameThrow("handsPerHour", handsPerHour);
	_jparser.parseByNameThrow("publPropFlag", publPropFlag);
	_jparser.parseByNameThrow("averageStack", averageStack);
	_jparser.parseByNameThrow("vpip", vpip);
	_jparser.parseByNameThrow("fppFactor", fppFactor);
	_jparser.parseByNameThrow("active", active);
}

/* static */ void ShadowLobby::publication::TableSubscr_Status::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE players; _jparser.validateByNameThrow("players", players);
	AtfValidator::validateInt(_descr, "players", players, _checker, __FILE__, __LINE__);
	BYTE waitingList; _jparser.validateByNameThrow("waitingList", waitingList);
	AtfValidator::validateInt(_descr, "waitingList", waitingList, _checker, __FILE__, __LINE__);
	BYTE playersPerFlop; _jparser.validateByNameThrow("playersPerFlop", playersPerFlop);
	AtfValidator::validateInt(_descr, "playersPerFlop", playersPerFlop, _checker, __FILE__, __LINE__);
	UINT32 averagePot; _jparser.validateByNameThrow("averagePot", averagePot);
	AtfValidator::validateInt(_descr, "averagePot", averagePot, _checker, __FILE__, __LINE__);
	UINT16 handsPerHour; _jparser.validateByNameThrow("handsPerHour", handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	BYTE publPropFlag; _jparser.validateByNameThrow("publPropFlag", publPropFlag);
	AtfValidator::validateInt(_descr, "publPropFlag", publPropFlag, _checker, __FILE__, __LINE__);
	UINT32 averageStack; _jparser.validateByNameThrow("averageStack", averageStack);
	AtfValidator::validateInt(_descr, "averageStack", averageStack, _checker, __FILE__, __LINE__);
	BYTE vpip; _jparser.validateByNameThrow("vpip", vpip);
	AtfValidator::validateInt(_descr, "vpip", vpip, _checker, __FILE__, __LINE__);
	TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType fppFactor; _jparser.validateByNameThrow("fppFactor", fppFactor);
	bool active; _jparser.validateByNameThrow("active", active);
	AtfValidator::validateInt(_descr, "active", active, _checker, __FILE__, __LINE__);
}

/*static*/ void ShadowLobby::publication::TableSubscr_Status::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE players; _parser.parseBYTE(players);
	AtfValidator::validateInt(_descr, "players", players, _checker, __FILE__, __LINE__);
	BYTE waitingList; _parser.parseBYTE(waitingList);
	AtfValidator::validateInt(_descr, "waitingList", waitingList, _checker, __FILE__, __LINE__);
	BYTE playersPerFlop; _parser.parseBYTE(playersPerFlop);
	AtfValidator::validateInt(_descr, "playersPerFlop", playersPerFlop, _checker, __FILE__, __LINE__);
	UINT32 averagePot; _parser.parseUINT32(averagePot);
	AtfValidator::validateInt(_descr, "averagePot", averagePot, _checker, __FILE__, __LINE__);
	UINT16 handsPerHour; _parser.parseUINT16(handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	BYTE publPropFlag; _parser.parseBYTE(publPropFlag);
	AtfValidator::validateInt(_descr, "publPropFlag", publPropFlag, _checker, __FILE__, __LINE__);
	UINT32 averageStack; _parser.parseUINT32(averageStack);
	AtfValidator::validateInt(_descr, "averageStack", averageStack, _checker, __FILE__, __LINE__);
	BYTE vpip; _parser.parseBYTE(vpip);
	AtfValidator::validateInt(_descr, "vpip", vpip, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("fppFactor"), _fieldsWithUnparsedContent);
	bool active; _parser.parseBOOL(active);
	AtfValidator::validateInt(_descr, "active", active, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ReplaySubscr_Winner
//=================================================================

ShadowLobby::publication::ReplaySubscr_Winner::ReplaySubscr_Winner()
{
	clear();
}

void ShadowLobby::publication::ReplaySubscr_Winner::clear()
{
	award = 0;
	bounty = 0;
	wasDealMode = false;
}

bool ShadowLobby::publication::ReplaySubscr_Winner::equals(const ReplaySubscr_Winner& _o) const
{
	return award == _o.award &&
		bounty == _o.bounty &&
		wasDealMode == _o.wasDealMode;
}

const char *ShadowLobby::publication::ReplaySubscr_Winner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("award=");
	_buf.appendInt64(award);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendInt64(bounty);
	_buf.append(',');
	_buf.append("wasDealMode=");
	_buf.appendUint(wasDealMode);
	_buf.append('}');
	return _buf.c_str();
}

const char *ShadowLobby::publication::ReplaySubscr_Winner::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("award", award, _buf);
	Atf::XmlElement::encodeAsXmlElement("bounty", bounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("wasDealMode", wasDealMode, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool ShadowLobby::publication::ReplaySubscr_Winner::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("award"))
		{
			award = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bounty"))
		{
			bounty = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("wasDealMode"))
		{
			wasDealMode = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void ShadowLobby::publication::ReplaySubscr_Winner::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ReplaySubscr_Winner())) // not empty
	{
		_body.composeINT64(award);
		_body.composeINT64(bounty);
		_body.composeBOOL(wasDealMode);
	}

	_msg.composeMsgBody(_body);
}

void ShadowLobby::publication::ReplaySubscr_Winner::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(award);
	_parser0.parseINT64(bounty);
	_parser0.parseBOOL(wasDealMode);
}

const char *ShadowLobby::publication::ReplaySubscr_Winner::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("award", award);
	_jsonstr.compose("bounty", bounty);
	_jsonstr.compose("wasDealMode", wasDealMode);
	return _buf.c_str();
}

void ShadowLobby::publication::ReplaySubscr_Winner::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("award", award);
	_jparser.parseByNameThrow("bounty", bounty);
	_jparser.parseByNameThrow("wasDealMode", wasDealMode);
}

/* static */ void ShadowLobby::publication::ReplaySubscr_Winner::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 award; _jparser.validateByNameThrow("award", award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	INT64 bounty; _jparser.validateByNameThrow("bounty", bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	bool wasDealMode; _jparser.validateByNameThrow("wasDealMode", wasDealMode);
	AtfValidator::validateInt(_descr, "wasDealMode", wasDealMode, _checker, __FILE__, __LINE__);
}

/*static*/ void ShadowLobby::publication::ReplaySubscr_Winner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT64 award; _parser0.parseINT64(award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	INT64 bounty; _parser0.parseINT64(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	bool wasDealMode; _parser0.parseBOOL(wasDealMode);
	AtfValidator::validateInt(_descr, "wasDealMode", wasDealMode, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ReplaySubscr_Static
//=================================================================

ShadowLobby::publication::ReplaySubscr_Static::ReplaySubscr_Static()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ShadowLobby::publication::ReplaySubscr_Static::ReplaySubscr_Static(ReplaySubscr_Static&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, serverObj(std::move(_o.serverObj))
	, whenStart(std::move(_o.whenStart))
	, name(std::move(_o.name))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, tournMask(std::move(_o.tournMask))
	, info(std::move(_o.info))
	, siteVisibilityMask(std::move(_o.siteVisibilityMask))
	, whenStart_t(std::move(_o.whenStart_t))
	, tournMask2(std::move(_o.tournMask2))
	, tournMask3(std::move(_o.tournMask3))
	, tournMask4(std::move(_o.tournMask4))
	, currency(std::move(_o.currency))
	, tournMask5(std::move(_o.tournMask5))
	, tournMask6(std::move(_o.tournMask6))
	, brandVisibilityMask(std::move(_o.brandVisibilityMask))
	, origTournDate(std::move(_o.origTournDate))
	, finalPrizePool(std::move(_o.finalPrizePool))
	, origTournName(std::move(_o.origTournName))
	, winners(std::move(_o.winners))
	, criteria(std::move(_o.criteria))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, bounty(std::move(_o.bounty))
	, maxPlayers(std::move(_o.maxPlayers))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlags2(std::move(_o.tournFlags2))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, groupReference(std::move(_o.groupReference))
	, pokerNgGroup(std::move(_o.pokerNgGroup))
	, siteVisibilityMaskEx(std::move(_o.siteVisibilityMaskEx))
{
}

ShadowLobby::publication::ReplaySubscr_Static& ShadowLobby::publication::ReplaySubscr_Static::operator=(ReplaySubscr_Static&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		serverObj = std::move(_o.serverObj);
		whenStart = std::move(_o.whenStart);
		name = std::move(_o.name);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		tournMask = std::move(_o.tournMask);
		info = std::move(_o.info);
		siteVisibilityMask = std::move(_o.siteVisibilityMask);
		whenStart_t = std::move(_o.whenStart_t);
		tournMask2 = std::move(_o.tournMask2);
		tournMask3 = std::move(_o.tournMask3);
		tournMask4 = std::move(_o.tournMask4);
		currency = std::move(_o.currency);
		tournMask5 = std::move(_o.tournMask5);
		tournMask6 = std::move(_o.tournMask6);
		brandVisibilityMask = std::move(_o.brandVisibilityMask);
		origTournDate = std::move(_o.origTournDate);
		finalPrizePool = std::move(_o.finalPrizePool);
		origTournName = std::move(_o.origTournName);
		winners = std::move(_o.winners);
		criteria = std::move(_o.criteria);
		isPlayMoney = std::move(_o.isPlayMoney);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		bounty = std::move(_o.bounty);
		maxPlayers = std::move(_o.maxPlayers);
		tournFlags = std::move(_o.tournFlags);
		tournFlags2 = std::move(_o.tournFlags2);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		groupReference = std::move(_o.groupReference);
		pokerNgGroup = std::move(_o.pokerNgGroup);
		siteVisibilityMaskEx = std::move(_o.siteVisibilityMaskEx);
	}
	return *this;
}

#endif

void ShadowLobby::publication::ReplaySubscr_Static::clear()
{
	tournamentId = 0;
	server.clear();
	serverObj.clear();
	whenStart.setNull();
	name.clear();
	game = 0;
	isHiLo = 0;
	structure = 0;
	tournMask = 0;
	info.clear();
	siteVisibilityMask = 0;
	whenStart_t = 0;
	tournMask2 = 0;
	tournMask3 = 0;
	tournMask4 = 0;
	currency.clear();
	tournMask5 = 0;
	tournMask6 = 0;
	brandVisibilityMask = 0;
	origTournDate.setNull();
	finalPrizePool = 0;
	origTournName.clear();
	winners.clear();
	criteria.clear();
	isPlayMoney = false;
	buyIn = 0;
	rake = 0;
	bounty = 0;
	maxPlayers = 0;
	tournFlags = 0;
	tournFlags2 = 0;
	tournFlagsServInt = 0;
	groupReference.clear();
	pokerNgGroup.clear();
	siteVisibilityMaskEx.clear();
}

bool ShadowLobby::publication::ReplaySubscr_Static::equals(const ReplaySubscr_Static& _o) const
{
	return tournamentId == _o.tournamentId &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObj, _o.serverObj) &&
		whenStart.equals(_o.whenStart) &&
		Atf::atfPStringEquals(name, _o.name) &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		tournMask == _o.tournMask &&
		Atf::atfPStringEquals(info, _o.info) &&
		siteVisibilityMask == _o.siteVisibilityMask &&
		whenStart_t == _o.whenStart_t &&
		tournMask2 == _o.tournMask2 &&
		tournMask3 == _o.tournMask3 &&
		tournMask4 == _o.tournMask4 &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		tournMask5 == _o.tournMask5 &&
		tournMask6 == _o.tournMask6 &&
		brandVisibilityMask == _o.brandVisibilityMask &&
		origTournDate.equals(_o.origTournDate) &&
		finalPrizePool == _o.finalPrizePool &&
		origTournName.equals(_o.origTournName) &&
		winners.equals(_o.winners) &&
		Atf::atfPStringEquals(criteria, _o.criteria) &&
		isPlayMoney == _o.isPlayMoney &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		bounty == _o.bounty &&
		maxPlayers == _o.maxPlayers &&
		tournFlags == _o.tournFlags &&
		tournFlags2 == _o.tournFlags2 &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		Atf::atfPStringEquals(groupReference, _o.groupReference) &&
		Atf::atfPStringEquals(pokerNgGroup, _o.pokerNgGroup) &&
		siteVisibilityMaskEx.equals(_o.siteVisibilityMaskEx);
}

const char *ShadowLobby::publication::ReplaySubscr_Static::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append(',');
	_buf.append("whenStart=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("tournMask=");
	_buf.appendUint(tournMask);
	_buf.append(',');
	_buf.append("info=");
	_buf.append(info);
	_buf.append(',');
	_buf.append("siteVisibilityMask=");
	_buf.appendUint(siteVisibilityMask);
	_buf.append(',');
	_buf.append("whenStart_t=");
	_buf.appendUint(whenStart_t);
	_buf.append(',');
	_buf.append("tournMask2=");
	_buf.appendUint(tournMask2);
	_buf.append(',');
	_buf.append("tournMask3=");
	_buf.appendUint(tournMask3);
	_buf.append(',');
	_buf.append("tournMask4=");
	_buf.appendUint(tournMask4);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("tournMask5=");
	_buf.appendUint(tournMask5);
	_buf.append(',');
	_buf.append("tournMask6=");
	_buf.appendUint(tournMask6);
	_buf.append(',');
	_buf.append("brandVisibilityMask=");
	_buf.appendUint(brandVisibilityMask);
	_buf.append(',');
	_buf.append("origTournDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, origTournDate);
	_buf.append(',');
	_buf.append("finalPrizePool=");
	_buf.appendInt64(finalPrizePool);
	_buf.append(',');
	_buf.append("origTournName=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, origTournName);
	_buf.append(',');
	_buf.append("winners=");
	winners.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	_buf.append(criteria);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt64(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt64(rake);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendInt64(bounty);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendInt(maxPlayers);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append(',');
	_buf.append("tournFlagsServInt=");
	_buf.appendUint(tournFlagsServInt);
	_buf.append(',');
	_buf.append("groupReference=");
	_buf.append(groupReference);
	_buf.append(',');
	_buf.append("pokerNgGroup=");
	_buf.append(pokerNgGroup);
	_buf.append(',');
	_buf.append("siteVisibilityMaskEx=");
	siteVisibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *ShadowLobby::publication::ReplaySubscr_Static::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournamentId", tournamentId, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObj", serverObj, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenStart", whenStart);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask", tournMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("info", info, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteVisibilityMask", siteVisibilityMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("whenStart_t", whenStart_t, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask2", tournMask2, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask3", tournMask3, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask4", tournMask4, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask5", tournMask5, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask6", tournMask6, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandVisibilityMask", brandVisibilityMask, _buf);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "origTournDate", origTournDate);
	Atf::XmlElement::encodeAsXmlElement("finalPrizePool", finalPrizePool, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "origTournName", origTournName);
	winners.toXmlString("winners", _buf);
	Atf::XmlElement::encodeAsXmlElement("criteria", criteria, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("bounty", bounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlagsServInt", tournFlagsServInt, _buf);
	Atf::XmlElement::encodeAsXmlElement("groupReference", groupReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("pokerNgGroup", pokerNgGroup, _buf);
	siteVisibilityMaskEx.toXmlString("siteVisibilityMaskEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool ShadowLobby::publication::ReplaySubscr_Static::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournamentId"))
		{
			tournamentId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("serverObj"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObj)) return false;
		}
		else if (_element.equals("whenStart"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenStart);
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournMask"))
		{
			tournMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("info"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, info)) return false;
		}
		else if (_element.equals("siteVisibilityMask"))
		{
			siteVisibilityMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenStart_t"))
		{
			whenStart_t = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournMask2"))
		{
			tournMask2 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournMask3"))
		{
			tournMask3 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournMask4"))
		{
			tournMask4 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("tournMask5"))
		{
			tournMask5 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournMask6"))
		{
			tournMask6 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandVisibilityMask"))
		{
			brandVisibilityMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("origTournDate"))
		{
			Atf::AtfTempl<SrvDate>::FromXmlString(_value, origTournDate);
		}
		else if (_element.equals("finalPrizePool"))
		{
			finalPrizePool = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("origTournName"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, origTournName);
		}
		else if (_element.equals("winners"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< ReplaySubscr_Winner, 4 > >::FromXmlString(_value, winners)) return false;
		}
		else if (_element.equals("criteria"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, criteria)) return false;
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bounty"))
		{
			bounty = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayers"))
		{
			maxPlayers = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlags"))
		{
			tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlags2"))
		{
			tournFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlagsServInt"))
		{
			tournFlagsServInt = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("groupReference"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, groupReference)) return false;
		}
		else if (_element.equals("pokerNgGroup"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, pokerNgGroup)) return false;
		}
		else if (_element.equals("siteVisibilityMaskEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, siteVisibilityMaskEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void ShadowLobby::publication::ReplaySubscr_Static::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournamentId);
	_msg.composeString(server);
	_msg.composeString(serverObj);
	_msg.composeSrvTime(whenStart);
	_msg.composeString(name);
	_msg.composeBYTE(game);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(tournMask);
	_msg.composeString(info);
	_msg.composeUINT32(siteVisibilityMask);
	_msg.composeUINT32(whenStart_t);
	_msg.composeUINT32(tournMask2);
	_msg.composeUINT32(tournMask3);
	_msg.composeUINT32(tournMask4);
	_msg.composeString(currency);
	_msg.composeUINT32(tournMask5);
	_msg.composeUINT32(tournMask6);
	_msg.composeUINT32(brandVisibilityMask);
	CommMsgBody _msg0;
	_msg0.composeSrvDate(origTournDate);
	_msg0.composeINT64(finalPrizePool);
	origTournName.compose(_msg0);
	winners.composeMsg(_msg0, _ignoreJSON);
	_msg.composeMsgBody(_msg0);
	_msg.composeString(criteria);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeINT64(buyIn);
	_msg.composeINT64(rake);
	_msg.composeINT64(bounty);
	_msg.composeINT32(maxPlayers);
	_msg.composeUINT32(tournFlags);
	_msg.composeUINT64(tournFlags2);
	_msg.composeUINT32(tournFlagsServInt);
	_msg.composeString(groupReference);
	_msg.composeString(pokerNgGroup);
	siteVisibilityMaskEx.composeMsg(_msg, _ignoreJSON);
}

void ShadowLobby::publication::ReplaySubscr_Static::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournamentId);
	_parser.parseStringP(server);
	_parser.parseStringP(serverObj);
	_parser.parseSrvTime(whenStart);
	_parser.parseStringP(name);
	_parser.parseBYTE(game);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(tournMask);
	_parser.parseStringP(info);
	_parser.parseUINT32(siteVisibilityMask);
	_parser.parseUINT32(whenStart_t);
	_parser.parseUINT32(tournMask2);
	_parser.parseUINT32(tournMask3);
	_parser.parseUINT32(tournMask4);
	_parser.parseStringP(currency);
	_parser.parseUINT32(tournMask5);
	_parser.parseUINT32(tournMask6);
	_parser.parseUINT32(brandVisibilityMask);
	parseAnonymousMsgBody0(_parser);
	_parser.parseStringP(criteria);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isPlayMoney);
	_parser.parseINT64(buyIn);
	_parser.parseINT64(rake);
	_parser.parseINT64(bounty);
	_parser.parseINT32(maxPlayers);
	_parser.parseUINT32(tournFlags);
	_parser.parseUINT64(tournFlags2);
	_parser.parseUINT32(tournFlagsServInt);
	_parser.parseStringP(groupReference);
	_parser.parseStringP(pokerNgGroup);
	siteVisibilityMaskEx.parseMsg(_parser);
}

const char *ShadowLobby::publication::ReplaySubscr_Static::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournamentId", tournamentId);
	_jsonstr.compose("server", server);
	_jsonstr.compose("serverObj", serverObj);
	_jsonstr.compose("whenStart", whenStart);
	_jsonstr.compose("name", name);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("tournMask", tournMask);
	_jsonstr.compose("info", info);
	_jsonstr.compose("siteVisibilityMask", siteVisibilityMask);
	_jsonstr.compose("whenStart_t", whenStart_t);
	_jsonstr.compose("tournMask2", tournMask2);
	_jsonstr.compose("tournMask3", tournMask3);
	_jsonstr.compose("tournMask4", tournMask4);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("tournMask5", tournMask5);
	_jsonstr.compose("tournMask6", tournMask6);
	_jsonstr.compose("brandVisibilityMask", brandVisibilityMask);
	_jsonstr.compose("origTournDate", origTournDate);
	_jsonstr.compose("finalPrizePool", finalPrizePool);
	_jsonstr.compose("origTournName", origTournName);
	_jsonstr.compose("winners", winners);
	_jsonstr.compose("criteria", criteria);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("bounty", bounty);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("tournFlags", tournFlags);
	_jsonstr.compose("tournFlags2", tournFlags2);
	_jsonstr.compose("tournFlagsServInt", tournFlagsServInt);
	_jsonstr.compose("groupReference", groupReference);
	_jsonstr.compose("pokerNgGroup", pokerNgGroup);
	_jsonstr.compose("siteVisibilityMaskEx", siteVisibilityMaskEx);
	return _buf.c_str();
}

void ShadowLobby::publication::ReplaySubscr_Static::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournamentId", tournamentId);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("serverObj", serverObj);
	_jparser.parseByNameThrow("whenStart", whenStart);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("tournMask", tournMask);
	_jparser.parseByNameThrow("info", info);
	_jparser.parseByNameThrow("siteVisibilityMask", siteVisibilityMask);
	_jparser.parseByNameThrow("whenStart_t", whenStart_t);
	_jparser.parseByNameThrow("tournMask2", tournMask2);
	_jparser.parseByNameThrow("tournMask3", tournMask3);
	_jparser.parseByNameThrow("tournMask4", tournMask4);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("tournMask5", tournMask5);
	_jparser.parseByNameThrow("tournMask6", tournMask6);
	_jparser.parseByNameThrow("brandVisibilityMask", brandVisibilityMask);
	_jparser.parseByNameThrow("origTournDate", origTournDate);
	_jparser.parseByNameThrow("finalPrizePool", finalPrizePool);
	_jparser.parseByNameThrow("origTournName", origTournName);
	_jparser.parseByNameThrow("winners", winners);
	_jparser.parseByNameThrow("criteria", criteria);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("bounty", bounty);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("tournFlags", tournFlags);
	_jparser.parseByNameThrow("tournFlags2", tournFlags2);
	_jparser.parseByNameThrow("tournFlagsServInt", tournFlagsServInt);
	_jparser.parseByNameThrow("groupReference", groupReference);
	_jparser.parseByNameThrow("pokerNgGroup", pokerNgGroup);
	_jparser.parseByNameThrow("siteVisibilityMaskEx", siteVisibilityMaskEx);
}

/* static */ void ShadowLobby::publication::ReplaySubscr_Static::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournamentId; _jparser.validateByNameThrow("tournamentId", tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString serverObj; _jparser.validateByNameThrow("serverObj", serverObj);
	AtfValidator::validateInt(_descr, "serverObj", serverObj.length(), _checker, __FILE__, __LINE__);
	SrvTime whenStart; _jparser.validateByNameThrow("whenStart", whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _jparser.validateByNameThrow("tournMask", tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	PString info; _jparser.validateByNameThrow("info", info);
	AtfValidator::validateInt(_descr, "info", info.length(), _checker, __FILE__, __LINE__);
	UINT32 siteVisibilityMask; _jparser.validateByNameThrow("siteVisibilityMask", siteVisibilityMask);
	AtfValidator::validateInt(_descr, "siteVisibilityMask", siteVisibilityMask, _checker, __FILE__, __LINE__);
	UINT32 whenStart_t; _jparser.validateByNameThrow("whenStart_t", whenStart_t);
	AtfValidator::validateInt(_descr, "whenStart_t", whenStart_t, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _jparser.validateByNameThrow("tournMask2", tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _jparser.validateByNameThrow("tournMask3", tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _jparser.validateByNameThrow("tournMask4", tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 tournMask5; _jparser.validateByNameThrow("tournMask5", tournMask5);
	AtfValidator::validateInt(_descr, "tournMask5", tournMask5, _checker, __FILE__, __LINE__);
	UINT32 tournMask6; _jparser.validateByNameThrow("tournMask6", tournMask6);
	AtfValidator::validateInt(_descr, "tournMask6", tournMask6, _checker, __FILE__, __LINE__);
	UINT32 brandVisibilityMask; _jparser.validateByNameThrow("brandVisibilityMask", brandVisibilityMask);
	AtfValidator::validateInt(_descr, "brandVisibilityMask", brandVisibilityMask, _checker, __FILE__, __LINE__);
	SrvDate origTournDate; _jparser.validateByNameThrow("origTournDate", origTournDate);
	AtfValidator::validateSrvDateTime(_descr, "origTournDate", origTournDate, _checker, __FILE__, __LINE__);
	INT64 finalPrizePool; _jparser.validateByNameThrow("finalPrizePool", finalPrizePool);
	AtfValidator::validateInt(_descr, "finalPrizePool", finalPrizePool, _checker, __FILE__, __LINE__);
	I18nPString origTournName; _jparser.validateByNameThrow("origTournName", origTournName);
	Atf::AtfVectorBase< ReplaySubscr_Winner > winners; _jparser.validateByNameThrow("winners", winners);
	AtfValidator::validateInt(_descr, "winners", winners.size(), _checker, __FILE__, __LINE__);
	PString criteria; _jparser.validateByNameThrow("criteria", criteria);
	AtfValidator::validateInt(_descr, "criteria", criteria.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	INT64 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT64 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	INT64 bounty; _jparser.validateByNameThrow("bounty", bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	INT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _jparser.validateByNameThrow("tournFlagsServInt", tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	PString groupReference; _jparser.validateByNameThrow("groupReference", groupReference);
	AtfValidator::validateInt(_descr, "groupReference", groupReference.length(), _checker, __FILE__, __LINE__);
	PString pokerNgGroup; _jparser.validateByNameThrow("pokerNgGroup", pokerNgGroup);
	AtfValidator::validateInt(_descr, "pokerNgGroup", pokerNgGroup.length(), _checker, __FILE__, __LINE__);
	PSiteMask siteVisibilityMaskEx; _jparser.validateByNameThrow("siteVisibilityMaskEx", siteVisibilityMaskEx);
}

/*static*/ void ShadowLobby::publication::ReplaySubscr_Static::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 tournamentId; _parser.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	SrvTime whenStart; _parser.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _parser.parseUINT32(tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "info"); size_t szInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "info", szInfo, _checker, __FILE__, __LINE__);
	UINT32 siteVisibilityMask; _parser.parseUINT32(siteVisibilityMask);
	AtfValidator::validateInt(_descr, "siteVisibilityMask", siteVisibilityMask, _checker, __FILE__, __LINE__);
	UINT32 whenStart_t; _parser.parseUINT32(whenStart_t);
	AtfValidator::validateInt(_descr, "whenStart_t", whenStart_t, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _parser.parseUINT32(tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _parser.parseUINT32(tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _parser.parseUINT32(tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 tournMask5; _parser.parseUINT32(tournMask5);
	AtfValidator::validateInt(_descr, "tournMask5", tournMask5, _checker, __FILE__, __LINE__);
	UINT32 tournMask6; _parser.parseUINT32(tournMask6);
	AtfValidator::validateInt(_descr, "tournMask6", tournMask6, _checker, __FILE__, __LINE__);
	UINT32 brandVisibilityMask; _parser.parseUINT32(brandVisibilityMask);
	AtfValidator::validateInt(_descr, "brandVisibilityMask", brandVisibilityMask, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	_parser.parseStringN(_dummy, 0, "criteria"); size_t szCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "criteria", szCriteria, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	INT64 buyIn; _parser.parseINT64(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT64 rake; _parser.parseINT64(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	INT64 bounty; _parser.parseINT64(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	INT32 maxPlayers; _parser.parseINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _parser.parseUINT32(tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "groupReference"); size_t szGroupReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "groupReference", szGroupReference, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "pokerNgGroup"); size_t szPokerNgGroup = strlen(_dummy);
	AtfValidator::validateInt(_descr, "pokerNgGroup", szPokerNgGroup, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("siteVisibilityMaskEx"), _fieldsWithUnparsedContent);
}

void ShadowLobby::publication::ReplaySubscr_Static::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseSrvDate(origTournDate);
	_parser0.parseINT64(finalPrizePool);
	origTournName.parse(_parser0);
	winners.parseMsg(_parser0);
}

/*static*/ void ShadowLobby::publication::ReplaySubscr_Static::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	SrvDate origTournDate; _parser0.parseSrvDate(origTournDate);
	AtfValidator::validateSrvDateTime(_descr, "origTournDate", origTournDate, _checker, __FILE__, __LINE__);
	INT64 finalPrizePool; _parser0.parseINT64(finalPrizePool);
	AtfValidator::validateInt(_descr, "finalPrizePool", finalPrizePool, _checker, __FILE__, __LINE__);
	I18nPString origTournName; origTournName.parse(_parser0);
	PString _descbuf;
	int szWinners = Atf::LAtfVector< ReplaySubscr_Winner, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("winners"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "winners", szWinners, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ReplaySubscr_Status
//=================================================================

ShadowLobby::publication::ReplaySubscr_Status::ReplaySubscr_Status()
{
	clear();
}

void ShadowLobby::publication::ReplaySubscr_Status::clear()
{
	status = 0;
}

bool ShadowLobby::publication::ReplaySubscr_Status::equals(const ReplaySubscr_Status& _o) const
{
	return status == _o.status;
}

const char *ShadowLobby::publication::ReplaySubscr_Status::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append('}');
	return _buf.c_str();
}

const char *ShadowLobby::publication::ReplaySubscr_Status::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool ShadowLobby::publication::ReplaySubscr_Status::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void ShadowLobby::publication::ReplaySubscr_Status::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(status);
}

void ShadowLobby::publication::ReplaySubscr_Status::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(status);
}

const char *ShadowLobby::publication::ReplaySubscr_Status::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("status", status);
	return _buf.c_str();
}

void ShadowLobby::publication::ReplaySubscr_Status::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("status", status);
}

/* static */ void ShadowLobby::publication::ReplaySubscr_Status::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
}

/*static*/ void ShadowLobby::publication::ReplaySubscr_Status::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
}

