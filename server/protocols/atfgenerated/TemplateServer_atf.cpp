/**
 * TemplateServer_atf.cpp
 *
 * This file was auto-generated from TemplateServer_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor TemplateServer_atf.txt
 */
 
#include "TemplateServer_atf.h"

//=================================================================
//                    ContentDataSectionStruct
//=================================================================

TemplateServerATF::ContentDataSectionStruct::ContentDataSectionStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::ContentDataSectionStruct::ContentDataSectionStruct(ContentDataSectionStruct&& _o)
	: locale(std::move(_o.locale))
	, text(std::move(_o.text))
{
}

TemplateServerATF::ContentDataSectionStruct& TemplateServerATF::ContentDataSectionStruct::operator=(ContentDataSectionStruct&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		text = std::move(_o.text);
	}
	return *this;
}

#endif

void TemplateServerATF::ContentDataSectionStruct::clear()
{
	locale = 0;
	text.clear();
}

bool TemplateServerATF::ContentDataSectionStruct::equals(const ContentDataSectionStruct& _o) const
{
	return locale == _o.locale &&
		Atf::atfPStringEquals(text, _o.text);
}

const char *TemplateServerATF::ContentDataSectionStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("text=");
	_buf.append(text);
	_buf.append('}');
	return _buf.c_str();
}

const char *TemplateServerATF::ContentDataSectionStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("text", text, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TemplateServerATF::ContentDataSectionStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("locale"))
		{
			locale = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("text"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, text)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TemplateServerATF::ContentDataSectionStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ContentDataSectionStruct())) // not empty
	{
		_body.composeUINT32(locale);
		_body.composeString(text);
	}

	_msg.composeMsgBody(_body);
}

void TemplateServerATF::ContentDataSectionStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	_parser0.parseStringP(text);
}

const char *TemplateServerATF::ContentDataSectionStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("text", text);
	return _buf.c_str();
}

void TemplateServerATF::ContentDataSectionStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("text", text);
}

/* static */ void TemplateServerATF::ContentDataSectionStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	PString text; _jparser.validateByNameThrow("text", text);
	AtfValidator::validateInt(_descr, "text", text.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TemplateServerATF::ContentDataSectionStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "text"); size_t szText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "text", szText, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ContentDataStruct
//=================================================================

TemplateServerATF::ContentDataStruct::ContentDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::ContentDataStruct::ContentDataStruct(ContentDataStruct&& _o)
	: sectionCode(std::move(_o.sectionCode))
	, sections(std::move(_o.sections))
{
}

TemplateServerATF::ContentDataStruct& TemplateServerATF::ContentDataStruct::operator=(ContentDataStruct&& _o)
{
	if(this != &_o)
	{
		sectionCode = std::move(_o.sectionCode);
		sections = std::move(_o.sections);
	}
	return *this;
}

#endif

void TemplateServerATF::ContentDataStruct::clear()
{
	sectionCode = 0;
	sections.clear();
}

bool TemplateServerATF::ContentDataStruct::equals(const ContentDataStruct& _o) const
{
	return sectionCode == _o.sectionCode &&
		sections.equals(_o.sections);
}

const char *TemplateServerATF::ContentDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sectionCode=");
	_buf.appendUint(sectionCode);
	_buf.append(',');
	_buf.append("sections=");
	sections.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TemplateServerATF::ContentDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("sectionCode", sectionCode, _buf);
	sections.toXmlString("sections", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TemplateServerATF::ContentDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("sectionCode"))
		{
			sectionCode = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sections"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< ContentDataSectionStruct, 4 > >::FromXmlString(_value, sections)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TemplateServerATF::ContentDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ContentDataStruct())) // not empty
	{
		_body.composeUINT32(sectionCode);
		sections.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void TemplateServerATF::ContentDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(sectionCode);
	sections.parseMsg(_parser0);
}

const char *TemplateServerATF::ContentDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sectionCode", sectionCode);
	_jsonstr.compose("sections", sections);
	return _buf.c_str();
}

void TemplateServerATF::ContentDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sectionCode", sectionCode);
	_jparser.parseByNameThrow("sections", sections);
}

/* static */ void TemplateServerATF::ContentDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 sectionCode; _jparser.validateByNameThrow("sectionCode", sectionCode);
	AtfValidator::validateInt(_descr, "sectionCode", sectionCode, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ContentDataSectionStruct > sections; _jparser.validateByNameThrow("sections", sections);
	AtfValidator::validateInt(_descr, "sections", sections.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TemplateServerATF::ContentDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 sectionCode; _parser0.parseUINT32(sectionCode);
	AtfValidator::validateInt(_descr, "sectionCode", sectionCode, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSections = Atf::LAtfVector< ContentDataSectionStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sections"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sections", szSections, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ContentStruct
//=================================================================

TemplateServerATF::ContentStruct::ContentStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::ContentStruct::ContentStruct(ContentStruct&& _o)
	: contentId(std::move(_o.contentId))
	, criteria(std::move(_o.criteria))
	, from(std::move(_o.from))
	, until(std::move(_o.until))
	, contentDatas(std::move(_o.contentDatas))
{
}

TemplateServerATF::ContentStruct& TemplateServerATF::ContentStruct::operator=(ContentStruct&& _o)
{
	if(this != &_o)
	{
		contentId = std::move(_o.contentId);
		criteria = std::move(_o.criteria);
		from = std::move(_o.from);
		until = std::move(_o.until);
		contentDatas = std::move(_o.contentDatas);
	}
	return *this;
}

#endif

void TemplateServerATF::ContentStruct::clear()
{
	contentId = 0;
	criteria.clear();
	from.setNull();
	until.setNull();
	contentDatas.clear();
}

bool TemplateServerATF::ContentStruct::equals(const ContentStruct& _o) const
{
	return contentId == _o.contentId &&
		Atf::atfPStringEquals(criteria, _o.criteria) &&
		from.equals(_o.from) &&
		until.equals(_o.until) &&
		contentDatas.equals(_o.contentDatas);
}

const char *TemplateServerATF::ContentStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("contentId=");
	_buf.appendUint(contentId);
	_buf.append(',');
	_buf.append("criteria=");
	_buf.append(criteria);
	_buf.append(',');
	_buf.append("from=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, from);
	_buf.append(',');
	_buf.append("until=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, until);
	_buf.append(',');
	_buf.append("contentDatas=");
	contentDatas.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TemplateServerATF::ContentStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("contentId", contentId, _buf);
	Atf::XmlElement::encodeAsXmlElement("criteria", criteria, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "from", from);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "until", until);
	contentDatas.toXmlString("contentDatas", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TemplateServerATF::ContentStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("contentId"))
		{
			contentId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("criteria"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, criteria)) return false;
		}
		else if (_element.equals("from"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, from);
		}
		else if (_element.equals("until"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, until);
		}
		else if (_element.equals("contentDatas"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< ContentDataStruct, 4 > >::FromXmlString(_value, contentDatas)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TemplateServerATF::ContentStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ContentStruct())) // not empty
	{
		_body.composeUINT32(contentId);
		_body.composeString(criteria);
		_body.composeSrvTime(from);
		_body.composeSrvTime(until);
		contentDatas.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void TemplateServerATF::ContentStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(contentId);
	_parser0.parseStringP(criteria);
	_parser0.parseSrvTime(from);
	_parser0.parseSrvTime(until);
	contentDatas.parseMsg(_parser0);
}

const char *TemplateServerATF::ContentStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("contentId", contentId);
	_jsonstr.compose("criteria", criteria);
	_jsonstr.compose("from", from);
	_jsonstr.compose("until", until);
	_jsonstr.compose("contentDatas", contentDatas);
	return _buf.c_str();
}

void TemplateServerATF::ContentStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("contentId", contentId);
	_jparser.parseByNameThrow("criteria", criteria);
	_jparser.parseByNameThrow("from", from);
	_jparser.parseByNameThrow("until", until);
	_jparser.parseByNameThrow("contentDatas", contentDatas);
}

/* static */ void TemplateServerATF::ContentStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 contentId; _jparser.validateByNameThrow("contentId", contentId);
	AtfValidator::validateInt(_descr, "contentId", contentId, _checker, __FILE__, __LINE__);
	PString criteria; _jparser.validateByNameThrow("criteria", criteria);
	AtfValidator::validateInt(_descr, "criteria", criteria.length(), _checker, __FILE__, __LINE__);
	SrvTime from; _jparser.validateByNameThrow("from", from);
	AtfValidator::validateSrvDateTime(_descr, "from", from, _checker, __FILE__, __LINE__);
	SrvTime until; _jparser.validateByNameThrow("until", until);
	AtfValidator::validateSrvDateTime(_descr, "until", until, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ContentDataStruct > contentDatas; _jparser.validateByNameThrow("contentDatas", contentDatas);
	AtfValidator::validateInt(_descr, "contentDatas", contentDatas.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TemplateServerATF::ContentStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 contentId; _parser0.parseUINT32(contentId);
	AtfValidator::validateInt(_descr, "contentId", contentId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "criteria"); size_t szCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "criteria", szCriteria, _checker, __FILE__, __LINE__);
	SrvTime from; _parser0.parseSrvTime(from);
	AtfValidator::validateSrvDateTime(_descr, "from", from, _checker, __FILE__, __LINE__);
	SrvTime until; _parser0.parseSrvTime(until);
	AtfValidator::validateSrvDateTime(_descr, "until", until, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szContentDatas = Atf::LAtfVector< ContentDataStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("contentDatas"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "contentDatas", szContentDatas, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TemplateStruct
//=================================================================

TemplateServerATF::TemplateStruct::TemplateStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::TemplateStruct::TemplateStruct(TemplateStruct&& _o)
	: saveTemplateMask(std::move(_o.saveTemplateMask))
	, templateId(std::move(_o.templateId))
	, type(std::move(_o.type))
	, name(std::move(_o.name))
	, templateCode(std::move(_o.templateCode))
	, description(std::move(_o.description))
	, status(std::move(_o.status))
	, content(std::move(_o.content))
{
}

TemplateServerATF::TemplateStruct& TemplateServerATF::TemplateStruct::operator=(TemplateStruct&& _o)
{
	if(this != &_o)
	{
		saveTemplateMask = std::move(_o.saveTemplateMask);
		templateId = std::move(_o.templateId);
		type = std::move(_o.type);
		name = std::move(_o.name);
		templateCode = std::move(_o.templateCode);
		description = std::move(_o.description);
		status = std::move(_o.status);
		content = std::move(_o.content);
	}
	return *this;
}

#endif

void TemplateServerATF::TemplateStruct::clear()
{
	saveTemplateMask = 0;
	templateId = 0;
	type = 0;
	name.clear();
	templateCode.clear();
	description.clear();
	status = 0;
	content.clear();
}

bool TemplateServerATF::TemplateStruct::equals(const TemplateStruct& _o) const
{
	return saveTemplateMask == _o.saveTemplateMask &&
		templateId == _o.templateId &&
		type == _o.type &&
		Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(templateCode, _o.templateCode) &&
		Atf::atfPStringEquals(description, _o.description) &&
		status == _o.status &&
		content.equals(_o.content);
}

const char *TemplateServerATF::TemplateStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("saveTemplateMask=");
	_buf.appendUint(saveTemplateMask);
	_buf.append(',');
	_buf.append("templateId=");
	_buf.appendUint(templateId);
	_buf.append(',');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("templateCode=");
	_buf.append(templateCode);
	_buf.append(',');
	_buf.append("description=");
	_buf.append(description);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("content=");
	content.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TemplateServerATF::TemplateStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("saveTemplateMask", saveTemplateMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("templateId", templateId, _buf);
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("templateCode", templateCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("description", description, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	content.toXmlString("content", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TemplateServerATF::TemplateStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("saveTemplateMask"))
		{
			saveTemplateMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("templateId"))
		{
			templateId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("type"))
		{
			type = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("templateCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, templateCode)) return false;
		}
		else if (_element.equals("description"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, description)) return false;
		}
		else if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("content"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< ContentStruct, 4 > >::FromXmlString(_value, content)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TemplateServerATF::TemplateStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TemplateStruct())) // not empty
	{
		_body.composeUINT32(saveTemplateMask);
		_body.composeUINT32(templateId);
		_body.composeUINT32(type);
		_body.composeString(name);
		_body.composeString(templateCode);
		_body.composeString(description);
		_body.composeUINT32(status);
		content.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void TemplateServerATF::TemplateStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(saveTemplateMask);
	_parser0.parseUINT32(templateId);
	_parser0.parseUINT32(type);
	_parser0.parseStringP(name);
	_parser0.parseStringP(templateCode);
	_parser0.parseStringP(description);
	_parser0.parseUINT32(status);
	content.parseMsg(_parser0);
}

const char *TemplateServerATF::TemplateStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("saveTemplateMask", saveTemplateMask);
	_jsonstr.compose("templateId", templateId);
	_jsonstr.compose("type", type);
	_jsonstr.compose("name", name);
	_jsonstr.compose("templateCode", templateCode);
	_jsonstr.compose("description", description);
	_jsonstr.compose("status", status);
	_jsonstr.compose("content", content);
	return _buf.c_str();
}

void TemplateServerATF::TemplateStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("saveTemplateMask", saveTemplateMask);
	_jparser.parseByNameThrow("templateId", templateId);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("templateCode", templateCode);
	_jparser.parseByNameThrow("description", description);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("content", content);
}

/* static */ void TemplateServerATF::TemplateStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 saveTemplateMask; _jparser.validateByNameThrow("saveTemplateMask", saveTemplateMask);
	AtfValidator::validateInt(_descr, "saveTemplateMask", saveTemplateMask, _checker, __FILE__, __LINE__);
	UINT32 templateId; _jparser.validateByNameThrow("templateId", templateId);
	AtfValidator::validateInt(_descr, "templateId", templateId, _checker, __FILE__, __LINE__);
	UINT32 type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString templateCode; _jparser.validateByNameThrow("templateCode", templateCode);
	AtfValidator::validateInt(_descr, "templateCode", templateCode.length(), _checker, __FILE__, __LINE__);
	PString description; _jparser.validateByNameThrow("description", description);
	AtfValidator::validateInt(_descr, "description", description.length(), _checker, __FILE__, __LINE__);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ContentStruct > content; _jparser.validateByNameThrow("content", content);
	AtfValidator::validateInt(_descr, "content", content.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TemplateServerATF::TemplateStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 saveTemplateMask; _parser0.parseUINT32(saveTemplateMask);
	AtfValidator::validateInt(_descr, "saveTemplateMask", saveTemplateMask, _checker, __FILE__, __LINE__);
	UINT32 templateId; _parser0.parseUINT32(templateId);
	AtfValidator::validateInt(_descr, "templateId", templateId, _checker, __FILE__, __LINE__);
	UINT32 type; _parser0.parseUINT32(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "templateCode"); size_t szTemplateCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "templateCode", szTemplateCode, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "description"); size_t szDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "description", szDescription, _checker, __FILE__, __LINE__);
	UINT32 status; _parser0.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szContent = Atf::LAtfVector< ContentStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("content"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "content", szContent, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES
//=================================================================

TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES(Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES&& _o)
	: templates(std::move(_o.templates))
{
}

TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES& TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::operator=(Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES&& _o)
{
	if(this != &_o)
	{
		templates = std::move(_o.templates);
	}
	return *this;
}

#endif

void TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::clear()
{
	templates.clear();
}

bool TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::equals(const Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES& _o) const
{
	return templates.equals(_o.templates);
}

bool TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::equals(Atf::MessageProtocol* _other) const
{
	if (TS_Q_ADMIN_SAVE_BRANDED_LOBBIES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES*)_other));
}

const char *TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(TS_Q_ADMIN_SAVE_BRANDED_LOBBIES).append(")");
	_buf.append(',');
	_buf.append("templates=");
	templates.toTraceString(_buf);
	return _buf.c_str();
}

const char *TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(TS_Q_ADMIN_SAVE_BRANDED_LOBBIES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	templates.toXmlString("templates", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("templates"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TemplateStruct, 4 > >::FromXmlString(_value, templates)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	templates.composeMsg(_msg, _ignoreJSON);
}

void TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::parseMsg(CommMsgParser& _parser)
{
	templates.parseMsg(_parser);
}

const char *TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("templates", templates);
	return _buf.c_str();
}

void TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("templates", templates);
}

/*static*/ void TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_Q_ADMIN_SAVE_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TemplateStruct > templates; _jparser.validateByNameThrow("templates", templates);
	AtfValidator::validateInt(_descr, "templates", templates.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TemplateServerATF::Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_Q_ADMIN_SAVE_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTemplates = Atf::LAtfVector< TemplateStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("templates"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "templates", szTemplates, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES
//=================================================================

TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES(Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES&& _o)
	: errCode(std::move(_o.errCode))
	, msg(std::move(_o.msg))
{
}

TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES& TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::operator=(Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		msg = std::move(_o.msg);
	}
	return *this;
}

#endif

void TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::clear()
{
	errCode = 0;
	msg.clear();
}

bool TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::equals(const Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(msg, _o.msg);
}

bool TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::equals(Atf::MessageProtocol* _other) const
{
	if (TS_A_ADMIN_SAVE_BRANDED_LOBBIES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES*)_other));
}

const char *TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(TS_A_ADMIN_SAVE_BRANDED_LOBBIES).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("msg=");
	_buf.append(msg);
	return _buf.c_str();
}

const char *TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(TS_A_ADMIN_SAVE_BRANDED_LOBBIES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("msg", msg, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("msg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, msg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(msg);
}

void TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(msg);
}

const char *TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("msg", msg);
	return _buf.c_str();
}

void TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("msg", msg);
}

/*static*/ void TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_A_ADMIN_SAVE_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString msg; _jparser.validateByNameThrow("msg", msg);
	AtfValidator::validateInt(_descr, "msg", msg.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TemplateServerATF::Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_A_ADMIN_SAVE_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "msg"); size_t szMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "msg", szMsg, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_TS_Q_PS_NEED_DATA
//=================================================================

TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::Protocol_TS_Q_PS_NEED_DATA()
{
	clear();
}

void TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::clear()
{
	templateType = 0;
}

bool TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::equals(const Protocol_TS_Q_PS_NEED_DATA& _o) const
{
	return templateType == _o.templateType;
}

bool TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::equals(Atf::MessageProtocol* _other) const
{
	if (TS_Q_PS_NEED_DATA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_TS_Q_PS_NEED_DATA*)_other));
}

const char *TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(TS_Q_PS_NEED_DATA).append(")");
	_buf.append(',');
	_buf.append("templateType=");
	_buf.appendInt(templateType);
	return _buf.c_str();
}

const char *TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(TS_Q_PS_NEED_DATA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("templateType", templateType, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("templateType"))
			{
				templateType = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(templateType);
}

void TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(templateType);
}

const char *TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("templateType", templateType);
	return _buf.c_str();
}

void TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("templateType", templateType);
}

/*static*/ void TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_Q_PS_NEED_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 templateType; _jparser.validateByNameThrow("templateType", templateType);
	AtfValidator::validateInt(_descr, "templateType", templateType, _checker, __FILE__, __LINE__);
}

/*static*/ void TemplateServerATF::Protocol_TS_Q_PS_NEED_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_Q_PS_NEED_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 templateType; _parser.parseINT32(templateType);
	AtfValidator::validateInt(_descr, "templateType", templateType, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_TS_A_PS_NEED_DATA
//=================================================================

TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::Protocol_TS_A_PS_NEED_DATA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::Protocol_TS_A_PS_NEED_DATA(Protocol_TS_A_PS_NEED_DATA&& _o)
	: errCode(std::move(_o.errCode))
	, sqlErr(std::move(_o.sqlErr))
	, templates(std::move(_o.templates))
{
}

TemplateServerATF::Protocol_TS_A_PS_NEED_DATA& TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::operator=(Protocol_TS_A_PS_NEED_DATA&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		sqlErr = std::move(_o.sqlErr);
		templates = std::move(_o.templates);
	}
	return *this;
}

#endif

void TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::clear()
{
	errCode = 0;
	sqlErr.clear();
	templates.clear();
}

bool TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::equals(const Protocol_TS_A_PS_NEED_DATA& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(sqlErr, _o.sqlErr) &&
		templates.equals(_o.templates);
}

bool TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::equals(Atf::MessageProtocol* _other) const
{
	if (TS_A_PS_NEED_DATA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_TS_A_PS_NEED_DATA*)_other));
}

const char *TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(TS_A_PS_NEED_DATA).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("sqlErr=");
		_buf.append(sqlErr);
	}
	else
	{
		_buf.append(',');
		_buf.append("templates=");
		templates.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(TS_A_PS_NEED_DATA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("sqlErr", sqlErr, _buf);
	}
	else
	{
		templates.toXmlString("templates", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sqlErr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, sqlErr)) return false;
			}
			else if (_element.equals("templates"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TemplateStruct, 4 > >::FromXmlString(_value, templates)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(sqlErr);
	}
	else
	{
		templates.composeMsg(_msg, _ignoreJSON);
	}
}

void TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(sqlErr);
	}
	else
	{
		templates.parseMsg(_parser);
	}
}

const char *TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("sqlErr", sqlErr);
	}
	else
	{
		_jsonstr.compose("templates", templates);
	}
	return _buf.c_str();
}

void TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("sqlErr", sqlErr);
	}
	else
	{
		_jparser.parseByNameThrow("templates", templates);
	}
}

/*static*/ void TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_A_PS_NEED_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString sqlErr; _jparser.validateByNameThrow("sqlErr", sqlErr);
		AtfValidator::validateInt(_descr, "sqlErr", sqlErr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< TemplateStruct > templates; _jparser.validateByNameThrow("templates", templates);
		AtfValidator::validateInt(_descr, "templates", templates.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void TemplateServerATF::Protocol_TS_A_PS_NEED_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_A_PS_NEED_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "sqlErr"); size_t szSqlErr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "sqlErr", szSqlErr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTemplates = Atf::LAtfVector< TemplateStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("templates"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "templates", szTemplates, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_TS_Q_HFS_NEED_DATA
//=================================================================

TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::Protocol_TS_Q_HFS_NEED_DATA()
{
	clear();
}

void TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::clear()
{
	templateType = 0;
}

bool TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::equals(const Protocol_TS_Q_HFS_NEED_DATA& _o) const
{
	return templateType == _o.templateType;
}

bool TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::equals(Atf::MessageProtocol* _other) const
{
	if (TS_Q_HFS_NEED_DATA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_TS_Q_HFS_NEED_DATA*)_other));
}

const char *TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(TS_Q_HFS_NEED_DATA).append(")");
	_buf.append(',');
	_buf.append("templateType=");
	_buf.appendInt(templateType);
	return _buf.c_str();
}

const char *TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(TS_Q_HFS_NEED_DATA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("templateType", templateType, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("templateType"))
			{
				templateType = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(templateType);
}

void TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(templateType);
}

const char *TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("templateType", templateType);
	return _buf.c_str();
}

void TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("templateType", templateType);
}

/*static*/ void TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_Q_HFS_NEED_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 templateType; _jparser.validateByNameThrow("templateType", templateType);
	AtfValidator::validateInt(_descr, "templateType", templateType, _checker, __FILE__, __LINE__);
}

/*static*/ void TemplateServerATF::Protocol_TS_Q_HFS_NEED_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_Q_HFS_NEED_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 templateType; _parser.parseINT32(templateType);
	AtfValidator::validateInt(_descr, "templateType", templateType, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_TS_A_HFS_NEED_DATA
//=================================================================

TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::Protocol_TS_A_HFS_NEED_DATA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::Protocol_TS_A_HFS_NEED_DATA(Protocol_TS_A_HFS_NEED_DATA&& _o)
	: errCode(std::move(_o.errCode))
	, sqlErr(std::move(_o.sqlErr))
	, templates(std::move(_o.templates))
{
}

TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA& TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::operator=(Protocol_TS_A_HFS_NEED_DATA&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		sqlErr = std::move(_o.sqlErr);
		templates = std::move(_o.templates);
	}
	return *this;
}

#endif

void TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::clear()
{
	errCode = 0;
	sqlErr.clear();
	templates.clear();
}

bool TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::equals(const Protocol_TS_A_HFS_NEED_DATA& _o) const
{
	return errCode == _o.errCode &&
		sqlErr.equals(_o.sqlErr) &&
		templates.equals(_o.templates);
}

bool TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::equals(Atf::MessageProtocol* _other) const
{
	if (TS_A_HFS_NEED_DATA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_TS_A_HFS_NEED_DATA*)_other));
}

const char *TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(TS_A_HFS_NEED_DATA).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("sqlErr=");
		_buf.append(sqlErr);
	}
	else
	{
		_buf.append(',');
		_buf.append("templates=");
		templates.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(TS_A_HFS_NEED_DATA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("sqlErr", sqlErr, _buf);
	}
	else
	{
		templates.toXmlString("templates", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sqlErr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, sqlErr)) return false;
			}
			else if (_element.equals("templates"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TemplateStruct, 4 > >::FromXmlString(_value, templates)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(sqlErr);
	}
	else
	{
		templates.composeMsg(_msg, _ignoreJSON);
	}
}

void TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(sqlErr);
	}
	else
	{
		templates.parseMsg(_parser);
	}
}

const char *TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("sqlErr", sqlErr);
	}
	else
	{
		_jsonstr.compose("templates", templates);
	}
	return _buf.c_str();
}

void TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("sqlErr", sqlErr);
	}
	else
	{
		_jparser.parseByNameThrow("templates", templates);
	}
}

/*static*/ void TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_A_HFS_NEED_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString sqlErr; _jparser.validateByNameThrow("sqlErr", sqlErr);
		AtfValidator::validateInt(_descr, "sqlErr", sqlErr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< TemplateStruct > templates; _jparser.validateByNameThrow("templates", templates);
		AtfValidator::validateInt(_descr, "templates", templates.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void TemplateServerATF::Protocol_TS_A_HFS_NEED_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_A_HFS_NEED_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "sqlErr"); size_t szSqlErr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "sqlErr", szSqlErr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTemplates = Atf::LAtfVector< TemplateStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("templates"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "templates", szTemplates, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_TS_Q_HFS_GET_TEMPLATE_DATA
//=================================================================

TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA()
{
	clear();
}

void TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::clear()
{
	templateId = 0;
}

bool TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::equals(const Protocol_TS_Q_HFS_GET_TEMPLATE_DATA& _o) const
{
	return templateId == _o.templateId;
}

bool TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::equals(Atf::MessageProtocol* _other) const
{
	if (TS_Q_HFS_GET_TEMPLATE_DATA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_TS_Q_HFS_GET_TEMPLATE_DATA*)_other));
}

const char *TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(TS_Q_HFS_GET_TEMPLATE_DATA).append(")");
	_buf.append(',');
	_buf.append("templateId=");
	_buf.appendInt(templateId);
	return _buf.c_str();
}

const char *TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(TS_Q_HFS_GET_TEMPLATE_DATA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("templateId", templateId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("templateId"))
			{
				templateId = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(templateId);
}

void TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(templateId);
}

const char *TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("templateId", templateId);
	return _buf.c_str();
}

void TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("templateId", templateId);
}

/*static*/ void TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_Q_HFS_GET_TEMPLATE_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 templateId; _jparser.validateByNameThrow("templateId", templateId);
	AtfValidator::validateInt(_descr, "templateId", templateId, _checker, __FILE__, __LINE__);
}

/*static*/ void TemplateServerATF::Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_Q_HFS_GET_TEMPLATE_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 templateId; _parser.parseINT32(templateId);
	AtfValidator::validateInt(_descr, "templateId", templateId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_TS_A_HFS_GET_TEMPLATE_DATA
//=================================================================

TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::Protocol_TS_A_HFS_GET_TEMPLATE_DATA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::Protocol_TS_A_HFS_GET_TEMPLATE_DATA(Protocol_TS_A_HFS_GET_TEMPLATE_DATA&& _o)
	: errCode(std::move(_o.errCode))
	, sqlErr(std::move(_o.sqlErr))
	, templates(std::move(_o.templates))
{
}

TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA& TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::operator=(Protocol_TS_A_HFS_GET_TEMPLATE_DATA&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		sqlErr = std::move(_o.sqlErr);
		templates = std::move(_o.templates);
	}
	return *this;
}

#endif

void TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::clear()
{
	errCode = 0;
	sqlErr.clear();
	templates.clear();
}

bool TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::equals(const Protocol_TS_A_HFS_GET_TEMPLATE_DATA& _o) const
{
	return errCode == _o.errCode &&
		sqlErr.equals(_o.sqlErr) &&
		templates.equals(_o.templates);
}

bool TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::equals(Atf::MessageProtocol* _other) const
{
	if (TS_A_HFS_GET_TEMPLATE_DATA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_TS_A_HFS_GET_TEMPLATE_DATA*)_other));
}

const char *TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(TS_A_HFS_GET_TEMPLATE_DATA).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("sqlErr=");
		_buf.append(sqlErr);
	}
	else
	{
		_buf.append(',');
		_buf.append("templates=");
		templates.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(TS_A_HFS_GET_TEMPLATE_DATA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("sqlErr", sqlErr, _buf);
	}
	else
	{
		templates.toXmlString("templates", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sqlErr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, sqlErr)) return false;
			}
			else if (_element.equals("templates"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TemplateStruct, 4 > >::FromXmlString(_value, templates)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(sqlErr);
	}
	else
	{
		templates.composeMsg(_msg, _ignoreJSON);
	}
}

void TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(sqlErr);
	}
	else
	{
		templates.parseMsg(_parser);
	}
}

const char *TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("sqlErr", sqlErr);
	}
	else
	{
		_jsonstr.compose("templates", templates);
	}
	return _buf.c_str();
}

void TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("sqlErr", sqlErr);
	}
	else
	{
		_jparser.parseByNameThrow("templates", templates);
	}
}

/*static*/ void TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_A_HFS_GET_TEMPLATE_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString sqlErr; _jparser.validateByNameThrow("sqlErr", sqlErr);
		AtfValidator::validateInt(_descr, "sqlErr", sqlErr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< TemplateStruct > templates; _jparser.validateByNameThrow("templates", templates);
		AtfValidator::validateInt(_descr, "templates", templates.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void TemplateServerATF::Protocol_TS_A_HFS_GET_TEMPLATE_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "TS_A_HFS_GET_TEMPLATE_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "sqlErr"); size_t szSqlErr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "sqlErr", szSqlErr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTemplates = Atf::LAtfVector< TemplateStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("templates"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "templates", szTemplates, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* TemplateServerATF::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case TS_A_ADMIN_SAVE_BRANDED_LOBBIES: _obj = new Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES(); break;
			case TS_A_HFS_GET_TEMPLATE_DATA: _obj = new Protocol_TS_A_HFS_GET_TEMPLATE_DATA(); break;
			case TS_A_HFS_NEED_DATA: _obj = new Protocol_TS_A_HFS_NEED_DATA(); break;
			case TS_A_PS_NEED_DATA: _obj = new Protocol_TS_A_PS_NEED_DATA(); break;
			case TS_Q_ADMIN_SAVE_BRANDED_LOBBIES: _obj = new Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES(); break;
			case TS_Q_HFS_GET_TEMPLATE_DATA: _obj = new Protocol_TS_Q_HFS_GET_TEMPLATE_DATA(); break;
			case TS_Q_HFS_NEED_DATA: _obj = new Protocol_TS_Q_HFS_NEED_DATA(); break;
			case TS_Q_PS_NEED_DATA: _obj = new Protocol_TS_Q_PS_NEED_DATA(); break;
		}
	}
	
	return _obj;
}

/* static */ bool TemplateServerATF::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case TS_A_ADMIN_SAVE_BRANDED_LOBBIES: Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case TS_A_HFS_GET_TEMPLATE_DATA: Protocol_TS_A_HFS_GET_TEMPLATE_DATA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case TS_A_HFS_NEED_DATA: Protocol_TS_A_HFS_NEED_DATA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case TS_A_PS_NEED_DATA: Protocol_TS_A_PS_NEED_DATA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case TS_Q_ADMIN_SAVE_BRANDED_LOBBIES: Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case TS_Q_HFS_GET_TEMPLATE_DATA: Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case TS_Q_HFS_NEED_DATA: Protocol_TS_Q_HFS_NEED_DATA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case TS_Q_PS_NEED_DATA: Protocol_TS_Q_PS_NEED_DATA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool TemplateServerATF::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case TS_A_ADMIN_SAVE_BRANDED_LOBBIES: Protocol_TS_A_ADMIN_SAVE_BRANDED_LOBBIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case TS_A_HFS_GET_TEMPLATE_DATA: Protocol_TS_A_HFS_GET_TEMPLATE_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case TS_A_HFS_NEED_DATA: Protocol_TS_A_HFS_NEED_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case TS_A_PS_NEED_DATA: Protocol_TS_A_PS_NEED_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case TS_Q_ADMIN_SAVE_BRANDED_LOBBIES: Protocol_TS_Q_ADMIN_SAVE_BRANDED_LOBBIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case TS_Q_HFS_GET_TEMPLATE_DATA: Protocol_TS_Q_HFS_GET_TEMPLATE_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case TS_Q_HFS_NEED_DATA: Protocol_TS_Q_HFS_NEED_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case TS_Q_PS_NEED_DATA: Protocol_TS_Q_PS_NEED_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

