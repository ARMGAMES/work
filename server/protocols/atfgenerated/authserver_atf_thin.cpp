/**
 * authserver_atf_thin.cpp
 *
 * This file was auto-generated from authserver_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin authserver_atf.txt
 */
 
#include "authserver_atf_thin.h"

//=================================================================
//                Protocol_AUTH_Q_LOGIN_RSA
//=================================================================

Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::Protocol_AUTH_Q_LOGIN_RSA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::Protocol_AUTH_Q_LOGIN_RSA(Protocol_AUTH_Q_LOGIN_RSA&& _o)
	: rsaPin(std::move(_o.rsaPin))
	, rsaCode(std::move(_o.rsaCode))
{
}

Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA& Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::operator=(Protocol_AUTH_Q_LOGIN_RSA&& _o)
{
	if(this != &_o)
	{
		rsaPin = std::move(_o.rsaPin);
		rsaCode = std::move(_o.rsaCode);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::clear()
{
	rsaPin.clear();
	rsaCode.clear();
}

bool Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::equals(const Protocol_AUTH_Q_LOGIN_RSA& _o) const
{
	return rsaPin.equals(_o.rsaPin) &&
		rsaCode.equals(_o.rsaCode);
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_LOGIN_RSA).append(")");
	_buf.append(',');
	_buf.append("rsaPin=");
	_buf.append(rsaPin);
	_buf.append(',');
	_buf.append("rsaCode=");
	_buf.append(rsaCode);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(rsaPin);
	_msg.composeString(rsaCode);
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(rsaPin);
	_parser.parseStringP(rsaCode);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_LOGIN_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "rsaPin"); size_t szRsaPin = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "rsaPin", szRsaPin, 10, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "rsaCode"); size_t szRsaCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "rsaCode", szRsaCode, 10, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_LOGIN_RSA
//=================================================================

Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::Protocol_AUTH_A_LOGIN_RSA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::Protocol_AUTH_A_LOGIN_RSA(Protocol_AUTH_A_LOGIN_RSA&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Authserver::cli::Protocol_AUTH_A_LOGIN_RSA& Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::operator=(Protocol_AUTH_A_LOGIN_RSA&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::equals(const Protocol_AUTH_A_LOGIN_RSA& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_LOGIN_RSA).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_LOGIN_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_LOGIN_OTP
//=================================================================

Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::Protocol_AUTH_Q_LOGIN_OTP()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::Protocol_AUTH_Q_LOGIN_OTP(Protocol_AUTH_Q_LOGIN_OTP&& _o)
	: otp(std::move(_o.otp))
	, pin(std::move(_o.pin))
{
}

Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP& Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::operator=(Protocol_AUTH_Q_LOGIN_OTP&& _o)
{
	if(this != &_o)
	{
		otp = std::move(_o.otp);
		pin = std::move(_o.pin);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::clear()
{
	otp.clear();
	pin.clear();
}

bool Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::equals(const Protocol_AUTH_Q_LOGIN_OTP& _o) const
{
	return otp.equals(_o.otp) &&
		pin.equals(_o.pin);
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_LOGIN_OTP).append(")");
	_buf.append(',');
	_buf.append("otp=");
	_buf.append(otp);
	_buf.append(',');
	_buf.append("pin=");
	_buf.append(pin);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(otp);
	_msg.composeString(pin);
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(otp);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(pin);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_LOGIN_OTP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "otp"); size_t szOtp = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "otp", szOtp, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "pin"); size_t szPin = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "pin", szPin, 10, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_LOGIN_OTP
//=================================================================

Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::Protocol_AUTH_A_LOGIN_OTP()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::Protocol_AUTH_A_LOGIN_OTP(Protocol_AUTH_A_LOGIN_OTP&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Authserver::cli::Protocol_AUTH_A_LOGIN_OTP& Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::operator=(Protocol_AUTH_A_LOGIN_OTP&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::equals(const Protocol_AUTH_A_LOGIN_OTP& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_LOGIN_OTP).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_LOGIN_OTP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_LOGIN_LTD
//=================================================================

Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::Protocol_AUTH_Q_LOGIN_LTD()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::clear()
{
}

bool Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::equals(const Protocol_AUTH_Q_LOGIN_LTD& _o) const
{
	return true;
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_LOGIN_LTD).append(")");
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::composeMsg(CommMsgBody& _msg) const
{
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_LOGIN_LTD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_LOGIN_LTD
//=================================================================

Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::Protocol_AUTH_A_LOGIN_LTD()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::Protocol_AUTH_A_LOGIN_LTD(Protocol_AUTH_A_LOGIN_LTD&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Authserver::cli::Protocol_AUTH_A_LOGIN_LTD& Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::operator=(Protocol_AUTH_A_LOGIN_LTD&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::equals(const Protocol_AUTH_A_LOGIN_LTD& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_LOGIN_LTD).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_LOGIN_LTD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_U_LOGOUT_NOW
//=================================================================

Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::Protocol_AUTH_U_LOGOUT_NOW()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::clear()
{
}

bool Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::equals(const Protocol_AUTH_U_LOGOUT_NOW& _o) const
{
	return true;
}

const char *Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_U_LOGOUT_NOW).append(")");
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::composeMsg(CommMsgBody& _msg) const
{
}

void Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_U_LOGOUT_NOW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_GET_LOGIN_METHOD
//=================================================================

Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::Protocol_AUTH_Q_GET_LOGIN_METHOD()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::clear()
{
}

bool Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::equals(const Protocol_AUTH_Q_GET_LOGIN_METHOD& _o) const
{
	return true;
}

const char *Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_GET_LOGIN_METHOD).append(")");
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::composeMsg(CommMsgBody& _msg) const
{
}

void Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_GET_LOGIN_METHOD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_GET_LOGIN_METHOD
//=================================================================

Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::Protocol_AUTH_A_GET_LOGIN_METHOD()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::Protocol_AUTH_A_GET_LOGIN_METHOD(Protocol_AUTH_A_GET_LOGIN_METHOD&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, loginMethod(std::move(_o.loginMethod))
	, loginPriv(std::move(_o.loginPriv))
{
}

Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD& Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::operator=(Protocol_AUTH_A_GET_LOGIN_METHOD&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		loginMethod = std::move(_o.loginMethod);
		loginPriv = std::move(_o.loginPriv);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::clear()
{
	errCode = 0;
	errDescr.clear();
	loginMethod = 0;
	loginPriv = 0;
}

bool Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::equals(const Protocol_AUTH_A_GET_LOGIN_METHOD& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		loginMethod == _o.loginMethod &&
		loginPriv == _o.loginPriv;
}

const char *Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_GET_LOGIN_METHOD).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("loginMethod=");
		_buf.appendUint(loginMethod);
		_buf.append(',');
		_buf.append("loginPriv=");
		_buf.appendUint(loginPriv);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(loginMethod);
		_msg.composeUINT32(loginPriv);
	}
}

void Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(loginMethod);
		_parser.parseUINT32(loginPriv);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_GET_LOGIN_METHOD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 loginMethod; _parser.parseUINT32(loginMethod);
		AtfValidator::validateInt(_descr, "loginMethod", loginMethod, _checker, __FILE__, __LINE__);
		UINT32 loginPriv; _parser.parseUINT32(loginPriv);
		AtfValidator::validateInt(_descr, "loginPriv", loginPriv, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_SET_LOGIN_METHOD
//=================================================================

Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::Protocol_AUTH_Q_SET_LOGIN_METHOD()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::Protocol_AUTH_Q_SET_LOGIN_METHOD(Protocol_AUTH_Q_SET_LOGIN_METHOD&& _o)
	: loginMethod(std::move(_o.loginMethod))
	, password(std::move(_o.password))
	, sid(std::move(_o.sid))
	, rsaPin(std::move(_o.rsaPin))
	, rsaCode(std::move(_o.rsaCode))
{
}

Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD& Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::operator=(Protocol_AUTH_Q_SET_LOGIN_METHOD&& _o)
{
	if(this != &_o)
	{
		loginMethod = std::move(_o.loginMethod);
		password = std::move(_o.password);
		sid = std::move(_o.sid);
		rsaPin = std::move(_o.rsaPin);
		rsaCode = std::move(_o.rsaCode);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::clear()
{
	loginMethod = 0;
	password.clear();
	sid.clear();
	rsaPin.clear();
	rsaCode.clear();
}

bool Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::equals(const Protocol_AUTH_Q_SET_LOGIN_METHOD& _o) const
{
	return loginMethod == _o.loginMethod &&
		password.equals(_o.password) &&
		sid.equals(_o.sid) &&
		rsaPin.equals(_o.rsaPin) &&
		rsaCode.equals(_o.rsaCode);
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_SET_LOGIN_METHOD).append(")");
	_buf.append(',');
	_buf.append("loginMethod=");
	_buf.appendUint(loginMethod);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append(',');
	_buf.append("sid=");
	_buf.append(sid);
	_buf.append(',');
	_buf.append("rsaPin=");
	_buf.append(rsaPin);
	_buf.append(',');
	_buf.append("rsaCode=");
	_buf.append(rsaCode);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(loginMethod);
	_msg.composeString(password);
	_msg.composeString(sid);
	_msg.composeString(rsaPin);
	_msg.composeString(rsaCode);
}

void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(loginMethod);
	_parser.parseStringP(password);
	_parser.parseStringP(sid);
	_parser.parseStringP(rsaPin);
	_parser.parseStringP(rsaCode);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_SET_LOGIN_METHOD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 loginMethod; _parser.parseUINT32(loginMethod);
	AtfValidator::validateIntMax(_descr, "loginMethod", loginMethod, AUTH_LOGINTYPE_MAX, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 50, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "sid"); size_t szSid = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "sid", szSid, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "rsaPin"); size_t szRsaPin = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "rsaPin", szRsaPin, 10, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "rsaCode"); size_t szRsaCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "rsaCode", szRsaCode, 10, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_SET_LOGIN_METHOD
//=================================================================

Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::Protocol_AUTH_A_SET_LOGIN_METHOD()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::Protocol_AUTH_A_SET_LOGIN_METHOD(Protocol_AUTH_A_SET_LOGIN_METHOD&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD& Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::operator=(Protocol_AUTH_A_SET_LOGIN_METHOD&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::equals(const Protocol_AUTH_A_SET_LOGIN_METHOD& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_SET_LOGIN_METHOD).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_SET_LOGIN_METHOD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_SET_LOGIN_METHOD_EX
//=================================================================

Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX(Protocol_AUTH_Q_SET_LOGIN_METHOD_EX&& _o)
	: loginMethod(std::move(_o.loginMethod))
	, password(std::move(_o.password))
	, sid(std::move(_o.sid))
	, rsaPin(std::move(_o.rsaPin))
	, rsaCode(std::move(_o.rsaCode))
{
}

Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX& Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::operator=(Protocol_AUTH_Q_SET_LOGIN_METHOD_EX&& _o)
{
	if(this != &_o)
	{
		loginMethod = std::move(_o.loginMethod);
		password = std::move(_o.password);
		sid = std::move(_o.sid);
		rsaPin = std::move(_o.rsaPin);
		rsaCode = std::move(_o.rsaCode);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::clear()
{
	loginMethod = 0;
	password.clear();
	sid.clear();
	rsaPin.clear();
	rsaCode.clear();
}

bool Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::equals(const Protocol_AUTH_Q_SET_LOGIN_METHOD_EX& _o) const
{
	return loginMethod == _o.loginMethod &&
		password.equals(_o.password) &&
		sid.equals(_o.sid) &&
		rsaPin.equals(_o.rsaPin) &&
		rsaCode.equals(_o.rsaCode);
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_SET_LOGIN_METHOD_EX).append(")");
	_buf.append(',');
	_buf.append("loginMethod=");
	_buf.appendUint(loginMethod);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append(',');
	_buf.append("sid=");
	_buf.append(sid);
	_buf.append(',');
	_buf.append("rsaPin=");
	_buf.append(rsaPin);
	_buf.append(',');
	_buf.append("rsaCode=");
	_buf.append(rsaCode);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(loginMethod);
	_msg.composeString(password);
	_msg.composeString(sid);
	_msg.composeString(rsaPin);
	_msg.composeString(rsaCode);
}

void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(loginMethod);
	_parser.parseStringP(password);
	_parser.parseStringP(sid);
	_parser.parseStringP(rsaPin);
	_parser.parseStringP(rsaCode);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_SET_LOGIN_METHOD_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 loginMethod; _parser.parseUINT32(loginMethod);
	AtfValidator::validateIntMax(_descr, "loginMethod", loginMethod, AUTH_LOGINTYPE_MAX, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 200, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "sid"); size_t szSid = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "sid", szSid, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "rsaPin"); size_t szRsaPin = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "rsaPin", szRsaPin, 10, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "rsaCode"); size_t szRsaCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "rsaCode", szRsaCode, 10, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION
//=================================================================

Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::clear()
{
	enable = false;
}

bool Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::equals(const Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION& _o) const
{
	return enable == _o.enable;
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_SET_NEWINSTALL_VALIDATION).append(")");
	_buf.append(',');
	_buf.append("enable=");
	_buf.appendUint(enable);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(enable);
}

void Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(enable);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_SET_NEWINSTALL_VALIDATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool enable; _parser.parseBOOL(enable);
	AtfValidator::validateInt(_descr, "enable", enable, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION
//=================================================================

Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION(Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION& Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::operator=(Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::equals(const Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_SET_NEWINSTALL_VALIDATION).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_SET_NEWINSTALL_VALIDATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_GENERATE_PSP
//=================================================================

Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::Protocol_AUTH_Q_GENERATE_PSP()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::clear()
{
}

bool Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::equals(const Protocol_AUTH_Q_GENERATE_PSP& _o) const
{
	return true;
}

const char *Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_GENERATE_PSP).append(")");
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::composeMsg(CommMsgBody& _msg) const
{
}

void Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_GENERATE_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_GENERATE_PSP
//=================================================================

Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::Protocol_AUTH_A_GENERATE_PSP()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::Protocol_AUTH_A_GENERATE_PSP(Protocol_AUTH_A_GENERATE_PSP&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Authserver::cli::Protocol_AUTH_A_GENERATE_PSP& Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::operator=(Protocol_AUTH_A_GENERATE_PSP&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::equals(const Protocol_AUTH_A_GENERATE_PSP& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_GENERATE_PSP).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_GENERATE_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_SET_PSP
//=================================================================

Authserver::cli::Protocol_AUTH_Q_SET_PSP::Protocol_AUTH_Q_SET_PSP()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_Q_SET_PSP::Protocol_AUTH_Q_SET_PSP(Protocol_AUTH_Q_SET_PSP&& _o)
	: newPsp(std::move(_o.newPsp))
{
}

Authserver::cli::Protocol_AUTH_Q_SET_PSP& Authserver::cli::Protocol_AUTH_Q_SET_PSP::operator=(Protocol_AUTH_Q_SET_PSP&& _o)
{
	if(this != &_o)
	{
		newPsp = std::move(_o.newPsp);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_Q_SET_PSP::clear()
{
	newPsp.clear();
}

bool Authserver::cli::Protocol_AUTH_Q_SET_PSP::equals(const Protocol_AUTH_Q_SET_PSP& _o) const
{
	return newPsp.equals(_o.newPsp);
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_PSP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_SET_PSP).append(")");
	_buf.append(',');
	_buf.append("newPsp=");
	_buf.append(newPsp);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_SET_PSP::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(newPsp);
}

void Authserver::cli::Protocol_AUTH_Q_SET_PSP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(newPsp);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_SET_PSP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_SET_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "newPsp"); size_t szNewPsp = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "newPsp", szNewPsp, PSP_MIN_LENGTH, PSP_MAX_LENGTH, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_SET_PSP
//=================================================================

Authserver::cli::Protocol_AUTH_A_SET_PSP::Protocol_AUTH_A_SET_PSP()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_A_SET_PSP::Protocol_AUTH_A_SET_PSP(Protocol_AUTH_A_SET_PSP&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Authserver::cli::Protocol_AUTH_A_SET_PSP& Authserver::cli::Protocol_AUTH_A_SET_PSP::operator=(Protocol_AUTH_A_SET_PSP&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_A_SET_PSP::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_SET_PSP::equals(const Protocol_AUTH_A_SET_PSP& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Authserver::cli::Protocol_AUTH_A_SET_PSP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_SET_PSP).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_SET_PSP::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_SET_PSP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_SET_PSP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_SET_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_CHANGE_PSP
//=================================================================

Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::Protocol_AUTH_Q_CHANGE_PSP()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::Protocol_AUTH_Q_CHANGE_PSP(Protocol_AUTH_Q_CHANGE_PSP&& _o)
	: oldPsp(std::move(_o.oldPsp))
	, newPsp(std::move(_o.newPsp))
{
}

Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP& Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::operator=(Protocol_AUTH_Q_CHANGE_PSP&& _o)
{
	if(this != &_o)
	{
		oldPsp = std::move(_o.oldPsp);
		newPsp = std::move(_o.newPsp);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::clear()
{
	oldPsp.clear();
	newPsp.clear();
}

bool Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::equals(const Protocol_AUTH_Q_CHANGE_PSP& _o) const
{
	return oldPsp.equals(_o.oldPsp) &&
		newPsp.equals(_o.newPsp);
}

const char *Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_CHANGE_PSP).append(")");
	_buf.append(',');
	_buf.append("oldPsp=");
	_buf.append(oldPsp);
	_buf.append(',');
	_buf.append("newPsp=");
	_buf.append(newPsp);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(oldPsp);
	_msg.composeString(newPsp);
}

void Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(oldPsp);
	_parser.parseStringP(newPsp);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_CHANGE_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "oldPsp"); size_t szOldPsp = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "oldPsp", szOldPsp, PSP_MIN_LENGTH, PSP_MAX_LENGTH, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "newPsp"); size_t szNewPsp = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "newPsp", szNewPsp, PSP_MIN_LENGTH, PSP_MAX_LENGTH, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_CHANGE_PSP
//=================================================================

Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::Protocol_AUTH_A_CHANGE_PSP()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::Protocol_AUTH_A_CHANGE_PSP(Protocol_AUTH_A_CHANGE_PSP&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Authserver::cli::Protocol_AUTH_A_CHANGE_PSP& Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::operator=(Protocol_AUTH_A_CHANGE_PSP&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::equals(const Protocol_AUTH_A_CHANGE_PSP& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_CHANGE_PSP).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_CHANGE_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_ACTIVATE_RSA
//=================================================================

Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::Protocol_AUTH_Q_ACTIVATE_RSA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::Protocol_AUTH_Q_ACTIVATE_RSA(Protocol_AUTH_Q_ACTIVATE_RSA&& _o)
	: serialNumber(std::move(_o.serialNumber))
	, rsaPin(std::move(_o.rsaPin))
	, rsaCode(std::move(_o.rsaCode))
{
}

Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA& Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::operator=(Protocol_AUTH_Q_ACTIVATE_RSA&& _o)
{
	if(this != &_o)
	{
		serialNumber = std::move(_o.serialNumber);
		rsaPin = std::move(_o.rsaPin);
		rsaCode = std::move(_o.rsaCode);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::clear()
{
	serialNumber = 0;
	rsaPin.clear();
	rsaCode.clear();
}

bool Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::equals(const Protocol_AUTH_Q_ACTIVATE_RSA& _o) const
{
	return serialNumber == _o.serialNumber &&
		rsaPin.equals(_o.rsaPin) &&
		rsaCode.equals(_o.rsaCode);
}

const char *Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_ACTIVATE_RSA).append(")");
	_buf.append(',');
	_buf.append("serialNumber=");
	_buf.appendUint(serialNumber);
	_buf.append(',');
	_buf.append("rsaPin=");
	_buf.append(rsaPin);
	_buf.append(',');
	_buf.append("rsaCode=");
	_buf.append(rsaCode);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(serialNumber);
	_msg.composeString(rsaPin);
	_msg.composeString(rsaCode);
}

void Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(serialNumber);
	_parser.parseStringP(rsaPin);
	_parser.parseStringP(rsaCode);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_ACTIVATE_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 serialNumber; _parser.parseUINT32(serialNumber);
	AtfValidator::validateInt(_descr, "serialNumber", serialNumber, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "rsaPin"); size_t szRsaPin = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "rsaPin", szRsaPin, 10, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "rsaCode"); size_t szRsaCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "rsaCode", szRsaCode, 10, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_ACTIVATE_RSA
//=================================================================

Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::Protocol_AUTH_A_ACTIVATE_RSA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::Protocol_AUTH_A_ACTIVATE_RSA(Protocol_AUTH_A_ACTIVATE_RSA&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA& Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::operator=(Protocol_AUTH_A_ACTIVATE_RSA&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::equals(const Protocol_AUTH_A_ACTIVATE_RSA& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_ACTIVATE_RSA).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_ACTIVATE_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_CHECK_RSA
//=================================================================

Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::Protocol_AUTH_Q_CHECK_RSA()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::clear()
{
	serialNumber = 0;
}

bool Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::equals(const Protocol_AUTH_Q_CHECK_RSA& _o) const
{
	return serialNumber == _o.serialNumber;
}

const char *Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_CHECK_RSA).append(")");
	_buf.append(',');
	_buf.append("serialNumber=");
	_buf.appendUint(serialNumber);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(serialNumber);
}

void Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(serialNumber);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_CHECK_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 serialNumber; _parser.parseUINT32(serialNumber);
	AtfValidator::validateInt(_descr, "serialNumber", serialNumber, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_CHECK_RSA
//=================================================================

Authserver::cli::Protocol_AUTH_A_CHECK_RSA::Protocol_AUTH_A_CHECK_RSA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_A_CHECK_RSA::Protocol_AUTH_A_CHECK_RSA(Protocol_AUTH_A_CHECK_RSA&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Authserver::cli::Protocol_AUTH_A_CHECK_RSA& Authserver::cli::Protocol_AUTH_A_CHECK_RSA::operator=(Protocol_AUTH_A_CHECK_RSA&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_A_CHECK_RSA::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_CHECK_RSA::equals(const Protocol_AUTH_A_CHECK_RSA& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Authserver::cli::Protocol_AUTH_A_CHECK_RSA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_CHECK_RSA).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_CHECK_RSA::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_CHECK_RSA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_CHECK_RSA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_CHECK_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_GENERATE_OTP
//=================================================================

Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::Protocol_AUTH_Q_GENERATE_OTP()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::clear()
{
}

bool Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::equals(const Protocol_AUTH_Q_GENERATE_OTP& _o) const
{
	return true;
}

const char *Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_GENERATE_OTP).append(")");
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::composeMsg(CommMsgBody& _msg) const
{
}

void Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_GENERATE_OTP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_GENERATE_OTP
//=================================================================

Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::Protocol_AUTH_A_GENERATE_OTP()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::Protocol_AUTH_A_GENERATE_OTP(Protocol_AUTH_A_GENERATE_OTP&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, mobileNum(std::move(_o.mobileNum))
{
}

Authserver::cli::Protocol_AUTH_A_GENERATE_OTP& Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::operator=(Protocol_AUTH_A_GENERATE_OTP&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		mobileNum = std::move(_o.mobileNum);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::clear()
{
	errCode = 0;
	errDescr.clear();
	mobileNum.clear();
}

bool Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::equals(const Protocol_AUTH_A_GENERATE_OTP& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		mobileNum.equals(_o.mobileNum);
}

const char *Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_GENERATE_OTP).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("mobileNum=");
		_buf.append(mobileNum);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(mobileNum);
	}
}

void Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(mobileNum);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_GENERATE_OTP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "mobileNum"); size_t szMobileNum = strlen(_dummy);
		AtfValidator::validateInt(_descr, "mobileNum", szMobileNum, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION
//=================================================================

Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::clear()
{
	setOrRemove = false;
}

bool Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::equals(const Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION& _o) const
{
	return setOrRemove == _o.setOrRemove;
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_LOGIN_EMAIL_NOTIFICATION).append(")");
	_buf.append(',');
	_buf.append("setOrRemove=");
	_buf.appendUint(setOrRemove);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(setOrRemove);
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(setOrRemove);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_LOGIN_EMAIL_NOTIFICATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool setOrRemove; _parser.parseBOOL(setOrRemove);
	AtfValidator::validateInt(_descr, "setOrRemove", setOrRemove, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION
//=================================================================

Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION(Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION& Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::operator=(Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::equals(const Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_LOGIN_EMAIL_NOTIFICATION).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_LOGIN_EMAIL_NOTIFICATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool Authserver::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case AUTH_A_ACTIVATE_RSA: cli::Protocol_AUTH_A_ACTIVATE_RSA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_CHANGE_PSP: cli::Protocol_AUTH_A_CHANGE_PSP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_CHECK_RSA: cli::Protocol_AUTH_A_CHECK_RSA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_GENERATE_OTP: cli::Protocol_AUTH_A_GENERATE_OTP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_GENERATE_PSP: cli::Protocol_AUTH_A_GENERATE_PSP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_GET_LOGIN_METHOD: cli::Protocol_AUTH_A_GET_LOGIN_METHOD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_LOGIN_EMAIL_NOTIFICATION: cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_LOGIN_LTD: cli::Protocol_AUTH_A_LOGIN_LTD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_LOGIN_OTP: cli::Protocol_AUTH_A_LOGIN_OTP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_LOGIN_RSA: cli::Protocol_AUTH_A_LOGIN_RSA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_SET_LOGIN_METHOD: cli::Protocol_AUTH_A_SET_LOGIN_METHOD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_SET_NEWINSTALL_VALIDATION: cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_SET_PSP: cli::Protocol_AUTH_A_SET_PSP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_ACTIVATE_RSA: cli::Protocol_AUTH_Q_ACTIVATE_RSA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_CHANGE_PSP: cli::Protocol_AUTH_Q_CHANGE_PSP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_CHECK_RSA: cli::Protocol_AUTH_Q_CHECK_RSA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_GENERATE_OTP: cli::Protocol_AUTH_Q_GENERATE_OTP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_GENERATE_PSP: cli::Protocol_AUTH_Q_GENERATE_PSP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_GET_LOGIN_METHOD: cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_LOGIN_EMAIL_NOTIFICATION: cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_LOGIN_LTD: cli::Protocol_AUTH_Q_LOGIN_LTD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_LOGIN_OTP: cli::Protocol_AUTH_Q_LOGIN_OTP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_LOGIN_RSA: cli::Protocol_AUTH_Q_LOGIN_RSA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_SET_LOGIN_METHOD: cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_SET_LOGIN_METHOD_EX: cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_SET_NEWINSTALL_VALIDATION: cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_SET_PSP: cli::Protocol_AUTH_Q_SET_PSP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_U_LOGOUT_NOW: cli::Protocol_AUTH_U_LOGOUT_NOW::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

