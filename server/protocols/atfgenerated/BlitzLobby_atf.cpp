/**
 * BlitzLobby_atf.cpp
 *
 * This file was auto-generated from BlitzLobby_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: BlitzLobby_atf.txt
 */
 
#include "BlitzLobby_atf.h"

//=================================================================
//                    Accounts
//=================================================================

BlitzLobby::cli::Accounts::Accounts()
{
	clear();
}

void BlitzLobby::cli::Accounts::clear()
{
	currency.clear();
	convRate = 0;
	chips = 0;
	tChips = 0;
	chipsDst = 0;
	tChipsDst = 0;
}

bool BlitzLobby::cli::Accounts::equals(const Accounts& _o) const
{
	return Atf::atfPStringEquals(currency, _o.currency) &&
		convRate == _o.convRate &&
		chips == _o.chips &&
		tChips == _o.tChips &&
		chipsDst == _o.chipsDst &&
		tChipsDst == _o.tChipsDst;
}

const char *BlitzLobby::cli::Accounts::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("convRate=");
	_buf.appendInt64(convRate);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt(chips);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("chipsDst=");
	_buf.appendInt(chipsDst);
	_buf.append(',');
	_buf.append("tChipsDst=");
	_buf.appendInt(tChipsDst);
	_buf.append('}');
	return _buf.c_str();
}

const char *BlitzLobby::cli::Accounts::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("convRate", convRate, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("chipsDst", chipsDst, _buf);
	Atf::XmlElement::encodeAsXmlElement("tChipsDst", tChipsDst, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool BlitzLobby::cli::Accounts::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("convRate"))
		{
			convRate = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chips"))
		{
			chips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tChips"))
		{
			tChips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chipsDst"))
		{
			chipsDst = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tChipsDst"))
		{
			tChipsDst = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void BlitzLobby::cli::Accounts::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(Accounts())) // not empty
	{
		_body.composeString(currency);
		_body.composeINT64(convRate);
		_body.composeINT32(chips);
		_body.composeINT32(tChips);
		_body.composeINT32(chipsDst);
		_body.composeINT32(tChipsDst);
	}

	_msg.composeMsgBody(_body);
}

void BlitzLobby::cli::Accounts::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(convRate);
	_parser0.parseINT32(chips);
	_parser0.parseINT32(tChips);
	_parser0.parseINT32(chipsDst);
	_parser0.parseINT32(tChipsDst);
}

const char *BlitzLobby::cli::Accounts::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("convRate", convRate);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("tChips", tChips);
	_jsonstr.compose("chipsDst", chipsDst);
	_jsonstr.compose("tChipsDst", tChipsDst);
	return _buf.c_str();
}

void BlitzLobby::cli::Accounts::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("convRate", convRate);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("tChips", tChips);
	_jparser.parseByNameThrow("chipsDst", chipsDst);
	_jparser.parseByNameThrow("tChipsDst", tChipsDst);
}

/* static */ void BlitzLobby::cli::Accounts::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT64 convRate; _jparser.validateByNameThrow("convRate", convRate);
	AtfValidator::validateIntRange(_descr, "convRate", convRate, 0, 1000000000000LL, _checker, __FILE__, __LINE__);
	INT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateIntRange(_descr, "chips", chips, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 tChips; _jparser.validateByNameThrow("tChips", tChips);
	AtfValidator::validateIntRange(_descr, "tChips", tChips, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 chipsDst; _jparser.validateByNameThrow("chipsDst", chipsDst);
	AtfValidator::validateIntRange(_descr, "chipsDst", chipsDst, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 tChipsDst; _jparser.validateByNameThrow("tChipsDst", tChipsDst);
	AtfValidator::validateIntRange(_descr, "tChipsDst", tChipsDst, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
}

/*static*/ void BlitzLobby::cli::Accounts::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT64 convRate; _parser0.parseINT64(convRate);
	AtfValidator::validateIntRange(_descr, "convRate", convRate, 0, 1000000000000LL, _checker, __FILE__, __LINE__);
	INT32 chips; _parser0.parseINT32(chips);
	AtfValidator::validateIntRange(_descr, "chips", chips, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 tChips; _parser0.parseINT32(tChips);
	AtfValidator::validateIntRange(_descr, "tChips", tChips, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 chipsDst; _parser0.parseINT32(chipsDst);
	AtfValidator::validateIntRange(_descr, "chipsDst", chipsDst, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 tChipsDst; _parser0.parseINT32(tChipsDst);
	AtfValidator::validateIntRange(_descr, "tChipsDst", tChipsDst, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_BL_USER_BUYIN
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_BUYIN::Protocol_BL_USER_BUYIN()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_BUYIN::clear()
{
	buyIn = 0;
	currencyContext.clear();
}

bool BlitzLobby::cli::Protocol_BL_USER_BUYIN::equals(const Protocol_BL_USER_BUYIN& _o) const
{
	return buyIn == _o.buyIn &&
		currencyContext.equals(_o.currencyContext);
}

bool BlitzLobby::cli::Protocol_BL_USER_BUYIN::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_BUYIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_BUYIN*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_BUYIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_BUYIN).append(")");
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt(buyIn);
	_buf.append(',');
	_buf.append("currencyContext=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(currencyContext, _buf); _buf.append('}');
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_BUYIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_BUYIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_BUYIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyContext", currencyContext, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_BUYIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("buyIn"))
			{
				buyIn = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, currencyContext)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_BUYIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(buyIn);
	_msg.composeMsgBody(currencyContext);
}

void BlitzLobby::cli::Protocol_BL_USER_BUYIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(buyIn);
	_parser.parseMsgBody(currencyContext);
}

const char *BlitzLobby::cli::Protocol_BL_USER_BUYIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("currencyContext", currencyContext);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_BUYIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("currencyContext", currencyContext);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_BUYIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_BUYIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateIntMax(_descr, "buyIn", buyIn, 2000000000, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody currencyContext; _jparser.validateByNameThrow("currencyContext", currencyContext);
	AtfValidator::validateIntMax(_descr, "currencyContext", currencyContext._size(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_BUYIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_BUYIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 buyIn; _parser.parseINT32(buyIn);
	AtfValidator::validateIntMax(_descr, "buyIn", buyIn, 2000000000, _checker, __FILE__, __LINE__);
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateIntMax(_descr, "currencyContext", szCurrencyContext, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_BUYIN_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::Protocol_BL_USER_BUYIN_REPLY()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::clear()
{
	errCode = 0;
	errDescrForUser.clear();
	entry = 0;
	thisAddress.clear();
	tableObjectName.clear();
	sittingOut = false;
	chips = 0;
	sitOutNextBlind = false;
	state3Plus = false;
	isTablePublicationOverConnection = false;
	numPlayingEntries = 0;
	chipsAfter = 0;
}

bool BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::equals(const Protocol_BL_USER_BUYIN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescrForUser, _o.errDescrForUser) &&
		entry == _o.entry &&
		Atf::atfPStringEquals(thisAddress, _o.thisAddress) &&
		Atf::atfPStringEquals(tableObjectName, _o.tableObjectName) &&
		sittingOut == _o.sittingOut &&
		chips == _o.chips &&
		sitOutNextBlind == _o.sitOutNextBlind &&
		state3Plus == _o.state3Plus &&
		isTablePublicationOverConnection == _o.isTablePublicationOverConnection &&
		numPlayingEntries == _o.numPlayingEntries &&
		chipsAfter == _o.chipsAfter;
}

bool BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_BUYIN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_BUYIN_REPLY*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_BUYIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescrForUser=");
		_buf.append(errDescrForUser);
	}
	else
	{
		_buf.append(',');
		_buf.append("entry=");
		_buf.appendUint(entry);
		_buf.append(',');
		_buf.append("thisAddress=");
		_buf.append(thisAddress);
		_buf.append(',');
		_buf.append("tableObjectName=");
		_buf.append(tableObjectName);
		_buf.append(',');
		_buf.append("sittingOut=");
		_buf.appendUint(sittingOut);
		_buf.append(',');
		_buf.append("chips=");
		_buf.appendUint(chips);
		_buf.append(',');
		_buf.append("sitOutNextBlind=");
		_buf.appendUint(sitOutNextBlind);
		_buf.append(',');
		_buf.append("state3Plus=");
		_buf.appendUint(state3Plus);
		_buf.append(',');
		_buf.append("isTablePublicationOverConnection=");
		_buf.appendUint(isTablePublicationOverConnection);
		_buf.append(',');
		_buf.append("numPlayingEntries=");
		_buf.appendUint(numPlayingEntries);
		_buf.append(',');
		_buf.append("chipsAfter=");
		_buf.appendInt(chipsAfter);
	}
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_BUYIN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescrForUser", errDescrForUser, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("entry", entry, _buf);
		Atf::XmlElement::encodeAsXmlElement("thisAddress", thisAddress, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableObjectName", tableObjectName, _buf);
		Atf::XmlElement::encodeAsXmlElement("sittingOut", sittingOut, _buf);
		Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
		Atf::XmlElement::encodeAsXmlElement("sitOutNextBlind", sitOutNextBlind, _buf);
		Atf::XmlElement::encodeAsXmlElement("state3Plus", state3Plus, _buf);
		Atf::XmlElement::encodeAsXmlElement("isTablePublicationOverConnection", isTablePublicationOverConnection, _buf);
		Atf::XmlElement::encodeAsXmlElement("numPlayingEntries", numPlayingEntries, _buf);
		Atf::XmlElement::encodeAsXmlElement("chipsAfter", chipsAfter, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescrForUser"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescrForUser)) return false;
			}
			else if (_element.equals("entry"))
			{
				entry = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("thisAddress"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, thisAddress)) return false;
			}
			else if (_element.equals("tableObjectName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tableObjectName)) return false;
			}
			else if (_element.equals("sittingOut"))
			{
				sittingOut = (*_value.ptr() == '1');
			}
			else if (_element.equals("chips"))
			{
				chips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sitOutNextBlind"))
			{
				sitOutNextBlind = (*_value.ptr() == '1');
			}
			else if (_element.equals("state3Plus"))
			{
				state3Plus = (*_value.ptr() == '1');
			}
			else if (_element.equals("isTablePublicationOverConnection"))
			{
				isTablePublicationOverConnection = (*_value.ptr() == '1');
			}
			else if (_element.equals("numPlayingEntries"))
			{
				numPlayingEntries = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chipsAfter"))
			{
				chipsAfter = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescrForUser);
	}
	else
	{
		_msg.composeUINT32(entry);
		_msg.composeString(thisAddress);
		_msg.composeString(tableObjectName);
		_msg.composeBOOL(sittingOut);
		_msg.composeUINT32(chips);
		_msg.composeBOOL(sitOutNextBlind);
		_msg.composeBOOL(state3Plus);
		_msg.composeBOOL(isTablePublicationOverConnection);
		_msg.composeBYTE(numPlayingEntries);
		_msg.composeINT32(chipsAfter);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescrForUser);
	}
	else
	{
		_parser.parseUINT32(entry);
		_parser.parseStringP(thisAddress);
		_parser.parseStringP(tableObjectName);
		_parser.parseBOOL(sittingOut);
		_parser.parseUINT32(chips);
		_parser.parseBOOL(sitOutNextBlind);
		_parser.parseBOOL(state3Plus);
		_parser.parseBOOL(isTablePublicationOverConnection);
		_parser.parseBYTE(numPlayingEntries);
		_parser.parseINT32(chipsAfter);
	}
}

const char *BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescrForUser", errDescrForUser);
	}
	else
	{
		_jsonstr.compose("entry", entry);
		_jsonstr.compose("thisAddress", thisAddress);
		_jsonstr.compose("tableObjectName", tableObjectName);
		_jsonstr.compose("sittingOut", sittingOut);
		_jsonstr.compose("chips", chips);
		_jsonstr.compose("sitOutNextBlind", sitOutNextBlind);
		_jsonstr.compose("state3Plus", state3Plus);
		_jsonstr.compose("isTablePublicationOverConnection", isTablePublicationOverConnection);
		_jsonstr.compose("numPlayingEntries", numPlayingEntries);
		_jsonstr.compose("chipsAfter", chipsAfter);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescrForUser", errDescrForUser);
	}
	else
	{
		_jparser.parseByNameThrow("entry", entry);
		_jparser.parseByNameThrow("thisAddress", thisAddress);
		_jparser.parseByNameThrow("tableObjectName", tableObjectName);
		_jparser.parseByNameThrow("sittingOut", sittingOut);
		_jparser.parseByNameThrow("chips", chips);
		_jparser.parseByNameThrow("sitOutNextBlind", sitOutNextBlind);
		_jparser.parseByNameThrow("state3Plus", state3Plus);
		_jparser.parseByNameThrow("isTablePublicationOverConnection", isTablePublicationOverConnection);
		_jparser.parseByNameThrow("numPlayingEntries", numPlayingEntries);
		_jparser.parseByNameThrow("chipsAfter", chipsAfter);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_BUYIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescrForUser; _jparser.validateByNameThrow("errDescrForUser", errDescrForUser);
		AtfValidator::validateInt(_descr, "errDescrForUser", errDescrForUser.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 entry; _jparser.validateByNameThrow("entry", entry);
		AtfValidator::validateInt(_descr, "entry", entry, _checker, __FILE__, __LINE__);
		PString thisAddress; _jparser.validateByNameThrow("thisAddress", thisAddress);
		AtfValidator::validateInt(_descr, "thisAddress", thisAddress.length(), _checker, __FILE__, __LINE__);
		PString tableObjectName; _jparser.validateByNameThrow("tableObjectName", tableObjectName);
		AtfValidator::validateInt(_descr, "tableObjectName", tableObjectName.length(), _checker, __FILE__, __LINE__);
		bool sittingOut; _jparser.validateByNameThrow("sittingOut", sittingOut);
		AtfValidator::validateInt(_descr, "sittingOut", sittingOut, _checker, __FILE__, __LINE__);
		UINT32 chips; _jparser.validateByNameThrow("chips", chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		bool sitOutNextBlind; _jparser.validateByNameThrow("sitOutNextBlind", sitOutNextBlind);
		AtfValidator::validateInt(_descr, "sitOutNextBlind", sitOutNextBlind, _checker, __FILE__, __LINE__);
		bool state3Plus; _jparser.validateByNameThrow("state3Plus", state3Plus);
		AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
		bool isTablePublicationOverConnection; _jparser.validateByNameThrow("isTablePublicationOverConnection", isTablePublicationOverConnection);
		AtfValidator::validateInt(_descr, "isTablePublicationOverConnection", isTablePublicationOverConnection, _checker, __FILE__, __LINE__);
		BYTE numPlayingEntries; _jparser.validateByNameThrow("numPlayingEntries", numPlayingEntries);
		AtfValidator::validateInt(_descr, "numPlayingEntries", numPlayingEntries, _checker, __FILE__, __LINE__);
		INT32 chipsAfter; _jparser.validateByNameThrow("chipsAfter", chipsAfter);
		AtfValidator::validateInt(_descr, "chipsAfter", chipsAfter, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_BUYIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescrForUser"); size_t szErrDescrForUser = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescrForUser", szErrDescrForUser, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 entry; _parser.parseUINT32(entry);
		AtfValidator::validateInt(_descr, "entry", entry, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "thisAddress"); size_t szThisAddress = strlen(_dummy);
		AtfValidator::validateInt(_descr, "thisAddress", szThisAddress, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tableObjectName"); size_t szTableObjectName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableObjectName", szTableObjectName, _checker, __FILE__, __LINE__);
		bool sittingOut; _parser.parseBOOL(sittingOut);
		AtfValidator::validateInt(_descr, "sittingOut", sittingOut, _checker, __FILE__, __LINE__);
		UINT32 chips; _parser.parseUINT32(chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		bool sitOutNextBlind; _parser.parseBOOL(sitOutNextBlind);
		AtfValidator::validateInt(_descr, "sitOutNextBlind", sitOutNextBlind, _checker, __FILE__, __LINE__);
		bool state3Plus; _parser.parseBOOL(state3Plus);
		AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
		bool isTablePublicationOverConnection; _parser.parseBOOL(isTablePublicationOverConnection);
		AtfValidator::validateInt(_descr, "isTablePublicationOverConnection", isTablePublicationOverConnection, _checker, __FILE__, __LINE__);
		BYTE numPlayingEntries; _parser.parseBYTE(numPlayingEntries);
		AtfValidator::validateInt(_descr, "numPlayingEntries", numPlayingEntries, _checker, __FILE__, __LINE__);
		INT32 chipsAfter; _parser.parseINT32(chipsAfter);
		AtfValidator::validateInt(_descr, "chipsAfter", chipsAfter, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_OUT
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_OUT::Protocol_BL_USER_OUT()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_OUT::clear()
{
	entryId = 0;
}

bool BlitzLobby::cli::Protocol_BL_USER_OUT::equals(const Protocol_BL_USER_OUT& _o) const
{
	return entryId == _o.entryId;
}

bool BlitzLobby::cli::Protocol_BL_USER_OUT::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_OUT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_OUT*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_OUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_OUT).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_OUT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_OUT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_OUT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_OUT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_OUT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(entryId);
}

void BlitzLobby::cli::Protocol_BL_USER_OUT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
}

const char *BlitzLobby::cli::Protocol_BL_USER_OUT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryId", entryId);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_OUT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entryId", entryId);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_OUT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_OUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_OUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_OUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    BetInfo
//=================================================================

BlitzLobby::cli::BetInfo::BetInfo()
{
	clear();
}

void BlitzLobby::cli::BetInfo::clear()
{
	sumOfBets = 0;
	wonAmount = 0;
}

bool BlitzLobby::cli::BetInfo::equals(const BetInfo& _o) const
{
	return sumOfBets == _o.sumOfBets &&
		wonAmount == _o.wonAmount;
}

const char *BlitzLobby::cli::BetInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sumOfBets=");
	_buf.appendInt64(sumOfBets);
	_buf.append(',');
	_buf.append("wonAmount=");
	_buf.appendInt64(wonAmount);
	_buf.append('}');
	return _buf.c_str();
}

const char *BlitzLobby::cli::BetInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("sumOfBets", sumOfBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("wonAmount", wonAmount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool BlitzLobby::cli::BetInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("sumOfBets"))
		{
			sumOfBets = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("wonAmount"))
		{
			wonAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void BlitzLobby::cli::BetInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(BetInfo())) // not empty
	{
		_body.composeINT64(sumOfBets);
		_body.composeINT64(wonAmount);
	}

	_msg.composeMsgBody(_body);
}

void BlitzLobby::cli::BetInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(sumOfBets);
	_parser0.parseINT64(wonAmount);
}

const char *BlitzLobby::cli::BetInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sumOfBets", sumOfBets);
	_jsonstr.compose("wonAmount", wonAmount);
	return _buf.c_str();
}

void BlitzLobby::cli::BetInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sumOfBets", sumOfBets);
	_jparser.parseByNameThrow("wonAmount", wonAmount);
}

/* static */ void BlitzLobby::cli::BetInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 sumOfBets; _jparser.validateByNameThrow("sumOfBets", sumOfBets);
	AtfValidator::validateInt(_descr, "sumOfBets", sumOfBets, _checker, __FILE__, __LINE__);
	INT64 wonAmount; _jparser.validateByNameThrow("wonAmount", wonAmount);
	AtfValidator::validateInt(_descr, "wonAmount", wonAmount, _checker, __FILE__, __LINE__);
}

/*static*/ void BlitzLobby::cli::BetInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT64 sumOfBets; _parser0.parseINT64(sumOfBets);
	AtfValidator::validateInt(_descr, "sumOfBets", sumOfBets, _checker, __FILE__, __LINE__);
	INT64 wonAmount; _parser0.parseINT64(wonAmount);
	AtfValidator::validateInt(_descr, "wonAmount", wonAmount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_BL_USER_OUT_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::Protocol_BL_USER_OUT_REPLY()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::clear()
{
	entryId = 0;
	err = 0;
	errDescr.clear();
	betInfo.clear();
}

bool BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::equals(const Protocol_BL_USER_OUT_REPLY& _o) const
{
	return entryId == _o.entryId &&
		err == _o.err &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		betInfo.equals(_o.betInfo);
}

bool BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_OUT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_OUT_REPLY*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_OUT_REPLY).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("betInfo=");
		betInfo.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_OUT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("err", err, _buf);
	if (err)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		betInfo.toXmlString("betInfo", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("err"))
			{
				err = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("betInfo"))
			{
				if(!Atf::AtfTempl< BetInfo >::FromXmlString(_value, betInfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		betInfo.composeMsg(_msg, _ignoreJSON);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		betInfo.parseMsg(_parser);
	}
}

const char *BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("err", err);
	if (err)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("betInfo", betInfo);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("err", err);
	if (err)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("betInfo", betInfo);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_OUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err = 0;
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("err", err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		BetInfo betInfo; _jparser.validateByNameThrow("betInfo", betInfo);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_OUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		BetInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("betInfo"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_ADDON
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_ADDON::Protocol_BL_USER_ADDON()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_ADDON::clear()
{
	entryId = 0;
	addOn = 0;
	currencyContext.clear();
}

bool BlitzLobby::cli::Protocol_BL_USER_ADDON::equals(const Protocol_BL_USER_ADDON& _o) const
{
	return entryId == _o.entryId &&
		addOn == _o.addOn &&
		currencyContext.equals(_o.currencyContext);
}

bool BlitzLobby::cli::Protocol_BL_USER_ADDON::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_ADDON != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_ADDON*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_ADDON::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_ADDON).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("addOn=");
	_buf.appendInt(addOn);
	_buf.append(',');
	_buf.append("currencyContext=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(currencyContext, _buf); _buf.append('}');
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_ADDON::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_ADDON::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_ADDON).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("addOn", addOn, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyContext", currencyContext, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_ADDON::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("addOn"))
			{
				addOn = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, currencyContext)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_ADDON::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT32(addOn);
	_msg.composeMsgBody(currencyContext);
}

void BlitzLobby::cli::Protocol_BL_USER_ADDON::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT32(addOn);
	_parser.parseMsgBody(currencyContext);
}

const char *BlitzLobby::cli::Protocol_BL_USER_ADDON::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("addOn", addOn);
	_jsonstr.compose("currencyContext", currencyContext);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_ADDON::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("addOn", addOn);
	_jparser.parseByNameThrow("currencyContext", currencyContext);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_ADDON::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_ADDON";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	INT32 addOn; _jparser.validateByNameThrow("addOn", addOn);
	AtfValidator::validateIntMax(_descr, "addOn", addOn, 2000000000, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody currencyContext; _jparser.validateByNameThrow("currencyContext", currencyContext);
	AtfValidator::validateInt(_descr, "currencyContext", currencyContext._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_ADDON::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_ADDON";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	INT32 addOn; _parser.parseINT32(addOn);
	AtfValidator::validateIntMax(_descr, "addOn", addOn, 2000000000, _checker, __FILE__, __LINE__);
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_ADDON_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::Protocol_BL_USER_ADDON_REPLY()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::clear()
{
	err = 0;
	errDescr.clear();
	entryId = 0;
}

bool BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::equals(const Protocol_BL_USER_ADDON_REPLY& _o) const
{
	return err == _o.err &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		entryId == _o.entryId;
}

bool BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_ADDON_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_ADDON_REPLY*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_ADDON_REPLY).append(")");
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_ADDON_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("err", err, _buf);
	if (err)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("err"))
			{
				err = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
	_msg.composeUINT32(entryId);
}

void BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
	_parser.parseUINT32(entryId);
}

const char *BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("err", err);
	if (err)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	_jsonstr.compose("entryId", entryId);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("err", err);
	if (err)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	_jparser.parseByNameThrow("entryId", entryId);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_ADDON_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err = 0;
	_jparser.validateByNameThrow("err", err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_ADDON_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SITIN
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SITIN::Protocol_BL_USER_SITIN()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_SITIN::clear()
{
	entryId = 0;
}

bool BlitzLobby::cli::Protocol_BL_USER_SITIN::equals(const Protocol_BL_USER_SITIN& _o) const
{
	return entryId == _o.entryId;
}

bool BlitzLobby::cli::Protocol_BL_USER_SITIN::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_SITIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_SITIN*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SITIN).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_SITIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_SITIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SITIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(entryId);
}

void BlitzLobby::cli::Protocol_BL_USER_SITIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryId", entryId);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SITIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entryId", entryId);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SITIN_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::Protocol_BL_USER_SITIN_REPLY()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::clear()
{
	entryId = 0;
	err = 0;
	errDescr.clear();
	thisAddress.clear();
	tableObjectName.clear();
	sittingOut = false;
	chips = 0;
	sitOutNextBlind = false;
	state3Plus = false;
	isTablePublicationOverConnection = false;
}

bool BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::equals(const Protocol_BL_USER_SITIN_REPLY& _o) const
{
	return entryId == _o.entryId &&
		err == _o.err &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(thisAddress, _o.thisAddress) &&
		Atf::atfPStringEquals(tableObjectName, _o.tableObjectName) &&
		sittingOut == _o.sittingOut &&
		chips == _o.chips &&
		sitOutNextBlind == _o.sitOutNextBlind &&
		state3Plus == _o.state3Plus &&
		isTablePublicationOverConnection == _o.isTablePublicationOverConnection;
}

bool BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_SITIN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_SITIN_REPLY*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SITIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("thisAddress=");
		_buf.append(thisAddress);
		_buf.append(',');
		_buf.append("tableObjectName=");
		_buf.append(tableObjectName);
		_buf.append(',');
		_buf.append("sittingOut=");
		_buf.appendUint(sittingOut);
		_buf.append(',');
		_buf.append("chips=");
		_buf.appendUint(chips);
		_buf.append(',');
		_buf.append("sitOutNextBlind=");
		_buf.appendUint(sitOutNextBlind);
		_buf.append(',');
		_buf.append("state3Plus=");
		_buf.appendUint(state3Plus);
		_buf.append(',');
		_buf.append("isTablePublicationOverConnection=");
		_buf.appendUint(isTablePublicationOverConnection);
	}
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_SITIN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("err", err, _buf);
	if (err)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("thisAddress", thisAddress, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableObjectName", tableObjectName, _buf);
		Atf::XmlElement::encodeAsXmlElement("sittingOut", sittingOut, _buf);
		Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
		Atf::XmlElement::encodeAsXmlElement("sitOutNextBlind", sitOutNextBlind, _buf);
		Atf::XmlElement::encodeAsXmlElement("state3Plus", state3Plus, _buf);
		Atf::XmlElement::encodeAsXmlElement("isTablePublicationOverConnection", isTablePublicationOverConnection, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("err"))
			{
				err = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("thisAddress"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, thisAddress)) return false;
			}
			else if (_element.equals("tableObjectName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tableObjectName)) return false;
			}
			else if (_element.equals("sittingOut"))
			{
				sittingOut = (*_value.ptr() == '1');
			}
			else if (_element.equals("chips"))
			{
				chips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sitOutNextBlind"))
			{
				sitOutNextBlind = (*_value.ptr() == '1');
			}
			else if (_element.equals("state3Plus"))
			{
				state3Plus = (*_value.ptr() == '1');
			}
			else if (_element.equals("isTablePublicationOverConnection"))
			{
				isTablePublicationOverConnection = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(thisAddress);
		_msg.composeString(tableObjectName);
		_msg.composeBOOL(sittingOut);
		_msg.composeUINT32(chips);
		_msg.composeBOOL(sitOutNextBlind);
		_msg.composeBOOL(state3Plus);
		_msg.composeBOOL(isTablePublicationOverConnection);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(thisAddress);
		_parser.parseStringP(tableObjectName);
		_parser.parseBOOL(sittingOut);
		_parser.parseUINT32(chips);
		_parser.parseBOOL(sitOutNextBlind);
		_parser.parseBOOL(state3Plus);
		_parser.parseBOOL(isTablePublicationOverConnection);
	}
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("err", err);
	if (err)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("thisAddress", thisAddress);
		_jsonstr.compose("tableObjectName", tableObjectName);
		_jsonstr.compose("sittingOut", sittingOut);
		_jsonstr.compose("chips", chips);
		_jsonstr.compose("sitOutNextBlind", sitOutNextBlind);
		_jsonstr.compose("state3Plus", state3Plus);
		_jsonstr.compose("isTablePublicationOverConnection", isTablePublicationOverConnection);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("err", err);
	if (err)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("thisAddress", thisAddress);
		_jparser.parseByNameThrow("tableObjectName", tableObjectName);
		_jparser.parseByNameThrow("sittingOut", sittingOut);
		_jparser.parseByNameThrow("chips", chips);
		_jparser.parseByNameThrow("sitOutNextBlind", sitOutNextBlind);
		_jparser.parseByNameThrow("state3Plus", state3Plus);
		_jparser.parseByNameThrow("isTablePublicationOverConnection", isTablePublicationOverConnection);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err = 0;
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("err", err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString thisAddress; _jparser.validateByNameThrow("thisAddress", thisAddress);
		AtfValidator::validateInt(_descr, "thisAddress", thisAddress.length(), _checker, __FILE__, __LINE__);
		PString tableObjectName; _jparser.validateByNameThrow("tableObjectName", tableObjectName);
		AtfValidator::validateInt(_descr, "tableObjectName", tableObjectName.length(), _checker, __FILE__, __LINE__);
		bool sittingOut; _jparser.validateByNameThrow("sittingOut", sittingOut);
		AtfValidator::validateInt(_descr, "sittingOut", sittingOut, _checker, __FILE__, __LINE__);
		UINT32 chips; _jparser.validateByNameThrow("chips", chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		bool sitOutNextBlind; _jparser.validateByNameThrow("sitOutNextBlind", sitOutNextBlind);
		AtfValidator::validateInt(_descr, "sitOutNextBlind", sitOutNextBlind, _checker, __FILE__, __LINE__);
		bool state3Plus; _jparser.validateByNameThrow("state3Plus", state3Plus);
		AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
		bool isTablePublicationOverConnection; _jparser.validateByNameThrow("isTablePublicationOverConnection", isTablePublicationOverConnection);
		AtfValidator::validateInt(_descr, "isTablePublicationOverConnection", isTablePublicationOverConnection, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "thisAddress"); size_t szThisAddress = strlen(_dummy);
		AtfValidator::validateInt(_descr, "thisAddress", szThisAddress, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tableObjectName"); size_t szTableObjectName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableObjectName", szTableObjectName, _checker, __FILE__, __LINE__);
		bool sittingOut; _parser.parseBOOL(sittingOut);
		AtfValidator::validateInt(_descr, "sittingOut", sittingOut, _checker, __FILE__, __LINE__);
		UINT32 chips; _parser.parseUINT32(chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		bool sitOutNextBlind; _parser.parseBOOL(sitOutNextBlind);
		AtfValidator::validateInt(_descr, "sitOutNextBlind", sitOutNextBlind, _checker, __FILE__, __LINE__);
		bool state3Plus; _parser.parseBOOL(state3Plus);
		AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
		bool isTablePublicationOverConnection; _parser.parseBOOL(isTablePublicationOverConnection);
		AtfValidator::validateInt(_descr, "isTablePublicationOverConnection", isTablePublicationOverConnection, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_GET_ENTRIES
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::Protocol_BL_USER_GET_ENTRIES()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::clear()
{
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::equals(const Protocol_BL_USER_GET_ENTRIES& _o) const
{
	return true;
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_GET_ENTRIES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_GET_ENTRIES*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_GET_ENTRIES).append(")");
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_GET_ENTRIES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::parseMsg(CommMsgParser& _parser)
{
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_ENTRIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_ENTRIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    EntryBody
//=================================================================

BlitzLobby::cli::EntryBody::EntryBody()
{
	clear();
}

void BlitzLobby::cli::EntryBody::clear()
{
	entryId = 0;
	thisAddress.clear();
	tableObjectName.clear();
	sittingOut = false;
	chips = 0;
	autoRebuyOpt = 0;
	autoRebuyBigBets = 0;
	fallUnderBigBets = 0;
	fallUnderPercents = 0;
	sitOutNextBlind = false;
	state3Plus = false;
}

bool BlitzLobby::cli::EntryBody::equals(const EntryBody& _o) const
{
	return entryId == _o.entryId &&
		Atf::atfPStringEquals(thisAddress, _o.thisAddress) &&
		Atf::atfPStringEquals(tableObjectName, _o.tableObjectName) &&
		sittingOut == _o.sittingOut &&
		chips == _o.chips &&
		autoRebuyOpt == _o.autoRebuyOpt &&
		autoRebuyBigBets == _o.autoRebuyBigBets &&
		fallUnderBigBets == _o.fallUnderBigBets &&
		fallUnderPercents == _o.fallUnderPercents &&
		sitOutNextBlind == _o.sitOutNextBlind &&
		state3Plus == _o.state3Plus;
}

const char *BlitzLobby::cli::EntryBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("thisAddress=");
	_buf.append(thisAddress);
	_buf.append(',');
	_buf.append("tableObjectName=");
	_buf.append(tableObjectName);
	_buf.append(',');
	_buf.append("sittingOut=");
	_buf.appendUint(sittingOut);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendUint(chips);
	_buf.append(',');
	_buf.append("autoRebuyOpt=");
	_buf.appendInt(autoRebuyOpt);
	_buf.append(',');
	_buf.append("autoRebuyBigBets=");
	_buf.appendUint(autoRebuyBigBets);
	_buf.append(',');
	_buf.append("fallUnderBigBets=");
	_buf.appendUint(fallUnderBigBets);
	_buf.append(',');
	_buf.append("fallUnderPercents=");
	_buf.appendUint(fallUnderPercents);
	_buf.append(',');
	_buf.append("sitOutNextBlind=");
	_buf.appendUint(sitOutNextBlind);
	_buf.append(',');
	_buf.append("state3Plus=");
	_buf.appendUint(state3Plus);
	_buf.append('}');
	return _buf.c_str();
}

const char *BlitzLobby::cli::EntryBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("thisAddress", thisAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableObjectName", tableObjectName, _buf);
	Atf::XmlElement::encodeAsXmlElement("sittingOut", sittingOut, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoRebuyOpt", autoRebuyOpt, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoRebuyBigBets", autoRebuyBigBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("fallUnderBigBets", fallUnderBigBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("fallUnderPercents", fallUnderPercents, _buf);
	Atf::XmlElement::encodeAsXmlElement("sitOutNextBlind", sitOutNextBlind, _buf);
	Atf::XmlElement::encodeAsXmlElement("state3Plus", state3Plus, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool BlitzLobby::cli::EntryBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("entryId"))
		{
			entryId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("thisAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, thisAddress)) return false;
		}
		else if (_element.equals("tableObjectName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tableObjectName)) return false;
		}
		else if (_element.equals("sittingOut"))
		{
			sittingOut = (*_value.ptr() == '1');
		}
		else if (_element.equals("chips"))
		{
			chips = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("autoRebuyOpt"))
		{
			autoRebuyOpt = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("autoRebuyBigBets"))
		{
			autoRebuyBigBets = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fallUnderBigBets"))
		{
			fallUnderBigBets = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fallUnderPercents"))
		{
			fallUnderPercents = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sitOutNextBlind"))
		{
			sitOutNextBlind = (*_value.ptr() == '1');
		}
		else if (_element.equals("state3Plus"))
		{
			state3Plus = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void BlitzLobby::cli::EntryBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(EntryBody())) // not empty
	{
		_body.composeUINT32(entryId);
		_body.composeString(thisAddress);
		_body.composeString(tableObjectName);
		_body.composeBOOL(sittingOut);
		_body.composeUINT32(chips);
		_body.composeINT8(autoRebuyOpt);
		_body.composeUINT16(autoRebuyBigBets);
		_body.composeUINT16(fallUnderBigBets);
		_body.composeUINT16(fallUnderPercents);
		_body.composeBOOL(sitOutNextBlind);
		_body.composeBOOL(state3Plus);
	}

	_msg.composeMsgBody(_body);
}

void BlitzLobby::cli::EntryBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(entryId);
	_parser0.parseStringP(thisAddress);
	_parser0.parseStringP(tableObjectName);
	_parser0.parseBOOL(sittingOut);
	_parser0.parseUINT32(chips);
	_parser0.parseINT8(autoRebuyOpt);
	_parser0.parseUINT16(autoRebuyBigBets);
	_parser0.parseUINT16(fallUnderBigBets);
	_parser0.parseUINT16(fallUnderPercents);
	_parser0.parseBOOL(sitOutNextBlind);
	_parser0.parseBOOL(state3Plus);
}

const char *BlitzLobby::cli::EntryBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("thisAddress", thisAddress);
	_jsonstr.compose("tableObjectName", tableObjectName);
	_jsonstr.compose("sittingOut", sittingOut);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("autoRebuyOpt", autoRebuyOpt);
	_jsonstr.compose("autoRebuyBigBets", autoRebuyBigBets);
	_jsonstr.compose("fallUnderBigBets", fallUnderBigBets);
	_jsonstr.compose("fallUnderPercents", fallUnderPercents);
	_jsonstr.compose("sitOutNextBlind", sitOutNextBlind);
	_jsonstr.compose("state3Plus", state3Plus);
	return _buf.c_str();
}

void BlitzLobby::cli::EntryBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("thisAddress", thisAddress);
	_jparser.parseByNameThrow("tableObjectName", tableObjectName);
	_jparser.parseByNameThrow("sittingOut", sittingOut);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("autoRebuyOpt", autoRebuyOpt);
	_jparser.parseByNameThrow("autoRebuyBigBets", autoRebuyBigBets);
	_jparser.parseByNameThrow("fallUnderBigBets", fallUnderBigBets);
	_jparser.parseByNameThrow("fallUnderPercents", fallUnderPercents);
	_jparser.parseByNameThrow("sitOutNextBlind", sitOutNextBlind);
	_jparser.parseByNameThrow("state3Plus", state3Plus);
}

/* static */ void BlitzLobby::cli::EntryBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	PString thisAddress; _jparser.validateByNameThrow("thisAddress", thisAddress);
	AtfValidator::validateInt(_descr, "thisAddress", thisAddress.length(), _checker, __FILE__, __LINE__);
	PString tableObjectName; _jparser.validateByNameThrow("tableObjectName", tableObjectName);
	AtfValidator::validateInt(_descr, "tableObjectName", tableObjectName.length(), _checker, __FILE__, __LINE__);
	bool sittingOut; _jparser.validateByNameThrow("sittingOut", sittingOut);
	AtfValidator::validateInt(_descr, "sittingOut", sittingOut, _checker, __FILE__, __LINE__);
	UINT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT8 autoRebuyOpt; _jparser.validateByNameThrow("autoRebuyOpt", autoRebuyOpt);
	AtfValidator::validateInt(_descr, "autoRebuyOpt", autoRebuyOpt, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyBigBets; _jparser.validateByNameThrow("autoRebuyBigBets", autoRebuyBigBets);
	AtfValidator::validateInt(_descr, "autoRebuyBigBets", autoRebuyBigBets, _checker, __FILE__, __LINE__);
	UINT16 fallUnderBigBets; _jparser.validateByNameThrow("fallUnderBigBets", fallUnderBigBets);
	AtfValidator::validateInt(_descr, "fallUnderBigBets", fallUnderBigBets, _checker, __FILE__, __LINE__);
	UINT16 fallUnderPercents; _jparser.validateByNameThrow("fallUnderPercents", fallUnderPercents);
	AtfValidator::validateInt(_descr, "fallUnderPercents", fallUnderPercents, _checker, __FILE__, __LINE__);
	bool sitOutNextBlind; _jparser.validateByNameThrow("sitOutNextBlind", sitOutNextBlind);
	AtfValidator::validateInt(_descr, "sitOutNextBlind", sitOutNextBlind, _checker, __FILE__, __LINE__);
	bool state3Plus; _jparser.validateByNameThrow("state3Plus", state3Plus);
	AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
}

/*static*/ void BlitzLobby::cli::EntryBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 entryId; _parser0.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "thisAddress"); size_t szThisAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "thisAddress", szThisAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tableObjectName"); size_t szTableObjectName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableObjectName", szTableObjectName, _checker, __FILE__, __LINE__);
	bool sittingOut; _parser0.parseBOOL(sittingOut);
	AtfValidator::validateInt(_descr, "sittingOut", sittingOut, _checker, __FILE__, __LINE__);
	UINT32 chips; _parser0.parseUINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT8 autoRebuyOpt; _parser0.parseINT8(autoRebuyOpt);
	AtfValidator::validateInt(_descr, "autoRebuyOpt", autoRebuyOpt, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyBigBets; _parser0.parseUINT16(autoRebuyBigBets);
	AtfValidator::validateInt(_descr, "autoRebuyBigBets", autoRebuyBigBets, _checker, __FILE__, __LINE__);
	UINT16 fallUnderBigBets; _parser0.parseUINT16(fallUnderBigBets);
	AtfValidator::validateInt(_descr, "fallUnderBigBets", fallUnderBigBets, _checker, __FILE__, __LINE__);
	UINT16 fallUnderPercents; _parser0.parseUINT16(fallUnderPercents);
	AtfValidator::validateInt(_descr, "fallUnderPercents", fallUnderPercents, _checker, __FILE__, __LINE__);
	bool sitOutNextBlind; _parser0.parseBOOL(sitOutNextBlind);
	AtfValidator::validateInt(_descr, "sitOutNextBlind", sitOutNextBlind, _checker, __FILE__, __LINE__);
	bool state3Plus; _parser0.parseBOOL(state3Plus);
	AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_BL_USER_GET_ENTRIES_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::Protocol_BL_USER_GET_ENTRIES_REPLY()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::clear()
{
	entryBodies.clear();
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::equals(const Protocol_BL_USER_GET_ENTRIES_REPLY& _o) const
{
	return entryBodies.equals(_o.entryBodies);
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_GET_ENTRIES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_GET_ENTRIES_REPLY*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_GET_ENTRIES_REPLY).append(")");
	_buf.append(',');
	_buf.append("entryBodies=");
	entryBodies.toTraceString(_buf);
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_GET_ENTRIES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	entryBodies.toXmlString("entryBodies", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("entryBodies"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< EntryBody, 4 > >::FromXmlString(_value, entryBodies)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	entryBodies.composeMsg(_msg, _ignoreJSON);
}

void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::parseMsg(CommMsgParser& _parser)
{
	entryBodies.parseMsg(_parser);
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryBodies", entryBodies);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entryBodies", entryBodies);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_ENTRIES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< EntryBody > entryBodies; _jparser.validateByNameThrow("entryBodies", entryBodies);
	AtfValidator::validateInt(_descr, "entryBodies", entryBodies.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_ENTRIES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szEntryBodies = Atf::LAtfVector< EntryBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("entryBodies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "entryBodies", szEntryBodies, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_WHERE_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::Protocol_BL_USER_WHERE_REPLY()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::clear()
{
	entryId = 0;
	err = 0;
	errStr.clear();
	thisAddress.clear();
	tableObjectName.clear();
	sittingOut = false;
	chips = 0;
	sitOutNextBlind = false;
	italianSessionId.clear();
	state3Plus = false;
	scalePM = 0;
	privatePubl = false;
}

bool BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::equals(const Protocol_BL_USER_WHERE_REPLY& _o) const
{
	return entryId == _o.entryId &&
		err == _o.err &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		Atf::atfPStringEquals(thisAddress, _o.thisAddress) &&
		Atf::atfPStringEquals(tableObjectName, _o.tableObjectName) &&
		sittingOut == _o.sittingOut &&
		chips == _o.chips &&
		sitOutNextBlind == _o.sitOutNextBlind &&
		Atf::atfPStringEquals(italianSessionId, _o.italianSessionId) &&
		state3Plus == _o.state3Plus &&
		scalePM == _o.scalePM &&
		privatePubl == _o.privatePubl;
}

bool BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_WHERE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_WHERE_REPLY*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_WHERE_REPLY).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if( err )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("thisAddress=");
		_buf.append(thisAddress);
		_buf.append(',');
		_buf.append("tableObjectName=");
		_buf.append(tableObjectName);
		_buf.append(',');
		_buf.append("sittingOut=");
		_buf.appendUint(sittingOut);
		_buf.append(',');
		_buf.append("chips=");
		_buf.appendUint(chips);
		_buf.append(',');
		_buf.append("sitOutNextBlind=");
		_buf.appendUint(sitOutNextBlind);
		_buf.append(',');
		_buf.append("italianSessionId=");
		_buf.append(italianSessionId);
		_buf.append(',');
		_buf.append("state3Plus=");
		_buf.appendUint(state3Plus);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendUint(scalePM);
		_buf.append(',');
		_buf.append("privatePubl=");
		_buf.appendUint(privatePubl);
	}
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_WHERE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("err", err, _buf);
	if( err )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("thisAddress", thisAddress, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableObjectName", tableObjectName, _buf);
		Atf::XmlElement::encodeAsXmlElement("sittingOut", sittingOut, _buf);
		Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
		Atf::XmlElement::encodeAsXmlElement("sitOutNextBlind", sitOutNextBlind, _buf);
		Atf::XmlElement::encodeAsXmlElement("italianSessionId", italianSessionId, _buf);
		Atf::XmlElement::encodeAsXmlElement("state3Plus", state3Plus, _buf);
		Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
		Atf::XmlElement::encodeAsXmlElement("privatePubl", privatePubl, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("err"))
			{
				err = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("thisAddress"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, thisAddress)) return false;
			}
			else if (_element.equals("tableObjectName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tableObjectName)) return false;
			}
			else if (_element.equals("sittingOut"))
			{
				sittingOut = (*_value.ptr() == '1');
			}
			else if (_element.equals("chips"))
			{
				chips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sitOutNextBlind"))
			{
				sitOutNextBlind = (*_value.ptr() == '1');
			}
			else if (_element.equals("italianSessionId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, italianSessionId)) return false;
			}
			else if (_element.equals("state3Plus"))
			{
				state3Plus = (*_value.ptr() == '1');
			}
			else if (_element.equals("scalePM"))
			{
				scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("privatePubl"))
			{
				privatePubl = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT16(err);
	if( err )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeString(thisAddress);
		_msg.composeString(tableObjectName);
		_msg.composeBOOL(sittingOut);
		_msg.composeUINT32(chips);
		_msg.composeBOOL(sitOutNextBlind);
		_msg.composeString(italianSessionId);
		_msg.composeBOOL(state3Plus);
		_msg.composeUINT32(scalePM);
		_msg.composeBOOL(privatePubl);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT16(err);
	if( err )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseStringP(thisAddress);
		_parser.parseStringP(tableObjectName);
		_parser.parseBOOL(sittingOut);
		_parser.parseUINT32(chips);
		_parser.parseBOOL(sitOutNextBlind);
		_parser.parseStringP(italianSessionId);
		_parser.parseBOOL(state3Plus);
		_parser.parseUINT32(scalePM);
		_parser.parseBOOL(privatePubl);
	}
}

const char *BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("err", err);
	if( err )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("thisAddress", thisAddress);
		_jsonstr.compose("tableObjectName", tableObjectName);
		_jsonstr.compose("sittingOut", sittingOut);
		_jsonstr.compose("chips", chips);
		_jsonstr.compose("sitOutNextBlind", sitOutNextBlind);
		_jsonstr.compose("italianSessionId", italianSessionId);
		_jsonstr.compose("state3Plus", state3Plus);
		_jsonstr.compose("scalePM", scalePM);
		_jsonstr.compose("privatePubl", privatePubl);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("err", err);
	if( err )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("thisAddress", thisAddress);
		_jparser.parseByNameThrow("tableObjectName", tableObjectName);
		_jparser.parseByNameThrow("sittingOut", sittingOut);
		_jparser.parseByNameThrow("chips", chips);
		_jparser.parseByNameThrow("sitOutNextBlind", sitOutNextBlind);
		_jparser.parseByNameThrow("italianSessionId", italianSessionId);
		_jparser.parseByNameThrow("state3Plus", state3Plus);
		_jparser.parseByNameThrow("scalePM", scalePM);
		_jparser.parseByNameThrow("privatePubl", privatePubl);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_WHERE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err = 0;
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("err", err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if( err )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString thisAddress; _jparser.validateByNameThrow("thisAddress", thisAddress);
		AtfValidator::validateInt(_descr, "thisAddress", thisAddress.length(), _checker, __FILE__, __LINE__);
		PString tableObjectName; _jparser.validateByNameThrow("tableObjectName", tableObjectName);
		AtfValidator::validateInt(_descr, "tableObjectName", tableObjectName.length(), _checker, __FILE__, __LINE__);
		bool sittingOut; _jparser.validateByNameThrow("sittingOut", sittingOut);
		AtfValidator::validateInt(_descr, "sittingOut", sittingOut, _checker, __FILE__, __LINE__);
		UINT32 chips; _jparser.validateByNameThrow("chips", chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		bool sitOutNextBlind; _jparser.validateByNameThrow("sitOutNextBlind", sitOutNextBlind);
		AtfValidator::validateInt(_descr, "sitOutNextBlind", sitOutNextBlind, _checker, __FILE__, __LINE__);
		PString italianSessionId; _jparser.validateByNameThrow("italianSessionId", italianSessionId);
		AtfValidator::validateInt(_descr, "italianSessionId", italianSessionId.length(), _checker, __FILE__, __LINE__);
		bool state3Plus; _jparser.validateByNameThrow("state3Plus", state3Plus);
		AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
		UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		bool privatePubl; _jparser.validateByNameThrow("privatePubl", privatePubl);
		AtfValidator::validateInt(_descr, "privatePubl", privatePubl, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_WHERE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if( err )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "thisAddress"); size_t szThisAddress = strlen(_dummy);
		AtfValidator::validateInt(_descr, "thisAddress", szThisAddress, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tableObjectName"); size_t szTableObjectName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableObjectName", szTableObjectName, _checker, __FILE__, __LINE__);
		bool sittingOut; _parser.parseBOOL(sittingOut);
		AtfValidator::validateInt(_descr, "sittingOut", sittingOut, _checker, __FILE__, __LINE__);
		UINT32 chips; _parser.parseUINT32(chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		bool sitOutNextBlind; _parser.parseBOOL(sitOutNextBlind);
		AtfValidator::validateInt(_descr, "sitOutNextBlind", sitOutNextBlind, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "italianSessionId"); size_t szItalianSessionId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "italianSessionId", szItalianSessionId, _checker, __FILE__, __LINE__);
		bool state3Plus; _parser.parseBOOL(state3Plus);
		AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
		UINT32 scalePM; _parser.parseUINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		bool privatePubl; _parser.parseBOOL(privatePubl);
		AtfValidator::validateInt(_descr, "privatePubl", privatePubl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_GET_BUYIN_INFO
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::Protocol_BL_USER_GET_BUYIN_INFO()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::clear()
{
	entryId = 0;
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::equals(const Protocol_BL_USER_GET_BUYIN_INFO& _o) const
{
	return entryId == _o.entryId;
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_GET_BUYIN_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_GET_BUYIN_INFO*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_GET_BUYIN_INFO).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_GET_BUYIN_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(entryId);
}

void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(entryId);
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryId", entryId);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("entryId", entryId);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_BUYIN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_BUYIN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    OneAccount
//=================================================================

BlitzLobby::cli::OneAccount::OneAccount()
{
	clear();
}

void BlitzLobby::cli::OneAccount::clear()
{
	currency.clear();
	convRate = 0;
	chips = 0;
	tChips = 0;
	chipsDst = 0;
	tChipsDst = 0;
}

bool BlitzLobby::cli::OneAccount::equals(const OneAccount& _o) const
{
	return Atf::atfPStringEquals(currency, _o.currency) &&
		convRate == _o.convRate &&
		chips == _o.chips &&
		tChips == _o.tChips &&
		chipsDst == _o.chipsDst &&
		tChipsDst == _o.tChipsDst;
}

const char *BlitzLobby::cli::OneAccount::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("convRate=");
	_buf.appendInt64(convRate);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt(chips);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("chipsDst=");
	_buf.appendInt(chipsDst);
	_buf.append(',');
	_buf.append("tChipsDst=");
	_buf.appendInt(tChipsDst);
	_buf.append('}');
	return _buf.c_str();
}

const char *BlitzLobby::cli::OneAccount::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("convRate", convRate, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("chipsDst", chipsDst, _buf);
	Atf::XmlElement::encodeAsXmlElement("tChipsDst", tChipsDst, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool BlitzLobby::cli::OneAccount::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("convRate"))
		{
			convRate = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chips"))
		{
			chips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tChips"))
		{
			tChips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chipsDst"))
		{
			chipsDst = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tChipsDst"))
		{
			tChipsDst = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void BlitzLobby::cli::OneAccount::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(OneAccount())) // not empty
	{
		_body.composeString(currency);
		_body.composeINT64(convRate);
		_body.composeINT32(chips);
		_body.composeINT32(tChips);
		_body.composeINT32(chipsDst);
		_body.composeINT32(tChipsDst);
	}

	_msg.composeMsgBody(_body);
}

void BlitzLobby::cli::OneAccount::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(convRate);
	_parser0.parseINT32(chips);
	_parser0.parseINT32(tChips);
	_parser0.parseINT32(chipsDst);
	_parser0.parseINT32(tChipsDst);
}

const char *BlitzLobby::cli::OneAccount::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("convRate", convRate);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("tChips", tChips);
	_jsonstr.compose("chipsDst", chipsDst);
	_jsonstr.compose("tChipsDst", tChipsDst);
	return _buf.c_str();
}

void BlitzLobby::cli::OneAccount::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("convRate", convRate);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("tChips", tChips);
	_jparser.parseByNameThrow("chipsDst", chipsDst);
	_jparser.parseByNameThrow("tChipsDst", tChipsDst);
}

/* static */ void BlitzLobby::cli::OneAccount::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT64 convRate; _jparser.validateByNameThrow("convRate", convRate);
	AtfValidator::validateInt(_descr, "convRate", convRate, _checker, __FILE__, __LINE__);
	INT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT32 tChips; _jparser.validateByNameThrow("tChips", tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	INT32 chipsDst; _jparser.validateByNameThrow("chipsDst", chipsDst);
	AtfValidator::validateInt(_descr, "chipsDst", chipsDst, _checker, __FILE__, __LINE__);
	INT32 tChipsDst; _jparser.validateByNameThrow("tChipsDst", tChipsDst);
	AtfValidator::validateInt(_descr, "tChipsDst", tChipsDst, _checker, __FILE__, __LINE__);
}

/*static*/ void BlitzLobby::cli::OneAccount::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 convRate; _parser0.parseINT64(convRate);
	AtfValidator::validateInt(_descr, "convRate", convRate, _checker, __FILE__, __LINE__);
	INT32 chips; _parser0.parseINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT32 tChips; _parser0.parseINT32(tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	INT32 chipsDst; _parser0.parseINT32(chipsDst);
	AtfValidator::validateInt(_descr, "chipsDst", chipsDst, _checker, __FILE__, __LINE__);
	INT32 tChipsDst; _parser0.parseINT32(tChipsDst);
	AtfValidator::validateInt(_descr, "tChipsDst", tChipsDst, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MoneyAvailInfo
//=================================================================

BlitzLobby::cli::MoneyAvailInfo::MoneyAvailInfo()
{
	clear();
}

void BlitzLobby::cli::MoneyAvailInfo::clear()
{
	currencyDst.clear();
	availForSpendingDst = 0;
	unclearedDst = 0;
	accounts.clear();
	flags = 0;
	flags2 = 0;
	userRollId = 0;
	rollAmount = 0;
	availWithoutConv = 0;
}

bool BlitzLobby::cli::MoneyAvailInfo::equals(const MoneyAvailInfo& _o) const
{
	return Atf::atfPStringEquals(currencyDst, _o.currencyDst) &&
		availForSpendingDst == _o.availForSpendingDst &&
		unclearedDst == _o.unclearedDst &&
		accounts.equals(_o.accounts) &&
		flags == _o.flags &&
		flags2 == _o.flags2 &&
		userRollId == _o.userRollId &&
		rollAmount == _o.rollAmount &&
		availWithoutConv == _o.availWithoutConv;
}

const char *BlitzLobby::cli::MoneyAvailInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currencyDst=");
	_buf.append(currencyDst);
	_buf.append(',');
	_buf.append("availForSpendingDst=");
	_buf.appendInt(availForSpendingDst);
	_buf.append(',');
	_buf.append("unclearedDst=");
	_buf.appendInt(unclearedDst);
	_buf.append(',');
	_buf.append("accounts=");
	accounts.toTraceString(_buf);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("userRollId=");
	_buf.appendUint(userRollId);
	_buf.append(',');
	_buf.append("rollAmount=");
	_buf.appendInt(rollAmount);
	_buf.append(',');
	_buf.append("availWithoutConv=");
	_buf.appendInt(availWithoutConv);
	_buf.append('}');
	return _buf.c_str();
}

const char *BlitzLobby::cli::MoneyAvailInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("currencyDst", currencyDst, _buf);
	Atf::XmlElement::encodeAsXmlElement("availForSpendingDst", availForSpendingDst, _buf);
	Atf::XmlElement::encodeAsXmlElement("unclearedDst", unclearedDst, _buf);
	accounts.toXmlString("accounts", _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags2", flags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("userRollId", userRollId, _buf);
	Atf::XmlElement::encodeAsXmlElement("rollAmount", rollAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("availWithoutConv", availWithoutConv, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool BlitzLobby::cli::MoneyAvailInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("currencyDst"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currencyDst)) return false;
		}
		else if (_element.equals("availForSpendingDst"))
		{
			availForSpendingDst = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("unclearedDst"))
		{
			unclearedDst = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("accounts"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< OneAccount, 4 > >::FromXmlString(_value, accounts)) return false;
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags2"))
		{
			flags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userRollId"))
		{
			userRollId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rollAmount"))
		{
			rollAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("availWithoutConv"))
		{
			availWithoutConv = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void BlitzLobby::cli::MoneyAvailInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MoneyAvailInfo())) // not empty
	{
		_body.composeString(currencyDst);
		_body.composeINT32(availForSpendingDst);
		_body.composeINT32(unclearedDst);
		accounts.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(flags);
		_body.composeUINT64(flags2);
		_body.composeUINT32(userRollId);
		_body.composeINT32(rollAmount);
		_body.composeINT32(availWithoutConv);
	}

	_msg.composeMsgBody(_body);
}

void BlitzLobby::cli::MoneyAvailInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currencyDst);
	_parser0.parseINT32(availForSpendingDst);
	_parser0.parseINT32(unclearedDst);
	accounts.parseMsg(_parser0);
	_parser0.parseUINT32(flags);
	_parser0.parseUINT64(flags2);
	_parser0.parseUINT32(userRollId);
	_parser0.parseINT32(rollAmount);
	_parser0.parseINT32(availWithoutConv);
}

const char *BlitzLobby::cli::MoneyAvailInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currencyDst", currencyDst);
	_jsonstr.compose("availForSpendingDst", availForSpendingDst);
	_jsonstr.compose("unclearedDst", unclearedDst);
	_jsonstr.compose("accounts", accounts);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("flags2", flags2);
	_jsonstr.compose("userRollId", userRollId);
	_jsonstr.compose("rollAmount", rollAmount);
	_jsonstr.compose("availWithoutConv", availWithoutConv);
	return _buf.c_str();
}

void BlitzLobby::cli::MoneyAvailInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currencyDst", currencyDst);
	_jparser.parseByNameThrow("availForSpendingDst", availForSpendingDst);
	_jparser.parseByNameThrow("unclearedDst", unclearedDst);
	_jparser.parseByNameThrow("accounts", accounts);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("flags2", flags2);
	_jparser.parseByNameThrow("userRollId", userRollId);
	_jparser.parseByNameThrow("rollAmount", rollAmount);
	_jparser.parseByNameThrow("availWithoutConv", availWithoutConv);
}

/* static */ void BlitzLobby::cli::MoneyAvailInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currencyDst; _jparser.validateByNameThrow("currencyDst", currencyDst);
	AtfValidator::validateInt(_descr, "currencyDst", currencyDst.length(), _checker, __FILE__, __LINE__);
	INT32 availForSpendingDst; _jparser.validateByNameThrow("availForSpendingDst", availForSpendingDst);
	AtfValidator::validateInt(_descr, "availForSpendingDst", availForSpendingDst, _checker, __FILE__, __LINE__);
	INT32 unclearedDst; _jparser.validateByNameThrow("unclearedDst", unclearedDst);
	AtfValidator::validateInt(_descr, "unclearedDst", unclearedDst, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< OneAccount > accounts; _jparser.validateByNameThrow("accounts", accounts);
	AtfValidator::validateInt(_descr, "accounts", accounts.size(), _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _jparser.validateByNameThrow("flags2", flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	UINT32 userRollId; _jparser.validateByNameThrow("userRollId", userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
	INT32 rollAmount; _jparser.validateByNameThrow("rollAmount", rollAmount);
	AtfValidator::validateInt(_descr, "rollAmount", rollAmount, _checker, __FILE__, __LINE__);
	INT32 availWithoutConv; _jparser.validateByNameThrow("availWithoutConv", availWithoutConv);
	AtfValidator::validateInt(_descr, "availWithoutConv", availWithoutConv, _checker, __FILE__, __LINE__);
}

/*static*/ void BlitzLobby::cli::MoneyAvailInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currencyDst"); size_t szCurrencyDst = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currencyDst", szCurrencyDst, _checker, __FILE__, __LINE__);
	INT32 availForSpendingDst; _parser0.parseINT32(availForSpendingDst);
	AtfValidator::validateInt(_descr, "availForSpendingDst", availForSpendingDst, _checker, __FILE__, __LINE__);
	INT32 unclearedDst; _parser0.parseINT32(unclearedDst);
	AtfValidator::validateInt(_descr, "unclearedDst", unclearedDst, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAccounts = Atf::LAtfVector< OneAccount, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("accounts"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "accounts", szAccounts, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser0.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	UINT32 userRollId; _parser0.parseUINT32(userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
	INT32 rollAmount; _parser0.parseINT32(rollAmount);
	AtfValidator::validateInt(_descr, "rollAmount", rollAmount, _checker, __FILE__, __LINE__);
	INT32 availWithoutConv; _parser0.parseINT32(availWithoutConv);
	AtfValidator::validateInt(_descr, "availWithoutConv", availWithoutConv, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_BL_USER_GET_BUYIN_INFO_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::Protocol_BL_USER_GET_BUYIN_INFO_REPLY()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::clear()
{
	errCode = 0;
	errDescrForUser.clear();
	currency.clear();
	minChipsLimit = 0;
	enoughOnAllAccounts = false;
	chips = 0;
	chipsMin = 0;
	maxBuyIn = 0;
	chipsQuantum = 0;
	playAddB = 0;
	playAddU = 0;
	clientCurrencyContext.clear();
	entriesLeft = 0;
	entryId = 0;
	chipsInPlay = 0;
	enoughMoneyInOtherCurrencies = false;
	maxRebuyChips = 0;
	totalRebuyChips = 0;
	playChips64 = 0;
	scalePM = 0;
	clientServiceFlag = 0;
	defaultBuyIn = 0;
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::equals(const Protocol_BL_USER_GET_BUYIN_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescrForUser, _o.errDescrForUser) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		enoughOnAllAccounts == _o.enoughOnAllAccounts &&
		chips == _o.chips &&
		chipsMin == _o.chipsMin &&
		maxBuyIn == _o.maxBuyIn &&
		chipsQuantum == _o.chipsQuantum &&
		playAddB == _o.playAddB &&
		playAddU == _o.playAddU &&
		clientCurrencyContext.equals(_o.clientCurrencyContext) &&
		entriesLeft == _o.entriesLeft &&
		entryId == _o.entryId &&
		chipsInPlay == _o.chipsInPlay &&
		enoughMoneyInOtherCurrencies == _o.enoughMoneyInOtherCurrencies &&
		maxRebuyChips == _o.maxRebuyChips &&
		totalRebuyChips == _o.totalRebuyChips &&
		playChips64 == _o.playChips64 &&
		scalePM == _o.scalePM &&
		clientServiceFlag == _o.clientServiceFlag &&
		defaultBuyIn == _o.defaultBuyIn;
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_GET_BUYIN_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_GET_BUYIN_INFO_REPLY*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_GET_BUYIN_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescrForUser=");
		_buf.append(errDescrForUser);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("minChipsLimit=");
		_buf.appendUint(minChipsLimit);
		_buf.append(',');
		_buf.append("enoughOnAllAccounts=");
		_buf.appendUint(enoughOnAllAccounts);
	}
	else
	{
		_buf.append(',');
		_buf.append("chips=");
		_buf.appendInt(chips);
		_buf.append(',');
		_buf.append("chipsMin=");
		_buf.appendInt(chipsMin);
		_buf.append(',');
		_buf.append("maxBuyIn=");
		_buf.appendInt(maxBuyIn);
		_buf.append(',');
		_buf.append("chipsQuantum=");
		_buf.appendInt(chipsQuantum);
		_buf.append(',');
		_buf.append("playAddB=");
		_buf.appendUint(playAddB);
		_buf.append(',');
		_buf.append("playAddU=");
		_buf.appendInt(playAddU);
		_buf.append(',');
		_buf.append("clientCurrencyContext=");
		clientCurrencyContext.toTraceString(_buf);
		_buf.append(',');
		_buf.append("entriesLeft=");
		_buf.appendInt(entriesLeft);
		_buf.append(',');
		_buf.append("entryId=");
		_buf.appendUint(entryId);
		_buf.append(',');
		_buf.append("chipsInPlay=");
		_buf.appendInt(chipsInPlay);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrencies=");
		_buf.appendUint(enoughMoneyInOtherCurrencies);
		_buf.append(',');
		_buf.append("maxRebuyChips=");
		_buf.appendInt(maxRebuyChips);
		_buf.append(',');
		_buf.append("totalRebuyChips=");
		_buf.appendInt(totalRebuyChips);
		_buf.append(',');
		_buf.append("playChips64=");
		_buf.appendInt64(playChips64);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendInt(scalePM);
		_buf.append(',');
		_buf.append("clientServiceFlag=");
		_buf.appendUint(clientServiceFlag);
		_buf.append(',');
		_buf.append("defaultBuyIn=");
		_buf.appendInt(defaultBuyIn);
	}
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_GET_BUYIN_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescrForUser", errDescrForUser, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("minChipsLimit", minChipsLimit, _buf);
		Atf::XmlElement::encodeAsXmlElement("enoughOnAllAccounts", enoughOnAllAccounts, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
		Atf::XmlElement::encodeAsXmlElement("chipsMin", chipsMin, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
		Atf::XmlElement::encodeAsXmlElement("chipsQuantum", chipsQuantum, _buf);
		Atf::XmlElement::encodeAsXmlElement("playAddB", playAddB, _buf);
		Atf::XmlElement::encodeAsXmlElement("playAddU", playAddU, _buf);
		clientCurrencyContext.toXmlString("clientCurrencyContext", _buf);
		Atf::XmlElement::encodeAsXmlElement("entriesLeft", entriesLeft, _buf);
		Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
		Atf::XmlElement::encodeAsXmlElement("chipsInPlay", chipsInPlay, _buf);
		Atf::XmlElement::encodeAsXmlElement("enoughMoneyInOtherCurrencies", enoughMoneyInOtherCurrencies, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxRebuyChips", maxRebuyChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("totalRebuyChips", totalRebuyChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("playChips64", playChips64, _buf);
		Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientServiceFlag", clientServiceFlag, _buf);
		Atf::XmlElement::encodeAsXmlElement("defaultBuyIn", defaultBuyIn, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescrForUser"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescrForUser)) return false;
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("minChipsLimit"))
			{
				minChipsLimit = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("enoughOnAllAccounts"))
			{
				enoughOnAllAccounts = (*_value.ptr() == '1');
			}
			else if (_element.equals("chips"))
			{
				chips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chipsMin"))
			{
				chipsMin = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxBuyIn"))
			{
				maxBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chipsQuantum"))
			{
				chipsQuantum = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playAddB"))
			{
				playAddB = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playAddU"))
			{
				playAddU = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientCurrencyContext"))
			{
				if(!Atf::AtfTempl< MoneyAvailInfo >::FromXmlString(_value, clientCurrencyContext)) return false;
			}
			else if (_element.equals("entriesLeft"))
			{
				entriesLeft = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chipsInPlay"))
			{
				chipsInPlay = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("enoughMoneyInOtherCurrencies"))
			{
				enoughMoneyInOtherCurrencies = (*_value.ptr() == '1');
			}
			else if (_element.equals("maxRebuyChips"))
			{
				maxRebuyChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("totalRebuyChips"))
			{
				totalRebuyChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playChips64"))
			{
				playChips64 = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("scalePM"))
			{
				scalePM = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientServiceFlag"))
			{
				clientServiceFlag = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("defaultBuyIn"))
			{
				defaultBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescrForUser);
		_msg.composeString(currency);
		_msg.composeUINT32(minChipsLimit);
		_msg.composeBOOL(enoughOnAllAccounts);
	}
	else
	{
		_msg.composeINT32(chips);
		_msg.composeINT32(chipsMin);
		_msg.composeINT32(maxBuyIn);
		_msg.composeINT32(chipsQuantum);
		_msg.composeBYTE(playAddB);
		_msg.composeINT32(playAddU);
		clientCurrencyContext.composeMsg(_msg, _ignoreJSON);
		_msg.composeINT8(entriesLeft);
		_msg.composeUINT32(entryId);
		_msg.composeINT32(chipsInPlay);
		_msg.composeBOOL(enoughMoneyInOtherCurrencies);
		_msg.composeINT32(maxRebuyChips);
		_msg.composeINT32(totalRebuyChips);
		_msg.composeINT64(playChips64);
		_msg.composeINT32(scalePM);
		_msg.composeBYTE(clientServiceFlag);
		_msg.composeINT32(defaultBuyIn);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescrForUser);
		_parser.parseStringP(currency);
		_parser.parseUINT32(minChipsLimit);
		_parser.parseBOOL(enoughOnAllAccounts);
	}
	else
	{
		_parser.parseINT32(chips);
		_parser.parseINT32(chipsMin);
		_parser.parseINT32(maxBuyIn);
		_parser.parseINT32(chipsQuantum);
		_parser.parseBYTE(playAddB);
		_parser.parseINT32(playAddU);
		clientCurrencyContext.parseMsg(_parser);
		_parser.parseINT8(entriesLeft);
		_parser.parseUINT32(entryId);
		_parser.parseINT32(chipsInPlay);
		_parser.parseBOOL(enoughMoneyInOtherCurrencies);
		_parser.parseINT32(maxRebuyChips);
		_parser.parseINT32(totalRebuyChips);
		_parser.parseINT64(playChips64);
		_parser.parseINT32(scalePM);
		_parser.parseBYTE(clientServiceFlag);
		_parser.parseINT32(defaultBuyIn);
	}
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescrForUser", errDescrForUser);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("minChipsLimit", minChipsLimit);
		_jsonstr.compose("enoughOnAllAccounts", enoughOnAllAccounts);
	}
	else
	{
		_jsonstr.compose("chips", chips);
		_jsonstr.compose("chipsMin", chipsMin);
		_jsonstr.compose("maxBuyIn", maxBuyIn);
		_jsonstr.compose("chipsQuantum", chipsQuantum);
		_jsonstr.compose("playAddB", playAddB);
		_jsonstr.compose("playAddU", playAddU);
		_jsonstr.compose("clientCurrencyContext", clientCurrencyContext);
		_jsonstr.compose("entriesLeft", entriesLeft);
		_jsonstr.compose("entryId", entryId);
		_jsonstr.compose("chipsInPlay", chipsInPlay);
		_jsonstr.compose("enoughMoneyInOtherCurrencies", enoughMoneyInOtherCurrencies);
		_jsonstr.compose("maxRebuyChips", maxRebuyChips);
		_jsonstr.compose("totalRebuyChips", totalRebuyChips);
		_jsonstr.compose("playChips64", playChips64);
		_jsonstr.compose("scalePM", scalePM);
		_jsonstr.compose("clientServiceFlag", clientServiceFlag);
		_jsonstr.compose("defaultBuyIn", defaultBuyIn);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescrForUser", errDescrForUser);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("minChipsLimit", minChipsLimit);
		_jparser.parseByNameThrow("enoughOnAllAccounts", enoughOnAllAccounts);
	}
	else
	{
		_jparser.parseByNameThrow("chips", chips);
		_jparser.parseByNameThrow("chipsMin", chipsMin);
		_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
		_jparser.parseByNameThrow("chipsQuantum", chipsQuantum);
		_jparser.parseByNameThrow("playAddB", playAddB);
		_jparser.parseByNameThrow("playAddU", playAddU);
		_jparser.parseByNameThrow("clientCurrencyContext", clientCurrencyContext);
		_jparser.parseByNameThrow("entriesLeft", entriesLeft);
		_jparser.parseByNameThrow("entryId", entryId);
		_jparser.parseByNameThrow("chipsInPlay", chipsInPlay);
		_jparser.parseByNameThrow("enoughMoneyInOtherCurrencies", enoughMoneyInOtherCurrencies);
		_jparser.parseByNameThrow("maxRebuyChips", maxRebuyChips);
		_jparser.parseByNameThrow("totalRebuyChips", totalRebuyChips);
		_jparser.parseByNameThrow("playChips64", playChips64);
		_jparser.parseByNameThrow("scalePM", scalePM);
		_jparser.parseByNameThrow("clientServiceFlag", clientServiceFlag);
		_jparser.parseByNameThrow("defaultBuyIn", defaultBuyIn);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_BUYIN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescrForUser; _jparser.validateByNameThrow("errDescrForUser", errDescrForUser);
		AtfValidator::validateInt(_descr, "errDescrForUser", errDescrForUser.length(), _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		UINT32 minChipsLimit; _jparser.validateByNameThrow("minChipsLimit", minChipsLimit);
		AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
		bool enoughOnAllAccounts; _jparser.validateByNameThrow("enoughOnAllAccounts", enoughOnAllAccounts);
		AtfValidator::validateInt(_descr, "enoughOnAllAccounts", enoughOnAllAccounts, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 chips; _jparser.validateByNameThrow("chips", chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		INT32 chipsMin; _jparser.validateByNameThrow("chipsMin", chipsMin);
		AtfValidator::validateInt(_descr, "chipsMin", chipsMin, _checker, __FILE__, __LINE__);
		INT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
		AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
		INT32 chipsQuantum; _jparser.validateByNameThrow("chipsQuantum", chipsQuantum);
		AtfValidator::validateInt(_descr, "chipsQuantum", chipsQuantum, _checker, __FILE__, __LINE__);
		BYTE playAddB; _jparser.validateByNameThrow("playAddB", playAddB);
		AtfValidator::validateInt(_descr, "playAddB", playAddB, _checker, __FILE__, __LINE__);
		INT32 playAddU; _jparser.validateByNameThrow("playAddU", playAddU);
		AtfValidator::validateInt(_descr, "playAddU", playAddU, _checker, __FILE__, __LINE__);
		MoneyAvailInfo clientCurrencyContext; _jparser.validateByNameThrow("clientCurrencyContext", clientCurrencyContext);
		INT8 entriesLeft; _jparser.validateByNameThrow("entriesLeft", entriesLeft);
		AtfValidator::validateInt(_descr, "entriesLeft", entriesLeft, _checker, __FILE__, __LINE__);
		UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
		AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
		INT32 chipsInPlay; _jparser.validateByNameThrow("chipsInPlay", chipsInPlay);
		AtfValidator::validateInt(_descr, "chipsInPlay", chipsInPlay, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrencies; _jparser.validateByNameThrow("enoughMoneyInOtherCurrencies", enoughMoneyInOtherCurrencies);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrencies", enoughMoneyInOtherCurrencies, _checker, __FILE__, __LINE__);
		INT32 maxRebuyChips; _jparser.validateByNameThrow("maxRebuyChips", maxRebuyChips);
		AtfValidator::validateInt(_descr, "maxRebuyChips", maxRebuyChips, _checker, __FILE__, __LINE__);
		INT32 totalRebuyChips; _jparser.validateByNameThrow("totalRebuyChips", totalRebuyChips);
		AtfValidator::validateInt(_descr, "totalRebuyChips", totalRebuyChips, _checker, __FILE__, __LINE__);
		INT64 playChips64; _jparser.validateByNameThrow("playChips64", playChips64);
		AtfValidator::validateInt(_descr, "playChips64", playChips64, _checker, __FILE__, __LINE__);
		INT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE clientServiceFlag; _jparser.validateByNameThrow("clientServiceFlag", clientServiceFlag);
		AtfValidator::validateInt(_descr, "clientServiceFlag", clientServiceFlag, _checker, __FILE__, __LINE__);
		INT32 defaultBuyIn; _jparser.validateByNameThrow("defaultBuyIn", defaultBuyIn);
		AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_BUYIN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescrForUser"); size_t szErrDescrForUser = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescrForUser", szErrDescrForUser, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		UINT32 minChipsLimit; _parser.parseUINT32(minChipsLimit);
		AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
		bool enoughOnAllAccounts; _parser.parseBOOL(enoughOnAllAccounts);
		AtfValidator::validateInt(_descr, "enoughOnAllAccounts", enoughOnAllAccounts, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 chips; _parser.parseINT32(chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		INT32 chipsMin; _parser.parseINT32(chipsMin);
		AtfValidator::validateInt(_descr, "chipsMin", chipsMin, _checker, __FILE__, __LINE__);
		INT32 maxBuyIn; _parser.parseINT32(maxBuyIn);
		AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
		INT32 chipsQuantum; _parser.parseINT32(chipsQuantum);
		AtfValidator::validateInt(_descr, "chipsQuantum", chipsQuantum, _checker, __FILE__, __LINE__);
		BYTE playAddB; _parser.parseBYTE(playAddB);
		AtfValidator::validateInt(_descr, "playAddB", playAddB, _checker, __FILE__, __LINE__);
		INT32 playAddU; _parser.parseINT32(playAddU);
		AtfValidator::validateInt(_descr, "playAddU", playAddU, _checker, __FILE__, __LINE__);
		PString _descbuf;
		MoneyAvailInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientCurrencyContext"), _fieldsWithUnparsedContent);
		INT8 entriesLeft; _parser.parseINT8(entriesLeft);
		AtfValidator::validateInt(_descr, "entriesLeft", entriesLeft, _checker, __FILE__, __LINE__);
		UINT32 entryId; _parser.parseUINT32(entryId);
		AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
		INT32 chipsInPlay; _parser.parseINT32(chipsInPlay);
		AtfValidator::validateInt(_descr, "chipsInPlay", chipsInPlay, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrencies; _parser.parseBOOL(enoughMoneyInOtherCurrencies);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrencies", enoughMoneyInOtherCurrencies, _checker, __FILE__, __LINE__);
		INT32 maxRebuyChips; _parser.parseINT32(maxRebuyChips);
		AtfValidator::validateInt(_descr, "maxRebuyChips", maxRebuyChips, _checker, __FILE__, __LINE__);
		INT32 totalRebuyChips; _parser.parseINT32(totalRebuyChips);
		AtfValidator::validateInt(_descr, "totalRebuyChips", totalRebuyChips, _checker, __FILE__, __LINE__);
		INT64 playChips64; _parser.parseINT64(playChips64);
		AtfValidator::validateInt(_descr, "playChips64", playChips64, _checker, __FILE__, __LINE__);
		INT32 scalePM; _parser.parseINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE clientServiceFlag; _parser.parseBYTE(clientServiceFlag);
		AtfValidator::validateInt(_descr, "clientServiceFlag", clientServiceFlag, _checker, __FILE__, __LINE__);
		INT32 defaultBuyIn; _parser.parseINT32(defaultBuyIn);
		AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_GET_INFO
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_GET_INFO::Protocol_BL_USER_GET_INFO()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_INFO::clear()
{
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_INFO::equals(const Protocol_BL_USER_GET_INFO& _o) const
{
	return true;
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_GET_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_GET_INFO*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_GET_INFO).append(")");
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_GET_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_GET_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void BlitzLobby::cli::Protocol_BL_USER_GET_INFO::parseMsg(CommMsgParser& _parser)
{
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_GET_INFO_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::Protocol_BL_USER_GET_INFO_REPLY()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::clear()
{
	name.clear();
	isOneToOne = 0;
	isPlayMoney = 0;
	nMaxPlayersPerTable = 0;
	game = 0;
	hiLo = 0;
	smartLoBet = 0;
	highBet = 0;
	structure = 0;
	cap = 0;
	tableFlags = 0;
	chatLang = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	ante = 0;
	itId.clear();
	shortHanded = false;
	scalePM = 0;
	noVppGainSites = 0;
	tableStakes.clear();
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::equals(const Protocol_BL_USER_GET_INFO_REPLY& _o) const
{
	return Atf::atfPStringEquals(name, _o.name) &&
		isOneToOne == _o.isOneToOne &&
		isPlayMoney == _o.isPlayMoney &&
		nMaxPlayersPerTable == _o.nMaxPlayersPerTable &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		smartLoBet == _o.smartLoBet &&
		highBet == _o.highBet &&
		structure == _o.structure &&
		cap == _o.cap &&
		tableFlags == _o.tableFlags &&
		chatLang == _o.chatLang &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		ante == _o.ante &&
		Atf::atfPStringEquals(itId, _o.itId) &&
		shortHanded == _o.shortHanded &&
		scalePM == _o.scalePM &&
		noVppGainSites == _o.noVppGainSites &&
		tableStakes.equals(_o.tableStakes);
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_GET_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_GET_INFO_REPLY*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("isOneToOne=");
	_buf.appendUint(isOneToOne);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("nMaxPlayersPerTable=");
	_buf.appendUint(nMaxPlayersPerTable);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("smartLoBet=");
	_buf.appendUint(smartLoBet);
	_buf.append(',');
	_buf.append("highBet=");
	_buf.appendUint(highBet);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendUint(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("itId=");
	_buf.append(itId);
	_buf.append(',');
	_buf.append("shortHanded=");
	_buf.appendUint(shortHanded);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("noVppGainSites=");
	_buf.appendUint(noVppGainSites);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_GET_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("isOneToOne", isOneToOne, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("nMaxPlayersPerTable", nMaxPlayersPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiLo", hiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("smartLoBet", smartLoBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("highBet", highBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("cap", cap, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags", tableFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("chatLang", chatLang, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("minChipsLimit", minChipsLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("itId", itId, _buf);
	Atf::XmlElement::encodeAsXmlElement("shortHanded", shortHanded, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("noVppGainSites", noVppGainSites, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("name"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
			}
			else if (_element.equals("isOneToOne"))
			{
				isOneToOne = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("nMaxPlayersPerTable"))
			{
				nMaxPlayersPerTable = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("hiLo"))
			{
				hiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("smartLoBet"))
			{
				smartLoBet = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("highBet"))
			{
				highBet = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cap"))
			{
				cap = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableFlags"))
			{
				tableFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chatLang"))
			{
				chatLang = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("minChipsLimit"))
			{
				minChipsLimit = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxBuyIn"))
			{
				maxBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ante"))
			{
				ante = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("itId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, itId)) return false;
			}
			else if (_element.equals("shortHanded"))
			{
				shortHanded = (*_value.ptr() == '1');
			}
			else if (_element.equals("scalePM"))
			{
				scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("noVppGainSites"))
			{
				noVppGainSites = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableStakes"))
			{
				if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(name);
	_msg.composeBYTE(isOneToOne);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeBYTE(nMaxPlayersPerTable);
	_msg.composeBYTE(game);
	_msg.composeBYTE(hiLo);
	_msg.composeUINT32(smartLoBet);
	_msg.composeUINT32(highBet);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(cap);
	_msg.composeUINT32(tableFlags);
	_msg.composeUINT16(chatLang);
	_msg.composeString(currency);
	_msg.composeUINT32(minChipsLimit);
	_msg.composeUINT32(maxBuyIn);
	_msg.composeUINT32(ante);
	_msg.composeString(itId);
	_msg.composeBOOL(shortHanded);
	_msg.composeUINT32(scalePM);
	_msg.composeUINT32(noVppGainSites);
	tableStakes.composeMsg(_msg, _ignoreJSON);
}

void BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
	_parser.parseBYTE(isOneToOne);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseBYTE(nMaxPlayersPerTable);
	_parser.parseBYTE(game);
	_parser.parseBYTE(hiLo);
	_parser.parseUINT32(smartLoBet);
	_parser.parseUINT32(highBet);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(cap);
	_parser.parseUINT32(tableFlags);
	_parser.parseUINT16(chatLang);
	_parser.parseStringP(currency);
	_parser.parseUINT32(minChipsLimit);
	_parser.parseUINT32(maxBuyIn);
	_parser.parseUINT32(ante);
	_parser.parseStringP(itId);
	_parser.parseBOOL(shortHanded);
	_parser.parseUINT32(scalePM);
	_parser.parseUINT32(noVppGainSites);
	if(_parser.parseEnded()) return;
	tableStakes.parseMsg(_parser);
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	_jsonstr.compose("isOneToOne", isOneToOne);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("nMaxPlayersPerTable", nMaxPlayersPerTable);
	_jsonstr.compose("game", game);
	_jsonstr.compose("hiLo", hiLo);
	_jsonstr.compose("smartLoBet", smartLoBet);
	_jsonstr.compose("highBet", highBet);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("cap", cap);
	_jsonstr.compose("tableFlags", tableFlags);
	_jsonstr.compose("chatLang", chatLang);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("minChipsLimit", minChipsLimit);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("itId", itId);
	_jsonstr.compose("shortHanded", shortHanded);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("noVppGainSites", noVppGainSites);
	_jsonstr.compose("tableStakes", tableStakes);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("isOneToOne", isOneToOne);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("nMaxPlayersPerTable", nMaxPlayersPerTable);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("hiLo", hiLo);
	_jparser.parseByNameThrow("smartLoBet", smartLoBet);
	_jparser.parseByNameThrow("highBet", highBet);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("cap", cap);
	_jparser.parseByNameThrow("tableFlags", tableFlags);
	_jparser.parseByNameThrow("chatLang", chatLang);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("minChipsLimit", minChipsLimit);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("itId", itId);
	_jparser.parseByNameThrow("shortHanded", shortHanded);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("noVppGainSites", noVppGainSites);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableStakes", tableStakes);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	BYTE isOneToOne; _jparser.validateByNameThrow("isOneToOne", isOneToOne);
	AtfValidator::validateInt(_descr, "isOneToOne", isOneToOne, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE nMaxPlayersPerTable; _jparser.validateByNameThrow("nMaxPlayersPerTable", nMaxPlayersPerTable);
	AtfValidator::validateInt(_descr, "nMaxPlayersPerTable", nMaxPlayersPerTable, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE hiLo; _jparser.validateByNameThrow("hiLo", hiLo);
	AtfValidator::validateInt(_descr, "hiLo", hiLo, _checker, __FILE__, __LINE__);
	UINT32 smartLoBet; _jparser.validateByNameThrow("smartLoBet", smartLoBet);
	AtfValidator::validateInt(_descr, "smartLoBet", smartLoBet, _checker, __FILE__, __LINE__);
	UINT32 highBet; _jparser.validateByNameThrow("highBet", highBet);
	AtfValidator::validateInt(_descr, "highBet", highBet, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 cap; _jparser.validateByNameThrow("cap", cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _jparser.validateByNameThrow("tableFlags", tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _jparser.validateByNameThrow("chatLang", chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _jparser.validateByNameThrow("minChipsLimit", minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	PString itId; _jparser.validateByNameThrow("itId", itId);
	AtfValidator::validateInt(_descr, "itId", itId.length(), _checker, __FILE__, __LINE__);
	bool shortHanded; _jparser.validateByNameThrow("shortHanded", shortHanded);
	AtfValidator::validateInt(_descr, "shortHanded", shortHanded, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 noVppGainSites; _jparser.validateByNameThrow("noVppGainSites", noVppGainSites);
	AtfValidator::validateInt(_descr, "noVppGainSites", noVppGainSites, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	BYTE isOneToOne; _parser.parseBYTE(isOneToOne);
	AtfValidator::validateInt(_descr, "isOneToOne", isOneToOne, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE nMaxPlayersPerTable; _parser.parseBYTE(nMaxPlayersPerTable);
	AtfValidator::validateInt(_descr, "nMaxPlayersPerTable", nMaxPlayersPerTable, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser.parseBYTE(hiLo);
	AtfValidator::validateInt(_descr, "hiLo", hiLo, _checker, __FILE__, __LINE__);
	UINT32 smartLoBet; _parser.parseUINT32(smartLoBet);
	AtfValidator::validateInt(_descr, "smartLoBet", smartLoBet, _checker, __FILE__, __LINE__);
	UINT32 highBet; _parser.parseUINT32(highBet);
	AtfValidator::validateInt(_descr, "highBet", highBet, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 cap; _parser.parseUINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _parser.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _parser.parseUINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser.parseUINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "itId"); size_t szItId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "itId", szItId, _checker, __FILE__, __LINE__);
	bool shortHanded; _parser.parseBOOL(shortHanded);
	AtfValidator::validateInt(_descr, "shortHanded", shortHanded, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 noVppGainSites; _parser.parseUINT32(noVppGainSites);
	AtfValidator::validateInt(_descr, "noVppGainSites", noVppGainSites, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	TableCommon::TableStakes::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SET_AUTOREBUY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::Protocol_BL_USER_SET_AUTOREBUY()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::clear()
{
	entryId = 0;
	autoRebuyOpt = 0;
	autoRebuyBigBets = 0;
	fallUnderBigBets = 0;
	fallUnderPercents = 0;
}

bool BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::equals(const Protocol_BL_USER_SET_AUTOREBUY& _o) const
{
	return entryId == _o.entryId &&
		autoRebuyOpt == _o.autoRebuyOpt &&
		autoRebuyBigBets == _o.autoRebuyBigBets &&
		fallUnderBigBets == _o.fallUnderBigBets &&
		fallUnderPercents == _o.fallUnderPercents;
}

bool BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_SET_AUTOREBUY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_SET_AUTOREBUY*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SET_AUTOREBUY).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("autoRebuyOpt=");
	_buf.appendInt(autoRebuyOpt);
	_buf.append(',');
	_buf.append("autoRebuyBigBets=");
	_buf.appendUint(autoRebuyBigBets);
	_buf.append(',');
	_buf.append("fallUnderBigBets=");
	_buf.appendUint(fallUnderBigBets);
	_buf.append(',');
	_buf.append("fallUnderPercents=");
	_buf.appendUint(fallUnderPercents);
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_SET_AUTOREBUY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoRebuyOpt", autoRebuyOpt, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoRebuyBigBets", autoRebuyBigBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("fallUnderBigBets", fallUnderBigBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("fallUnderPercents", fallUnderPercents, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("autoRebuyOpt"))
			{
				autoRebuyOpt = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("autoRebuyBigBets"))
			{
				autoRebuyBigBets = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fallUnderBigBets"))
			{
				fallUnderBigBets = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fallUnderPercents"))
			{
				fallUnderPercents = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT8(autoRebuyOpt);
	_msg.composeUINT16(autoRebuyBigBets);
	_msg.composeUINT16(fallUnderBigBets);
	_msg.composeUINT16(fallUnderPercents);
}

void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT8(autoRebuyOpt);
	_parser.parseUINT16(autoRebuyBigBets);
	_parser.parseUINT16(fallUnderBigBets);
	_parser.parseUINT16(fallUnderPercents);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("autoRebuyOpt", autoRebuyOpt);
	_jsonstr.compose("autoRebuyBigBets", autoRebuyBigBets);
	_jsonstr.compose("fallUnderBigBets", fallUnderBigBets);
	_jsonstr.compose("fallUnderPercents", fallUnderPercents);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("autoRebuyOpt", autoRebuyOpt);
	_jparser.parseByNameThrow("autoRebuyBigBets", autoRebuyBigBets);
	_jparser.parseByNameThrow("fallUnderBigBets", fallUnderBigBets);
	_jparser.parseByNameThrow("fallUnderPercents", fallUnderPercents);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SET_AUTOREBUY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	INT8 autoRebuyOpt; _jparser.validateByNameThrow("autoRebuyOpt", autoRebuyOpt);
	AtfValidator::validateIntRange(_descr, "autoRebuyOpt", autoRebuyOpt, 0, 100, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyBigBets; _jparser.validateByNameThrow("autoRebuyBigBets", autoRebuyBigBets);
	AtfValidator::validateIntRange(_descr, "autoRebuyBigBets", autoRebuyBigBets, 0, 1000, _checker, __FILE__, __LINE__);
	UINT16 fallUnderBigBets; _jparser.validateByNameThrow("fallUnderBigBets", fallUnderBigBets);
	AtfValidator::validateIntRange(_descr, "fallUnderBigBets", fallUnderBigBets, 0, 1000, _checker, __FILE__, __LINE__);
	UINT16 fallUnderPercents; _jparser.validateByNameThrow("fallUnderPercents", fallUnderPercents);
	AtfValidator::validateIntRange(_descr, "fallUnderPercents", fallUnderPercents, 0, 100, _checker, __FILE__, __LINE__);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SET_AUTOREBUY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	INT8 autoRebuyOpt; _parser.parseINT8(autoRebuyOpt);
	AtfValidator::validateIntRange(_descr, "autoRebuyOpt", autoRebuyOpt, 0, 100, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyBigBets; _parser.parseUINT16(autoRebuyBigBets);
	AtfValidator::validateIntRange(_descr, "autoRebuyBigBets", autoRebuyBigBets, 0, 1000, _checker, __FILE__, __LINE__);
	UINT16 fallUnderBigBets; _parser.parseUINT16(fallUnderBigBets);
	AtfValidator::validateIntRange(_descr, "fallUnderBigBets", fallUnderBigBets, 0, 1000, _checker, __FILE__, __LINE__);
	UINT16 fallUnderPercents; _parser.parseUINT16(fallUnderPercents);
	AtfValidator::validateIntRange(_descr, "fallUnderPercents", fallUnderPercents, 0, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SET_AUTOREBUY_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::Protocol_BL_USER_SET_AUTOREBUY_REPLY()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::clear()
{
	entryId = 0;
	err = 0;
	errDescr.clear();
}

bool BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::equals(const Protocol_BL_USER_SET_AUTOREBUY_REPLY& _o) const
{
	return entryId == _o.entryId &&
		err == _o.err &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_SET_AUTOREBUY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_SET_AUTOREBUY_REPLY*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SET_AUTOREBUY_REPLY).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_SET_AUTOREBUY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("err", err, _buf);
	if (err)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("err"))
			{
				err = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("err", err);
	if (err)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("err", err);
	if (err)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SET_AUTOREBUY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err = 0;
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("err", err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SET_AUTOREBUY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SITOUT
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SITOUT::Protocol_BL_USER_SITOUT()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT::clear()
{
	entryId = 0;
}

bool BlitzLobby::cli::Protocol_BL_USER_SITOUT::equals(const Protocol_BL_USER_SITOUT& _o) const
{
	return entryId == _o.entryId;
}

bool BlitzLobby::cli::Protocol_BL_USER_SITOUT::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_SITOUT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_SITOUT*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SITOUT).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_SITOUT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_SITOUT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(entryId);
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryId", entryId);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entryId", entryId);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITOUT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SITOUT_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::Protocol_BL_USER_SITOUT_REPLY()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::clear()
{
	entryId = 0;
	err = 0;
	errDescr.clear();
}

bool BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::equals(const Protocol_BL_USER_SITOUT_REPLY& _o) const
{
	return entryId == _o.entryId &&
		err == _o.err &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_SITOUT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_SITOUT_REPLY*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SITOUT_REPLY).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_SITOUT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("err", err, _buf);
	if (err)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("err"))
			{
				err = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("err", err);
	if (err)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("err", err);
	if (err)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err = 0;
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("err", err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SITOUT_NEXTBB
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::Protocol_BL_USER_SITOUT_NEXTBB()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::clear()
{
	entryId = 0;
	sitoutBB = false;
}

bool BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::equals(const Protocol_BL_USER_SITOUT_NEXTBB& _o) const
{
	return entryId == _o.entryId &&
		sitoutBB == _o.sitoutBB;
}

bool BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_SITOUT_NEXTBB != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_SITOUT_NEXTBB*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SITOUT_NEXTBB).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("sitoutBB=");
	_buf.appendUint(sitoutBB);
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_SITOUT_NEXTBB).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("sitoutBB", sitoutBB, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sitoutBB"))
			{
				sitoutBB = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(entryId);
	_msg.composeBOOL(sitoutBB);
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseBOOL(sitoutBB);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("sitoutBB", sitoutBB);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("sitoutBB", sitoutBB);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITOUT_NEXTBB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	bool sitoutBB; _jparser.validateByNameThrow("sitoutBB", sitoutBB);
	AtfValidator::validateInt(_descr, "sitoutBB", sitoutBB, _checker, __FILE__, __LINE__);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITOUT_NEXTBB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	bool sitoutBB; _parser.parseBOOL(sitoutBB);
	AtfValidator::validateInt(_descr, "sitoutBB", sitoutBB, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SITOUT_NEXTBB_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::Protocol_BL_USER_SITOUT_NEXTBB_REPLY()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::clear()
{
	entryId = 0;
	err = 0;
	errDescr.clear();
	sitOutNextBlind = false;
}

bool BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::equals(const Protocol_BL_USER_SITOUT_NEXTBB_REPLY& _o) const
{
	return entryId == _o.entryId &&
		err == _o.err &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		sitOutNextBlind == _o.sitOutNextBlind;
}

bool BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_SITOUT_NEXTBB_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_SITOUT_NEXTBB_REPLY*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SITOUT_NEXTBB_REPLY).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("sitOutNextBlind=");
		_buf.appendUint(sitOutNextBlind);
	}
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_SITOUT_NEXTBB_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("err", err, _buf);
	if (err)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("sitOutNextBlind", sitOutNextBlind, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("err"))
			{
				err = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("sitOutNextBlind"))
			{
				sitOutNextBlind = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(sitOutNextBlind);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(sitOutNextBlind);
	}
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("err", err);
	if (err)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("sitOutNextBlind", sitOutNextBlind);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("err", err);
	if (err)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("sitOutNextBlind", sitOutNextBlind);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITOUT_NEXTBB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err = 0;
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("err", err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool sitOutNextBlind; _jparser.validateByNameThrow("sitOutNextBlind", sitOutNextBlind);
		AtfValidator::validateInt(_descr, "sitOutNextBlind", sitOutNextBlind, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITOUT_NEXTBB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool sitOutNextBlind; _parser.parseBOOL(sitOutNextBlind);
		AtfValidator::validateInt(_descr, "sitOutNextBlind", sitOutNextBlind, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SET_3PLUS
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::Protocol_BL_USER_SET_3PLUS()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::clear()
{
	entryId = 0;
	state3Plus = false;
}

bool BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::equals(const Protocol_BL_USER_SET_3PLUS& _o) const
{
	return entryId == _o.entryId &&
		state3Plus == _o.state3Plus;
}

bool BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_SET_3PLUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_SET_3PLUS*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SET_3PLUS).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("state3Plus=");
	_buf.appendUint(state3Plus);
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_SET_3PLUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("state3Plus", state3Plus, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("state3Plus"))
			{
				state3Plus = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(entryId);
	_msg.composeBOOL(state3Plus);
}

void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseBOOL(state3Plus);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("state3Plus", state3Plus);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("state3Plus", state3Plus);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SET_3PLUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	bool state3Plus; _jparser.validateByNameThrow("state3Plus", state3Plus);
	AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SET_3PLUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	bool state3Plus; _parser.parseBOOL(state3Plus);
	AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SET_3PLUS_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::Protocol_BL_USER_SET_3PLUS_REPLY()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::clear()
{
	entryId = 0;
	err = 0;
	errDescr.clear();
	state3Plus = false;
}

bool BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::equals(const Protocol_BL_USER_SET_3PLUS_REPLY& _o) const
{
	return entryId == _o.entryId &&
		err == _o.err &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		state3Plus == _o.state3Plus;
}

bool BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (BL_USER_SET_3PLUS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_BL_USER_SET_3PLUS_REPLY*)_other));
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SET_3PLUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("state3Plus=");
		_buf.appendUint(state3Plus);
	}
	return _buf.c_str();
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(BL_USER_SET_3PLUS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("err", err, _buf);
	if (err)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("state3Plus", state3Plus, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("err"))
			{
				err = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("state3Plus"))
			{
				state3Plus = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(state3Plus);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(state3Plus);
	}
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("err", err);
	if (err)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("state3Plus", state3Plus);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("err", err);
	if (err)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("state3Plus", state3Plus);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SET_3PLUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err = 0;
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("err", err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool state3Plus; _jparser.validateByNameThrow("state3Plus", state3Plus);
		AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SET_3PLUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool state3Plus; _parser.parseBOOL(state3Plus);
		AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* BlitzLobby::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case BL_USER_ADDON: _obj = new cli::Protocol_BL_USER_ADDON(); break;
			case BL_USER_ADDON_REPLY: _obj = new cli::Protocol_BL_USER_ADDON_REPLY(); break;
			case BL_USER_BUYIN: _obj = new cli::Protocol_BL_USER_BUYIN(); break;
			case BL_USER_BUYIN_REPLY: _obj = new cli::Protocol_BL_USER_BUYIN_REPLY(); break;
			case BL_USER_GET_BUYIN_INFO: _obj = new cli::Protocol_BL_USER_GET_BUYIN_INFO(); break;
			case BL_USER_GET_BUYIN_INFO_REPLY: _obj = new cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY(); break;
			case BL_USER_GET_ENTRIES: _obj = new cli::Protocol_BL_USER_GET_ENTRIES(); break;
			case BL_USER_GET_ENTRIES_REPLY: _obj = new cli::Protocol_BL_USER_GET_ENTRIES_REPLY(); break;
			case BL_USER_GET_INFO: _obj = new cli::Protocol_BL_USER_GET_INFO(); break;
			case BL_USER_GET_INFO_REPLY: _obj = new cli::Protocol_BL_USER_GET_INFO_REPLY(); break;
			case BL_USER_OUT: _obj = new cli::Protocol_BL_USER_OUT(); break;
			case BL_USER_OUT_REPLY: _obj = new cli::Protocol_BL_USER_OUT_REPLY(); break;
			case BL_USER_SET_3PLUS: _obj = new cli::Protocol_BL_USER_SET_3PLUS(); break;
			case BL_USER_SET_3PLUS_REPLY: _obj = new cli::Protocol_BL_USER_SET_3PLUS_REPLY(); break;
			case BL_USER_SET_AUTOREBUY: _obj = new cli::Protocol_BL_USER_SET_AUTOREBUY(); break;
			case BL_USER_SET_AUTOREBUY_REPLY: _obj = new cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY(); break;
			case BL_USER_SITIN: _obj = new cli::Protocol_BL_USER_SITIN(); break;
			case BL_USER_SITIN_REPLY: _obj = new cli::Protocol_BL_USER_SITIN_REPLY(); break;
			case BL_USER_SITOUT: _obj = new cli::Protocol_BL_USER_SITOUT(); break;
			case BL_USER_SITOUT_NEXTBB: _obj = new cli::Protocol_BL_USER_SITOUT_NEXTBB(); break;
			case BL_USER_SITOUT_NEXTBB_REPLY: _obj = new cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY(); break;
			case BL_USER_SITOUT_REPLY: _obj = new cli::Protocol_BL_USER_SITOUT_REPLY(); break;
			case BL_USER_WHERE_REPLY: _obj = new cli::Protocol_BL_USER_WHERE_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool BlitzLobby::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case BL_USER_ADDON: cli::Protocol_BL_USER_ADDON::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_ADDON_REPLY: cli::Protocol_BL_USER_ADDON_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_BUYIN: cli::Protocol_BL_USER_BUYIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_BUYIN_REPLY: cli::Protocol_BL_USER_BUYIN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_BUYIN_INFO: cli::Protocol_BL_USER_GET_BUYIN_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_BUYIN_INFO_REPLY: cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_ENTRIES: cli::Protocol_BL_USER_GET_ENTRIES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_ENTRIES_REPLY: cli::Protocol_BL_USER_GET_ENTRIES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_INFO: cli::Protocol_BL_USER_GET_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_INFO_REPLY: cli::Protocol_BL_USER_GET_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_OUT: cli::Protocol_BL_USER_OUT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_OUT_REPLY: cli::Protocol_BL_USER_OUT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SET_3PLUS: cli::Protocol_BL_USER_SET_3PLUS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SET_3PLUS_REPLY: cli::Protocol_BL_USER_SET_3PLUS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SET_AUTOREBUY: cli::Protocol_BL_USER_SET_AUTOREBUY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SET_AUTOREBUY_REPLY: cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITIN: cli::Protocol_BL_USER_SITIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITIN_REPLY: cli::Protocol_BL_USER_SITIN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITOUT: cli::Protocol_BL_USER_SITOUT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITOUT_NEXTBB: cli::Protocol_BL_USER_SITOUT_NEXTBB::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITOUT_NEXTBB_REPLY: cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITOUT_REPLY: cli::Protocol_BL_USER_SITOUT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_WHERE_REPLY: cli::Protocol_BL_USER_WHERE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool BlitzLobby::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case BL_USER_ADDON: cli::Protocol_BL_USER_ADDON::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_ADDON_REPLY: cli::Protocol_BL_USER_ADDON_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_BUYIN: cli::Protocol_BL_USER_BUYIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_BUYIN_REPLY: cli::Protocol_BL_USER_BUYIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_BUYIN_INFO: cli::Protocol_BL_USER_GET_BUYIN_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_BUYIN_INFO_REPLY: cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_ENTRIES: cli::Protocol_BL_USER_GET_ENTRIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_ENTRIES_REPLY: cli::Protocol_BL_USER_GET_ENTRIES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_INFO: cli::Protocol_BL_USER_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_INFO_REPLY: cli::Protocol_BL_USER_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_OUT: cli::Protocol_BL_USER_OUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_OUT_REPLY: cli::Protocol_BL_USER_OUT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SET_3PLUS: cli::Protocol_BL_USER_SET_3PLUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SET_3PLUS_REPLY: cli::Protocol_BL_USER_SET_3PLUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SET_AUTOREBUY: cli::Protocol_BL_USER_SET_AUTOREBUY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SET_AUTOREBUY_REPLY: cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITIN: cli::Protocol_BL_USER_SITIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITIN_REPLY: cli::Protocol_BL_USER_SITIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITOUT: cli::Protocol_BL_USER_SITOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITOUT_NEXTBB: cli::Protocol_BL_USER_SITOUT_NEXTBB::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITOUT_NEXTBB_REPLY: cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITOUT_REPLY: cli::Protocol_BL_USER_SITOUT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_WHERE_REPLY: cli::Protocol_BL_USER_WHERE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

