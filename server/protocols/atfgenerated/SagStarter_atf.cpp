/**
 * SagStarter_atf.cpp
 *
 * This file was auto-generated from SagStarter_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor SagStarter_atf.txt
 */
 
#include "SagStarter_atf.h"

//=================================================================
//                Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID
//=================================================================

SagStarter::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID()
{
	clear();
}

void SagStarter::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::clear()
{
	scriptId = 0;
	numGames = 0;
	tournRegInfoFlags = 0;
	variantId = esvBase;
}

bool SagStarter::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::equals(const Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID& _o) const
{
	return scriptId == _o.scriptId &&
		numGames == _o.numGames &&
		tournRegInfoFlags == _o.tournRegInfoFlags &&
		variantId == _o.variantId;
}

bool SagStarter::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID*)_other));
}

const char *SagStarter::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID).append(")");
	_buf.append(',');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	_buf.append(',');
	_buf.append("numGames=");
	_buf.appendUint(numGames);
	_buf.append(',');
	_buf.append("tournRegInfoFlags=");
	_buf.appendUint(tournRegInfoFlags);
	_buf.append(',');
	_buf.append("variantId=");
	_buf.appendUint(variantId);
	return _buf.c_str();
}

const char *SagStarter::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *SagStarter::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("scriptId", scriptId, _buf);
	Atf::XmlElement::encodeAsXmlElement("numGames", numGames, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournRegInfoFlags", tournRegInfoFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("variantId", variantId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool SagStarter::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("scriptId"))
			{
				scriptId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numGames"))
			{
				numGames = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournRegInfoFlags"))
			{
				tournRegInfoFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("variantId"))
			{
				variantId = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void SagStarter::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(scriptId);
	_msg.composeBYTE(numGames);
	_msg.composeUINT32(tournRegInfoFlags);
	_msg.composeBYTE(variantId);
}

void SagStarter::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(scriptId);
	_parser.parseBYTE(numGames);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(tournRegInfoFlags);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(variantId);
}

const char *SagStarter::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("scriptId", scriptId);
	_jsonstr.compose("numGames", numGames);
	_jsonstr.compose("tournRegInfoFlags", tournRegInfoFlags);
	_jsonstr.compose("variantId", variantId);
	return _buf.c_str();
}

void SagStarter::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("scriptId", scriptId);
	_jparser.parseByNameThrow("numGames", numGames);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tournRegInfoFlags", tournRegInfoFlags);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("variantId", variantId);
}

/*static*/ void SagStarter::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 scriptId; _jparser.validateByNameThrow("scriptId", scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	BYTE numGames; _jparser.validateByNameThrow("numGames", numGames);
	AtfValidator::validateIntRange(_descr, "numGames", numGames, 0, ATF_SAG_MAX_REG_GAMES, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 tournRegInfoFlags; _jparser.validateByNameThrow("tournRegInfoFlags", tournRegInfoFlags);
	AtfValidator::validateInt(_descr, "tournRegInfoFlags", tournRegInfoFlags, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE variantId; _jparser.validateByNameThrow("variantId", variantId);
	AtfValidator::validateIntRange(_descr, "variantId", variantId, 0, 1, _checker, __FILE__, __LINE__);
}

/*static*/ void SagStarter::cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 scriptId; _parser.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	BYTE numGames; _parser.parseBYTE(numGames);
	AtfValidator::validateIntRange(_descr, "numGames", numGames, 0, ATF_SAG_MAX_REG_GAMES, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 tournRegInfoFlags; _parser.parseUINT32(tournRegInfoFlags);
	AtfValidator::validateInt(_descr, "tournRegInfoFlags", tournRegInfoFlags, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE variantId; _parser.parseBYTE(variantId);
	AtfValidator::validateIntRange(_descr, "variantId", variantId, 0, 1, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID
//=================================================================

SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID(Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID&& _o)
	: ri(std::move(_o.ri))
	, variantId(std::move(_o.variantId))
{
}

SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID& SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::operator=(Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID&& _o)
{
	if(this != &_o)
	{
		ri = std::move(_o.ri);
		variantId = std::move(_o.variantId);
	}
	return *this;
}

#endif

void SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::clear()
{
	ri.clear();
	variantId = esvBase;
}

bool SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::equals(const Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID& _o) const
{
	return ri.equals(_o.ri) &&
		variantId == _o.variantId;
}

bool SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID*)_other));
}

const char *SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID).append(")");
	_buf.append(',');
	_buf.append("ri=");
	ri.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variantId=");
	_buf.appendUint(variantId);
	return _buf.c_str();
}

const char *SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	ri.toXmlString("ri", _buf);
	Atf::XmlElement::encodeAsXmlElement("variantId", variantId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("ri"))
			{
				if(!Atf::AtfTempl< common::RegisterWithScriptId >::FromXmlString(_value, ri)) return false;
			}
			else if (_element.equals("variantId"))
			{
				variantId = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	ri.composeMsg(_msg, _ignoreJSON);
	_msg.composeBYTE(variantId);
}

void SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::parseMsg(CommMsgParser& _parser)
{
	ri.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(variantId);
}

const char *SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ri", ri);
	_jsonstr.compose("variantId", variantId);
	return _buf.c_str();
}

void SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ri", ri);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("variantId", variantId);
}

/*static*/ void SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common::RegisterWithScriptId ri; _jparser.validateByNameThrow("ri", ri);
	if(_jparser.parseEnded()) return;
	BYTE variantId; _jparser.validateByNameThrow("variantId", variantId);
	AtfValidator::validateIntRange(_descr, "variantId", variantId, 0, 1, _checker, __FILE__, __LINE__);
}

/*static*/ void SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common::RegisterWithScriptId::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ri"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	BYTE variantId; _parser.parseBYTE(variantId);
	AtfValidator::validateIntRange(_descr, "variantId", variantId, 0, 1, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserTicketDataATF
//=================================================================

SagStarter::cli::UserTicketDataATF::UserTicketDataATF()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SagStarter::cli::UserTicketDataATF::UserTicketDataATF(UserTicketDataATF&& _o)
	: admissionId(std::move(_o.admissionId))
	, totalCount(std::move(_o.totalCount))
	, reserved(std::move(_o.reserved))
{
}

SagStarter::cli::UserTicketDataATF& SagStarter::cli::UserTicketDataATF::operator=(UserTicketDataATF&& _o)
{
	if(this != &_o)
	{
		admissionId = std::move(_o.admissionId);
		totalCount = std::move(_o.totalCount);
		reserved = std::move(_o.reserved);
	}
	return *this;
}

#endif

void SagStarter::cli::UserTicketDataATF::clear()
{
	admissionId.clear();
	totalCount = 0;
	reserved = 0;
}

bool SagStarter::cli::UserTicketDataATF::equals(const UserTicketDataATF& _o) const
{
	return admissionId.equals(_o.admissionId) &&
		totalCount == _o.totalCount &&
		reserved == _o.reserved;
}

const char *SagStarter::cli::UserTicketDataATF::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("totalCount=");
	_buf.appendUint(totalCount);
	_buf.append(',');
	_buf.append("reserved=");
	_buf.appendUint(reserved);
	_buf.append('}');
	return _buf.c_str();
}

const char *SagStarter::cli::UserTicketDataATF::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("admissionId", admissionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalCount", totalCount, _buf);
	Atf::XmlElement::encodeAsXmlElement("reserved", reserved, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool SagStarter::cli::UserTicketDataATF::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("admissionId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, admissionId)) return false;
		}
		else if (_element.equals("totalCount"))
		{
			totalCount = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("reserved"))
		{
			reserved = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void SagStarter::cli::UserTicketDataATF::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(admissionId);
	_msg.composeUINT32(totalCount);
	_msg.composeUINT32(reserved);
}

void SagStarter::cli::UserTicketDataATF::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(admissionId);
	_parser.parseUINT32(totalCount);
	_parser.parseUINT32(reserved);
}

void SagStarter::cli::UserTicketDataATF::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("admissionId", admissionId);
	_parser.parse("totalCount", totalCount);
	_parser.parse("reserved", reserved);
}

const char *SagStarter::cli::UserTicketDataATF::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("admissionId", admissionId);
	_jsonstr.compose("totalCount", totalCount);
	_jsonstr.compose("reserved", reserved);
	return _buf.c_str();
}

void SagStarter::cli::UserTicketDataATF::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("admissionId", admissionId);
	_jparser.parseByNameThrow("totalCount", totalCount);
	_jparser.parseByNameThrow("reserved", reserved);
}

/* static */ void SagStarter::cli::UserTicketDataATF::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString admissionId; _jparser.validateByNameThrow("admissionId", admissionId);
	AtfValidator::validateInt(_descr, "admissionId", admissionId.length(), _checker, __FILE__, __LINE__);
	UINT32 totalCount; _jparser.validateByNameThrow("totalCount", totalCount);
	AtfValidator::validateInt(_descr, "totalCount", totalCount, _checker, __FILE__, __LINE__);
	UINT32 reserved; _jparser.validateByNameThrow("reserved", reserved);
	AtfValidator::validateInt(_descr, "reserved", reserved, _checker, __FILE__, __LINE__);
}

/*static*/ void SagStarter::cli::UserTicketDataATF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	UINT32 totalCount; _parser.parseUINT32(totalCount);
	AtfValidator::validateInt(_descr, "totalCount", totalCount, _checker, __FILE__, __LINE__);
	UINT32 reserved; _parser.parseUINT32(reserved);
	AtfValidator::validateInt(_descr, "reserved", reserved, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY
//=================================================================

SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY(Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errMsg(std::move(_o.errMsg))
	, buyin(std::move(_o.buyin))
	, rake(std::move(_o.rake))
	, fppBuyin(std::move(_o.fppBuyin))
	, admission(std::move(_o.admission))
	, pm(std::move(_o.pm))
	, pwd(std::move(_o.pwd))
	, chips(std::move(_o.chips))
	, playChips32(std::move(_o.playChips32))
	, fpp(std::move(_o.fpp))
	, tickets(std::move(_o.tickets))
	, tchips(std::move(_o.tchips))
	, notused(std::move(_o.notused))
	, preRegistrMessage(std::move(_o.preRegistrMessage))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, currency(std::move(_o.currency))
	, enoughMoneyInOtherCurrency(std::move(_o.enoughMoneyInOtherCurrency))
	, currencyContext(std::move(_o.currencyContext))
	, clientCurrencyContext(std::move(_o.clientCurrencyContext))
	, whenStartAbs(std::move(_o.whenStartAbs))
	, name(std::move(_o.name))
	, playChips(std::move(_o.playChips))
	, scalePM(std::move(_o.scalePM))
	, speedDisplay(std::move(_o.speedDisplay))
	, minPlayers(std::move(_o.minPlayers))
	, maxPlayers(std::move(_o.maxPlayers))
	, maxPerTable(std::move(_o.maxPerTable))
	, tournFlags(std::move(_o.tournFlags))
	, knockout(std::move(_o.knockout))
	, boolValue(std::move(_o.boolValue))
	, admissionPrice(std::move(_o.admissionPrice))
	, effectiveAdmissions(std::move(_o.effectiveAdmissions))
	, tournFlags2(std::move(_o.tournFlags2))
{
}

SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY& SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::operator=(Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errMsg = std::move(_o.errMsg);
		buyin = std::move(_o.buyin);
		rake = std::move(_o.rake);
		fppBuyin = std::move(_o.fppBuyin);
		admission = std::move(_o.admission);
		pm = std::move(_o.pm);
		pwd = std::move(_o.pwd);
		chips = std::move(_o.chips);
		playChips32 = std::move(_o.playChips32);
		fpp = std::move(_o.fpp);
		tickets = std::move(_o.tickets);
		tchips = std::move(_o.tchips);
		notused = std::move(_o.notused);
		preRegistrMessage = std::move(_o.preRegistrMessage);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		currency = std::move(_o.currency);
		enoughMoneyInOtherCurrency = std::move(_o.enoughMoneyInOtherCurrency);
		currencyContext = std::move(_o.currencyContext);
		clientCurrencyContext = std::move(_o.clientCurrencyContext);
		whenStartAbs = std::move(_o.whenStartAbs);
		name = std::move(_o.name);
		playChips = std::move(_o.playChips);
		scalePM = std::move(_o.scalePM);
		speedDisplay = std::move(_o.speedDisplay);
		minPlayers = std::move(_o.minPlayers);
		maxPlayers = std::move(_o.maxPlayers);
		maxPerTable = std::move(_o.maxPerTable);
		tournFlags = std::move(_o.tournFlags);
		knockout = std::move(_o.knockout);
		boolValue = std::move(_o.boolValue);
		admissionPrice = std::move(_o.admissionPrice);
		effectiveAdmissions = std::move(_o.effectiveAdmissions);
		tournFlags2 = std::move(_o.tournFlags2);
	}
	return *this;
}

#endif

void SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
	buyin = 0;
	rake = 0;
	fppBuyin = 0;
	admission.clear();
	pm = 0;
	pwd = 0;
	chips = 0;
	playChips32 = 0;
	fpp = 0;
	tickets = 0;
	tchips = 0;
	notused = 0;
	preRegistrMessage.clear();
	game = 0;
	isHiLo = 0;
	structure = 0;
	currency.clear();
	enoughMoneyInOtherCurrency = false;
	currencyContext.clear();
	clientCurrencyContext.clear();
	whenStartAbs.setNull();
	name.clear();
	playChips = 0;
	scalePM = 0;
	speedDisplay = 0;
	minPlayers = 0;
	maxPlayers = 0;
	maxPerTable = 0;
	tournFlags = 0;
	knockout = 0;
	boolValue = false;
	admissionPrice = 0;
	effectiveAdmissions.clear();
	tournFlags2 = 0;
}

bool SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::equals(const Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errMsg.equals(_o.errMsg) &&
		buyin == _o.buyin &&
		rake == _o.rake &&
		fppBuyin == _o.fppBuyin &&
		admission.equals(_o.admission) &&
		pm == _o.pm &&
		pwd == _o.pwd &&
		chips == _o.chips &&
		playChips32 == _o.playChips32 &&
		fpp == _o.fpp &&
		tickets == _o.tickets &&
		tchips == _o.tchips &&
		notused == _o.notused &&
		preRegistrMessage.equals(_o.preRegistrMessage) &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		currency.equals(_o.currency) &&
		enoughMoneyInOtherCurrency == _o.enoughMoneyInOtherCurrency &&
		currencyContext.equals(_o.currencyContext) &&
		clientCurrencyContext.equals(_o.clientCurrencyContext) &&
		whenStartAbs.equals(_o.whenStartAbs) &&
		name.equals(_o.name) &&
		playChips == _o.playChips &&
		scalePM == _o.scalePM &&
		speedDisplay == _o.speedDisplay &&
		minPlayers == _o.minPlayers &&
		maxPlayers == _o.maxPlayers &&
		maxPerTable == _o.maxPerTable &&
		tournFlags == _o.tournFlags &&
		knockout == _o.knockout &&
		boolValue == _o.boolValue &&
		admissionPrice == _o.admissionPrice &&
		effectiveAdmissions.equals(_o.effectiveAdmissions) &&
		tournFlags2 == _o.tournFlags2;
}

bool SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TOURN_REG_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY*)_other));
}

const char *SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_REG_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	else
	{
		_buf.append(',');
		_buf.append("buyin=");
		_buf.appendUint(buyin);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendUint(rake);
		_buf.append(',');
		_buf.append("fppBuyin=");
		_buf.appendUint(fppBuyin);
		_buf.append(',');
		_buf.append("admission=");
		_buf.append(admission);
		_buf.append(',');
		_buf.append("pm=");
		_buf.appendUint(pm);
		_buf.append(',');
		_buf.append("pwd=");
		_buf.appendUint(pwd);
		_buf.append(',');
		_buf.append("chips=");
		_buf.appendUint(chips);
		_buf.append(',');
		_buf.append("playChips32=");
		_buf.appendUint(playChips32);
		_buf.append(',');
		_buf.append("fpp=");
		_buf.appendUint(fpp);
		_buf.append(',');
		_buf.append("tickets=");
		_buf.appendUint(tickets);
		_buf.append(',');
		_buf.append("tchips=");
		_buf.appendUint(tchips);
		_buf.append(',');
		_buf.append("notused=");
		_buf.appendUint(notused);
		_buf.append(',');
		_buf.append("preRegistrMessage=");
		_buf.append(preRegistrMessage);
		_buf.append(',');
		_buf.append("game=");
		_buf.appendUint(game);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
		_buf.append(',');
		_buf.append("currencyContext=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(currencyContext, _buf); _buf.append('}');
		_buf.append(',');
		_buf.append("clientCurrencyContext=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientCurrencyContext, _buf); _buf.append('}');
		_buf.append(',');
		_buf.append("whenStartAbs=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStartAbs);
		_buf.append(',');
		_buf.append("name=");
		_buf.append(name);
		_buf.append(',');
		_buf.append("playChips=");
		_buf.appendUint64(playChips);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendUint(scalePM);
		_buf.append(',');
		_buf.append("speedDisplay=");
		_buf.appendUint(speedDisplay);
		_buf.append(',');
		_buf.append("minPlayers=");
		_buf.appendUint(minPlayers);
		_buf.append(',');
		_buf.append("maxPlayers=");
		_buf.appendUint(maxPlayers);
		_buf.append(',');
		_buf.append("maxPerTable=");
		_buf.appendUint(maxPerTable);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("knockout=");
		_buf.appendUint(knockout);
		_buf.append(',');
		_buf.append("boolValue=");
		_buf.appendUint(boolValue);
		_buf.append(',');
		_buf.append("admissionPrice=");
		_buf.appendInt64(admissionPrice);
		_buf.append(',');
		_buf.append("effectiveAdmissions=");
		effectiveAdmissions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournFlags2=");
		_buf.appendUint64(tournFlags2);
	}
	return _buf.c_str();
}

const char *SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TOURN_REG_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != DBM_NO_ERROR )
	{
		Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("buyin", buyin, _buf);
		Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
		Atf::XmlElement::encodeAsXmlElement("fppBuyin", fppBuyin, _buf);
		Atf::XmlElement::encodeAsXmlElement("admission", admission, _buf);
		Atf::XmlElement::encodeAsXmlElement("pm", pm, _buf);
		Atf::XmlElement::encodeAsXmlElement("pwd", pwd, _buf);
		Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
		Atf::XmlElement::encodeAsXmlElement("playChips32", playChips32, _buf);
		Atf::XmlElement::encodeAsXmlElement("fpp", fpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("tickets", tickets, _buf);
		Atf::XmlElement::encodeAsXmlElement("tchips", tchips, _buf);
		Atf::XmlElement::encodeAsXmlElement("notused", notused, _buf);
		Atf::XmlElement::encodeAsXmlElement("preRegistrMessage", preRegistrMessage, _buf);
		Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
		Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
		Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("currencyContext", currencyContext, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientCurrencyContext", clientCurrencyContext, _buf);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenStartAbs", whenStartAbs);
		Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
		Atf::XmlElement::encodeAsXmlElement("playChips", playChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
		Atf::XmlElement::encodeAsXmlElement("speedDisplay", speedDisplay, _buf);
		Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxPerTable", maxPerTable, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("knockout", knockout, _buf);
		Atf::XmlElement::encodeAsXmlElement("boolValue", boolValue, _buf);
		Atf::XmlElement::encodeAsXmlElement("admissionPrice", admissionPrice, _buf);
		effectiveAdmissions.toXmlString("effectiveAdmissions", _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else if (_element.equals("buyin"))
			{
				buyin = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rake"))
			{
				rake = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppBuyin"))
			{
				fppBuyin = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("admission"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, admission)) return false;
			}
			else if (_element.equals("pm"))
			{
				pm = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pwd"))
			{
				pwd = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chips"))
			{
				chips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playChips32"))
			{
				playChips32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fpp"))
			{
				fpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tickets"))
			{
				tickets = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tchips"))
			{
				tchips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notused"))
			{
				notused = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("preRegistrMessage"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, preRegistrMessage)) return false;
			}
			else if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isHiLo"))
			{
				isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("enoughMoneyInOtherCurrency"))
			{
				enoughMoneyInOtherCurrency = (*_value.ptr() == '1');
			}
			else if (_element.equals("currencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, currencyContext)) return false;
			}
			else if (_element.equals("clientCurrencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientCurrencyContext)) return false;
			}
			else if (_element.equals("whenStartAbs"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenStartAbs);
			}
			else if (_element.equals("name"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
			}
			else if (_element.equals("playChips"))
			{
				playChips = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("scalePM"))
			{
				scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("speedDisplay"))
			{
				speedDisplay = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minPlayers"))
			{
				minPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPlayers"))
			{
				maxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPerTable"))
			{
				maxPerTable = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlags"))
			{
				tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("knockout"))
			{
				knockout = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("boolValue"))
			{
				boolValue = (*_value.ptr() == '1');
			}
			else if (_element.equals("admissionPrice"))
			{
				admissionPrice = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("effectiveAdmissions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserTicketDataATF, 4 > >::FromXmlString(_value, effectiveAdmissions)) return false;
			}
			else if (_element.equals("tournFlags2"))
			{
				tournFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_msg.composeString(errMsg);
	}
	else
	{
		_msg.composeUINT32(buyin);
		_msg.composeUINT32(rake);
		_msg.composeUINT32(fppBuyin);
		_msg.composeString(admission);
		_msg.composeBYTE(pm);
		_msg.composeBYTE(pwd);
		_msg.composeUINT32(chips);
		_msg.composeUINT32(playChips32);
		_msg.composeUINT32(fpp);
		_msg.composeUINT32(tickets);
		_msg.composeUINT32(tchips);
		_msg.composeUINT32(notused);
		_msg.composeString(preRegistrMessage);
		_msg.composeBYTE(game);
		_msg.composeBYTE(isHiLo);
		_msg.composeBYTE(structure);
		_msg.composeString(currency);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
		_msg.composeMsgBody(currencyContext);
		_msg.composeMsgBody(clientCurrencyContext);
		_msg.composeSrvTime(whenStartAbs);
		_msg.composeString(name);
		_msg.composeUINT64(playChips);
		_msg.composeUINT32(scalePM);
		_msg.composeBYTE(speedDisplay);
		_msg.composeUINT32(minPlayers);
		_msg.composeUINT32(maxPlayers);
		_msg.composeBYTE(maxPerTable);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT32(knockout);
		_msg.composeBOOL(boolValue);
		_msg.composeINT64(admissionPrice);
		effectiveAdmissions.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT64(tournFlags2);
	}
}

void SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_parser.parseStringP(errMsg);
	}
	else
	{
		_parser.parseUINT32(buyin);
		_parser.parseUINT32(rake);
		_parser.parseUINT32(fppBuyin);
		_parser.parseStringP(admission);
		_parser.parseBYTE(pm);
		_parser.parseBYTE(pwd);
		_parser.parseUINT32(chips);
		_parser.parseUINT32(playChips32);
		_parser.parseUINT32(fpp);
		_parser.parseUINT32(tickets);
		_parser.parseUINT32(tchips);
		_parser.parseUINT32(notused);
		_parser.parseStringP(preRegistrMessage);
		_parser.parseBYTE(game);
		_parser.parseBYTE(isHiLo);
		_parser.parseBYTE(structure);
		_parser.parseStringP(currency);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
		_parser.parseMsgBody(currencyContext);
		_parser.parseMsgBody(clientCurrencyContext);
		_parser.parseSrvTime(whenStartAbs);
		_parser.parseStringP(name);
		_parser.parseUINT64(playChips);
		_parser.parseUINT32(scalePM);
		_parser.parseBYTE(speedDisplay);
		_parser.parseUINT32(minPlayers);
		_parser.parseUINT32(maxPlayers);
		_parser.parseBYTE(maxPerTable);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT32(knockout);
		_parser.parseBOOL(boolValue);
		_parser.parseINT64(admissionPrice);
		effectiveAdmissions.parseMsg(_parser);
		_parser.parseUINT64(tournFlags2);
	}
}

const char *SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_jsonstr.compose("errMsg", errMsg);
	}
	else
	{
		_jsonstr.compose("buyin", buyin);
		_jsonstr.compose("rake", rake);
		_jsonstr.compose("fppBuyin", fppBuyin);
		_jsonstr.compose("admission", admission);
		_jsonstr.compose("pm", pm);
		_jsonstr.compose("pwd", pwd);
		_jsonstr.compose("chips", chips);
		_jsonstr.compose("playChips32", playChips32);
		_jsonstr.compose("fpp", fpp);
		_jsonstr.compose("tickets", tickets);
		_jsonstr.compose("tchips", tchips);
		_jsonstr.compose("notused", notused);
		_jsonstr.compose("preRegistrMessage", preRegistrMessage);
		_jsonstr.compose("game", game);
		_jsonstr.compose("isHiLo", isHiLo);
		_jsonstr.compose("structure", structure);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		_jsonstr.compose("currencyContext", currencyContext);
		_jsonstr.compose("clientCurrencyContext", clientCurrencyContext);
		_jsonstr.compose("whenStartAbs", whenStartAbs);
		_jsonstr.compose("name", name);
		_jsonstr.compose("playChips", playChips);
		_jsonstr.compose("scalePM", scalePM);
		_jsonstr.compose("speedDisplay", speedDisplay);
		_jsonstr.compose("minPlayers", minPlayers);
		_jsonstr.compose("maxPlayers", maxPlayers);
		_jsonstr.compose("maxPerTable", maxPerTable);
		_jsonstr.compose("tournFlags", tournFlags);
		_jsonstr.compose("knockout", knockout);
		_jsonstr.compose("boolValue", boolValue);
		_jsonstr.compose("admissionPrice", admissionPrice);
		_jsonstr.compose("effectiveAdmissions", effectiveAdmissions);
		_jsonstr.compose("tournFlags2", tournFlags2);
	}
	return _buf.c_str();
}

void SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_jparser.parseByNameThrow("errMsg", errMsg);
	}
	else
	{
		_jparser.parseByNameThrow("buyin", buyin);
		_jparser.parseByNameThrow("rake", rake);
		_jparser.parseByNameThrow("fppBuyin", fppBuyin);
		_jparser.parseByNameThrow("admission", admission);
		_jparser.parseByNameThrow("pm", pm);
		_jparser.parseByNameThrow("pwd", pwd);
		_jparser.parseByNameThrow("chips", chips);
		_jparser.parseByNameThrow("playChips32", playChips32);
		_jparser.parseByNameThrow("fpp", fpp);
		_jparser.parseByNameThrow("tickets", tickets);
		_jparser.parseByNameThrow("tchips", tchips);
		_jparser.parseByNameThrow("notused", notused);
		_jparser.parseByNameThrow("preRegistrMessage", preRegistrMessage);
		_jparser.parseByNameThrow("game", game);
		_jparser.parseByNameThrow("isHiLo", isHiLo);
		_jparser.parseByNameThrow("structure", structure);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		_jparser.parseByNameThrow("currencyContext", currencyContext);
		_jparser.parseByNameThrow("clientCurrencyContext", clientCurrencyContext);
		_jparser.parseByNameThrow("whenStartAbs", whenStartAbs);
		_jparser.parseByNameThrow("name", name);
		_jparser.parseByNameThrow("playChips", playChips);
		_jparser.parseByNameThrow("scalePM", scalePM);
		_jparser.parseByNameThrow("speedDisplay", speedDisplay);
		_jparser.parseByNameThrow("minPlayers", minPlayers);
		_jparser.parseByNameThrow("maxPlayers", maxPlayers);
		_jparser.parseByNameThrow("maxPerTable", maxPerTable);
		_jparser.parseByNameThrow("tournFlags", tournFlags);
		_jparser.parseByNameThrow("knockout", knockout);
		_jparser.parseByNameThrow("boolValue", boolValue);
		_jparser.parseByNameThrow("admissionPrice", admissionPrice);
		_jparser.parseByNameThrow("effectiveAdmissions", effectiveAdmissions);
		_jparser.parseByNameThrow("tournFlags2", tournFlags2);
	}
}

/*static*/ void SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != DBM_NO_ERROR )
	{
		PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
		AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 buyin; _jparser.validateByNameThrow("buyin", buyin);
		AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
		UINT32 rake; _jparser.validateByNameThrow("rake", rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 fppBuyin; _jparser.validateByNameThrow("fppBuyin", fppBuyin);
		AtfValidator::validateInt(_descr, "fppBuyin", fppBuyin, _checker, __FILE__, __LINE__);
		PString admission; _jparser.validateByNameThrow("admission", admission);
		AtfValidator::validateInt(_descr, "admission", admission.length(), _checker, __FILE__, __LINE__);
		BYTE pm; _jparser.validateByNameThrow("pm", pm);
		AtfValidator::validateInt(_descr, "pm", pm, _checker, __FILE__, __LINE__);
		BYTE pwd; _jparser.validateByNameThrow("pwd", pwd);
		AtfValidator::validateInt(_descr, "pwd", pwd, _checker, __FILE__, __LINE__);
		UINT32 chips; _jparser.validateByNameThrow("chips", chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		UINT32 playChips32; _jparser.validateByNameThrow("playChips32", playChips32);
		AtfValidator::validateInt(_descr, "playChips32", playChips32, _checker, __FILE__, __LINE__);
		UINT32 fpp; _jparser.validateByNameThrow("fpp", fpp);
		AtfValidator::validateInt(_descr, "fpp", fpp, _checker, __FILE__, __LINE__);
		UINT32 tickets; _jparser.validateByNameThrow("tickets", tickets);
		AtfValidator::validateInt(_descr, "tickets", tickets, _checker, __FILE__, __LINE__);
		UINT32 tchips; _jparser.validateByNameThrow("tchips", tchips);
		AtfValidator::validateInt(_descr, "tchips", tchips, _checker, __FILE__, __LINE__);
		UINT32 notused; _jparser.validateByNameThrow("notused", notused);
		AtfValidator::validateInt(_descr, "notused", notused, _checker, __FILE__, __LINE__);
		PString preRegistrMessage; _jparser.validateByNameThrow("preRegistrMessage", preRegistrMessage);
		AtfValidator::validateInt(_descr, "preRegistrMessage", preRegistrMessage.length(), _checker, __FILE__, __LINE__);
		BYTE game; _jparser.validateByNameThrow("game", game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _jparser.validateByNameThrow("structure", structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _jparser.validateByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody currencyContext; _jparser.validateByNameThrow("currencyContext", currencyContext);
		AtfValidator::validateInt(_descr, "currencyContext", currencyContext._size(), _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody clientCurrencyContext; _jparser.validateByNameThrow("clientCurrencyContext", clientCurrencyContext);
		AtfValidator::validateInt(_descr, "clientCurrencyContext", clientCurrencyContext._size(), _checker, __FILE__, __LINE__);
		SrvTime whenStartAbs; _jparser.validateByNameThrow("whenStartAbs", whenStartAbs);
		AtfValidator::validateSrvDateTime(_descr, "whenStartAbs", whenStartAbs, _checker, __FILE__, __LINE__);
		PString name; _jparser.validateByNameThrow("name", name);
		AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
		UINT64 playChips; _jparser.validateByNameThrow("playChips", playChips);
		AtfValidator::validateUint(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
		UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE speedDisplay; _jparser.validateByNameThrow("speedDisplay", speedDisplay);
		AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
		UINT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		UINT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		BYTE maxPerTable; _jparser.validateByNameThrow("maxPerTable", maxPerTable);
		AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 knockout; _jparser.validateByNameThrow("knockout", knockout);
		AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
		bool boolValue; _jparser.validateByNameThrow("boolValue", boolValue);
		AtfValidator::validateInt(_descr, "boolValue", boolValue, _checker, __FILE__, __LINE__);
		INT64 admissionPrice; _jparser.validateByNameThrow("admissionPrice", admissionPrice);
		AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UserTicketDataATF > effectiveAdmissions; _jparser.validateByNameThrow("effectiveAdmissions", effectiveAdmissions);
		AtfValidator::validateInt(_descr, "effectiveAdmissions", effectiveAdmissions.size(), _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void SagStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != DBM_NO_ERROR )
	{
		_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 buyin; _parser.parseUINT32(buyin);
		AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
		UINT32 rake; _parser.parseUINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 fppBuyin; _parser.parseUINT32(fppBuyin);
		AtfValidator::validateInt(_descr, "fppBuyin", fppBuyin, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "admission"); size_t szAdmission = strlen(_dummy);
		AtfValidator::validateInt(_descr, "admission", szAdmission, _checker, __FILE__, __LINE__);
		BYTE pm; _parser.parseBYTE(pm);
		AtfValidator::validateInt(_descr, "pm", pm, _checker, __FILE__, __LINE__);
		BYTE pwd; _parser.parseBYTE(pwd);
		AtfValidator::validateInt(_descr, "pwd", pwd, _checker, __FILE__, __LINE__);
		UINT32 chips; _parser.parseUINT32(chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		UINT32 playChips32; _parser.parseUINT32(playChips32);
		AtfValidator::validateInt(_descr, "playChips32", playChips32, _checker, __FILE__, __LINE__);
		UINT32 fpp; _parser.parseUINT32(fpp);
		AtfValidator::validateInt(_descr, "fpp", fpp, _checker, __FILE__, __LINE__);
		UINT32 tickets; _parser.parseUINT32(tickets);
		AtfValidator::validateInt(_descr, "tickets", tickets, _checker, __FILE__, __LINE__);
		UINT32 tchips; _parser.parseUINT32(tchips);
		AtfValidator::validateInt(_descr, "tchips", tchips, _checker, __FILE__, __LINE__);
		UINT32 notused; _parser.parseUINT32(notused);
		AtfValidator::validateInt(_descr, "notused", notused, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "preRegistrMessage"); size_t szPreRegistrMessage = strlen(_dummy);
		AtfValidator::validateInt(_descr, "preRegistrMessage", szPreRegistrMessage, _checker, __FILE__, __LINE__);
		BYTE game; _parser.parseBYTE(game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _parser.parseBYTE(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
		AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
		size_t szClientCurrencyContext; _parser.skipMsgBody(szClientCurrencyContext);  /*clientCurrencyContext*/
		AtfValidator::validateInt(_descr, "clientCurrencyContext", szClientCurrencyContext, _checker, __FILE__, __LINE__);
		SrvTime whenStartAbs; _parser.parseSrvTime(whenStartAbs);
		AtfValidator::validateSrvDateTime(_descr, "whenStartAbs", whenStartAbs, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
		UINT64 playChips; _parser.parseUINT64(playChips);
		AtfValidator::validateUint(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
		UINT32 scalePM; _parser.parseUINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE speedDisplay; _parser.parseBYTE(speedDisplay);
		AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
		UINT32 minPlayers; _parser.parseUINT32(minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		UINT32 maxPlayers; _parser.parseUINT32(maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		BYTE maxPerTable; _parser.parseBYTE(maxPerTable);
		AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 knockout; _parser.parseUINT32(knockout);
		AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
		bool boolValue; _parser.parseBOOL(boolValue);
		AtfValidator::validateInt(_descr, "boolValue", boolValue, _checker, __FILE__, __LINE__);
		INT64 admissionPrice; _parser.parseINT64(admissionPrice);
		AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szEffectiveAdmissions = Atf::LAtfVector< UserTicketDataATF, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("effectiveAdmissions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "effectiveAdmissions", szEffectiveAdmissions, _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    WhereIsBodyATF
//=================================================================

SagStarter::cli::WhereIsBodyATF::WhereIsBodyATF()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SagStarter::cli::WhereIsBodyATF::WhereIsBodyATF(WhereIsBodyATF&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, serverName(std::move(_o.serverName))
	, serverObjectName(std::move(_o.serverObjectName))
	, clubId(std::move(_o.clubId))
	, tournFlags(std::move(_o.tournFlags))
	, isAvail(std::move(_o.isAvail))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, speedDisplay(std::move(_o.speedDisplay))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, scalePM(std::move(_o.scalePM))
	, knockout(std::move(_o.knockout))
	, minPlayers(std::move(_o.minPlayers))
	, maxPlayers(std::move(_o.maxPlayers))
	, maxPerTable(std::move(_o.maxPerTable))
	, awardSchemaProportional(std::move(_o.awardSchemaProportional))
	, whenStartAbs(std::move(_o.whenStartAbs))
	, whenStartAbsInt(std::move(_o.whenStartAbsInt))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, tournMask(std::move(_o.tournMask))
	, tournMask2(std::move(_o.tournMask2))
	, tournMask3(std::move(_o.tournMask3))
	, tournMask4(std::move(_o.tournMask4))
	, admission(std::move(_o.admission))
	, admissionPrice(std::move(_o.admissionPrice))
	, tournFlags2(std::move(_o.tournFlags2))
{
}

SagStarter::cli::WhereIsBodyATF& SagStarter::cli::WhereIsBodyATF::operator=(WhereIsBodyATF&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		serverName = std::move(_o.serverName);
		serverObjectName = std::move(_o.serverObjectName);
		clubId = std::move(_o.clubId);
		tournFlags = std::move(_o.tournFlags);
		isAvail = std::move(_o.isAvail);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		speedDisplay = std::move(_o.speedDisplay);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		scalePM = std::move(_o.scalePM);
		knockout = std::move(_o.knockout);
		minPlayers = std::move(_o.minPlayers);
		maxPlayers = std::move(_o.maxPlayers);
		maxPerTable = std::move(_o.maxPerTable);
		awardSchemaProportional = std::move(_o.awardSchemaProportional);
		whenStartAbs = std::move(_o.whenStartAbs);
		whenStartAbsInt = std::move(_o.whenStartAbsInt);
		fppBuyIn = std::move(_o.fppBuyIn);
		tournMask = std::move(_o.tournMask);
		tournMask2 = std::move(_o.tournMask2);
		tournMask3 = std::move(_o.tournMask3);
		tournMask4 = std::move(_o.tournMask4);
		admission = std::move(_o.admission);
		admissionPrice = std::move(_o.admissionPrice);
		tournFlags2 = std::move(_o.tournFlags2);
	}
	return *this;
}

#endif

void SagStarter::cli::WhereIsBodyATF::clear()
{
	tournamentId = 0;
	serverName.clear();
	serverObjectName.clear();
	clubId = 0;
	tournFlags = 0;
	isAvail = false;
	game = 0;
	isHiLo = 0;
	structure = 0;
	speedDisplay = 0;
	isPlayMoney = 0;
	currency.clear();
	buyIn = 0;
	rake = 0;
	scalePM = 0;
	knockout = 0;
	minPlayers = 0;
	maxPlayers = 0;
	maxPerTable = 0;
	awardSchemaProportional = false;
	whenStartAbs.setNull();
	whenStartAbsInt = 0;
	fppBuyIn = 0;
	tournMask = 0;
	tournMask2 = 0;
	tournMask3 = 0;
	tournMask4 = 0;
	admission.clear();
	admissionPrice = 0;
	tournFlags2 = 0;
}

bool SagStarter::cli::WhereIsBodyATF::equals(const WhereIsBodyATF& _o) const
{
	return tournamentId == _o.tournamentId &&
		serverName.equals(_o.serverName) &&
		serverObjectName.equals(_o.serverObjectName) &&
		clubId == _o.clubId &&
		tournFlags == _o.tournFlags &&
		isAvail == _o.isAvail &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		speedDisplay == _o.speedDisplay &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		scalePM == _o.scalePM &&
		knockout == _o.knockout &&
		minPlayers == _o.minPlayers &&
		maxPlayers == _o.maxPlayers &&
		maxPerTable == _o.maxPerTable &&
		awardSchemaProportional == _o.awardSchemaProportional &&
		whenStartAbs.equals(_o.whenStartAbs) &&
		whenStartAbsInt == _o.whenStartAbsInt &&
		fppBuyIn == _o.fppBuyIn &&
		tournMask == _o.tournMask &&
		tournMask2 == _o.tournMask2 &&
		tournMask3 == _o.tournMask3 &&
		tournMask4 == _o.tournMask4 &&
		admission.equals(_o.admission) &&
		admissionPrice == _o.admissionPrice &&
		tournFlags2 == _o.tournFlags2;
}

const char *SagStarter::cli::WhereIsBodyATF::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("serverName=");
	_buf.append(serverName);
	_buf.append(',');
	_buf.append("serverObjectName=");
	_buf.append(serverObjectName);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("isAvail=");
	_buf.appendUint(isAvail);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("speedDisplay=");
	_buf.appendUint(speedDisplay);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append(',');
	_buf.append("knockout=");
	_buf.appendUint(knockout);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("maxPerTable=");
	_buf.appendUint(maxPerTable);
	_buf.append(',');
	_buf.append("awardSchemaProportional=");
	_buf.appendUint(awardSchemaProportional);
	_buf.append(',');
	_buf.append("whenStartAbs=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStartAbs);
	_buf.append(',');
	_buf.append("whenStartAbsInt=");
	_buf.appendUint(whenStartAbsInt);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("tournMask=");
	_buf.appendUint(tournMask);
	_buf.append(',');
	_buf.append("tournMask2=");
	_buf.appendUint(tournMask2);
	_buf.append(',');
	_buf.append("tournMask3=");
	_buf.appendUint(tournMask3);
	_buf.append(',');
	_buf.append("tournMask4=");
	_buf.appendUint(tournMask4);
	_buf.append(',');
	_buf.append("admission=");
	_buf.append(admission);
	_buf.append(',');
	_buf.append("admissionPrice=");
	_buf.appendInt64(admissionPrice);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendInt64(tournFlags2);
	_buf.append('}');
	return _buf.c_str();
}

const char *SagStarter::cli::WhereIsBodyATF::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournamentId", tournamentId, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverName", serverName, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObjectName", serverObjectName, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("isAvail", isAvail, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("speedDisplay", speedDisplay, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("knockout", knockout, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPerTable", maxPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("awardSchemaProportional", awardSchemaProportional, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenStartAbs", whenStartAbs);
	Atf::XmlElement::encodeAsXmlElement("whenStartAbsInt", whenStartAbsInt, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBuyIn", fppBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask", tournMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask2", tournMask2, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask3", tournMask3, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask4", tournMask4, _buf);
	Atf::XmlElement::encodeAsXmlElement("admission", admission, _buf);
	Atf::XmlElement::encodeAsXmlElement("admissionPrice", admissionPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool SagStarter::cli::WhereIsBodyATF::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournamentId"))
		{
			tournamentId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("serverName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverName)) return false;
		}
		else if (_element.equals("serverObjectName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObjectName)) return false;
		}
		else if (_element.equals("clubId"))
		{
			clubId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlags"))
		{
			tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isAvail"))
		{
			isAvail = (*_value.ptr() == '1');
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("speedDisplay"))
		{
			speedDisplay = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("knockout"))
		{
			knockout = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minPlayers"))
		{
			minPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayers"))
		{
			maxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPerTable"))
		{
			maxPerTable = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("awardSchemaProportional"))
		{
			awardSchemaProportional = (*_value.ptr() == '1');
		}
		else if (_element.equals("whenStartAbs"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenStartAbs);
		}
		else if (_element.equals("whenStartAbsInt"))
		{
			whenStartAbsInt = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppBuyIn"))
		{
			fppBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournMask"))
		{
			tournMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournMask2"))
		{
			tournMask2 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournMask3"))
		{
			tournMask3 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournMask4"))
		{
			tournMask4 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("admission"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, admission)) return false;
		}
		else if (_element.equals("admissionPrice"))
		{
			admissionPrice = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlags2"))
		{
			tournFlags2 = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void SagStarter::cli::WhereIsBodyATF::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(WhereIsBodyATF())) // not empty
	{
		_body.composeUINT32(tournamentId);
		_body.composeString(serverName);
		_body.composeString(serverObjectName);
		_body.composeUINT32(clubId);
		_body.composeUINT32(tournFlags);
		_body.composeBOOL(isAvail);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(structure);
		_body.composeBYTE(speedDisplay);
		_body.composeBYTE(isPlayMoney);
		_body.composeString(currency);
		_body.composeUINT32(buyIn);
		_body.composeUINT32(rake);
		_body.composeINT32(scalePM);
		_body.composeUINT32(knockout);
		_body.composeUINT32(minPlayers);
		_body.composeUINT32(maxPlayers);
		_body.composeUINT32(maxPerTable);
		_body.composeBOOL(awardSchemaProportional);
		_body.composeSrvTime(whenStartAbs);
		_body.composeUINT32(whenStartAbsInt);
		_body.composeUINT32(fppBuyIn);
		_body.composeUINT32(tournMask);
		_body.composeUINT32(tournMask2);
		_body.composeUINT32(tournMask3);
		_body.composeUINT32(tournMask4);
		_body.composeString(admission);
		_body.composeINT64(admissionPrice);
		_body.composeINT64(tournFlags2);
	}

	_msg.composeMsgBody(_body);
}

void SagStarter::cli::WhereIsBodyATF::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournamentId);
	_parser0.parseStringP(serverName);
	_parser0.parseStringP(serverObjectName);
	_parser0.parseUINT32(clubId);
	_parser0.parseUINT32(tournFlags);
	_parser0.parseBOOL(isAvail);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(speedDisplay);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(buyIn);
	_parser0.parseUINT32(rake);
	_parser0.parseINT32(scalePM);
	_parser0.parseUINT32(knockout);
	_parser0.parseUINT32(minPlayers);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseUINT32(maxPerTable);
	_parser0.parseBOOL(awardSchemaProportional);
	_parser0.parseSrvTime(whenStartAbs);
	_parser0.parseUINT32(whenStartAbsInt);
	_parser0.parseUINT32(fppBuyIn);
	_parser0.parseUINT32(tournMask);
	_parser0.parseUINT32(tournMask2);
	_parser0.parseUINT32(tournMask3);
	_parser0.parseUINT32(tournMask4);
	_parser0.parseStringP(admission);
	_parser0.parseINT64(admissionPrice);
	_parser0.parseINT64(tournFlags2);
}

void SagStarter::cli::WhereIsBodyATF::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("tournamentId", tournamentId);
	_parser0.parse("serverName", serverName);
	_parser0.parse("serverObjectName", serverObjectName);
	_parser0.parse("clubId", clubId);
	_parser0.parse("tournFlags", tournFlags);
	_parser0.parse("isAvail", isAvail);
	_parser0.parse("game", game);
	_parser0.parse("isHiLo", isHiLo);
	_parser0.parse("structure", structure);
	_parser0.parse("speedDisplay", speedDisplay);
	_parser0.parse("isPlayMoney", isPlayMoney);
	_parser0.parse("currency", currency);
	_parser0.parse("buyIn", buyIn);
	_parser0.parse("rake", rake);
	_parser0.parse("scalePM", scalePM);
	_parser0.parse("knockout", knockout);
	_parser0.parse("minPlayers", minPlayers);
	_parser0.parse("maxPlayers", maxPlayers);
	_parser0.parse("maxPerTable", maxPerTable);
	_parser0.parse("awardSchemaProportional", awardSchemaProportional);
	_parser0.parse("whenStartAbs", whenStartAbs);
	_parser0.parse("whenStartAbsInt", whenStartAbsInt);
	_parser0.parse("fppBuyIn", fppBuyIn);
	_parser0.parse("tournMask", tournMask);
	_parser0.parse("tournMask2", tournMask2);
	_parser0.parse("tournMask3", tournMask3);
	_parser0.parse("tournMask4", tournMask4);
	_parser0.parse("admission", admission);
	_parser0.parse("admissionPrice", admissionPrice);
	_parser0.parse("tournFlags2", tournFlags2);
}

const char *SagStarter::cli::WhereIsBodyATF::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournamentId", tournamentId);
	_jsonstr.compose("serverName", serverName);
	_jsonstr.compose("serverObjectName", serverObjectName);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("tournFlags", tournFlags);
	_jsonstr.compose("isAvail", isAvail);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("speedDisplay", speedDisplay);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("knockout", knockout);
	_jsonstr.compose("minPlayers", minPlayers);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("maxPerTable", maxPerTable);
	_jsonstr.compose("awardSchemaProportional", awardSchemaProportional);
	_jsonstr.compose("whenStartAbs", whenStartAbs);
	_jsonstr.compose("whenStartAbsInt", whenStartAbsInt);
	_jsonstr.compose("fppBuyIn", fppBuyIn);
	_jsonstr.compose("tournMask", tournMask);
	_jsonstr.compose("tournMask2", tournMask2);
	_jsonstr.compose("tournMask3", tournMask3);
	_jsonstr.compose("tournMask4", tournMask4);
	_jsonstr.compose("admission", admission);
	_jsonstr.compose("admissionPrice", admissionPrice);
	_jsonstr.compose("tournFlags2", tournFlags2);
	return _buf.c_str();
}

void SagStarter::cli::WhereIsBodyATF::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournamentId", tournamentId);
	_jparser.parseByNameThrow("serverName", serverName);
	_jparser.parseByNameThrow("serverObjectName", serverObjectName);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("tournFlags", tournFlags);
	_jparser.parseByNameThrow("isAvail", isAvail);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("speedDisplay", speedDisplay);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("knockout", knockout);
	_jparser.parseByNameThrow("minPlayers", minPlayers);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("maxPerTable", maxPerTable);
	_jparser.parseByNameThrow("awardSchemaProportional", awardSchemaProportional);
	_jparser.parseByNameThrow("whenStartAbs", whenStartAbs);
	_jparser.parseByNameThrow("whenStartAbsInt", whenStartAbsInt);
	_jparser.parseByNameThrow("fppBuyIn", fppBuyIn);
	_jparser.parseByNameThrow("tournMask", tournMask);
	_jparser.parseByNameThrow("tournMask2", tournMask2);
	_jparser.parseByNameThrow("tournMask3", tournMask3);
	_jparser.parseByNameThrow("tournMask4", tournMask4);
	_jparser.parseByNameThrow("admission", admission);
	_jparser.parseByNameThrow("admissionPrice", admissionPrice);
	_jparser.parseByNameThrow("tournFlags2", tournFlags2);
}

/* static */ void SagStarter::cli::WhereIsBodyATF::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournamentId; _jparser.validateByNameThrow("tournamentId", tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	PString serverName; _jparser.validateByNameThrow("serverName", serverName);
	AtfValidator::validateInt(_descr, "serverName", serverName.length(), _checker, __FILE__, __LINE__);
	PString serverObjectName; _jparser.validateByNameThrow("serverObjectName", serverObjectName);
	AtfValidator::validateInt(_descr, "serverObjectName", serverObjectName.length(), _checker, __FILE__, __LINE__);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	bool isAvail; _jparser.validateByNameThrow("isAvail", isAvail);
	AtfValidator::validateInt(_descr, "isAvail", isAvail, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _jparser.validateByNameThrow("speedDisplay", speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	INT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 knockout; _jparser.validateByNameThrow("knockout", knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 maxPerTable; _jparser.validateByNameThrow("maxPerTable", maxPerTable);
	AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
	bool awardSchemaProportional; _jparser.validateByNameThrow("awardSchemaProportional", awardSchemaProportional);
	AtfValidator::validateInt(_descr, "awardSchemaProportional", awardSchemaProportional, _checker, __FILE__, __LINE__);
	SrvTime whenStartAbs; _jparser.validateByNameThrow("whenStartAbs", whenStartAbs);
	AtfValidator::validateSrvDateTime(_descr, "whenStartAbs", whenStartAbs, _checker, __FILE__, __LINE__);
	UINT32 whenStartAbsInt; _jparser.validateByNameThrow("whenStartAbsInt", whenStartAbsInt);
	AtfValidator::validateInt(_descr, "whenStartAbsInt", whenStartAbsInt, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _jparser.validateByNameThrow("fppBuyIn", fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _jparser.validateByNameThrow("tournMask", tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _jparser.validateByNameThrow("tournMask2", tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _jparser.validateByNameThrow("tournMask3", tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _jparser.validateByNameThrow("tournMask4", tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	PString admission; _jparser.validateByNameThrow("admission", admission);
	AtfValidator::validateInt(_descr, "admission", admission.length(), _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _jparser.validateByNameThrow("admissionPrice", admissionPrice);
	AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	INT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
	AtfValidator::validateInt(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
}

/*static*/ void SagStarter::cli::WhereIsBodyATF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tournamentId; _parser0.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverName"); size_t szServerName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverName", szServerName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObjectName"); size_t szServerObjectName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObjectName", szServerObjectName, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser0.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser0.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	bool isAvail; _parser0.parseBOOL(isAvail);
	AtfValidator::validateInt(_descr, "isAvail", isAvail, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _parser0.parseBYTE(speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	INT32 scalePM; _parser0.parseINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 knockout; _parser0.parseUINT32(knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser0.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 maxPerTable; _parser0.parseUINT32(maxPerTable);
	AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
	bool awardSchemaProportional; _parser0.parseBOOL(awardSchemaProportional);
	AtfValidator::validateInt(_descr, "awardSchemaProportional", awardSchemaProportional, _checker, __FILE__, __LINE__);
	SrvTime whenStartAbs; _parser0.parseSrvTime(whenStartAbs);
	AtfValidator::validateSrvDateTime(_descr, "whenStartAbs", whenStartAbs, _checker, __FILE__, __LINE__);
	UINT32 whenStartAbsInt; _parser0.parseUINT32(whenStartAbsInt);
	AtfValidator::validateInt(_descr, "whenStartAbsInt", whenStartAbsInt, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser0.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _parser0.parseUINT32(tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _parser0.parseUINT32(tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _parser0.parseUINT32(tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _parser0.parseUINT32(tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "admission"); size_t szAdmission = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admission", szAdmission, _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _parser0.parseINT64(admissionPrice);
	AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	INT64 tournFlags2; _parser0.parseINT64(tournFlags2);
	AtfValidator::validateInt(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY
//=================================================================

SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY(Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errMsg(std::move(_o.errMsg))
	, allInOption(std::move(_o.allInOption))
	, locale(std::move(_o.locale))
	, tournId(std::move(_o.tournId))
	, seatAvail(std::move(_o.seatAvail))
	, serverName(std::move(_o.serverName))
	, socialToken(std::move(_o.socialToken))
	, whereIsBody(std::move(_o.whereIsBody))
	, aamsTicket(std::move(_o.aamsTicket))
	, clientNotification(std::move(_o.clientNotification))
{
}

SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY& SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::operator=(Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errMsg = std::move(_o.errMsg);
		allInOption = std::move(_o.allInOption);
		locale = std::move(_o.locale);
		tournId = std::move(_o.tournId);
		seatAvail = std::move(_o.seatAvail);
		serverName = std::move(_o.serverName);
		socialToken = std::move(_o.socialToken);
		whereIsBody = std::move(_o.whereIsBody);
		aamsTicket = std::move(_o.aamsTicket);
		clientNotification = std::move(_o.clientNotification);
	}
	return *this;
}

#endif

void SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
	allInOption = 0;
	locale.clear();
	tournId = 0;
	seatAvail = false;
	serverName.clear();
	socialToken.clear();
	whereIsBody.clear();
	aamsTicket.clear();
	clientNotification.clear();
}

bool SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::equals(const Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errMsg.equals(_o.errMsg) &&
		allInOption == _o.allInOption &&
		locale.equals(_o.locale) &&
		tournId == _o.tournId &&
		seatAvail == _o.seatAvail &&
		serverName.equals(_o.serverName) &&
		socialToken.equals(_o.socialToken) &&
		whereIsBody.equals(_o.whereIsBody) &&
		aamsTicket.equals(_o.aamsTicket) &&
		clientNotification.equals(_o.clientNotification);
}

bool SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY*)_other));
}

const char *SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	if( errCode == DBM_NO_ERROR )
	{
		_buf.append(',');
		_buf.append("allInOption=");
		_buf.appendInt(allInOption);
		_buf.append(',');
		_buf.append("locale=");
		_buf.append(locale);
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("seatAvail=");
		_buf.appendUint(seatAvail);
		_buf.append(',');
		_buf.append("serverName=");
		_buf.append(serverName);
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("whereIsBody=");
		whereIsBody.toTraceString(_buf);
		_buf.append(',');
		_buf.append("aamsTicket=");
		_buf.append(aamsTicket);
		_buf.append(',');
		_buf.append("clientNotification=");
		_buf.append(clientNotification);
	}
	return _buf.c_str();
}

const char *SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	if( errCode == DBM_NO_ERROR )
	{
		Atf::XmlElement::encodeAsXmlElement("allInOption", allInOption, _buf);
		Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
		Atf::XmlElement::encodeAsXmlElement("seatAvail", seatAvail, _buf);
		Atf::XmlElement::encodeAsXmlElement("serverName", serverName, _buf);
		Atf::XmlElement::encodeAsXmlElement("socialToken", socialToken, _buf);
		whereIsBody.toXmlString("whereIsBody", _buf);
		Atf::XmlElement::encodeAsXmlElement("aamsTicket", aamsTicket, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientNotification", clientNotification, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else if (_element.equals("allInOption"))
			{
				allInOption = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("locale"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, locale)) return false;
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seatAvail"))
			{
				seatAvail = (*_value.ptr() == '1');
			}
			else if (_element.equals("serverName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, serverName)) return false;
			}
			else if (_element.equals("socialToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
			}
			else if (_element.equals("whereIsBody"))
			{
				if(!Atf::AtfTempl< WhereIsBodyATF >::FromXmlString(_value, whereIsBody)) return false;
			}
			else if (_element.equals("aamsTicket"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, aamsTicket)) return false;
			}
			else if (_element.equals("clientNotification"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clientNotification)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errMsg);
	if( errCode == DBM_NO_ERROR )
	{
		_msg.composeINT16(allInOption);
		_msg.composeString(locale);
		_msg.composeUINT32(tournId);
		_msg.composeBOOL(seatAvail);
		_msg.composeString(serverName);
		_msg.composeString(socialToken);
		whereIsBody.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(aamsTicket);
		_msg.composeString(clientNotification);
	}
}

void SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errMsg);
	if( errCode == DBM_NO_ERROR )
	{
		_parser.parseINT16(allInOption);
		_parser.parseStringP(locale);
		_parser.parseUINT32(tournId);
		_parser.parseBOOL(seatAvail);
		_parser.parseStringP(serverName);
		_parser.parseStringP(socialToken);
		whereIsBody.parseMsg(_parser);
		_parser.parseStringP(aamsTicket);
		_parser.parseStringP(clientNotification);
	}
}

const char *SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsg", errMsg);
	if( errCode == DBM_NO_ERROR )
	{
		_jsonstr.compose("allInOption", allInOption);
		_jsonstr.compose("locale", locale);
		_jsonstr.compose("tournId", tournId);
		_jsonstr.compose("seatAvail", seatAvail);
		_jsonstr.compose("serverName", serverName);
		_jsonstr.compose("socialToken", socialToken);
		_jsonstr.compose("whereIsBody", whereIsBody);
		_jsonstr.compose("aamsTicket", aamsTicket);
		_jsonstr.compose("clientNotification", clientNotification);
	}
	return _buf.c_str();
}

void SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsg", errMsg);
	if( errCode == DBM_NO_ERROR )
	{
		_jparser.parseByNameThrow("allInOption", allInOption);
		_jparser.parseByNameThrow("locale", locale);
		_jparser.parseByNameThrow("tournId", tournId);
		_jparser.parseByNameThrow("seatAvail", seatAvail);
		_jparser.parseByNameThrow("serverName", serverName);
		_jparser.parseByNameThrow("socialToken", socialToken);
		_jparser.parseByNameThrow("whereIsBody", whereIsBody);
		_jparser.parseByNameThrow("aamsTicket", aamsTicket);
		_jparser.parseByNameThrow("clientNotification", clientNotification);
	}
}

/*static*/ void SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
	AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	if( errCode == DBM_NO_ERROR )
	{
		INT16 allInOption; _jparser.validateByNameThrow("allInOption", allInOption);
		AtfValidator::validateInt(_descr, "allInOption", allInOption, _checker, __FILE__, __LINE__);
		PString locale; _jparser.validateByNameThrow("locale", locale);
		AtfValidator::validateInt(_descr, "locale", locale.length(), _checker, __FILE__, __LINE__);
		UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		bool seatAvail; _jparser.validateByNameThrow("seatAvail", seatAvail);
		AtfValidator::validateInt(_descr, "seatAvail", seatAvail, _checker, __FILE__, __LINE__);
		PString serverName; _jparser.validateByNameThrow("serverName", serverName);
		AtfValidator::validateInt(_descr, "serverName", serverName.length(), _checker, __FILE__, __LINE__);
		PString socialToken; _jparser.validateByNameThrow("socialToken", socialToken);
		AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
		WhereIsBodyATF whereIsBody; _jparser.validateByNameThrow("whereIsBody", whereIsBody);
		PString aamsTicket; _jparser.validateByNameThrow("aamsTicket", aamsTicket);
		AtfValidator::validateInt(_descr, "aamsTicket", aamsTicket.length(), _checker, __FILE__, __LINE__);
		PString clientNotification; _jparser.validateByNameThrow("clientNotification", clientNotification);
		AtfValidator::validateInt(_descr, "clientNotification", clientNotification.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void SagStarter::cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	if( errCode == DBM_NO_ERROR )
	{
		INT16 allInOption; _parser.parseINT16(allInOption);
		AtfValidator::validateInt(_descr, "allInOption", allInOption, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "locale"); size_t szLocale = strlen(_dummy);
		AtfValidator::validateInt(_descr, "locale", szLocale, _checker, __FILE__, __LINE__);
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		bool seatAvail; _parser.parseBOOL(seatAvail);
		AtfValidator::validateInt(_descr, "seatAvail", seatAvail, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverName"); size_t szServerName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverName", szServerName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		PString _descbuf;
		WhereIsBodyATF::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("whereIsBody"), _fieldsWithUnparsedContent);
		_parser.parseStringN(_dummy, 0, "aamsTicket"); size_t szAamsTicket = strlen(_dummy);
		AtfValidator::validateInt(_descr, "aamsTicket", szAamsTicket, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "clientNotification"); size_t szClientNotification = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clientNotification", szClientNotification, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SagWinnerInfo
//=================================================================

SagStarter::cli::SagWinnerInfo::SagWinnerInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SagStarter::cli::SagWinnerInfo::SagWinnerInfo(SagWinnerInfo&& _o)
	: userId(std::move(_o.userId))
	, payoutTicketTypeId(std::move(_o.payoutTicketTypeId))
	, userImageId(std::move(_o.userImageId))
	, award(std::move(_o.award))
	, targetRef(std::move(_o.targetRef))
	, targetName(std::move(_o.targetName))
	, ticketName(std::move(_o.ticketName))
{
}

SagStarter::cli::SagWinnerInfo& SagStarter::cli::SagWinnerInfo::operator=(SagWinnerInfo&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		payoutTicketTypeId = std::move(_o.payoutTicketTypeId);
		userImageId = std::move(_o.userImageId);
		award = std::move(_o.award);
		targetRef = std::move(_o.targetRef);
		targetName = std::move(_o.targetName);
		ticketName = std::move(_o.ticketName);
	}
	return *this;
}

#endif

void SagStarter::cli::SagWinnerInfo::clear()
{
	userId.clear();
	payoutTicketTypeId = 0;
	userImageId = 0;
	award = 0;
	targetRef.clear();
	targetName.clear();
	ticketName.clear();
}

bool SagStarter::cli::SagWinnerInfo::equals(const SagWinnerInfo& _o) const
{
	return userId.equals(_o.userId) &&
		payoutTicketTypeId == _o.payoutTicketTypeId &&
		userImageId == _o.userImageId &&
		award == _o.award &&
		targetRef.equals(_o.targetRef) &&
		targetName.equals(_o.targetName) &&
		ticketName.equals(_o.ticketName);
}

const char *SagStarter::cli::SagWinnerInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("payoutTicketTypeId=");
	_buf.appendUint(payoutTicketTypeId);
	_buf.append(',');
	_buf.append("userImageId=");
	_buf.appendUint(userImageId);
	_buf.append(',');
	_buf.append("award=");
	_buf.appendInt(award);
	_buf.append(',');
	_buf.append("targetRef=");
	_buf.append(targetRef);
	_buf.append(',');
	_buf.append("targetName=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, targetName);
	_buf.append(',');
	_buf.append("ticketName=");
	_buf.append(ticketName);
	_buf.append('}');
	return _buf.c_str();
}

const char *SagStarter::cli::SagWinnerInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("payoutTicketTypeId", payoutTicketTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userImageId", userImageId, _buf);
	Atf::XmlElement::encodeAsXmlElement("award", award, _buf);
	Atf::XmlElement::encodeAsXmlElement("targetRef", targetRef, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "targetName", targetName);
	Atf::XmlElement::encodeAsXmlElement("ticketName", ticketName, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool SagStarter::cli::SagWinnerInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("payoutTicketTypeId"))
		{
			payoutTicketTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userImageId"))
		{
			userImageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("award"))
		{
			award = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("targetRef"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, targetRef)) return false;
		}
		else if (_element.equals("targetName"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, targetName);
		}
		else if (_element.equals("ticketName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, ticketName)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void SagStarter::cli::SagWinnerInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SagWinnerInfo())) // not empty
	{
		_body.composeString(userId);
		_body.composeUINT32(payoutTicketTypeId);
		_body.composeUINT32(userImageId);
		_body.composeINT32(award);
		_body.composeString(targetRef);
		targetName.compose(_body);
		_body.composeString(ticketName);
	}

	_msg.composeMsgBody(_body);
}

void SagStarter::cli::SagWinnerInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(userId);
	_parser0.parseUINT32(payoutTicketTypeId);
	_parser0.parseUINT32(userImageId);
	_parser0.parseINT32(award);
	_parser0.parseStringP(targetRef);
	targetName.parse(_parser0);
	_parser0.parseStringP(ticketName);
}

void SagStarter::cli::SagWinnerInfo::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("userId", userId);
	_parser0.parse("payoutTicketTypeId", payoutTicketTypeId);
	_parser0.parse("userImageId", userImageId);
	_parser0.parse("award", award);
	_parser0.parse("targetRef", targetRef);
	_parser0.parse("targetName", targetName);
	_parser0.parse("ticketName", ticketName);
}

const char *SagStarter::cli::SagWinnerInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("payoutTicketTypeId", payoutTicketTypeId);
	_jsonstr.compose("userImageId", userImageId);
	_jsonstr.compose("award", award);
	_jsonstr.compose("targetRef", targetRef);
	_jsonstr.compose("targetName", targetName);
	_jsonstr.compose("ticketName", ticketName);
	return _buf.c_str();
}

void SagStarter::cli::SagWinnerInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("payoutTicketTypeId", payoutTicketTypeId);
	_jparser.parseByNameThrow("userImageId", userImageId);
	_jparser.parseByNameThrow("award", award);
	_jparser.parseByNameThrow("targetRef", targetRef);
	_jparser.parseByNameThrow("targetName", targetName);
	_jparser.parseByNameThrow("ticketName", ticketName);
}

/* static */ void SagStarter::cli::SagWinnerInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	UINT32 payoutTicketTypeId; _jparser.validateByNameThrow("payoutTicketTypeId", payoutTicketTypeId);
	AtfValidator::validateInt(_descr, "payoutTicketTypeId", payoutTicketTypeId, _checker, __FILE__, __LINE__);
	UINT32 userImageId; _jparser.validateByNameThrow("userImageId", userImageId);
	AtfValidator::validateInt(_descr, "userImageId", userImageId, _checker, __FILE__, __LINE__);
	INT32 award; _jparser.validateByNameThrow("award", award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	PString targetRef; _jparser.validateByNameThrow("targetRef", targetRef);
	AtfValidator::validateInt(_descr, "targetRef", targetRef.length(), _checker, __FILE__, __LINE__);
	I18nPString targetName; _jparser.validateByNameThrow("targetName", targetName);
	PString ticketName; _jparser.validateByNameThrow("ticketName", ticketName);
	AtfValidator::validateInt(_descr, "ticketName", ticketName.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void SagStarter::cli::SagWinnerInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	UINT32 payoutTicketTypeId; _parser0.parseUINT32(payoutTicketTypeId);
	AtfValidator::validateInt(_descr, "payoutTicketTypeId", payoutTicketTypeId, _checker, __FILE__, __LINE__);
	UINT32 userImageId; _parser0.parseUINT32(userImageId);
	AtfValidator::validateInt(_descr, "userImageId", userImageId, _checker, __FILE__, __LINE__);
	INT32 award; _parser0.parseINT32(award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "targetRef"); size_t szTargetRef = strlen(_dummy);
	AtfValidator::validateInt(_descr, "targetRef", szTargetRef, _checker, __FILE__, __LINE__);
	I18nPString targetName; targetName.parse(_parser0);
	_parser0.parseStringN(_dummy, 0, "ticketName"); size_t szTicketName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketName", szTicketName, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SagDataExCli
//=================================================================

SagStarter::cli::SagDataExCli::SagDataExCli()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SagStarter::cli::SagDataExCli::SagDataExCli(SagDataExCli&& _o)
	: active(std::move(_o.active))
	, visibilityMask32(std::move(_o.visibilityMask32))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, currency(std::move(_o.currency))
	, scalePM(std::move(_o.scalePM))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, speed(std::move(_o.speed))
	, finished(std::move(_o.finished))
	, levelMark(std::move(_o.levelMark))
	, winners(std::move(_o.winners))
	, visibilityMask(std::move(_o.visibilityMask))
{
}

SagStarter::cli::SagDataExCli& SagStarter::cli::SagDataExCli::operator=(SagDataExCli&& _o)
{
	if(this != &_o)
	{
		active = std::move(_o.active);
		visibilityMask32 = std::move(_o.visibilityMask32);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		currency = std::move(_o.currency);
		scalePM = std::move(_o.scalePM);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		speed = std::move(_o.speed);
		finished = std::move(_o.finished);
		levelMark = std::move(_o.levelMark);
		winners = std::move(_o.winners);
		visibilityMask = std::move(_o.visibilityMask);
	}
	return *this;
}

#endif

void SagStarter::cli::SagDataExCli::clear()
{
	active = false;
	visibilityMask32 = 0;
	buyIn = 0;
	rake = 0;
	currency = 0;
	scalePM = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	speed = 0;
	finished.setNull();
	levelMark = 0;
	winners.clear();
	visibilityMask.clear();
}

bool SagStarter::cli::SagDataExCli::equals(const SagDataExCli& _o) const
{
	return active == _o.active &&
		visibilityMask32 == _o.visibilityMask32 &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		currency == _o.currency &&
		scalePM == _o.scalePM &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		speed == _o.speed &&
		finished.equals(_o.finished) &&
		levelMark == _o.levelMark &&
		winners.equals(_o.winners) &&
		visibilityMask.equals(_o.visibilityMask);
}

const char *SagStarter::cli::SagDataExCli::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("active=");
	_buf.appendUint(active);
	_buf.append(',');
	_buf.append("visibilityMask32=");
	_buf.appendInt(visibilityMask32);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt(rake);
	_buf.append(',');
	_buf.append("currency=");
	_buf.appendInt(currency);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("speed=");
	_buf.appendUint(speed);
	_buf.append(',');
	_buf.append("finished=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, finished);
	_buf.append(',');
	_buf.append("levelMark=");
	_buf.appendInt(levelMark);
	_buf.append(',');
	_buf.append("winners=");
	winners.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMask=");
	visibilityMask.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *SagStarter::cli::SagDataExCli::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("active", active, _buf);
	Atf::XmlElement::encodeAsXmlElement("visibilityMask32", visibilityMask32, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("speed", speed, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "finished", finished);
	Atf::XmlElement::encodeAsXmlElement("levelMark", levelMark, _buf);
	winners.toXmlString("winners", _buf);
	visibilityMask.toXmlString("visibilityMask", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool SagStarter::cli::SagDataExCli::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("active"))
		{
			active = (*_value.ptr() == '1');
		}
		else if (_element.equals("visibilityMask32"))
		{
			visibilityMask32 = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			currency = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("speed"))
		{
			speed = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("finished"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, finished);
		}
		else if (_element.equals("levelMark"))
		{
			levelMark = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("winners"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SagWinnerInfo, 4 > >::FromXmlString(_value, winners)) return false;
		}
		else if (_element.equals("visibilityMask"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, visibilityMask)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void SagStarter::cli::SagDataExCli::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(active);
	_msg.composeINT32(visibilityMask32);
	_msg.composeINT32(buyIn);
	_msg.composeINT32(rake);
	_msg.composeINT32(currency);
	_msg.composeINT32(scalePM);
	_msg.composeBYTE(game);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(structure);
	_msg.composeBYTE(speed);
	_msg.composeSrvTime(finished);
	_msg.composeINT32(levelMark);
	winners.composeMsg(_msg, _ignoreJSON);
	visibilityMask.composeMsg(_msg, _ignoreJSON);
}

void SagStarter::cli::SagDataExCli::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(active);
	_parser.parseINT32(visibilityMask32);
	_parser.parseINT32(buyIn);
	_parser.parseINT32(rake);
	_parser.parseINT32(currency);
	_parser.parseINT32(scalePM);
	_parser.parseBYTE(game);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(structure);
	_parser.parseBYTE(speed);
	_parser.parseSrvTime(finished);
	_parser.parseINT32(levelMark);
	winners.parseMsg(_parser);
	visibilityMask.parseMsg(_parser);
}

void SagStarter::cli::SagDataExCli::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("active", active);
	_parser.parse("visibilityMask32", visibilityMask32);
	_parser.parse("buyIn", buyIn);
	_parser.parse("rake", rake);
	_parser.parse("currency", currency);
	_parser.parse("scalePM", scalePM);
	_parser.parse("game", game);
	_parser.parse("isHiLo", isHiLo);
	_parser.parse("structure", structure);
	_parser.parse("speed", speed);
	_parser.parse("finished", finished);
	_parser.parse("levelMark", levelMark);
	_parser.parse("winners", winners);
	_parser.parse("visibilityMask", visibilityMask);
}

const char *SagStarter::cli::SagDataExCli::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("active", active);
	_jsonstr.compose("visibilityMask32", visibilityMask32);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("speed", speed);
	_jsonstr.compose("finished", finished);
	_jsonstr.compose("levelMark", levelMark);
	_jsonstr.compose("winners", winners);
	_jsonstr.compose("visibilityMask", visibilityMask);
	return _buf.c_str();
}

void SagStarter::cli::SagDataExCli::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("active", active);
	_jparser.parseByNameThrow("visibilityMask32", visibilityMask32);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("speed", speed);
	_jparser.parseByNameThrow("finished", finished);
	_jparser.parseByNameThrow("levelMark", levelMark);
	_jparser.parseByNameThrow("winners", winners);
	_jparser.parseByNameThrow("visibilityMask", visibilityMask);
}

/* static */ void SagStarter::cli::SagDataExCli::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool active; _jparser.validateByNameThrow("active", active);
	AtfValidator::validateInt(_descr, "active", active, _checker, __FILE__, __LINE__);
	INT32 visibilityMask32; _jparser.validateByNameThrow("visibilityMask32", visibilityMask32);
	AtfValidator::validateInt(_descr, "visibilityMask32", visibilityMask32, _checker, __FILE__, __LINE__);
	INT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	INT32 currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency, _checker, __FILE__, __LINE__);
	INT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE speed; _jparser.validateByNameThrow("speed", speed);
	AtfValidator::validateInt(_descr, "speed", speed, _checker, __FILE__, __LINE__);
	SrvTime finished; _jparser.validateByNameThrow("finished", finished);
	AtfValidator::validateSrvDateTime(_descr, "finished", finished, _checker, __FILE__, __LINE__);
	INT32 levelMark; _jparser.validateByNameThrow("levelMark", levelMark);
	AtfValidator::validateInt(_descr, "levelMark", levelMark, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SagWinnerInfo > winners; _jparser.validateByNameThrow("winners", winners);
	AtfValidator::validateInt(_descr, "winners", winners.size(), _checker, __FILE__, __LINE__);
	PSiteMask visibilityMask; _jparser.validateByNameThrow("visibilityMask", visibilityMask);
}

/*static*/ void SagStarter::cli::SagDataExCli::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool active; _parser.parseBOOL(active);
	AtfValidator::validateInt(_descr, "active", active, _checker, __FILE__, __LINE__);
	INT32 visibilityMask32; _parser.parseINT32(visibilityMask32);
	AtfValidator::validateInt(_descr, "visibilityMask32", visibilityMask32, _checker, __FILE__, __LINE__);
	INT32 buyIn; _parser.parseINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT32 rake; _parser.parseINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	INT32 currency; _parser.parseINT32(currency);
	AtfValidator::validateInt(_descr, "currency", currency, _checker, __FILE__, __LINE__);
	INT32 scalePM; _parser.parseINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE speed; _parser.parseBYTE(speed);
	AtfValidator::validateInt(_descr, "speed", speed, _checker, __FILE__, __LINE__);
	SrvTime finished; _parser.parseSrvTime(finished);
	AtfValidator::validateSrvDateTime(_descr, "finished", finished, _checker, __FILE__, __LINE__);
	INT32 levelMark; _parser.parseINT32(levelMark);
	AtfValidator::validateInt(_descr, "levelMark", levelMark, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szWinners = Atf::LAtfVector< SagWinnerInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("winners"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "winners", szWinners, _checker, __FILE__, __LINE__);
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("visibilityMask"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    SagTournFinishInfo
//=================================================================

SagStarter::srv::SagTournFinishInfo::SagTournFinishInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SagStarter::srv::SagTournFinishInfo::SagTournFinishInfo(SagTournFinishInfo&& _o)
	: tournId(std::move(_o.tournId))
	, finished(std::move(_o.finished))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, winners(std::move(_o.winners))
{
}

SagStarter::srv::SagTournFinishInfo& SagStarter::srv::SagTournFinishInfo::operator=(SagTournFinishInfo&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		finished = std::move(_o.finished);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		winners = std::move(_o.winners);
	}
	return *this;
}

#endif

void SagStarter::srv::SagTournFinishInfo::clear()
{
	tournId = 0;
	finished.setNull();
	buyIn = 0;
	rake = 0;
	winners.clear();
}

bool SagStarter::srv::SagTournFinishInfo::equals(const SagTournFinishInfo& _o) const
{
	return tournId == _o.tournId &&
		finished.equals(_o.finished) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		winners.equals(_o.winners);
}

const char *SagStarter::srv::SagTournFinishInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("finished=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, finished);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt(rake);
	_buf.append(',');
	_buf.append("winners=");
	winners.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *SagStarter::srv::SagTournFinishInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "finished", finished);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	winners.toXmlString("winners", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool SagStarter::srv::SagTournFinishInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournId"))
		{
			tournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("finished"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, finished);
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("winners"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< cli::SagWinnerInfo, 4 > >::FromXmlString(_value, winners)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void SagStarter::srv::SagTournFinishInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SagTournFinishInfo())) // not empty
	{
		_body.composeUINT32(tournId);
		_body.composeSrvTime(finished);
		_body.composeINT32(buyIn);
		_body.composeINT32(rake);
		winners.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void SagStarter::srv::SagTournFinishInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournId);
	_parser0.parseSrvTime(finished);
	_parser0.parseINT32(buyIn);
	_parser0.parseINT32(rake);
	winners.parseMsg(_parser0);
}

void SagStarter::srv::SagTournFinishInfo::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("tournId", tournId);
	_parser0.parse("finished", finished);
	_parser0.parse("buyIn", buyIn);
	_parser0.parse("rake", rake);
	_parser0.parse("winners", winners);
}

const char *SagStarter::srv::SagTournFinishInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("finished", finished);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("winners", winners);
	return _buf.c_str();
}

void SagStarter::srv::SagTournFinishInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("finished", finished);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("winners", winners);
}

/* static */ void SagStarter::srv::SagTournFinishInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	SrvTime finished; _jparser.validateByNameThrow("finished", finished);
	AtfValidator::validateSrvDateTime(_descr, "finished", finished, _checker, __FILE__, __LINE__);
	INT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< cli::SagWinnerInfo > winners; _jparser.validateByNameThrow("winners", winners);
	AtfValidator::validateInt(_descr, "winners", winners.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void SagStarter::srv::SagTournFinishInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 tournId; _parser0.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	SrvTime finished; _parser0.parseSrvTime(finished);
	AtfValidator::validateSrvDateTime(_descr, "finished", finished, _checker, __FILE__, __LINE__);
	INT32 buyIn; _parser0.parseINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT32 rake; _parser0.parseINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szWinners = Atf::LAtfVector< cli::SagWinnerInfo, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("winners"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "winners", szWinners, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* SagStarter::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_TOURN_REG_INFO_REPLY: _obj = new cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY(); break;
			case MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID: _obj = new cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID(); break;
			case MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY: _obj = new cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY(); break;
			case MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID: _obj = new cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID(); break;
		}
	}
	
	return _obj;
}

/* static */ bool SagStarter::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_TOURN_REG_INFO_REPLY: cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID: cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY: cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID: cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool SagStarter::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_TOURN_REG_INFO_REPLY: cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID: cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_BY_SCRIPTID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY: cli::Protocol_MSG_SAG_REGISTER_TOURNAMENT_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID: cli::Protocol_MSG_SAG_TOURN_REG_INFO_BY_SCRIPTID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

