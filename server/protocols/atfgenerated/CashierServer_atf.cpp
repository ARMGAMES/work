/**
 * CashierServer_atf.cpp
 *
 * This file was auto-generated from CashierServer_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: CashierServer_atf.txt
 */
 
#include "CashierServer_atf.h"

//=================================================================
//                    SetUserRollStatus
//=================================================================

CashierServer::common_structs::SetUserRollStatus::SetUserRollStatus()
{
	clear();
}

void CashierServer::common_structs::SetUserRollStatus::clear()
{
	userRollId = 0;
	curStatus = 0;
	action = 0;
}

bool CashierServer::common_structs::SetUserRollStatus::equals(const SetUserRollStatus& _o) const
{
	return userRollId == _o.userRollId &&
		curStatus == _o.curStatus &&
		action == _o.action;
}

const char *CashierServer::common_structs::SetUserRollStatus::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userRollId=");
	_buf.appendUint(userRollId);
	_buf.append(',');
	_buf.append("curStatus=");
	_buf.appendInt(curStatus);
	_buf.append(',');
	_buf.append("action=");
	_buf.appendInt(action);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::common_structs::SetUserRollStatus::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userRollId", userRollId, _buf);
	Atf::XmlElement::encodeAsXmlElement("curStatus", curStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("action", action, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::common_structs::SetUserRollStatus::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userRollId"))
		{
			userRollId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("curStatus"))
		{
			curStatus = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("action"))
		{
			action = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::common_structs::SetUserRollStatus::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(userRollId);
	_msg.composeINT32(curStatus);
	_msg.composeINT32(action);
}

void CashierServer::common_structs::SetUserRollStatus::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(userRollId);
	_parser.parseINT32(curStatus);
	_parser.parseINT32(action);
}

const char *CashierServer::common_structs::SetUserRollStatus::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userRollId", userRollId);
	_jsonstr.compose("curStatus", curStatus);
	_jsonstr.compose("action", action);
	return _buf.c_str();
}

void CashierServer::common_structs::SetUserRollStatus::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userRollId", userRollId);
	_jparser.parseByNameThrow("curStatus", curStatus);
	_jparser.parseByNameThrow("action", action);
}

/* static */ void CashierServer::common_structs::SetUserRollStatus::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 userRollId; _jparser.validateByNameThrow("userRollId", userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
	INT32 curStatus; _jparser.validateByNameThrow("curStatus", curStatus);
	AtfValidator::validateIntRange(_descr, "curStatus", curStatus, eUserRollStatus_Undefined, eUserRollStatus_Last, _checker, __FILE__, __LINE__);
	INT32 action; _jparser.validateByNameThrow("action", action);
	{ const INT32 action_enum[] = {eUserRollAction_AcceptIssued, eUserRollAction_Void, eUserRollAction_Surrender, eUserRollAction_Pause, eUserRollAction_Resume }; AtfValidator::validateEnum(_descr, "action", action, action_enum, _checker, __FILE__, __LINE__); }
}

/*static*/ void CashierServer::common_structs::SetUserRollStatus::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 userRollId; _parser.parseUINT32(userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
	INT32 curStatus; _parser.parseINT32(curStatus);
	AtfValidator::validateIntRange(_descr, "curStatus", curStatus, eUserRollStatus_Undefined, eUserRollStatus_Last, _checker, __FILE__, __LINE__);
	INT32 action; _parser.parseINT32(action);
	{ const INT32 action_enum[] = {eUserRollAction_AcceptIssued, eUserRollAction_Void, eUserRollAction_Surrender, eUserRollAction_Pause, eUserRollAction_Resume }; AtfValidator::validateEnum(_descr, "action", action, action_enum, _checker, __FILE__, __LINE__); }
}

//=================================================================
//                    SetUserRollStatusReply
//=================================================================

CashierServer::common_structs::SetUserRollStatusReply::SetUserRollStatusReply()
{
	clear();
}

void CashierServer::common_structs::SetUserRollStatusReply::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::common_structs::SetUserRollStatusReply::equals(const SetUserRollStatusReply& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

const char *CashierServer::common_structs::SetUserRollStatusReply::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::common_structs::SetUserRollStatusReply::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::common_structs::SetUserRollStatusReply::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("errCode"))
		{
			errCode = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errDescr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::common_structs::SetUserRollStatusReply::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::common_structs::SetUserRollStatusReply::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::common_structs::SetUserRollStatusReply::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::common_structs::SetUserRollStatusReply::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/* static */ void CashierServer::common_structs::SetUserRollStatusReply::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::common_structs::SetUserRollStatusReply::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    SetGameTicketStatus
//=================================================================

CashierServer::common_structs::SetGameTicketStatus::SetGameTicketStatus()
{
	clear();
}

void CashierServer::common_structs::SetGameTicketStatus::clear()
{
	gameTicketId = 0;
	curStatus = 0;
	action = 0;
}

bool CashierServer::common_structs::SetGameTicketStatus::equals(const SetGameTicketStatus& _o) const
{
	return gameTicketId == _o.gameTicketId &&
		curStatus == _o.curStatus &&
		action == _o.action;
}

const char *CashierServer::common_structs::SetGameTicketStatus::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameTicketId=");
	_buf.appendUint64(gameTicketId);
	_buf.append(',');
	_buf.append("curStatus=");
	_buf.appendInt(curStatus);
	_buf.append(',');
	_buf.append("action=");
	_buf.appendInt(action);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::common_structs::SetGameTicketStatus::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameTicketId", gameTicketId, _buf);
	Atf::XmlElement::encodeAsXmlElement("curStatus", curStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("action", action, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::common_structs::SetGameTicketStatus::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameTicketId"))
		{
			gameTicketId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("curStatus"))
		{
			curStatus = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("action"))
		{
			action = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::common_structs::SetGameTicketStatus::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(gameTicketId);
	_msg.composeINT32(curStatus);
	_msg.composeINT32(action);
}

void CashierServer::common_structs::SetGameTicketStatus::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(gameTicketId);
	_parser.parseINT32(curStatus);
	_parser.parseINT32(action);
}

const char *CashierServer::common_structs::SetGameTicketStatus::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameTicketId", gameTicketId);
	_jsonstr.compose("curStatus", curStatus);
	_jsonstr.compose("action", action);
	return _buf.c_str();
}

void CashierServer::common_structs::SetGameTicketStatus::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameTicketId", gameTicketId);
	_jparser.parseByNameThrow("curStatus", curStatus);
	_jparser.parseByNameThrow("action", action);
}

/* static */ void CashierServer::common_structs::SetGameTicketStatus::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 gameTicketId; _jparser.validateByNameThrow("gameTicketId", gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
	INT32 curStatus; _jparser.validateByNameThrow("curStatus", curStatus);
	AtfValidator::validateIntRange(_descr, "curStatus", curStatus, eGameTicketStatus_Issued, eGameTicketStatus_Last, _checker, __FILE__, __LINE__);
	INT32 action; _jparser.validateByNameThrow("action", action);
	{ const INT32 action_enum[] = { eGameTicketAction_Accept, eGameTicketAction_Reject, eGameTicketAction_Void }; AtfValidator::validateEnum(_descr, "action", action, action_enum, _checker, __FILE__, __LINE__); }
}

/*static*/ void CashierServer::common_structs::SetGameTicketStatus::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT64 gameTicketId; _parser.parseUINT64(gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
	INT32 curStatus; _parser.parseINT32(curStatus);
	AtfValidator::validateIntRange(_descr, "curStatus", curStatus, eGameTicketStatus_Issued, eGameTicketStatus_Last, _checker, __FILE__, __LINE__);
	INT32 action; _parser.parseINT32(action);
	{ const INT32 action_enum[] = { eGameTicketAction_Accept, eGameTicketAction_Reject, eGameTicketAction_Void }; AtfValidator::validateEnum(_descr, "action", action, action_enum, _checker, __FILE__, __LINE__); }
}

//=================================================================
//                    SetGameTicketStatusReply
//=================================================================

CashierServer::common_structs::SetGameTicketStatusReply::SetGameTicketStatusReply()
{
	clear();
}

void CashierServer::common_structs::SetGameTicketStatusReply::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::common_structs::SetGameTicketStatusReply::equals(const SetGameTicketStatusReply& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

const char *CashierServer::common_structs::SetGameTicketStatusReply::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::common_structs::SetGameTicketStatusReply::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::common_structs::SetGameTicketStatusReply::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("errCode"))
		{
			errCode = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errDescr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::common_structs::SetGameTicketStatusReply::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::common_structs::SetGameTicketStatusReply::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::common_structs::SetGameTicketStatusReply::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::common_structs::SetGameTicketStatusReply::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/* static */ void CashierServer::common_structs::SetGameTicketStatusReply::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::common_structs::SetGameTicketStatusReply::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    CashierRollBody
//=================================================================

CashierServer::common_structs::CashierRollBody::CashierRollBody()
{
	clear();
}

void CashierServer::common_structs::CashierRollBody::clear()
{
	rollId = 0;
	rollAmount = 0;
	bonusCurrency.clear();
	rollAmountInAcctCur = 0;
	acctCurrency.clear();
	cashPriceInAcctCur = 0;
	acctCurrency2.clear();
	rollProducts = 0;
	clearPointsInCentsRounded = 0;
	clearBets = 0;
	redemptionLimit = 0;
	clearStakes = 0;
}

bool CashierServer::common_structs::CashierRollBody::equals(const CashierRollBody& _o) const
{
	return rollId == _o.rollId &&
		rollAmount == _o.rollAmount &&
		Atf::atfPStringEquals(bonusCurrency, _o.bonusCurrency) &&
		rollAmountInAcctCur == _o.rollAmountInAcctCur &&
		Atf::atfPStringEquals(acctCurrency, _o.acctCurrency) &&
		cashPriceInAcctCur == _o.cashPriceInAcctCur &&
		Atf::atfPStringEquals(acctCurrency2, _o.acctCurrency2) &&
		rollProducts == _o.rollProducts &&
		clearPointsInCentsRounded == _o.clearPointsInCentsRounded &&
		clearBets == _o.clearBets &&
		redemptionLimit == _o.redemptionLimit &&
		clearStakes == _o.clearStakes;
}

const char *CashierServer::common_structs::CashierRollBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("rollId=");
	_buf.appendUint(rollId);
	_buf.append(',');
	_buf.append("rollAmount=");
	_buf.appendInt(rollAmount);
	_buf.append(',');
	_buf.append("bonusCurrency=");
	_buf.append(bonusCurrency);
	_buf.append(',');
	_buf.append("rollAmountInAcctCur=");
	_buf.appendInt(rollAmountInAcctCur);
	_buf.append(',');
	_buf.append("acctCurrency=");
	_buf.append(acctCurrency);
	_buf.append(',');
	_buf.append("cashPriceInAcctCur=");
	_buf.appendInt(cashPriceInAcctCur);
	_buf.append(',');
	_buf.append("acctCurrency2=");
	_buf.append(acctCurrency2);
	_buf.append(',');
	_buf.append("rollProducts=");
	_buf.appendUint(rollProducts);
	_buf.append(',');
	_buf.append("clearPointsInCentsRounded=");
	_buf.appendInt(clearPointsInCentsRounded);
	_buf.append(',');
	_buf.append("clearBets=");
	_buf.appendInt(clearBets);
	_buf.append(',');
	_buf.append("redemptionLimit=");
	_buf.appendInt(redemptionLimit);
	_buf.append(',');
	_buf.append("clearStakes=");
	_buf.appendInt(clearStakes);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::common_structs::CashierRollBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("rollId", rollId, _buf);
	Atf::XmlElement::encodeAsXmlElement("rollAmount", rollAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusCurrency", bonusCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("rollAmountInAcctCur", rollAmountInAcctCur, _buf);
	Atf::XmlElement::encodeAsXmlElement("acctCurrency", acctCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("cashPriceInAcctCur", cashPriceInAcctCur, _buf);
	Atf::XmlElement::encodeAsXmlElement("acctCurrency2", acctCurrency2, _buf);
	Atf::XmlElement::encodeAsXmlElement("rollProducts", rollProducts, _buf);
	Atf::XmlElement::encodeAsXmlElement("clearPointsInCentsRounded", clearPointsInCentsRounded, _buf);
	Atf::XmlElement::encodeAsXmlElement("clearBets", clearBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("redemptionLimit", redemptionLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("clearStakes", clearStakes, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::common_structs::CashierRollBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("rollId"))
		{
			rollId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rollAmount"))
		{
			rollAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bonusCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, bonusCurrency)) return false;
		}
		else if (_element.equals("rollAmountInAcctCur"))
		{
			rollAmountInAcctCur = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("acctCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, acctCurrency)) return false;
		}
		else if (_element.equals("cashPriceInAcctCur"))
		{
			cashPriceInAcctCur = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("acctCurrency2"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, acctCurrency2)) return false;
		}
		else if (_element.equals("rollProducts"))
		{
			rollProducts = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clearPointsInCentsRounded"))
		{
			clearPointsInCentsRounded = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clearBets"))
		{
			clearBets = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("redemptionLimit"))
		{
			redemptionLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clearStakes"))
		{
			clearStakes = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::common_structs::CashierRollBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierRollBody())) // not empty
	{
		_body.composeUINT32(rollId);
		_body.composeINT32(rollAmount);
		_body.composeString(bonusCurrency);
		_body.composeINT32(rollAmountInAcctCur);
		_body.composeString(acctCurrency);
		_body.composeINT32(cashPriceInAcctCur);
		_body.composeString(acctCurrency2);
		_body.composeUINT32(rollProducts);
		_body.composeINT32(clearPointsInCentsRounded);
		_body.composeINT32(clearBets);
		_body.composeINT32(redemptionLimit);
		_body.composeINT32(clearStakes);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::common_structs::CashierRollBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(rollId);
	_parser0.parseINT32(rollAmount);
	_parser0.parseStringP(bonusCurrency);
	_parser0.parseINT32(rollAmountInAcctCur);
	_parser0.parseStringP(acctCurrency);
	_parser0.parseINT32(cashPriceInAcctCur);
	_parser0.parseStringP(acctCurrency2);
	_parser0.parseUINT32(rollProducts);
	_parser0.parseINT32(clearPointsInCentsRounded);
	_parser0.parseINT32(clearBets);
	_parser0.parseINT32(redemptionLimit);
	_parser0.parseINT32(clearStakes);
}

const char *CashierServer::common_structs::CashierRollBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("rollId", rollId);
	_jsonstr.compose("rollAmount", rollAmount);
	_jsonstr.compose("bonusCurrency", bonusCurrency);
	_jsonstr.compose("rollAmountInAcctCur", rollAmountInAcctCur);
	_jsonstr.compose("acctCurrency", acctCurrency);
	_jsonstr.compose("cashPriceInAcctCur", cashPriceInAcctCur);
	_jsonstr.compose("acctCurrency2", acctCurrency2);
	_jsonstr.compose("rollProducts", rollProducts);
	_jsonstr.compose("clearPointsInCentsRounded", clearPointsInCentsRounded);
	_jsonstr.compose("clearBets", clearBets);
	_jsonstr.compose("redemptionLimit", redemptionLimit);
	_jsonstr.compose("clearStakes", clearStakes);
	return _buf.c_str();
}

void CashierServer::common_structs::CashierRollBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("rollId", rollId);
	_jparser.parseByNameThrow("rollAmount", rollAmount);
	_jparser.parseByNameThrow("bonusCurrency", bonusCurrency);
	_jparser.parseByNameThrow("rollAmountInAcctCur", rollAmountInAcctCur);
	_jparser.parseByNameThrow("acctCurrency", acctCurrency);
	_jparser.parseByNameThrow("cashPriceInAcctCur", cashPriceInAcctCur);
	_jparser.parseByNameThrow("acctCurrency2", acctCurrency2);
	_jparser.parseByNameThrow("rollProducts", rollProducts);
	_jparser.parseByNameThrow("clearPointsInCentsRounded", clearPointsInCentsRounded);
	_jparser.parseByNameThrow("clearBets", clearBets);
	_jparser.parseByNameThrow("redemptionLimit", redemptionLimit);
	_jparser.parseByNameThrow("clearStakes", clearStakes);
}

/* static */ void CashierServer::common_structs::CashierRollBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	UINT32 rollId; _jparser.validateByNameThrow("rollId", rollId);
	AtfValidator::validateInt(_descr, "rollId", rollId, _checker, __FILE__, __LINE__);
	INT32 rollAmount; _jparser.validateByNameThrow("rollAmount", rollAmount);
	AtfValidator::validateInt(_descr, "rollAmount", rollAmount, _checker, __FILE__, __LINE__);
	PString bonusCurrency; _jparser.validateByNameThrow("bonusCurrency", bonusCurrency);
	AtfValidator::validateInt(_descr, "bonusCurrency", bonusCurrency.length(), _checker, __FILE__, __LINE__);
	INT32 rollAmountInAcctCur; _jparser.validateByNameThrow("rollAmountInAcctCur", rollAmountInAcctCur);
	AtfValidator::validateInt(_descr, "rollAmountInAcctCur", rollAmountInAcctCur, _checker, __FILE__, __LINE__);
	PString acctCurrency; _jparser.validateByNameThrow("acctCurrency", acctCurrency);
	AtfValidator::validateInt(_descr, "acctCurrency", acctCurrency.length(), _checker, __FILE__, __LINE__);
	INT32 cashPriceInAcctCur; _jparser.validateByNameThrow("cashPriceInAcctCur", cashPriceInAcctCur);
	AtfValidator::validateInt(_descr, "cashPriceInAcctCur", cashPriceInAcctCur, _checker, __FILE__, __LINE__);
	PString acctCurrency2; _jparser.validateByNameThrow("acctCurrency2", acctCurrency2);
	AtfValidator::validateInt(_descr, "acctCurrency2", acctCurrency2.length(), _checker, __FILE__, __LINE__);
	UINT32 rollProducts; _jparser.validateByNameThrow("rollProducts", rollProducts);
	AtfValidator::validateInt(_descr, "rollProducts", rollProducts, _checker, __FILE__, __LINE__);
	INT32 clearPointsInCentsRounded; _jparser.validateByNameThrow("clearPointsInCentsRounded", clearPointsInCentsRounded);
	AtfValidator::validateInt(_descr, "clearPointsInCentsRounded", clearPointsInCentsRounded, _checker, __FILE__, __LINE__);
	INT32 clearBets; _jparser.validateByNameThrow("clearBets", clearBets);
	AtfValidator::validateInt(_descr, "clearBets", clearBets, _checker, __FILE__, __LINE__);
	INT32 redemptionLimit; _jparser.validateByNameThrow("redemptionLimit", redemptionLimit);
	AtfValidator::validateInt(_descr, "redemptionLimit", redemptionLimit, _checker, __FILE__, __LINE__);
	INT32 clearStakes; _jparser.validateByNameThrow("clearStakes", clearStakes);
	AtfValidator::validateInt(_descr, "clearStakes", clearStakes, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::common_structs::CashierRollBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	if(_parser0.parseEnded()) return;
	UINT32 rollId; _parser0.parseUINT32(rollId);
	AtfValidator::validateInt(_descr, "rollId", rollId, _checker, __FILE__, __LINE__);
	INT32 rollAmount; _parser0.parseINT32(rollAmount);
	AtfValidator::validateInt(_descr, "rollAmount", rollAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "bonusCurrency"); size_t szBonusCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "bonusCurrency", szBonusCurrency, _checker, __FILE__, __LINE__);
	INT32 rollAmountInAcctCur; _parser0.parseINT32(rollAmountInAcctCur);
	AtfValidator::validateInt(_descr, "rollAmountInAcctCur", rollAmountInAcctCur, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "acctCurrency"); size_t szAcctCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "acctCurrency", szAcctCurrency, _checker, __FILE__, __LINE__);
	INT32 cashPriceInAcctCur; _parser0.parseINT32(cashPriceInAcctCur);
	AtfValidator::validateInt(_descr, "cashPriceInAcctCur", cashPriceInAcctCur, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "acctCurrency2"); size_t szAcctCurrency2 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "acctCurrency2", szAcctCurrency2, _checker, __FILE__, __LINE__);
	UINT32 rollProducts; _parser0.parseUINT32(rollProducts);
	AtfValidator::validateInt(_descr, "rollProducts", rollProducts, _checker, __FILE__, __LINE__);
	INT32 clearPointsInCentsRounded; _parser0.parseINT32(clearPointsInCentsRounded);
	AtfValidator::validateInt(_descr, "clearPointsInCentsRounded", clearPointsInCentsRounded, _checker, __FILE__, __LINE__);
	INT32 clearBets; _parser0.parseINT32(clearBets);
	AtfValidator::validateInt(_descr, "clearBets", clearBets, _checker, __FILE__, __LINE__);
	INT32 redemptionLimit; _parser0.parseINT32(redemptionLimit);
	AtfValidator::validateInt(_descr, "redemptionLimit", redemptionLimit, _checker, __FILE__, __LINE__);
	INT32 clearStakes; _parser0.parseINT32(clearStakes);
	AtfValidator::validateInt(_descr, "clearStakes", clearStakes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PaysystemLimit
//=================================================================

CashierServer::common_structs::PaysystemLimit::PaysystemLimit()
{
	clear();
}

void CashierServer::common_structs::PaysystemLimit::clear()
{
	paySystemByte = 0;
	paysystemName.clear();
	minDeposit = 0;
	maxCashinMonthly = 0;
	maxCashinWeekly = 0;
	maxCashinDaily = 0;
	feeStr.clear();
	empty.clear();
	maxDeposits = 0;
	depositsHours = 0;
	userLimitText.clear();
	maxCashin1Trans = 0;
	fastDepositIsOk = false;
	psAvailFlagToClient = 0;
}

bool CashierServer::common_structs::PaysystemLimit::equals(const PaysystemLimit& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		Atf::atfPStringEquals(paysystemName, _o.paysystemName) &&
		minDeposit == _o.minDeposit &&
		maxCashinMonthly == _o.maxCashinMonthly &&
		maxCashinWeekly == _o.maxCashinWeekly &&
		maxCashinDaily == _o.maxCashinDaily &&
		Atf::atfPStringEquals(feeStr, _o.feeStr) &&
		Atf::atfPStringEquals(empty, _o.empty) &&
		maxDeposits == _o.maxDeposits &&
		depositsHours == _o.depositsHours &&
		Atf::atfPStringEquals(userLimitText, _o.userLimitText) &&
		maxCashin1Trans == _o.maxCashin1Trans &&
		fastDepositIsOk == _o.fastDepositIsOk &&
		psAvailFlagToClient == _o.psAvailFlagToClient;
}

const char *CashierServer::common_structs::PaysystemLimit::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("paysystemName=");
	_buf.append(paysystemName);
	_buf.append(',');
	_buf.append("minDeposit=");
	_buf.appendInt(minDeposit);
	_buf.append(',');
	_buf.append("maxCashinMonthly=");
	_buf.appendInt(maxCashinMonthly);
	_buf.append(',');
	_buf.append("maxCashinWeekly=");
	_buf.appendInt(maxCashinWeekly);
	_buf.append(',');
	_buf.append("maxCashinDaily=");
	_buf.appendInt(maxCashinDaily);
	_buf.append(',');
	_buf.append("feeStr=");
	_buf.append(feeStr);
	_buf.append(',');
	_buf.append("empty=");
	_buf.append(empty);
	_buf.append(',');
	_buf.append("maxDeposits=");
	_buf.appendInt(maxDeposits);
	_buf.append(',');
	_buf.append("depositsHours=");
	_buf.appendInt(depositsHours);
	_buf.append(',');
	_buf.append("userLimitText=");
	_buf.append(userLimitText);
	_buf.append(',');
	_buf.append("maxCashin1Trans=");
	_buf.appendInt(maxCashin1Trans);
	_buf.append(',');
	_buf.append("fastDepositIsOk=");
	_buf.appendUint(fastDepositIsOk);
	_buf.append(',');
	_buf.append("psAvailFlagToClient=");
	_buf.appendUint(psAvailFlagToClient);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::common_structs::PaysystemLimit::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("paysystemName", paysystemName, _buf);
	Atf::XmlElement::encodeAsXmlElement("minDeposit", minDeposit, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxCashinMonthly", maxCashinMonthly, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxCashinWeekly", maxCashinWeekly, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxCashinDaily", maxCashinDaily, _buf);
	Atf::XmlElement::encodeAsXmlElement("feeStr", feeStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("empty", empty, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxDeposits", maxDeposits, _buf);
	Atf::XmlElement::encodeAsXmlElement("depositsHours", depositsHours, _buf);
	Atf::XmlElement::encodeAsXmlElement("userLimitText", userLimitText, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxCashin1Trans", maxCashin1Trans, _buf);
	Atf::XmlElement::encodeAsXmlElement("fastDepositIsOk", fastDepositIsOk, _buf);
	Atf::XmlElement::encodeAsXmlElement("psAvailFlagToClient", psAvailFlagToClient, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::common_structs::PaysystemLimit::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("paySystemByte"))
		{
			paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("paysystemName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, paysystemName)) return false;
		}
		else if (_element.equals("minDeposit"))
		{
			minDeposit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxCashinMonthly"))
		{
			maxCashinMonthly = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxCashinWeekly"))
		{
			maxCashinWeekly = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxCashinDaily"))
		{
			maxCashinDaily = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("feeStr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, feeStr)) return false;
		}
		else if (_element.equals("empty"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, empty)) return false;
		}
		else if (_element.equals("maxDeposits"))
		{
			maxDeposits = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("depositsHours"))
		{
			depositsHours = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userLimitText"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userLimitText)) return false;
		}
		else if (_element.equals("maxCashin1Trans"))
		{
			maxCashin1Trans = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fastDepositIsOk"))
		{
			fastDepositIsOk = (*_value.ptr() == '1');
		}
		else if (_element.equals("psAvailFlagToClient"))
		{
			psAvailFlagToClient = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::common_structs::PaysystemLimit::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeString(paysystemName);
	_msg.composeINT32(minDeposit);
	_msg.composeINT32(maxCashinMonthly);
	_msg.composeINT32(maxCashinWeekly);
	_msg.composeINT32(maxCashinDaily);
	_msg.composeString(feeStr);
	_msg.composeString(empty);
	_msg.composeINT32(maxDeposits);
	_msg.composeINT32(depositsHours);
	_msg.composeString(userLimitText);
	_msg.composeINT32(maxCashin1Trans);
	_msg.composeBOOL(fastDepositIsOk);
	_msg.composeUINT32(psAvailFlagToClient);
}

void CashierServer::common_structs::PaysystemLimit::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseStringP(paysystemName);
	_parser.parseINT32(minDeposit);
	_parser.parseINT32(maxCashinMonthly);
	_parser.parseINT32(maxCashinWeekly);
	_parser.parseINT32(maxCashinDaily);
	_parser.parseStringP(feeStr);
	_parser.parseStringP(empty);
	_parser.parseINT32(maxDeposits);
	_parser.parseINT32(depositsHours);
	_parser.parseStringP(userLimitText);
	_parser.parseINT32(maxCashin1Trans);
	_parser.parseBOOL(fastDepositIsOk);
	_parser.parseUINT32(psAvailFlagToClient);
}

const char *CashierServer::common_structs::PaysystemLimit::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemByte", paySystemByte);
	_jsonstr.compose("paysystemName", paysystemName);
	_jsonstr.compose("minDeposit", minDeposit);
	_jsonstr.compose("maxCashinMonthly", maxCashinMonthly);
	_jsonstr.compose("maxCashinWeekly", maxCashinWeekly);
	_jsonstr.compose("maxCashinDaily", maxCashinDaily);
	_jsonstr.compose("feeStr", feeStr);
	_jsonstr.compose("empty", empty);
	_jsonstr.compose("maxDeposits", maxDeposits);
	_jsonstr.compose("depositsHours", depositsHours);
	_jsonstr.compose("userLimitText", userLimitText);
	_jsonstr.compose("maxCashin1Trans", maxCashin1Trans);
	_jsonstr.compose("fastDepositIsOk", fastDepositIsOk);
	_jsonstr.compose("psAvailFlagToClient", psAvailFlagToClient);
	return _buf.c_str();
}

void CashierServer::common_structs::PaysystemLimit::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
	_jparser.parseByNameThrow("paysystemName", paysystemName);
	_jparser.parseByNameThrow("minDeposit", minDeposit);
	_jparser.parseByNameThrow("maxCashinMonthly", maxCashinMonthly);
	_jparser.parseByNameThrow("maxCashinWeekly", maxCashinWeekly);
	_jparser.parseByNameThrow("maxCashinDaily", maxCashinDaily);
	_jparser.parseByNameThrow("feeStr", feeStr);
	_jparser.parseByNameThrow("empty", empty);
	_jparser.parseByNameThrow("maxDeposits", maxDeposits);
	_jparser.parseByNameThrow("depositsHours", depositsHours);
	_jparser.parseByNameThrow("userLimitText", userLimitText);
	_jparser.parseByNameThrow("maxCashin1Trans", maxCashin1Trans);
	_jparser.parseByNameThrow("fastDepositIsOk", fastDepositIsOk);
	_jparser.parseByNameThrow("psAvailFlagToClient", psAvailFlagToClient);
}

/* static */ void CashierServer::common_structs::PaysystemLimit::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateInt(_descr, "paySystemByte", paySystemByte, _checker, __FILE__, __LINE__);
	PString paysystemName; _jparser.validateByNameThrow("paysystemName", paysystemName);
	AtfValidator::validateInt(_descr, "paysystemName", paysystemName.length(), _checker, __FILE__, __LINE__);
	INT32 minDeposit; _jparser.validateByNameThrow("minDeposit", minDeposit);
	AtfValidator::validateInt(_descr, "minDeposit", minDeposit, _checker, __FILE__, __LINE__);
	INT32 maxCashinMonthly; _jparser.validateByNameThrow("maxCashinMonthly", maxCashinMonthly);
	AtfValidator::validateInt(_descr, "maxCashinMonthly", maxCashinMonthly, _checker, __FILE__, __LINE__);
	INT32 maxCashinWeekly; _jparser.validateByNameThrow("maxCashinWeekly", maxCashinWeekly);
	AtfValidator::validateInt(_descr, "maxCashinWeekly", maxCashinWeekly, _checker, __FILE__, __LINE__);
	INT32 maxCashinDaily; _jparser.validateByNameThrow("maxCashinDaily", maxCashinDaily);
	AtfValidator::validateInt(_descr, "maxCashinDaily", maxCashinDaily, _checker, __FILE__, __LINE__);
	PString feeStr; _jparser.validateByNameThrow("feeStr", feeStr);
	AtfValidator::validateInt(_descr, "feeStr", feeStr.length(), _checker, __FILE__, __LINE__);
	PString empty; _jparser.validateByNameThrow("empty", empty);
	AtfValidator::validateInt(_descr, "empty", empty.length(), _checker, __FILE__, __LINE__);
	INT32 maxDeposits; _jparser.validateByNameThrow("maxDeposits", maxDeposits);
	AtfValidator::validateInt(_descr, "maxDeposits", maxDeposits, _checker, __FILE__, __LINE__);
	INT32 depositsHours; _jparser.validateByNameThrow("depositsHours", depositsHours);
	AtfValidator::validateInt(_descr, "depositsHours", depositsHours, _checker, __FILE__, __LINE__);
	PString userLimitText; _jparser.validateByNameThrow("userLimitText", userLimitText);
	AtfValidator::validateInt(_descr, "userLimitText", userLimitText.length(), _checker, __FILE__, __LINE__);
	INT32 maxCashin1Trans; _jparser.validateByNameThrow("maxCashin1Trans", maxCashin1Trans);
	AtfValidator::validateInt(_descr, "maxCashin1Trans", maxCashin1Trans, _checker, __FILE__, __LINE__);
	bool fastDepositIsOk; _jparser.validateByNameThrow("fastDepositIsOk", fastDepositIsOk);
	AtfValidator::validateInt(_descr, "fastDepositIsOk", fastDepositIsOk, _checker, __FILE__, __LINE__);
	UINT32 psAvailFlagToClient; _jparser.validateByNameThrow("psAvailFlagToClient", psAvailFlagToClient);
	AtfValidator::validateInt(_descr, "psAvailFlagToClient", psAvailFlagToClient, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::common_structs::PaysystemLimit::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateInt(_descr, "paySystemByte", paySystemByte, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "paysystemName"); size_t szPaysystemName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "paysystemName", szPaysystemName, _checker, __FILE__, __LINE__);
	INT32 minDeposit; _parser.parseINT32(minDeposit);
	AtfValidator::validateInt(_descr, "minDeposit", minDeposit, _checker, __FILE__, __LINE__);
	INT32 maxCashinMonthly; _parser.parseINT32(maxCashinMonthly);
	AtfValidator::validateInt(_descr, "maxCashinMonthly", maxCashinMonthly, _checker, __FILE__, __LINE__);
	INT32 maxCashinWeekly; _parser.parseINT32(maxCashinWeekly);
	AtfValidator::validateInt(_descr, "maxCashinWeekly", maxCashinWeekly, _checker, __FILE__, __LINE__);
	INT32 maxCashinDaily; _parser.parseINT32(maxCashinDaily);
	AtfValidator::validateInt(_descr, "maxCashinDaily", maxCashinDaily, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "feeStr"); size_t szFeeStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "feeStr", szFeeStr, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "empty"); size_t szEmpty = strlen(_dummy);
	AtfValidator::validateInt(_descr, "empty", szEmpty, _checker, __FILE__, __LINE__);
	INT32 maxDeposits; _parser.parseINT32(maxDeposits);
	AtfValidator::validateInt(_descr, "maxDeposits", maxDeposits, _checker, __FILE__, __LINE__);
	INT32 depositsHours; _parser.parseINT32(depositsHours);
	AtfValidator::validateInt(_descr, "depositsHours", depositsHours, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userLimitText"); size_t szUserLimitText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userLimitText", szUserLimitText, _checker, __FILE__, __LINE__);
	INT32 maxCashin1Trans; _parser.parseINT32(maxCashin1Trans);
	AtfValidator::validateInt(_descr, "maxCashin1Trans", maxCashin1Trans, _checker, __FILE__, __LINE__);
	bool fastDepositIsOk; _parser.parseBOOL(fastDepositIsOk);
	AtfValidator::validateInt(_descr, "fastDepositIsOk", fastDepositIsOk, _checker, __FILE__, __LINE__);
	UINT32 psAvailFlagToClient; _parser.parseUINT32(psAvailFlagToClient);
	AtfValidator::validateInt(_descr, "psAvailFlagToClient", psAvailFlagToClient, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TransactionHistoryCacheItem
//=================================================================

CashierServer::common_structs::TransactionHistoryCacheItem::TransactionHistoryCacheItem()
{
	clear();
}

void CashierServer::common_structs::TransactionHistoryCacheItem::clear()
{
	whenAccountWasImpacted.setNull();
	typeDescr.clear();
	transAcctAmount = 0;
	obsoleteSystemFee = 0;
	cardMaskedOrReference.clear();
	transId = 0;
	transBalanceCurrency.clear();
	descriptor.clear();
	transConverted = 0;
	transCurrency.clear();
	transCardTypeByte = 0;
	referenceHint.clear();
	historyFlags = 0;
}

bool CashierServer::common_structs::TransactionHistoryCacheItem::equals(const TransactionHistoryCacheItem& _o) const
{
	return whenAccountWasImpacted.equals(_o.whenAccountWasImpacted) &&
		Atf::atfPStringEquals(typeDescr, _o.typeDescr) &&
		transAcctAmount == _o.transAcctAmount &&
		obsoleteSystemFee == _o.obsoleteSystemFee &&
		Atf::atfPStringEquals(cardMaskedOrReference, _o.cardMaskedOrReference) &&
		transId == _o.transId &&
		Atf::atfPStringEquals(transBalanceCurrency, _o.transBalanceCurrency) &&
		Atf::atfPStringEquals(descriptor, _o.descriptor) &&
		transConverted == _o.transConverted &&
		Atf::atfPStringEquals(transCurrency, _o.transCurrency) &&
		transCardTypeByte == _o.transCardTypeByte &&
		Atf::atfPStringEquals(referenceHint, _o.referenceHint) &&
		historyFlags == _o.historyFlags;
}

const char *CashierServer::common_structs::TransactionHistoryCacheItem::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("whenAccountWasImpacted=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenAccountWasImpacted);
	_buf.append(',');
	_buf.append("typeDescr=");
	_buf.append(typeDescr);
	_buf.append(',');
	_buf.append("transAcctAmount=");
	_buf.appendInt(transAcctAmount);
	_buf.append(',');
	_buf.append("obsoleteSystemFee=");
	_buf.appendUint(obsoleteSystemFee);
	_buf.append(',');
	_buf.append("cardMaskedOrReference=");
	_buf.append(cardMaskedOrReference);
	_buf.append(',');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("transBalanceCurrency=");
	_buf.append(transBalanceCurrency);
	_buf.append(',');
	_buf.append("descriptor=");
	_buf.append(descriptor);
	_buf.append(',');
	_buf.append("transConverted=");
	_buf.appendInt(transConverted);
	_buf.append(',');
	_buf.append("transCurrency=");
	_buf.append(transCurrency);
	_buf.append(',');
	_buf.append("transCardTypeByte=");
	_buf.appendUint(transCardTypeByte);
	_buf.append(',');
	_buf.append("referenceHint=");
	_buf.append(referenceHint);
	_buf.append(',');
	_buf.append("historyFlags=");
	_buf.appendUint(historyFlags);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::common_structs::TransactionHistoryCacheItem::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenAccountWasImpacted", whenAccountWasImpacted);
	Atf::XmlElement::encodeAsXmlElement("typeDescr", typeDescr, _buf);
	Atf::XmlElement::encodeAsXmlElement("transAcctAmount", transAcctAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("obsoleteSystemFee", obsoleteSystemFee, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardMaskedOrReference", cardMaskedOrReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
	Atf::XmlElement::encodeAsXmlElement("transBalanceCurrency", transBalanceCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("descriptor", descriptor, _buf);
	Atf::XmlElement::encodeAsXmlElement("transConverted", transConverted, _buf);
	Atf::XmlElement::encodeAsXmlElement("transCurrency", transCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("transCardTypeByte", transCardTypeByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("referenceHint", referenceHint, _buf);
	Atf::XmlElement::encodeAsXmlElement("historyFlags", historyFlags, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::common_structs::TransactionHistoryCacheItem::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("whenAccountWasImpacted"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenAccountWasImpacted);
		}
		else if (_element.equals("typeDescr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, typeDescr)) return false;
		}
		else if (_element.equals("transAcctAmount"))
		{
			transAcctAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("obsoleteSystemFee"))
		{
			obsoleteSystemFee = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cardMaskedOrReference"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cardMaskedOrReference)) return false;
		}
		else if (_element.equals("transId"))
		{
			transId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("transBalanceCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, transBalanceCurrency)) return false;
		}
		else if (_element.equals("descriptor"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, descriptor)) return false;
		}
		else if (_element.equals("transConverted"))
		{
			transConverted = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("transCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, transCurrency)) return false;
		}
		else if (_element.equals("transCardTypeByte"))
		{
			transCardTypeByte = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("referenceHint"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, referenceHint)) return false;
		}
		else if (_element.equals("historyFlags"))
		{
			historyFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::common_structs::TransactionHistoryCacheItem::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TransactionHistoryCacheItem())) // not empty
	{
		_body.composeSrvTime(whenAccountWasImpacted);
		_body.composeString(typeDescr);
		_body.composeINT32(transAcctAmount);
		_body.composeUINT32(obsoleteSystemFee);
		_body.composeString(cardMaskedOrReference);
		_body.composeUINT32(transId);
		_body.composeString(transBalanceCurrency);
		_body.composeString(descriptor);
		_body.composeINT32(transConverted);
		_body.composeString(transCurrency);
		_body.composeBYTE(transCardTypeByte);
		_body.composeString(referenceHint);
		_body.composeUINT32(historyFlags);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::common_structs::TransactionHistoryCacheItem::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseSrvTime(whenAccountWasImpacted);
	_parser0.parseStringP(typeDescr);
	_parser0.parseINT32(transAcctAmount);
	_parser0.parseUINT32(obsoleteSystemFee);
	_parser0.parseStringP(cardMaskedOrReference);
	_parser0.parseUINT32(transId);
	_parser0.parseStringP(transBalanceCurrency);
	_parser0.parseStringP(descriptor);
	_parser0.parseINT32(transConverted);
	_parser0.parseStringP(transCurrency);
	_parser0.parseBYTE(transCardTypeByte);
	_parser0.parseStringP(referenceHint);
	_parser0.parseUINT32(historyFlags);
}

const char *CashierServer::common_structs::TransactionHistoryCacheItem::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("whenAccountWasImpacted", whenAccountWasImpacted);
	_jsonstr.compose("typeDescr", typeDescr);
	_jsonstr.compose("transAcctAmount", transAcctAmount);
	_jsonstr.compose("obsoleteSystemFee", obsoleteSystemFee);
	_jsonstr.compose("cardMaskedOrReference", cardMaskedOrReference);
	_jsonstr.compose("transId", transId);
	_jsonstr.compose("transBalanceCurrency", transBalanceCurrency);
	_jsonstr.compose("descriptor", descriptor);
	_jsonstr.compose("transConverted", transConverted);
	_jsonstr.compose("transCurrency", transCurrency);
	_jsonstr.compose("transCardTypeByte", transCardTypeByte);
	_jsonstr.compose("referenceHint", referenceHint);
	_jsonstr.compose("historyFlags", historyFlags);
	return _buf.c_str();
}

void CashierServer::common_structs::TransactionHistoryCacheItem::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("whenAccountWasImpacted", whenAccountWasImpacted);
	_jparser.parseByNameThrow("typeDescr", typeDescr);
	_jparser.parseByNameThrow("transAcctAmount", transAcctAmount);
	_jparser.parseByNameThrow("obsoleteSystemFee", obsoleteSystemFee);
	_jparser.parseByNameThrow("cardMaskedOrReference", cardMaskedOrReference);
	_jparser.parseByNameThrow("transId", transId);
	_jparser.parseByNameThrow("transBalanceCurrency", transBalanceCurrency);
	_jparser.parseByNameThrow("descriptor", descriptor);
	_jparser.parseByNameThrow("transConverted", transConverted);
	_jparser.parseByNameThrow("transCurrency", transCurrency);
	_jparser.parseByNameThrow("transCardTypeByte", transCardTypeByte);
	_jparser.parseByNameThrow("referenceHint", referenceHint);
	_jparser.parseByNameThrow("historyFlags", historyFlags);
}

/* static */ void CashierServer::common_structs::TransactionHistoryCacheItem::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime whenAccountWasImpacted; _jparser.validateByNameThrow("whenAccountWasImpacted", whenAccountWasImpacted);
	AtfValidator::validateSrvDateTime(_descr, "whenAccountWasImpacted", whenAccountWasImpacted, _checker, __FILE__, __LINE__);
	PString typeDescr; _jparser.validateByNameThrow("typeDescr", typeDescr);
	AtfValidator::validateInt(_descr, "typeDescr", typeDescr.length(), _checker, __FILE__, __LINE__);
	INT32 transAcctAmount; _jparser.validateByNameThrow("transAcctAmount", transAcctAmount);
	AtfValidator::validateInt(_descr, "transAcctAmount", transAcctAmount, _checker, __FILE__, __LINE__);
	UINT32 obsoleteSystemFee; _jparser.validateByNameThrow("obsoleteSystemFee", obsoleteSystemFee);
	AtfValidator::validateInt(_descr, "obsoleteSystemFee", obsoleteSystemFee, _checker, __FILE__, __LINE__);
	PString cardMaskedOrReference; _jparser.validateByNameThrow("cardMaskedOrReference", cardMaskedOrReference);
	AtfValidator::validateInt(_descr, "cardMaskedOrReference", cardMaskedOrReference.length(), _checker, __FILE__, __LINE__);
	UINT32 transId; _jparser.validateByNameThrow("transId", transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	PString transBalanceCurrency; _jparser.validateByNameThrow("transBalanceCurrency", transBalanceCurrency);
	AtfValidator::validateInt(_descr, "transBalanceCurrency", transBalanceCurrency.length(), _checker, __FILE__, __LINE__);
	PString descriptor; _jparser.validateByNameThrow("descriptor", descriptor);
	AtfValidator::validateInt(_descr, "descriptor", descriptor.length(), _checker, __FILE__, __LINE__);
	INT32 transConverted; _jparser.validateByNameThrow("transConverted", transConverted);
	AtfValidator::validateInt(_descr, "transConverted", transConverted, _checker, __FILE__, __LINE__);
	PString transCurrency; _jparser.validateByNameThrow("transCurrency", transCurrency);
	AtfValidator::validateInt(_descr, "transCurrency", transCurrency.length(), _checker, __FILE__, __LINE__);
	BYTE transCardTypeByte; _jparser.validateByNameThrow("transCardTypeByte", transCardTypeByte);
	AtfValidator::validateInt(_descr, "transCardTypeByte", transCardTypeByte, _checker, __FILE__, __LINE__);
	PString referenceHint; _jparser.validateByNameThrow("referenceHint", referenceHint);
	AtfValidator::validateInt(_descr, "referenceHint", referenceHint.length(), _checker, __FILE__, __LINE__);
	UINT32 historyFlags; _jparser.validateByNameThrow("historyFlags", historyFlags);
	AtfValidator::validateInt(_descr, "historyFlags", historyFlags, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::common_structs::TransactionHistoryCacheItem::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	SrvTime whenAccountWasImpacted; _parser0.parseSrvTime(whenAccountWasImpacted);
	AtfValidator::validateSrvDateTime(_descr, "whenAccountWasImpacted", whenAccountWasImpacted, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "typeDescr"); size_t szTypeDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "typeDescr", szTypeDescr, _checker, __FILE__, __LINE__);
	INT32 transAcctAmount; _parser0.parseINT32(transAcctAmount);
	AtfValidator::validateInt(_descr, "transAcctAmount", transAcctAmount, _checker, __FILE__, __LINE__);
	UINT32 obsoleteSystemFee; _parser0.parseUINT32(obsoleteSystemFee);
	AtfValidator::validateInt(_descr, "obsoleteSystemFee", obsoleteSystemFee, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "cardMaskedOrReference"); size_t szCardMaskedOrReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cardMaskedOrReference", szCardMaskedOrReference, _checker, __FILE__, __LINE__);
	UINT32 transId; _parser0.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "transBalanceCurrency"); size_t szTransBalanceCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "transBalanceCurrency", szTransBalanceCurrency, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "descriptor"); size_t szDescriptor = strlen(_dummy);
	AtfValidator::validateInt(_descr, "descriptor", szDescriptor, _checker, __FILE__, __LINE__);
	INT32 transConverted; _parser0.parseINT32(transConverted);
	AtfValidator::validateInt(_descr, "transConverted", transConverted, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "transCurrency"); size_t szTransCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "transCurrency", szTransCurrency, _checker, __FILE__, __LINE__);
	BYTE transCardTypeByte; _parser0.parseBYTE(transCardTypeByte);
	AtfValidator::validateInt(_descr, "transCardTypeByte", transCardTypeByte, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "referenceHint"); size_t szReferenceHint = strlen(_dummy);
	AtfValidator::validateInt(_descr, "referenceHint", szReferenceHint, _checker, __FILE__, __LINE__);
	UINT32 historyFlags; _parser0.parseUINT32(historyFlags);
	AtfValidator::validateInt(_descr, "historyFlags", historyFlags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHIPS_INFO2
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::Protocol_MSG_CASHIER_CHIPS_INFO2()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::clear()
{
	userId.clear();
	clientVersionInfo.clear();
	infoFlags = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::equals(const Protocol_MSG_CASHIER_CHIPS_INFO2& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(clientVersionInfo, _o.clientVersionInfo) &&
		infoFlags == _o.infoFlags;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CHIPS_INFO2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CHIPS_INFO2*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHIPS_INFO2).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("clientVersionInfo=");
	_buf.append(clientVersionInfo);
	_buf.append(',');
	_buf.append("infoFlags=");
	_buf.appendUint(infoFlags);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CHIPS_INFO2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientVersionInfo", clientVersionInfo, _buf);
	Atf::XmlElement::encodeAsXmlElement("infoFlags", infoFlags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("clientVersionInfo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clientVersionInfo)) return false;
			}
			else if (_element.equals("infoFlags"))
			{
				infoFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeString(clientVersionInfo);
	_msg.composeUINT32(infoFlags);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(clientVersionInfo);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(infoFlags);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("clientVersionInfo", clientVersionInfo);
	_jsonstr.compose("infoFlags", infoFlags);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientVersionInfo", clientVersionInfo);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("infoFlags", infoFlags);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHIPS_INFO2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString clientVersionInfo; _jparser.validateByNameThrow("clientVersionInfo", clientVersionInfo);
	AtfValidator::validateIntMax(_descr, "clientVersionInfo", clientVersionInfo.length(), 1000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 infoFlags; _jparser.validateByNameThrow("infoFlags", infoFlags);
	AtfValidator::validateIntMax(_descr, "infoFlags", infoFlags, ((((UINT32)eCashierChipsInfoFlag_Last)<<1)-1), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHIPS_INFO2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "clientVersionInfo"); size_t szClientVersionInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientVersionInfo", szClientVersionInfo, 1000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 infoFlags; _parser.parseUINT32(infoFlags);
	AtfValidator::validateIntMax(_descr, "infoFlags", infoFlags, ((((UINT32)eCashierChipsInfoFlag_Last)<<1)-1), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PhoneValidationInfo
//=================================================================

CashierServer::cli::PhoneValidationInfo::PhoneValidationInfo()
{
	clear();
}

void CashierServer::cli::PhoneValidationInfo::clear()
{
	result = 0;
	contryPhoneCode.clear();
	verifiedPhoneNumber.clear();
	dialingInfo.clear();
	phoneNumber.clear();
}

bool CashierServer::cli::PhoneValidationInfo::equals(const PhoneValidationInfo& _o) const
{
	return result == _o.result &&
		Atf::atfPStringEquals(contryPhoneCode, _o.contryPhoneCode) &&
		Atf::atfPStringEquals(verifiedPhoneNumber, _o.verifiedPhoneNumber) &&
		Atf::atfPStringEquals(dialingInfo, _o.dialingInfo) &&
		Atf::atfPStringEquals(phoneNumber, _o.phoneNumber);
}

const char *CashierServer::cli::PhoneValidationInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("result=");
	_buf.appendUint(result);
	_buf.append(',');
	_buf.append("contryPhoneCode=");
	_buf.append(contryPhoneCode);
	_buf.append(',');
	_buf.append("verifiedPhoneNumber=");
	_buf.append(verifiedPhoneNumber);
	_buf.append(',');
	_buf.append("dialingInfo=");
	_buf.append(dialingInfo);
	_buf.append(',');
	_buf.append("phoneNumber=");
	_buf.append(phoneNumber);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::PhoneValidationInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("result", result, _buf);
	Atf::XmlElement::encodeAsXmlElement("contryPhoneCode", contryPhoneCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("verifiedPhoneNumber", verifiedPhoneNumber, _buf);
	Atf::XmlElement::encodeAsXmlElement("dialingInfo", dialingInfo, _buf);
	Atf::XmlElement::encodeAsXmlElement("phoneNumber", phoneNumber, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::PhoneValidationInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("result"))
		{
			result = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("contryPhoneCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, contryPhoneCode)) return false;
		}
		else if (_element.equals("verifiedPhoneNumber"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, verifiedPhoneNumber)) return false;
		}
		else if (_element.equals("dialingInfo"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, dialingInfo)) return false;
		}
		else if (_element.equals("phoneNumber"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, phoneNumber)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::PhoneValidationInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(result);
	_msg.composeString(contryPhoneCode);
	_msg.composeString(verifiedPhoneNumber);
	_msg.composeString(dialingInfo);
	_msg.composeString(phoneNumber);
}

void CashierServer::cli::PhoneValidationInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(result);
	_parser.parseStringP(contryPhoneCode);
	_parser.parseStringP(verifiedPhoneNumber);
	_parser.parseStringP(dialingInfo);
	_parser.parseStringP(phoneNumber);
}

const char *CashierServer::cli::PhoneValidationInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("result", result);
	_jsonstr.compose("contryPhoneCode", contryPhoneCode);
	_jsonstr.compose("verifiedPhoneNumber", verifiedPhoneNumber);
	_jsonstr.compose("dialingInfo", dialingInfo);
	_jsonstr.compose("phoneNumber", phoneNumber);
	return _buf.c_str();
}

void CashierServer::cli::PhoneValidationInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("result", result);
	_jparser.parseByNameThrow("contryPhoneCode", contryPhoneCode);
	_jparser.parseByNameThrow("verifiedPhoneNumber", verifiedPhoneNumber);
	_jparser.parseByNameThrow("dialingInfo", dialingInfo);
	_jparser.parseByNameThrow("phoneNumber", phoneNumber);
}

/* static */ void CashierServer::cli::PhoneValidationInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE result; _jparser.validateByNameThrow("result", result);
	AtfValidator::validateInt(_descr, "result", result, _checker, __FILE__, __LINE__);
	PString contryPhoneCode; _jparser.validateByNameThrow("contryPhoneCode", contryPhoneCode);
	AtfValidator::validateInt(_descr, "contryPhoneCode", contryPhoneCode.length(), _checker, __FILE__, __LINE__);
	PString verifiedPhoneNumber; _jparser.validateByNameThrow("verifiedPhoneNumber", verifiedPhoneNumber);
	AtfValidator::validateInt(_descr, "verifiedPhoneNumber", verifiedPhoneNumber.length(), _checker, __FILE__, __LINE__);
	PString dialingInfo; _jparser.validateByNameThrow("dialingInfo", dialingInfo);
	AtfValidator::validateInt(_descr, "dialingInfo", dialingInfo.length(), _checker, __FILE__, __LINE__);
	PString phoneNumber; _jparser.validateByNameThrow("phoneNumber", phoneNumber);
	AtfValidator::validateInt(_descr, "phoneNumber", phoneNumber.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::PhoneValidationInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	BYTE result; _parser.parseBYTE(result);
	AtfValidator::validateInt(_descr, "result", result, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "contryPhoneCode"); size_t szContryPhoneCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "contryPhoneCode", szContryPhoneCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "verifiedPhoneNumber"); size_t szVerifiedPhoneNumber = strlen(_dummy);
	AtfValidator::validateInt(_descr, "verifiedPhoneNumber", szVerifiedPhoneNumber, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "dialingInfo"); size_t szDialingInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "dialingInfo", szDialingInfo, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "phoneNumber"); size_t szPhoneNumber = strlen(_dummy);
	AtfValidator::validateInt(_descr, "phoneNumber", szPhoneNumber, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    UserBalanceInfo
//=================================================================

CashierServer::cli::UserBalanceInfo::UserBalanceInfo()
{
	clear();
}

void CashierServer::cli::UserBalanceInfo::clear()
{
	balanceFlags = 0;
	currency.clear();
	availForSpending = 0;
	unclearedForSpending = 0;
	availForCashout = 0;
	unclearedForCashout = 0;
	owedChips = 0;
	tChips = 0;
	wChips = 0;
	chips = 0;
	markedForCashoutOnly = 0;
	userRollsWalletAmount = 0;
	fsbTotalBetsNumber = 0;
	userRollsAllocAmount = 0;
}

bool CashierServer::cli::UserBalanceInfo::equals(const UserBalanceInfo& _o) const
{
	return balanceFlags == _o.balanceFlags &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		availForSpending == _o.availForSpending &&
		unclearedForSpending == _o.unclearedForSpending &&
		availForCashout == _o.availForCashout &&
		unclearedForCashout == _o.unclearedForCashout &&
		owedChips == _o.owedChips &&
		tChips == _o.tChips &&
		wChips == _o.wChips &&
		chips == _o.chips &&
		markedForCashoutOnly == _o.markedForCashoutOnly &&
		userRollsWalletAmount == _o.userRollsWalletAmount &&
		fsbTotalBetsNumber == _o.fsbTotalBetsNumber &&
		userRollsAllocAmount == _o.userRollsAllocAmount;
}

const char *CashierServer::cli::UserBalanceInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("balanceFlags=");
	_buf.appendUint(balanceFlags);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("availForSpending=");
	_buf.appendInt(availForSpending);
	_buf.append(',');
	_buf.append("unclearedForSpending=");
	_buf.appendInt(unclearedForSpending);
	_buf.append(',');
	_buf.append("availForCashout=");
	_buf.appendInt(availForCashout);
	_buf.append(',');
	_buf.append("unclearedForCashout=");
	_buf.appendInt(unclearedForCashout);
	_buf.append(',');
	_buf.append("owedChips=");
	_buf.appendInt(owedChips);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("wChips=");
	_buf.appendInt(wChips);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt(chips);
	_buf.append(',');
	_buf.append("markedForCashoutOnly=");
	_buf.appendInt(markedForCashoutOnly);
	_buf.append(',');
	_buf.append("userRollsWalletAmount=");
	_buf.appendInt(userRollsWalletAmount);
	_buf.append(',');
	_buf.append("fsbTotalBetsNumber=");
	_buf.appendInt(fsbTotalBetsNumber);
	_buf.append(',');
	_buf.append("userRollsAllocAmount=");
	_buf.appendInt(userRollsAllocAmount);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::UserBalanceInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("balanceFlags", balanceFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("availForSpending", availForSpending, _buf);
	Atf::XmlElement::encodeAsXmlElement("unclearedForSpending", unclearedForSpending, _buf);
	Atf::XmlElement::encodeAsXmlElement("availForCashout", availForCashout, _buf);
	Atf::XmlElement::encodeAsXmlElement("unclearedForCashout", unclearedForCashout, _buf);
	Atf::XmlElement::encodeAsXmlElement("owedChips", owedChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("wChips", wChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("markedForCashoutOnly", markedForCashoutOnly, _buf);
	Atf::XmlElement::encodeAsXmlElement("userRollsWalletAmount", userRollsWalletAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("fsbTotalBetsNumber", fsbTotalBetsNumber, _buf);
	Atf::XmlElement::encodeAsXmlElement("userRollsAllocAmount", userRollsAllocAmount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::UserBalanceInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("balanceFlags"))
		{
			balanceFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("availForSpending"))
		{
			availForSpending = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("unclearedForSpending"))
		{
			unclearedForSpending = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("availForCashout"))
		{
			availForCashout = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("unclearedForCashout"))
		{
			unclearedForCashout = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("owedChips"))
		{
			owedChips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tChips"))
		{
			tChips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("wChips"))
		{
			wChips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chips"))
		{
			chips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("markedForCashoutOnly"))
		{
			markedForCashoutOnly = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userRollsWalletAmount"))
		{
			userRollsWalletAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fsbTotalBetsNumber"))
		{
			fsbTotalBetsNumber = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userRollsAllocAmount"))
		{
			userRollsAllocAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::UserBalanceInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(UserBalanceInfo())) // not empty
	{
		_body.composeUINT32(balanceFlags);
		_body.composeString(currency);
		_body.composeINT32(availForSpending);
		_body.composeINT32(unclearedForSpending);
		_body.composeINT32(availForCashout);
		_body.composeINT32(unclearedForCashout);
		_body.composeINT32(owedChips);
		_body.composeINT32(tChips);
		_body.composeINT32(wChips);
		_body.composeINT32(chips);
		_body.composeINT32(markedForCashoutOnly);
		_body.composeINT32(userRollsWalletAmount);
		_body.composeINT32(fsbTotalBetsNumber);
		_body.composeINT32(userRollsAllocAmount);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::UserBalanceInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(balanceFlags);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(availForSpending);
	_parser0.parseINT32(unclearedForSpending);
	_parser0.parseINT32(availForCashout);
	_parser0.parseINT32(unclearedForCashout);
	_parser0.parseINT32(owedChips);
	_parser0.parseINT32(tChips);
	_parser0.parseINT32(wChips);
	_parser0.parseINT32(chips);
	_parser0.parseINT32(markedForCashoutOnly);
	_parser0.parseINT32(userRollsWalletAmount);
	_parser0.parseINT32(fsbTotalBetsNumber);
	_parser0.parseINT32(userRollsAllocAmount);
}

const char *CashierServer::cli::UserBalanceInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("balanceFlags", balanceFlags);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("availForSpending", availForSpending);
	_jsonstr.compose("unclearedForSpending", unclearedForSpending);
	_jsonstr.compose("availForCashout", availForCashout);
	_jsonstr.compose("unclearedForCashout", unclearedForCashout);
	_jsonstr.compose("owedChips", owedChips);
	_jsonstr.compose("tChips", tChips);
	_jsonstr.compose("wChips", wChips);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("markedForCashoutOnly", markedForCashoutOnly);
	_jsonstr.compose("userRollsWalletAmount", userRollsWalletAmount);
	_jsonstr.compose("fsbTotalBetsNumber", fsbTotalBetsNumber);
	_jsonstr.compose("userRollsAllocAmount", userRollsAllocAmount);
	return _buf.c_str();
}

void CashierServer::cli::UserBalanceInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("balanceFlags", balanceFlags);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("availForSpending", availForSpending);
	_jparser.parseByNameThrow("unclearedForSpending", unclearedForSpending);
	_jparser.parseByNameThrow("availForCashout", availForCashout);
	_jparser.parseByNameThrow("unclearedForCashout", unclearedForCashout);
	_jparser.parseByNameThrow("owedChips", owedChips);
	_jparser.parseByNameThrow("tChips", tChips);
	_jparser.parseByNameThrow("wChips", wChips);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("markedForCashoutOnly", markedForCashoutOnly);
	_jparser.parseByNameThrow("userRollsWalletAmount", userRollsWalletAmount);
	_jparser.parseByNameThrow("fsbTotalBetsNumber", fsbTotalBetsNumber);
	_jparser.parseByNameThrow("userRollsAllocAmount", userRollsAllocAmount);
}

/* static */ void CashierServer::cli::UserBalanceInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 balanceFlags; _jparser.validateByNameThrow("balanceFlags", balanceFlags);
	AtfValidator::validateInt(_descr, "balanceFlags", balanceFlags, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 availForSpending; _jparser.validateByNameThrow("availForSpending", availForSpending);
	AtfValidator::validateInt(_descr, "availForSpending", availForSpending, _checker, __FILE__, __LINE__);
	INT32 unclearedForSpending; _jparser.validateByNameThrow("unclearedForSpending", unclearedForSpending);
	AtfValidator::validateInt(_descr, "unclearedForSpending", unclearedForSpending, _checker, __FILE__, __LINE__);
	INT32 availForCashout; _jparser.validateByNameThrow("availForCashout", availForCashout);
	AtfValidator::validateInt(_descr, "availForCashout", availForCashout, _checker, __FILE__, __LINE__);
	INT32 unclearedForCashout; _jparser.validateByNameThrow("unclearedForCashout", unclearedForCashout);
	AtfValidator::validateInt(_descr, "unclearedForCashout", unclearedForCashout, _checker, __FILE__, __LINE__);
	INT32 owedChips; _jparser.validateByNameThrow("owedChips", owedChips);
	AtfValidator::validateInt(_descr, "owedChips", owedChips, _checker, __FILE__, __LINE__);
	INT32 tChips; _jparser.validateByNameThrow("tChips", tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	INT32 wChips; _jparser.validateByNameThrow("wChips", wChips);
	AtfValidator::validateInt(_descr, "wChips", wChips, _checker, __FILE__, __LINE__);
	INT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT32 markedForCashoutOnly; _jparser.validateByNameThrow("markedForCashoutOnly", markedForCashoutOnly);
	AtfValidator::validateInt(_descr, "markedForCashoutOnly", markedForCashoutOnly, _checker, __FILE__, __LINE__);
	INT32 userRollsWalletAmount; _jparser.validateByNameThrow("userRollsWalletAmount", userRollsWalletAmount);
	AtfValidator::validateInt(_descr, "userRollsWalletAmount", userRollsWalletAmount, _checker, __FILE__, __LINE__);
	INT32 fsbTotalBetsNumber; _jparser.validateByNameThrow("fsbTotalBetsNumber", fsbTotalBetsNumber);
	AtfValidator::validateInt(_descr, "fsbTotalBetsNumber", fsbTotalBetsNumber, _checker, __FILE__, __LINE__);
	INT32 userRollsAllocAmount; _jparser.validateByNameThrow("userRollsAllocAmount", userRollsAllocAmount);
	AtfValidator::validateInt(_descr, "userRollsAllocAmount", userRollsAllocAmount, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::UserBalanceInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 balanceFlags; _parser0.parseUINT32(balanceFlags);
	AtfValidator::validateInt(_descr, "balanceFlags", balanceFlags, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 availForSpending; _parser0.parseINT32(availForSpending);
	AtfValidator::validateInt(_descr, "availForSpending", availForSpending, _checker, __FILE__, __LINE__);
	INT32 unclearedForSpending; _parser0.parseINT32(unclearedForSpending);
	AtfValidator::validateInt(_descr, "unclearedForSpending", unclearedForSpending, _checker, __FILE__, __LINE__);
	INT32 availForCashout; _parser0.parseINT32(availForCashout);
	AtfValidator::validateInt(_descr, "availForCashout", availForCashout, _checker, __FILE__, __LINE__);
	INT32 unclearedForCashout; _parser0.parseINT32(unclearedForCashout);
	AtfValidator::validateInt(_descr, "unclearedForCashout", unclearedForCashout, _checker, __FILE__, __LINE__);
	INT32 owedChips; _parser0.parseINT32(owedChips);
	AtfValidator::validateInt(_descr, "owedChips", owedChips, _checker, __FILE__, __LINE__);
	INT32 tChips; _parser0.parseINT32(tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	INT32 wChips; _parser0.parseINT32(wChips);
	AtfValidator::validateInt(_descr, "wChips", wChips, _checker, __FILE__, __LINE__);
	INT32 chips; _parser0.parseINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT32 markedForCashoutOnly; _parser0.parseINT32(markedForCashoutOnly);
	AtfValidator::validateInt(_descr, "markedForCashoutOnly", markedForCashoutOnly, _checker, __FILE__, __LINE__);
	INT32 userRollsWalletAmount; _parser0.parseINT32(userRollsWalletAmount);
	AtfValidator::validateInt(_descr, "userRollsWalletAmount", userRollsWalletAmount, _checker, __FILE__, __LINE__);
	INT32 fsbTotalBetsNumber; _parser0.parseINT32(fsbTotalBetsNumber);
	AtfValidator::validateInt(_descr, "fsbTotalBetsNumber", fsbTotalBetsNumber, _checker, __FILE__, __LINE__);
	INT32 userRollsAllocAmount; _parser0.parseINT32(userRollsAllocAmount);
	AtfValidator::validateInt(_descr, "userRollsAllocAmount", userRollsAllocAmount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserFundsInfo
//=================================================================

CashierServer::cli::UserFundsInfo::UserFundsInfo()
{
	clear();
}

void CashierServer::cli::UserFundsInfo::clear()
{
	currency.clear();
	amount = 0;
}

bool CashierServer::cli::UserFundsInfo::equals(const UserFundsInfo& _o) const
{
	return Atf::atfPStringEquals(currency, _o.currency) &&
		amount == _o.amount;
}

const char *CashierServer::cli::UserFundsInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::UserFundsInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::UserFundsInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("amount"))
		{
			amount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::UserFundsInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(UserFundsInfo())) // not empty
	{
		_body.composeString(currency);
		_body.composeINT32(amount);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::UserFundsInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(amount);
}

const char *CashierServer::cli::UserFundsInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("amount", amount);
	return _buf.c_str();
}

void CashierServer::cli::UserFundsInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("amount", amount);
}

/* static */ void CashierServer::cli::UserFundsInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::UserFundsInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 amount; _parser0.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserNonUsdCurrency
//=================================================================

CashierServer::cli::UserNonUsdCurrency::UserNonUsdCurrency()
{
	clear();
}

void CashierServer::cli::UserNonUsdCurrency::clear()
{
	name.clear();
}

bool CashierServer::cli::UserNonUsdCurrency::equals(const UserNonUsdCurrency& _o) const
{
	return Atf::atfPStringEquals(name, _o.name);
}

const char *CashierServer::cli::UserNonUsdCurrency::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::UserNonUsdCurrency::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::UserNonUsdCurrency::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::UserNonUsdCurrency::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(UserNonUsdCurrency())) // not empty
	{
		_body.composeString(name);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::UserNonUsdCurrency::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(name);
}

const char *CashierServer::cli::UserNonUsdCurrency::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	return _buf.c_str();
}

void CashierServer::cli::UserNonUsdCurrency::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
}

/* static */ void CashierServer::cli::UserNonUsdCurrency::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::UserNonUsdCurrency::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierExtraInfo
//=================================================================

CashierServer::cli::CashierExtraInfo::CashierExtraInfo()
{
	clear();
}

void CashierServer::cli::CashierExtraInfo::clear()
{
	type = 0;
	currency.clear();
	greekDailyGameProfit = 0;
	greekNotAvailForCashout = 0;
	hasCashoutHistory = false;
}

bool CashierServer::cli::CashierExtraInfo::equals(const CashierExtraInfo& _o) const
{
	return type == _o.type &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		greekDailyGameProfit == _o.greekDailyGameProfit &&
		greekNotAvailForCashout == _o.greekNotAvailForCashout &&
		hasCashoutHistory == _o.hasCashoutHistory;
}

const char *CashierServer::cli::CashierExtraInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendInt(type);
	if (type == eCashierExtraInfoType_Greek)
	{
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("greekDailyGameProfit=");
		_buf.appendInt64(greekDailyGameProfit);
		_buf.append(',');
		_buf.append("greekNotAvailForCashout=");
		_buf.appendInt64(greekNotAvailForCashout);
	}
	else if (type == eCashierExtraInfoType_UserHasCashoutHistory)
	{
		_buf.append(',');
		_buf.append("hasCashoutHistory=");
		_buf.appendUint(hasCashoutHistory);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierExtraInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	if (type == eCashierExtraInfoType_Greek)
	{
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("greekDailyGameProfit", greekDailyGameProfit, _buf);
		Atf::XmlElement::encodeAsXmlElement("greekNotAvailForCashout", greekNotAvailForCashout, _buf);
	}
	else if (type == eCashierExtraInfoType_UserHasCashoutHistory)
	{
		Atf::XmlElement::encodeAsXmlElement("hasCashoutHistory", hasCashoutHistory, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierExtraInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("type"))
		{
			type = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("greekDailyGameProfit"))
		{
			greekDailyGameProfit = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("greekNotAvailForCashout"))
		{
			greekNotAvailForCashout = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hasCashoutHistory"))
		{
			hasCashoutHistory = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierExtraInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(type);
	if (type == eCashierExtraInfoType_Greek)
	{
		CommMsgBody _msg0;
		_msg0.composeString(currency);
		_msg0.composeINT64(greekDailyGameProfit);
		_msg0.composeINT64(greekNotAvailForCashout);
		_msg.composeMsgBody(_msg0);
	}
	else if (type == eCashierExtraInfoType_UserHasCashoutHistory)
	{
		CommMsgBody _msg1;
		_msg1.composeBOOL(hasCashoutHistory);
		_msg.composeMsgBody(_msg1);
	}
}

void CashierServer::cli::CashierExtraInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(type);
	if (type == eCashierExtraInfoType_Greek)
	{
		parseAnonymousMsgBody0(_parser);
	}
	else if (type == eCashierExtraInfoType_UserHasCashoutHistory)
	{
		parseAnonymousMsgBody1(_parser);
	}
}

const char *CashierServer::cli::CashierExtraInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("type", type);
	if (type == eCashierExtraInfoType_Greek)
	{
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("greekDailyGameProfit", greekDailyGameProfit);
		_jsonstr.compose("greekNotAvailForCashout", greekNotAvailForCashout);
	}
	else if (type == eCashierExtraInfoType_UserHasCashoutHistory)
	{
		_jsonstr.compose("hasCashoutHistory", hasCashoutHistory);
	}
	return _buf.c_str();
}

void CashierServer::cli::CashierExtraInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("type", type);
	if (type == eCashierExtraInfoType_Greek)
	{
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("greekDailyGameProfit", greekDailyGameProfit);
		_jparser.parseByNameThrow("greekNotAvailForCashout", greekNotAvailForCashout);
	}
	else if (type == eCashierExtraInfoType_UserHasCashoutHistory)
	{
		_jparser.parseByNameThrow("hasCashoutHistory", hasCashoutHistory);
	}
}

/* static */ void CashierServer::cli::CashierExtraInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 type = 0;
	_jparser.validateByNameThrow("type", type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	if (type == eCashierExtraInfoType_Greek)
	{
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		INT64 greekDailyGameProfit; _jparser.validateByNameThrow("greekDailyGameProfit", greekDailyGameProfit);
		AtfValidator::validateInt(_descr, "greekDailyGameProfit", greekDailyGameProfit, _checker, __FILE__, __LINE__);
		INT64 greekNotAvailForCashout; _jparser.validateByNameThrow("greekNotAvailForCashout", greekNotAvailForCashout);
		AtfValidator::validateInt(_descr, "greekNotAvailForCashout", greekNotAvailForCashout, _checker, __FILE__, __LINE__);
	}
	else if (type == eCashierExtraInfoType_UserHasCashoutHistory)
	{
		bool hasCashoutHistory; _jparser.validateByNameThrow("hasCashoutHistory", hasCashoutHistory);
		AtfValidator::validateInt(_descr, "hasCashoutHistory", hasCashoutHistory, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::CashierExtraInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 type = 0;
	_parser.parseINT32(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	if (type == eCashierExtraInfoType_Greek)
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (type == eCashierExtraInfoType_UserHasCashoutHistory)
	{
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
}

void CashierServer::cli::CashierExtraInfo::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(greekDailyGameProfit);
	_parser0.parseINT64(greekNotAvailForCashout);
}

/*static*/ void CashierServer::cli::CashierExtraInfo::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 greekDailyGameProfit; _parser0.parseINT64(greekDailyGameProfit);
	AtfValidator::validateInt(_descr, "greekDailyGameProfit", greekDailyGameProfit, _checker, __FILE__, __LINE__);
	INT64 greekNotAvailForCashout; _parser0.parseINT64(greekNotAvailForCashout);
	AtfValidator::validateInt(_descr, "greekNotAvailForCashout", greekNotAvailForCashout, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::CashierExtraInfo::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(hasCashoutHistory);
}

/*static*/ void CashierServer::cli::CashierExtraInfo::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool hasCashoutHistory; _parser0.parseBOOL(hasCashoutHistory);
	AtfValidator::validateInt(_descr, "hasCashoutHistory", hasCashoutHistory, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	email.clear();
	addr1.clear();
	addr2.clear();
	city.clear();
	state.clear();
	country.clear();
	zipCode.clear();
	fullName.clear();
	birthDate.setNull();
	homePhoneValidation.clear();
	firstName.clear();
	onlyLastName.clear();
	fiscalCode.clear();
	userProperties.clear();
	sex.clear();
	mobilePhoneValidation.clear();
	registered.setNull();
	flags = 0;
	bitMask = 0;
	realMoneyOk = 0;
	vipStatus = 0;
	playChips = 0;
	allocPlayChips = 0;
	fpWithCents = 0;
	showBonusButton = 0;
	showBonusButton2 = 0;
	balances.clear();
	funds.clear();
	nonUsdCurrencies.clear();
	defaultCurrencyForCountry.clear();
	totalBalanceInPreferredCurrency = 0;
	totalTBalanceInPreferredCurrency = 0;
	fastDepositPaysystemByte = 0;
	beProtectedFromGaming = 0;
	beUnusedLossLimit = 0;
	playChips2 = 0;
	allocPlayChips2 = 0;
	fulltiltUserId.clear();
	ftCashoutMinLimit = 0;
	cashierExtraInfo.clear();
	userRolls.clear();
	totalForCashoutInPrefCur = 0;
	flags3 = 0;
	totalBalanceInUsd = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::equals(const Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(email, _o.email) &&
		Atf::atfPStringEquals(addr1, _o.addr1) &&
		Atf::atfPStringEquals(addr2, _o.addr2) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(country, _o.country) &&
		Atf::atfPStringEquals(zipCode, _o.zipCode) &&
		Atf::atfPStringEquals(fullName, _o.fullName) &&
		birthDate.equals(_o.birthDate) &&
		homePhoneValidation.equals(_o.homePhoneValidation) &&
		Atf::atfPStringEquals(firstName, _o.firstName) &&
		Atf::atfPStringEquals(onlyLastName, _o.onlyLastName) &&
		Atf::atfPStringEquals(fiscalCode, _o.fiscalCode) &&
		userProperties.equals(_o.userProperties) &&
		Atf::atfPStringEquals(sex, _o.sex) &&
		mobilePhoneValidation.equals(_o.mobilePhoneValidation) &&
		registered.equals(_o.registered) &&
		flags == _o.flags &&
		bitMask == _o.bitMask &&
		realMoneyOk == _o.realMoneyOk &&
		vipStatus == _o.vipStatus &&
		playChips == _o.playChips &&
		allocPlayChips == _o.allocPlayChips &&
		fpWithCents == _o.fpWithCents &&
		showBonusButton == _o.showBonusButton &&
		showBonusButton2 == _o.showBonusButton2 &&
		balances.equals(_o.balances) &&
		funds.equals(_o.funds) &&
		nonUsdCurrencies.equals(_o.nonUsdCurrencies) &&
		Atf::atfPStringEquals(defaultCurrencyForCountry, _o.defaultCurrencyForCountry) &&
		totalBalanceInPreferredCurrency == _o.totalBalanceInPreferredCurrency &&
		totalTBalanceInPreferredCurrency == _o.totalTBalanceInPreferredCurrency &&
		fastDepositPaysystemByte == _o.fastDepositPaysystemByte &&
		beProtectedFromGaming == _o.beProtectedFromGaming &&
		beUnusedLossLimit == _o.beUnusedLossLimit &&
		playChips2 == _o.playChips2 &&
		allocPlayChips2 == _o.allocPlayChips2 &&
		Atf::atfPStringEquals(fulltiltUserId, _o.fulltiltUserId) &&
		ftCashoutMinLimit == _o.ftCashoutMinLimit &&
		cashierExtraInfo.equals(_o.cashierExtraInfo) &&
		userRolls.equals(_o.userRolls) &&
		totalForCashoutInPrefCur == _o.totalForCashoutInPrefCur &&
		flags3 == _o.flags3 &&
		totalBalanceInUsd == _o.totalBalanceInUsd;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CHIPS_INFO2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHIPS_INFO2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
		_buf.append(',');
		_buf.append("addr1=");
		_buf.append(addr1);
		_buf.append(',');
		_buf.append("addr2=");
		_buf.append(addr2);
		_buf.append(',');
		_buf.append("city=");
		_buf.append(city);
		_buf.append(',');
		_buf.append("state=");
		_buf.append(state);
		_buf.append(',');
		_buf.append("country=");
		_buf.append(country);
		_buf.append(',');
		_buf.append("zipCode=");
		_buf.append(zipCode);
		_buf.append(',');
		_buf.append("fullName=");
		_buf.append(fullName);
		_buf.append(',');
		_buf.append("birthDate=");
		Atf::AtfTempl<SrvDate>::ToTraceString(_buf, birthDate);
		_buf.append(',');
		_buf.append("homePhoneValidation=");
		homePhoneValidation.toTraceString(_buf);
		_buf.append(',');
		_buf.append("firstName=");
		_buf.append(firstName);
		_buf.append(',');
		_buf.append("onlyLastName=");
		_buf.append(onlyLastName);
		_buf.append(',');
		_buf.append("fiscalCode=");
		_buf.append(fiscalCode);
		_buf.append(',');
		_buf.append("userProperties=");
		userProperties.toTraceString(_buf);
		_buf.append(',');
		_buf.append("sex=");
		_buf.append(sex);
		_buf.append(',');
		_buf.append("mobilePhoneValidation=");
		mobilePhoneValidation.toTraceString(_buf);
		_buf.append(',');
		_buf.append("registered=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, registered);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
		_buf.append(',');
		_buf.append("bitMask=");
		_buf.appendUint(bitMask);
		_buf.append(',');
		_buf.append("realMoneyOk=");
		_buf.appendUint(realMoneyOk);
		_buf.append(',');
		_buf.append("vipStatus=");
		_buf.appendInt(vipStatus);
		_buf.append(',');
		_buf.append("playChips=");
		_buf.appendInt(playChips);
		_buf.append(',');
		_buf.append("allocPlayChips=");
		_buf.appendInt(allocPlayChips);
		_buf.append(',');
		_buf.append("fpWithCents=");
		_buf.appendInt(fpWithCents);
		_buf.append(',');
		_buf.append("showBonusButton=");
		_buf.appendUint(showBonusButton);
		_buf.append(',');
		_buf.append("showBonusButton2=");
		_buf.appendUint(showBonusButton2);
		_buf.append(',');
		_buf.append("balances=");
		balances.toTraceString(_buf);
		_buf.append(',');
		_buf.append("funds=");
		funds.toTraceString(_buf);
		_buf.append(',');
		_buf.append("nonUsdCurrencies=");
		nonUsdCurrencies.toTraceString(_buf);
		_buf.append(',');
		_buf.append("defaultCurrencyForCountry=");
		_buf.append(defaultCurrencyForCountry);
		_buf.append(',');
		_buf.append("totalBalanceInPreferredCurrency=");
		_buf.appendInt(totalBalanceInPreferredCurrency);
		_buf.append(',');
		_buf.append("totalTBalanceInPreferredCurrency=");
		_buf.appendInt(totalTBalanceInPreferredCurrency);
		_buf.append(',');
		_buf.append("fastDepositPaysystemByte=");
		_buf.appendUint(fastDepositPaysystemByte);
		_buf.append(',');
		_buf.append("beProtectedFromGaming=");
		_buf.appendInt(beProtectedFromGaming);
		_buf.append(',');
		_buf.append("beUnusedLossLimit=");
		_buf.appendInt(beUnusedLossLimit);
		_buf.append(',');
		_buf.append("playChips2=");
		_buf.appendInt64(playChips2);
		_buf.append(',');
		_buf.append("allocPlayChips2=");
		_buf.appendInt64(allocPlayChips2);
		_buf.append(',');
		_buf.append("fulltiltUserId=");
		_buf.append(fulltiltUserId);
		_buf.append(',');
		_buf.append("ftCashoutMinLimit=");
		_buf.appendInt(ftCashoutMinLimit);
		_buf.append(',');
		_buf.append("cashierExtraInfo=");
		cashierExtraInfo.toTraceString(_buf);
		_buf.append(',');
		_buf.append("userRolls=");
		userRolls.toTraceString(_buf);
		_buf.append(',');
		_buf.append("totalForCashoutInPrefCur=");
		_buf.appendInt(totalForCashoutInPrefCur);
		_buf.append(',');
		_buf.append("flags3=");
		_buf.appendUint64(flags3);
		_buf.append(',');
		_buf.append(',');
		_buf.append("totalBalanceInUsd=");
		_buf.appendInt64(totalBalanceInUsd);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CHIPS_INFO2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
		Atf::XmlElement::encodeAsXmlElement("addr1", addr1, _buf);
		Atf::XmlElement::encodeAsXmlElement("addr2", addr2, _buf);
		Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
		Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
		Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
		Atf::XmlElement::encodeAsXmlElement("zipCode", zipCode, _buf);
		Atf::XmlElement::encodeAsXmlElement("fullName", fullName, _buf);
		Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "birthDate", birthDate);
		homePhoneValidation.toXmlString("homePhoneValidation", _buf);
		Atf::XmlElement::encodeAsXmlElement("firstName", firstName, _buf);
		Atf::XmlElement::encodeAsXmlElement("onlyLastName", onlyLastName, _buf);
		Atf::XmlElement::encodeAsXmlElement("fiscalCode", fiscalCode, _buf);
		userProperties.toXmlString("userProperties", _buf);
		Atf::XmlElement::encodeAsXmlElement("sex", sex, _buf);
		mobilePhoneValidation.toXmlString("mobilePhoneValidation", _buf);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "registered", registered);
		Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
		Atf::XmlElement::encodeAsXmlElement("bitMask", bitMask, _buf);
		Atf::XmlElement::encodeAsXmlElement("realMoneyOk", realMoneyOk, _buf);
		Atf::XmlElement::encodeAsXmlElement("vipStatus", vipStatus, _buf);
		Atf::XmlElement::encodeAsXmlElement("playChips", playChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("allocPlayChips", allocPlayChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("fpWithCents", fpWithCents, _buf);
		Atf::XmlElement::encodeAsXmlElement("showBonusButton", showBonusButton, _buf);
		Atf::XmlElement::encodeAsXmlElement("showBonusButton2", showBonusButton2, _buf);
		balances.toXmlString("balances", _buf);
		funds.toXmlString("funds", _buf);
		nonUsdCurrencies.toXmlString("nonUsdCurrencies", _buf);
		Atf::XmlElement::encodeAsXmlElement("defaultCurrencyForCountry", defaultCurrencyForCountry, _buf);
		Atf::XmlElement::encodeAsXmlElement("totalBalanceInPreferredCurrency", totalBalanceInPreferredCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("totalTBalanceInPreferredCurrency", totalTBalanceInPreferredCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("fastDepositPaysystemByte", fastDepositPaysystemByte, _buf);
		Atf::XmlElement::encodeAsXmlElement("beProtectedFromGaming", beProtectedFromGaming, _buf);
		Atf::XmlElement::encodeAsXmlElement("beUnusedLossLimit", beUnusedLossLimit, _buf);
		Atf::XmlElement::encodeAsXmlElement("playChips2", playChips2, _buf);
		Atf::XmlElement::encodeAsXmlElement("allocPlayChips2", allocPlayChips2, _buf);
		Atf::XmlElement::encodeAsXmlElement("fulltiltUserId", fulltiltUserId, _buf);
		Atf::XmlElement::encodeAsXmlElement("ftCashoutMinLimit", ftCashoutMinLimit, _buf);
		cashierExtraInfo.toXmlString("cashierExtraInfo", _buf);
		userRolls.toXmlString("userRolls", _buf);
		Atf::XmlElement::encodeAsXmlElement("totalForCashoutInPrefCur", totalForCashoutInPrefCur, _buf);
		Atf::XmlElement::encodeAsXmlElement("flags3", flags3, _buf);
		Atf::XmlElement::encodeAsXmlElement("totalBalanceInUsd", totalBalanceInUsd, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else if (_element.equals("addr1"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, addr1)) return false;
			}
			else if (_element.equals("addr2"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, addr2)) return false;
			}
			else if (_element.equals("city"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
			}
			else if (_element.equals("state"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("zipCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, zipCode)) return false;
			}
			else if (_element.equals("fullName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fullName)) return false;
			}
			else if (_element.equals("birthDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, birthDate);
			}
			else if (_element.equals("homePhoneValidation"))
			{
				if(!Atf::AtfTempl< PhoneValidationInfo >::FromXmlString(_value, homePhoneValidation)) return false;
			}
			else if (_element.equals("firstName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, firstName)) return false;
			}
			else if (_element.equals("onlyLastName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, onlyLastName)) return false;
			}
			else if (_element.equals("fiscalCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fiscalCode)) return false;
			}
			else if (_element.equals("userProperties"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< Common::AtfShared::UserPropertyBody, 4 > >::FromXmlString(_value, userProperties)) return false;
			}
			else if (_element.equals("sex"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, sex)) return false;
			}
			else if (_element.equals("mobilePhoneValidation"))
			{
				if(!Atf::AtfTempl< PhoneValidationInfo >::FromXmlString(_value, mobilePhoneValidation)) return false;
			}
			else if (_element.equals("registered"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, registered);
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bitMask"))
			{
				bitMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("realMoneyOk"))
			{
				realMoneyOk = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vipStatus"))
			{
				vipStatus = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playChips"))
			{
				playChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("allocPlayChips"))
			{
				allocPlayChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fpWithCents"))
			{
				fpWithCents = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("showBonusButton"))
			{
				showBonusButton = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("showBonusButton2"))
			{
				showBonusButton2 = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("balances"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserBalanceInfo, 4 > >::FromXmlString(_value, balances)) return false;
			}
			else if (_element.equals("funds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserFundsInfo, 4 > >::FromXmlString(_value, funds)) return false;
			}
			else if (_element.equals("nonUsdCurrencies"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserNonUsdCurrency, 4 > >::FromXmlString(_value, nonUsdCurrencies)) return false;
			}
			else if (_element.equals("defaultCurrencyForCountry"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, defaultCurrencyForCountry)) return false;
			}
			else if (_element.equals("totalBalanceInPreferredCurrency"))
			{
				totalBalanceInPreferredCurrency = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("totalTBalanceInPreferredCurrency"))
			{
				totalTBalanceInPreferredCurrency = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fastDepositPaysystemByte"))
			{
				fastDepositPaysystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("beProtectedFromGaming"))
			{
				beProtectedFromGaming = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("beUnusedLossLimit"))
			{
				beUnusedLossLimit = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playChips2"))
			{
				playChips2 = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("allocPlayChips2"))
			{
				allocPlayChips2 = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fulltiltUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fulltiltUserId)) return false;
			}
			else if (_element.equals("ftCashoutMinLimit"))
			{
				ftCashoutMinLimit = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cashierExtraInfo"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierExtraInfo, 4 > >::FromXmlString(_value, cashierExtraInfo)) return false;
			}
			else if (_element.equals("userRolls"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< common_structs::CashierRollBody, 4 > >::FromXmlString(_value, userRolls)) return false;
			}
			else if (_element.equals("totalForCashoutInPrefCur"))
			{
				totalForCashoutInPrefCur = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags3"))
			{
				flags3 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("totalBalanceInUsd"))
			{
				totalBalanceInUsd = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		CommMsgBody _msg0;
		_msg0.composeString(email);
		_msg0.composeString(addr1);
		_msg0.composeString(addr2);
		_msg0.composeString(city);
		_msg0.composeString(state);
		_msg0.composeString(country);
		_msg0.composeString(zipCode);
		_msg0.composeString(fullName);
		_msg0.composeSrvDate(birthDate);
		CommMsgBody _msg1;
		homePhoneValidation.composeMsg(_msg1, _ignoreJSON);
		_msg0.composeMsgBody(_msg1);
		_msg0.composeString(firstName);
		_msg0.composeString(onlyLastName);
		_msg0.composeString(fiscalCode);
		userProperties.composeMsg(_msg0, _ignoreJSON);
		_msg0.composeString(sex);
		CommMsgBody _msg2;
		mobilePhoneValidation.composeMsg(_msg2, _ignoreJSON);
		_msg0.composeMsgBody(_msg2);
		_msg0.composeSrvTime(registered);
		_msg.composeMsgBody(_msg0);
		_msg.composeUINT32(flags);
		_msg.composeUINT32(bitMask);
		_msg.composeBYTE(realMoneyOk);
		_msg.composeINT32(vipStatus);
		_msg.composeINT32(playChips);
		_msg.composeINT32(allocPlayChips);
		_msg.composeINT32(fpWithCents);
		_msg.composeBYTE(showBonusButton);
		_msg.composeBYTE(showBonusButton2);
		balances.composeMsg(_msg, _ignoreJSON);
		funds.composeMsg(_msg, _ignoreJSON);
		nonUsdCurrencies.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(defaultCurrencyForCountry);
		_msg.composeINT32(totalBalanceInPreferredCurrency);
		_msg.composeINT32(totalTBalanceInPreferredCurrency);
		_msg.composeBYTE(fastDepositPaysystemByte);
		_msg.composeINT32(beProtectedFromGaming);
		_msg.composeINT32(beUnusedLossLimit);
		_msg.composeINT64(playChips2);
		_msg.composeINT64(allocPlayChips2);
		_msg.composeString(fulltiltUserId);
		_msg.composeINT32(ftCashoutMinLimit);
		cashierExtraInfo.composeMsg(_msg, _ignoreJSON);
		userRolls.composeMsg(_msg, _ignoreJSON);
		_msg.composeINT32(totalForCashoutInPrefCur);
		_msg.composeUINT64(flags3);
		CommMsgBody _msg3;
		_msg.composeMsgBody(_msg3);
		_msg.composeINT64(totalBalanceInUsd);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		parseAnonymousMsgBody0(_parser);
		_parser.parseUINT32(flags);
		_parser.parseUINT32(bitMask);
		_parser.parseBYTE(realMoneyOk);
		_parser.parseINT32(vipStatus);
		_parser.parseINT32(playChips);
		_parser.parseINT32(allocPlayChips);
		_parser.parseINT32(fpWithCents);
		_parser.parseBYTE(showBonusButton);
		_parser.parseBYTE(showBonusButton2);
		balances.parseMsg(_parser);
		funds.parseMsg(_parser);
		nonUsdCurrencies.parseMsg(_parser);
		_parser.parseStringP(defaultCurrencyForCountry);
		_parser.parseINT32(totalBalanceInPreferredCurrency);
		_parser.parseINT32(totalTBalanceInPreferredCurrency);
		_parser.parseBYTE(fastDepositPaysystemByte);
		_parser.parseINT32(beProtectedFromGaming);
		_parser.parseINT32(beUnusedLossLimit);
		_parser.parseINT64(playChips2);
		_parser.parseINT64(allocPlayChips2);
		_parser.parseStringP(fulltiltUserId);
		_parser.parseINT32(ftCashoutMinLimit);
		cashierExtraInfo.parseMsg(_parser);
		userRolls.parseMsg(_parser);
		_parser.parseINT32(totalForCashoutInPrefCur);
		_parser.parseUINT64(flags3);
		parseAnonymousMsgBody3(_parser);
		_parser.parseINT64(totalBalanceInUsd);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("email", email);
		_jsonstr.compose("addr1", addr1);
		_jsonstr.compose("addr2", addr2);
		_jsonstr.compose("city", city);
		_jsonstr.compose("state", state);
		_jsonstr.compose("country", country);
		_jsonstr.compose("zipCode", zipCode);
		_jsonstr.compose("fullName", fullName);
		_jsonstr.compose("birthDate", birthDate);
		_jsonstr.compose("homePhoneValidation", homePhoneValidation);
		_jsonstr.compose("firstName", firstName);
		_jsonstr.compose("onlyLastName", onlyLastName);
		_jsonstr.compose("fiscalCode", fiscalCode);
		_jsonstr.compose("userProperties", userProperties);
		_jsonstr.compose("sex", sex);
		_jsonstr.compose("mobilePhoneValidation", mobilePhoneValidation);
		_jsonstr.compose("registered", registered);
		_jsonstr.compose("flags", flags);
		_jsonstr.compose("bitMask", bitMask);
		_jsonstr.compose("realMoneyOk", realMoneyOk);
		_jsonstr.compose("vipStatus", vipStatus);
		_jsonstr.compose("playChips", playChips);
		_jsonstr.compose("allocPlayChips", allocPlayChips);
		_jsonstr.compose("fpWithCents", fpWithCents);
		_jsonstr.compose("showBonusButton", showBonusButton);
		_jsonstr.compose("showBonusButton2", showBonusButton2);
		_jsonstr.compose("balances", balances);
		_jsonstr.compose("funds", funds);
		_jsonstr.compose("nonUsdCurrencies", nonUsdCurrencies);
		_jsonstr.compose("defaultCurrencyForCountry", defaultCurrencyForCountry);
		_jsonstr.compose("totalBalanceInPreferredCurrency", totalBalanceInPreferredCurrency);
		_jsonstr.compose("totalTBalanceInPreferredCurrency", totalTBalanceInPreferredCurrency);
		_jsonstr.compose("fastDepositPaysystemByte", fastDepositPaysystemByte);
		_jsonstr.compose("beProtectedFromGaming", beProtectedFromGaming);
		_jsonstr.compose("beUnusedLossLimit", beUnusedLossLimit);
		_jsonstr.compose("playChips2", playChips2);
		_jsonstr.compose("allocPlayChips2", allocPlayChips2);
		_jsonstr.compose("fulltiltUserId", fulltiltUserId);
		_jsonstr.compose("ftCashoutMinLimit", ftCashoutMinLimit);
		_jsonstr.compose("cashierExtraInfo", cashierExtraInfo);
		_jsonstr.compose("userRolls", userRolls);
		_jsonstr.compose("totalForCashoutInPrefCur", totalForCashoutInPrefCur);
		_jsonstr.compose("flags3", flags3);
		_jsonstr.compose("totalBalanceInUsd", totalBalanceInUsd);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("email", email);
		_jparser.parseByNameThrow("addr1", addr1);
		_jparser.parseByNameThrow("addr2", addr2);
		_jparser.parseByNameThrow("city", city);
		_jparser.parseByNameThrow("state", state);
		_jparser.parseByNameThrow("country", country);
		_jparser.parseByNameThrow("zipCode", zipCode);
		_jparser.parseByNameThrow("fullName", fullName);
		_jparser.parseByNameThrow("birthDate", birthDate);
		_jparser.parseByNameThrow("homePhoneValidation", homePhoneValidation);
		_jparser.parseByNameThrow("firstName", firstName);
		_jparser.parseByNameThrow("onlyLastName", onlyLastName);
		_jparser.parseByNameThrow("fiscalCode", fiscalCode);
		_jparser.parseByNameThrow("userProperties", userProperties);
		_jparser.parseByNameThrow("sex", sex);
		_jparser.parseByNameThrow("mobilePhoneValidation", mobilePhoneValidation);
		_jparser.parseByNameThrow("registered", registered);
		_jparser.parseByNameThrow("flags", flags);
		_jparser.parseByNameThrow("bitMask", bitMask);
		_jparser.parseByNameThrow("realMoneyOk", realMoneyOk);
		_jparser.parseByNameThrow("vipStatus", vipStatus);
		_jparser.parseByNameThrow("playChips", playChips);
		_jparser.parseByNameThrow("allocPlayChips", allocPlayChips);
		_jparser.parseByNameThrow("fpWithCents", fpWithCents);
		_jparser.parseByNameThrow("showBonusButton", showBonusButton);
		_jparser.parseByNameThrow("showBonusButton2", showBonusButton2);
		_jparser.parseByNameThrow("balances", balances);
		_jparser.parseByNameThrow("funds", funds);
		_jparser.parseByNameThrow("nonUsdCurrencies", nonUsdCurrencies);
		_jparser.parseByNameThrow("defaultCurrencyForCountry", defaultCurrencyForCountry);
		_jparser.parseByNameThrow("totalBalanceInPreferredCurrency", totalBalanceInPreferredCurrency);
		_jparser.parseByNameThrow("totalTBalanceInPreferredCurrency", totalTBalanceInPreferredCurrency);
		_jparser.parseByNameThrow("fastDepositPaysystemByte", fastDepositPaysystemByte);
		_jparser.parseByNameThrow("beProtectedFromGaming", beProtectedFromGaming);
		_jparser.parseByNameThrow("beUnusedLossLimit", beUnusedLossLimit);
		_jparser.parseByNameThrow("playChips2", playChips2);
		_jparser.parseByNameThrow("allocPlayChips2", allocPlayChips2);
		_jparser.parseByNameThrow("fulltiltUserId", fulltiltUserId);
		_jparser.parseByNameThrow("ftCashoutMinLimit", ftCashoutMinLimit);
		_jparser.parseByNameThrow("cashierExtraInfo", cashierExtraInfo);
		_jparser.parseByNameThrow("userRolls", userRolls);
		_jparser.parseByNameThrow("totalForCashoutInPrefCur", totalForCashoutInPrefCur);
		_jparser.parseByNameThrow("flags3", flags3);
		_jparser.parseByNameThrow("totalBalanceInUsd", totalBalanceInUsd);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHIPS_INFO2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString email; _jparser.validateByNameThrow("email", email);
		AtfValidator::validateInt(_descr, "email", email.length(), _checker, __FILE__, __LINE__);
		PString addr1; _jparser.validateByNameThrow("addr1", addr1);
		AtfValidator::validateInt(_descr, "addr1", addr1.length(), _checker, __FILE__, __LINE__);
		PString addr2; _jparser.validateByNameThrow("addr2", addr2);
		AtfValidator::validateInt(_descr, "addr2", addr2.length(), _checker, __FILE__, __LINE__);
		PString city; _jparser.validateByNameThrow("city", city);
		AtfValidator::validateInt(_descr, "city", city.length(), _checker, __FILE__, __LINE__);
		PString state; _jparser.validateByNameThrow("state", state);
		AtfValidator::validateInt(_descr, "state", state.length(), _checker, __FILE__, __LINE__);
		PString country; _jparser.validateByNameThrow("country", country);
		AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
		PString zipCode; _jparser.validateByNameThrow("zipCode", zipCode);
		AtfValidator::validateInt(_descr, "zipCode", zipCode.length(), _checker, __FILE__, __LINE__);
		PString fullName; _jparser.validateByNameThrow("fullName", fullName);
		AtfValidator::validateInt(_descr, "fullName", fullName.length(), _checker, __FILE__, __LINE__);
		SrvDate birthDate; _jparser.validateByNameThrow("birthDate", birthDate);
		AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
		PhoneValidationInfo homePhoneValidation; _jparser.validateByNameThrow("homePhoneValidation", homePhoneValidation);
		PString firstName; _jparser.validateByNameThrow("firstName", firstName);
		AtfValidator::validateInt(_descr, "firstName", firstName.length(), _checker, __FILE__, __LINE__);
		PString onlyLastName; _jparser.validateByNameThrow("onlyLastName", onlyLastName);
		AtfValidator::validateInt(_descr, "onlyLastName", onlyLastName.length(), _checker, __FILE__, __LINE__);
		PString fiscalCode; _jparser.validateByNameThrow("fiscalCode", fiscalCode);
		AtfValidator::validateInt(_descr, "fiscalCode", fiscalCode.length(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< Common::AtfShared::UserPropertyBody > userProperties; _jparser.validateByNameThrow("userProperties", userProperties);
		AtfValidator::validateInt(_descr, "userProperties", userProperties.size(), _checker, __FILE__, __LINE__);
		PString sex; _jparser.validateByNameThrow("sex", sex);
		AtfValidator::validateInt(_descr, "sex", sex.length(), _checker, __FILE__, __LINE__);
		PhoneValidationInfo mobilePhoneValidation; _jparser.validateByNameThrow("mobilePhoneValidation", mobilePhoneValidation);
		SrvTime registered; _jparser.validateByNameThrow("registered", registered);
		AtfValidator::validateSrvDateTime(_descr, "registered", registered, _checker, __FILE__, __LINE__);
		UINT32 flags; _jparser.validateByNameThrow("flags", flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		UINT32 bitMask; _jparser.validateByNameThrow("bitMask", bitMask);
		AtfValidator::validateInt(_descr, "bitMask", bitMask, _checker, __FILE__, __LINE__);
		BYTE realMoneyOk; _jparser.validateByNameThrow("realMoneyOk", realMoneyOk);
		AtfValidator::validateInt(_descr, "realMoneyOk", realMoneyOk, _checker, __FILE__, __LINE__);
		INT32 vipStatus; _jparser.validateByNameThrow("vipStatus", vipStatus);
		AtfValidator::validateInt(_descr, "vipStatus", vipStatus, _checker, __FILE__, __LINE__);
		INT32 playChips; _jparser.validateByNameThrow("playChips", playChips);
		AtfValidator::validateInt(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
		INT32 allocPlayChips; _jparser.validateByNameThrow("allocPlayChips", allocPlayChips);
		AtfValidator::validateInt(_descr, "allocPlayChips", allocPlayChips, _checker, __FILE__, __LINE__);
		INT32 fpWithCents; _jparser.validateByNameThrow("fpWithCents", fpWithCents);
		AtfValidator::validateInt(_descr, "fpWithCents", fpWithCents, _checker, __FILE__, __LINE__);
		BYTE showBonusButton; _jparser.validateByNameThrow("showBonusButton", showBonusButton);
		AtfValidator::validateIntRange(_descr, "showBonusButton", showBonusButton, 0, 1, _checker, __FILE__, __LINE__);
		BYTE showBonusButton2; _jparser.validateByNameThrow("showBonusButton2", showBonusButton2);
		AtfValidator::validateIntRange(_descr, "showBonusButton2", showBonusButton2, 0, 1, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UserBalanceInfo > balances; _jparser.validateByNameThrow("balances", balances);
		AtfValidator::validateInt(_descr, "balances", balances.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UserFundsInfo > funds; _jparser.validateByNameThrow("funds", funds);
		AtfValidator::validateInt(_descr, "funds", funds.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UserNonUsdCurrency > nonUsdCurrencies; _jparser.validateByNameThrow("nonUsdCurrencies", nonUsdCurrencies);
		AtfValidator::validateInt(_descr, "nonUsdCurrencies", nonUsdCurrencies.size(), _checker, __FILE__, __LINE__);
		PString defaultCurrencyForCountry; _jparser.validateByNameThrow("defaultCurrencyForCountry", defaultCurrencyForCountry);
		AtfValidator::validateInt(_descr, "defaultCurrencyForCountry", defaultCurrencyForCountry.length(), _checker, __FILE__, __LINE__);
		INT32 totalBalanceInPreferredCurrency; _jparser.validateByNameThrow("totalBalanceInPreferredCurrency", totalBalanceInPreferredCurrency);
		AtfValidator::validateInt(_descr, "totalBalanceInPreferredCurrency", totalBalanceInPreferredCurrency, _checker, __FILE__, __LINE__);
		INT32 totalTBalanceInPreferredCurrency; _jparser.validateByNameThrow("totalTBalanceInPreferredCurrency", totalTBalanceInPreferredCurrency);
		AtfValidator::validateInt(_descr, "totalTBalanceInPreferredCurrency", totalTBalanceInPreferredCurrency, _checker, __FILE__, __LINE__);
		BYTE fastDepositPaysystemByte; _jparser.validateByNameThrow("fastDepositPaysystemByte", fastDepositPaysystemByte);
		AtfValidator::validateInt(_descr, "fastDepositPaysystemByte", fastDepositPaysystemByte, _checker, __FILE__, __LINE__);
		INT32 beProtectedFromGaming; _jparser.validateByNameThrow("beProtectedFromGaming", beProtectedFromGaming);
		AtfValidator::validateInt(_descr, "beProtectedFromGaming", beProtectedFromGaming, _checker, __FILE__, __LINE__);
		INT32 beUnusedLossLimit; _jparser.validateByNameThrow("beUnusedLossLimit", beUnusedLossLimit);
		AtfValidator::validateInt(_descr, "beUnusedLossLimit", beUnusedLossLimit, _checker, __FILE__, __LINE__);
		INT64 playChips2; _jparser.validateByNameThrow("playChips2", playChips2);
		AtfValidator::validateInt(_descr, "playChips2", playChips2, _checker, __FILE__, __LINE__);
		INT64 allocPlayChips2; _jparser.validateByNameThrow("allocPlayChips2", allocPlayChips2);
		AtfValidator::validateInt(_descr, "allocPlayChips2", allocPlayChips2, _checker, __FILE__, __LINE__);
		PString fulltiltUserId; _jparser.validateByNameThrow("fulltiltUserId", fulltiltUserId);
		AtfValidator::validateInt(_descr, "fulltiltUserId", fulltiltUserId.length(), _checker, __FILE__, __LINE__);
		INT32 ftCashoutMinLimit; _jparser.validateByNameThrow("ftCashoutMinLimit", ftCashoutMinLimit);
		AtfValidator::validateInt(_descr, "ftCashoutMinLimit", ftCashoutMinLimit, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< CashierExtraInfo > cashierExtraInfo; _jparser.validateByNameThrow("cashierExtraInfo", cashierExtraInfo);
		AtfValidator::validateInt(_descr, "cashierExtraInfo", cashierExtraInfo.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< common_structs::CashierRollBody > userRolls; _jparser.validateByNameThrow("userRolls", userRolls);
		AtfValidator::validateInt(_descr, "userRolls", userRolls.size(), _checker, __FILE__, __LINE__);
		INT32 totalForCashoutInPrefCur; _jparser.validateByNameThrow("totalForCashoutInPrefCur", totalForCashoutInPrefCur);
		AtfValidator::validateInt(_descr, "totalForCashoutInPrefCur", totalForCashoutInPrefCur, _checker, __FILE__, __LINE__);
		UINT64 flags3; _jparser.validateByNameThrow("flags3", flags3);
		AtfValidator::validateUint(_descr, "flags3", flags3, _checker, __FILE__, __LINE__);
		INT64 totalBalanceInUsd; _jparser.validateByNameThrow("totalBalanceInUsd", totalBalanceInUsd);
		AtfValidator::validateInt(_descr, "totalBalanceInUsd", totalBalanceInUsd, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHIPS_INFO2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		UINT32 flags; _parser.parseUINT32(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		UINT32 bitMask; _parser.parseUINT32(bitMask);
		AtfValidator::validateInt(_descr, "bitMask", bitMask, _checker, __FILE__, __LINE__);
		BYTE realMoneyOk; _parser.parseBYTE(realMoneyOk);
		AtfValidator::validateInt(_descr, "realMoneyOk", realMoneyOk, _checker, __FILE__, __LINE__);
		INT32 vipStatus; _parser.parseINT32(vipStatus);
		AtfValidator::validateInt(_descr, "vipStatus", vipStatus, _checker, __FILE__, __LINE__);
		INT32 playChips; _parser.parseINT32(playChips);
		AtfValidator::validateInt(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
		INT32 allocPlayChips; _parser.parseINT32(allocPlayChips);
		AtfValidator::validateInt(_descr, "allocPlayChips", allocPlayChips, _checker, __FILE__, __LINE__);
		INT32 fpWithCents; _parser.parseINT32(fpWithCents);
		AtfValidator::validateInt(_descr, "fpWithCents", fpWithCents, _checker, __FILE__, __LINE__);
		BYTE showBonusButton; _parser.parseBYTE(showBonusButton);
		AtfValidator::validateIntRange(_descr, "showBonusButton", showBonusButton, 0, 1, _checker, __FILE__, __LINE__);
		BYTE showBonusButton2; _parser.parseBYTE(showBonusButton2);
		AtfValidator::validateIntRange(_descr, "showBonusButton2", showBonusButton2, 0, 1, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szBalances = Atf::LAtfVector< UserBalanceInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("balances"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "balances", szBalances, _checker, __FILE__, __LINE__);
		int szFunds = Atf::LAtfVector< UserFundsInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("funds"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "funds", szFunds, _checker, __FILE__, __LINE__);
		int szNonUsdCurrencies = Atf::LAtfVector< UserNonUsdCurrency, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("nonUsdCurrencies"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "nonUsdCurrencies", szNonUsdCurrencies, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "defaultCurrencyForCountry"); size_t szDefaultCurrencyForCountry = strlen(_dummy);
		AtfValidator::validateInt(_descr, "defaultCurrencyForCountry", szDefaultCurrencyForCountry, _checker, __FILE__, __LINE__);
		INT32 totalBalanceInPreferredCurrency; _parser.parseINT32(totalBalanceInPreferredCurrency);
		AtfValidator::validateInt(_descr, "totalBalanceInPreferredCurrency", totalBalanceInPreferredCurrency, _checker, __FILE__, __LINE__);
		INT32 totalTBalanceInPreferredCurrency; _parser.parseINT32(totalTBalanceInPreferredCurrency);
		AtfValidator::validateInt(_descr, "totalTBalanceInPreferredCurrency", totalTBalanceInPreferredCurrency, _checker, __FILE__, __LINE__);
		BYTE fastDepositPaysystemByte; _parser.parseBYTE(fastDepositPaysystemByte);
		AtfValidator::validateInt(_descr, "fastDepositPaysystemByte", fastDepositPaysystemByte, _checker, __FILE__, __LINE__);
		INT32 beProtectedFromGaming; _parser.parseINT32(beProtectedFromGaming);
		AtfValidator::validateInt(_descr, "beProtectedFromGaming", beProtectedFromGaming, _checker, __FILE__, __LINE__);
		INT32 beUnusedLossLimit; _parser.parseINT32(beUnusedLossLimit);
		AtfValidator::validateInt(_descr, "beUnusedLossLimit", beUnusedLossLimit, _checker, __FILE__, __LINE__);
		INT64 playChips2; _parser.parseINT64(playChips2);
		AtfValidator::validateInt(_descr, "playChips2", playChips2, _checker, __FILE__, __LINE__);
		INT64 allocPlayChips2; _parser.parseINT64(allocPlayChips2);
		AtfValidator::validateInt(_descr, "allocPlayChips2", allocPlayChips2, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fulltiltUserId"); size_t szFulltiltUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fulltiltUserId", szFulltiltUserId, _checker, __FILE__, __LINE__);
		INT32 ftCashoutMinLimit; _parser.parseINT32(ftCashoutMinLimit);
		AtfValidator::validateInt(_descr, "ftCashoutMinLimit", ftCashoutMinLimit, _checker, __FILE__, __LINE__);
		int szCashierExtraInfo = Atf::LAtfVector< CashierExtraInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cashierExtraInfo"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "cashierExtraInfo", szCashierExtraInfo, _checker, __FILE__, __LINE__);
		int szUserRolls = Atf::LAtfVector< common_structs::CashierRollBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userRolls"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "userRolls", szUserRolls, _checker, __FILE__, __LINE__);
		INT32 totalForCashoutInPrefCur; _parser.parseINT32(totalForCashoutInPrefCur);
		AtfValidator::validateInt(_descr, "totalForCashoutInPrefCur", totalForCashoutInPrefCur, _checker, __FILE__, __LINE__);
		UINT64 flags3; _parser.parseUINT64(flags3);
		AtfValidator::validateUint(_descr, "flags3", flags3, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody3(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		INT64 totalBalanceInUsd; _parser.parseINT64(totalBalanceInUsd);
		AtfValidator::validateInt(_descr, "totalBalanceInUsd", totalBalanceInUsd, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(email);
	_parser0.parseStringP(addr1);
	_parser0.parseStringP(addr2);
	_parser0.parseStringP(city);
	_parser0.parseStringP(state);
	_parser0.parseStringP(country);
	_parser0.parseStringP(zipCode);
	_parser0.parseStringP(fullName);
	_parser0.parseSrvDate(birthDate);
	parseAnonymousMsgBody1(_parser0);
	_parser0.parseStringP(firstName);
	_parser0.parseStringP(onlyLastName);
	_parser0.parseStringP(fiscalCode);
	userProperties.parseMsg(_parser0);
	_parser0.parseStringP(sex);
	parseAnonymousMsgBody2(_parser0);
	_parser0.parseSrvTime(registered);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "addr1"); size_t szAddr1 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "addr1", szAddr1, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "addr2"); size_t szAddr2 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "addr2", szAddr2, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateInt(_descr, "state", szState, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "zipCode"); size_t szZipCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "zipCode", szZipCode, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "fullName"); size_t szFullName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "fullName", szFullName, _checker, __FILE__, __LINE__);
	SrvDate birthDate; _parser0.parseSrvDate(birthDate);
	AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody1(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	_parser0.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "firstName", szFirstName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "onlyLastName"); size_t szOnlyLastName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "onlyLastName", szOnlyLastName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "fiscalCode"); size_t szFiscalCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "fiscalCode", szFiscalCode, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szUserProperties = Atf::LAtfVector< Common::AtfShared::UserPropertyBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("userProperties"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userProperties", szUserProperties, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "sex"); size_t szSex = strlen(_dummy);
	AtfValidator::validateInt(_descr, "sex", szSex, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody2(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime registered; _parser0.parseSrvTime(registered);
	AtfValidator::validateSrvDateTime(_descr, "registered", registered, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	homePhoneValidation.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	PhoneValidationInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("homePhoneValidation"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	mobilePhoneValidation.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	PhoneValidationInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("mobilePhoneValidation"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::parseAnonymousMsgBody3(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::validateAnonymousMsgBody3(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                    PaymentSpecificDataOne
//=================================================================

CashierServer::cli::PaymentSpecificDataOne::PaymentSpecificDataOne()
{
	clear();
}

void CashierServer::cli::PaymentSpecificDataOne::clear()
{
	dataId = 0;
	worldpay3DS2_referenceId.clear();
	worldpay3DS2_windowSize.clear();
	starswallet_mTan.clear();
	cbsUrl.clear();
	cbsUrl_wc2mt.clear();
	applePay_encrPaymentToken.clear();
	childTransId = 0;
	clientAcceptHeader.clear();
	clientJavaEnabled.clear();
	clientScreenColorDepth.clear();
	clientScreenHeight.clear();
	clientScreenWidth.clear();
	clientUserAgent.clear();
	clientTzOffsetInMin.clear();
	clientBrowserLocale.clear();
	clientChallengeWinSize.clear();
}

bool CashierServer::cli::PaymentSpecificDataOne::equals(const PaymentSpecificDataOne& _o) const
{
	return dataId == _o.dataId &&
		Atf::atfPStringEquals(worldpay3DS2_referenceId, _o.worldpay3DS2_referenceId) &&
		Atf::atfPStringEquals(worldpay3DS2_windowSize, _o.worldpay3DS2_windowSize) &&
		Atf::atfPStringEquals(starswallet_mTan, _o.starswallet_mTan) &&
		Atf::atfPStringEquals(cbsUrl, _o.cbsUrl) &&
		Atf::atfPStringEquals(cbsUrl_wc2mt, _o.cbsUrl_wc2mt) &&
		Atf::atfPStringEquals(applePay_encrPaymentToken, _o.applePay_encrPaymentToken) &&
		childTransId == _o.childTransId &&
		Atf::atfPStringEquals(clientAcceptHeader, _o.clientAcceptHeader) &&
		Atf::atfPStringEquals(clientJavaEnabled, _o.clientJavaEnabled) &&
		Atf::atfPStringEquals(clientScreenColorDepth, _o.clientScreenColorDepth) &&
		Atf::atfPStringEquals(clientScreenHeight, _o.clientScreenHeight) &&
		Atf::atfPStringEquals(clientScreenWidth, _o.clientScreenWidth) &&
		Atf::atfPStringEquals(clientUserAgent, _o.clientUserAgent) &&
		Atf::atfPStringEquals(clientTzOffsetInMin, _o.clientTzOffsetInMin) &&
		Atf::atfPStringEquals(clientBrowserLocale, _o.clientBrowserLocale) &&
		Atf::atfPStringEquals(clientChallengeWinSize, _o.clientChallengeWinSize);
}

const char *CashierServer::cli::PaymentSpecificDataOne::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("dataId=");
	_buf.appendUint(dataId);
	if (dataId == ePaymentSpecificData_Worldpay3DS2_ReferenceId)
	{
		_buf.append(',');
		_buf.append("worldpay3DS2_referenceId=");
		_buf.append(worldpay3DS2_referenceId);
		_buf.append(',');
		_buf.append("worldpay3DS2_windowSize=");
		_buf.append(worldpay3DS2_windowSize);
	}
	else if (dataId == ePaymentSpecificData_StarswalletMtan)
	{
		_buf.append(',');
		_buf.append("starswallet_mTan=");
		_buf.append(starswallet_mTan);
	}
	else if (dataId == ePaymentSpecificData_CbsUrl)
	{
		_buf.append(',');
		_buf.append("cbsUrl=");
		_buf.append(cbsUrl);
		_buf.append(',');
		_buf.append("cbsUrl_wc2mt=");
		_buf.append(cbsUrl_wc2mt);
	}
	else if (dataId == ePaymentSpecificData_ApplePay)
	{
		_buf.append(',');
		_buf.append("applePay_encrPaymentToken=");
		_buf.append(applePay_encrPaymentToken);
	}
	else if (dataId == ePaymentSpecificData_3dFormDone)
	{
		_buf.append(',');
		_buf.append("childTransId=");
		_buf.appendUint(childTransId);
	}
	else if (dataId == ePaymentSpecificData_ClientCapability)
	{
		_buf.append(',');
		_buf.append("clientAcceptHeader=");
		_buf.append(clientAcceptHeader);
		_buf.append(',');
		_buf.append("clientJavaEnabled=");
		_buf.append(clientJavaEnabled);
		_buf.append(',');
		_buf.append("clientScreenColorDepth=");
		_buf.append(clientScreenColorDepth);
		_buf.append(',');
		_buf.append("clientScreenHeight=");
		_buf.append(clientScreenHeight);
		_buf.append(',');
		_buf.append("clientScreenWidth=");
		_buf.append(clientScreenWidth);
		_buf.append(',');
		_buf.append("clientUserAgent=");
		_buf.append(clientUserAgent);
		_buf.append(',');
		_buf.append("clientTzOffsetInMin=");
		_buf.append(clientTzOffsetInMin);
		_buf.append(',');
		_buf.append("clientBrowserLocale=");
		_buf.append(clientBrowserLocale);
		_buf.append(',');
		_buf.append("clientChallengeWinSize=");
		_buf.append(clientChallengeWinSize);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::PaymentSpecificDataOne::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("dataId", dataId, _buf);
	if (dataId == ePaymentSpecificData_Worldpay3DS2_ReferenceId)
	{
		Atf::XmlElement::encodeAsXmlElement("worldpay3DS2_referenceId", worldpay3DS2_referenceId, _buf);
		Atf::XmlElement::encodeAsXmlElement("worldpay3DS2_windowSize", worldpay3DS2_windowSize, _buf);
	}
	else if (dataId == ePaymentSpecificData_StarswalletMtan)
	{
		Atf::XmlElement::encodeAsXmlElement("starswallet_mTan", starswallet_mTan, _buf);
	}
	else if (dataId == ePaymentSpecificData_CbsUrl)
	{
		Atf::XmlElement::encodeAsXmlElement("cbsUrl", cbsUrl, _buf);
		Atf::XmlElement::encodeAsXmlElement("cbsUrl_wc2mt", cbsUrl_wc2mt, _buf);
	}
	else if (dataId == ePaymentSpecificData_ApplePay)
	{
		Atf::XmlElement::encodeAsXmlElement("applePay_encrPaymentToken", applePay_encrPaymentToken, _buf);
	}
	else if (dataId == ePaymentSpecificData_3dFormDone)
	{
		Atf::XmlElement::encodeAsXmlElement("childTransId", childTransId, _buf);
	}
	else if (dataId == ePaymentSpecificData_ClientCapability)
	{
		Atf::XmlElement::encodeAsXmlElement("clientAcceptHeader", clientAcceptHeader, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientJavaEnabled", clientJavaEnabled, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientScreenColorDepth", clientScreenColorDepth, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientScreenHeight", clientScreenHeight, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientScreenWidth", clientScreenWidth, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientUserAgent", clientUserAgent, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientTzOffsetInMin", clientTzOffsetInMin, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientBrowserLocale", clientBrowserLocale, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientChallengeWinSize", clientChallengeWinSize, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::PaymentSpecificDataOne::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("dataId"))
		{
			dataId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("worldpay3DS2_referenceId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, worldpay3DS2_referenceId)) return false;
		}
		else if (_element.equals("worldpay3DS2_windowSize"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, worldpay3DS2_windowSize)) return false;
		}
		else if (_element.equals("starswallet_mTan"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, starswallet_mTan)) return false;
		}
		else if (_element.equals("cbsUrl"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cbsUrl)) return false;
		}
		else if (_element.equals("cbsUrl_wc2mt"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cbsUrl_wc2mt)) return false;
		}
		else if (_element.equals("applePay_encrPaymentToken"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, applePay_encrPaymentToken)) return false;
		}
		else if (_element.equals("childTransId"))
		{
			childTransId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clientAcceptHeader"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clientAcceptHeader)) return false;
		}
		else if (_element.equals("clientJavaEnabled"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clientJavaEnabled)) return false;
		}
		else if (_element.equals("clientScreenColorDepth"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clientScreenColorDepth)) return false;
		}
		else if (_element.equals("clientScreenHeight"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clientScreenHeight)) return false;
		}
		else if (_element.equals("clientScreenWidth"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clientScreenWidth)) return false;
		}
		else if (_element.equals("clientUserAgent"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clientUserAgent)) return false;
		}
		else if (_element.equals("clientTzOffsetInMin"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clientTzOffsetInMin)) return false;
		}
		else if (_element.equals("clientBrowserLocale"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clientBrowserLocale)) return false;
		}
		else if (_element.equals("clientChallengeWinSize"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clientChallengeWinSize)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::PaymentSpecificDataOne::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(dataId);
	if (dataId == ePaymentSpecificData_Worldpay3DS2_ReferenceId)
	{
		CommMsgBody _msg0;
		_msg0.composeString(worldpay3DS2_referenceId);
		_msg0.composeString(worldpay3DS2_windowSize);
		_msg.composeMsgBody(_msg0);
	}
	else if (dataId == ePaymentSpecificData_StarswalletMtan)
	{
		CommMsgBody _msg1;
		_msg1.composeString(starswallet_mTan);
		_msg.composeMsgBody(_msg1);
	}
	else if (dataId == ePaymentSpecificData_CbsUrl)
	{
		CommMsgBody _msg2;
		_msg2.composeString(cbsUrl);
		_msg2.composeString(cbsUrl_wc2mt);
		_msg.composeMsgBody(_msg2);
	}
	else if (dataId == ePaymentSpecificData_ApplePay)
	{
		CommMsgBody _msg3;
		_msg3.composeString(applePay_encrPaymentToken);
		_msg.composeMsgBody(_msg3);
	}
	else if (dataId == ePaymentSpecificData_3dFormDone)
	{
		CommMsgBody _msg4;
		_msg4.composeUINT32(childTransId);
		_msg.composeMsgBody(_msg4);
	}
	else if (dataId == ePaymentSpecificData_ClientCapability)
	{
		CommMsgBody _msg5;
		_msg5.composeString(clientAcceptHeader);
		_msg5.composeString(clientJavaEnabled);
		_msg5.composeString(clientScreenColorDepth);
		_msg5.composeString(clientScreenHeight);
		_msg5.composeString(clientScreenWidth);
		_msg5.composeString(clientUserAgent);
		_msg5.composeString(clientTzOffsetInMin);
		_msg5.composeString(clientBrowserLocale);
		_msg5.composeString(clientChallengeWinSize);
		_msg.composeMsgBody(_msg5);
	}
}

void CashierServer::cli::PaymentSpecificDataOne::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(dataId);
	if (dataId == ePaymentSpecificData_Worldpay3DS2_ReferenceId)
	{
		parseAnonymousMsgBody0(_parser);
	}
	else if (dataId == ePaymentSpecificData_StarswalletMtan)
	{
		parseAnonymousMsgBody1(_parser);
	}
	else if (dataId == ePaymentSpecificData_CbsUrl)
	{
		parseAnonymousMsgBody2(_parser);
	}
	else if (dataId == ePaymentSpecificData_ApplePay)
	{
		parseAnonymousMsgBody3(_parser);
	}
	else if (dataId == ePaymentSpecificData_3dFormDone)
	{
		parseAnonymousMsgBody4(_parser);
	}
	else if (dataId == ePaymentSpecificData_ClientCapability)
	{
		parseAnonymousMsgBody5(_parser);
	}
}

const char *CashierServer::cli::PaymentSpecificDataOne::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("dataId", dataId);
	if (dataId == ePaymentSpecificData_Worldpay3DS2_ReferenceId)
	{
		_jsonstr.compose("worldpay3DS2_referenceId", worldpay3DS2_referenceId);
		_jsonstr.compose("worldpay3DS2_windowSize", worldpay3DS2_windowSize);
	}
	else if (dataId == ePaymentSpecificData_StarswalletMtan)
	{
		_jsonstr.compose("starswallet_mTan", starswallet_mTan);
	}
	else if (dataId == ePaymentSpecificData_CbsUrl)
	{
		_jsonstr.compose("cbsUrl", cbsUrl);
		_jsonstr.compose("cbsUrl_wc2mt", cbsUrl_wc2mt);
	}
	else if (dataId == ePaymentSpecificData_ApplePay)
	{
		_jsonstr.compose("applePay_encrPaymentToken", applePay_encrPaymentToken);
	}
	else if (dataId == ePaymentSpecificData_3dFormDone)
	{
		_jsonstr.compose("childTransId", childTransId);
	}
	else if (dataId == ePaymentSpecificData_ClientCapability)
	{
		_jsonstr.compose("clientAcceptHeader", clientAcceptHeader);
		_jsonstr.compose("clientJavaEnabled", clientJavaEnabled);
		_jsonstr.compose("clientScreenColorDepth", clientScreenColorDepth);
		_jsonstr.compose("clientScreenHeight", clientScreenHeight);
		_jsonstr.compose("clientScreenWidth", clientScreenWidth);
		_jsonstr.compose("clientUserAgent", clientUserAgent);
		_jsonstr.compose("clientTzOffsetInMin", clientTzOffsetInMin);
		_jsonstr.compose("clientBrowserLocale", clientBrowserLocale);
		_jsonstr.compose("clientChallengeWinSize", clientChallengeWinSize);
	}
	return _buf.c_str();
}

void CashierServer::cli::PaymentSpecificDataOne::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("dataId", dataId);
	if (dataId == ePaymentSpecificData_Worldpay3DS2_ReferenceId)
	{
		_jparser.parseByNameThrow("worldpay3DS2_referenceId", worldpay3DS2_referenceId);
		_jparser.parseByNameThrow("worldpay3DS2_windowSize", worldpay3DS2_windowSize);
	}
	else if (dataId == ePaymentSpecificData_StarswalletMtan)
	{
		_jparser.parseByNameThrow("starswallet_mTan", starswallet_mTan);
	}
	else if (dataId == ePaymentSpecificData_CbsUrl)
	{
		_jparser.parseByNameThrow("cbsUrl", cbsUrl);
		_jparser.parseByName("cbsUrl_wc2mt", cbsUrl_wc2mt);
	}
	else if (dataId == ePaymentSpecificData_ApplePay)
	{
		_jparser.parseByNameThrow("applePay_encrPaymentToken", applePay_encrPaymentToken);
	}
	else if (dataId == ePaymentSpecificData_3dFormDone)
	{
		_jparser.parseByNameThrow("childTransId", childTransId);
	}
	else if (dataId == ePaymentSpecificData_ClientCapability)
	{
		_jparser.parseByNameThrow("clientAcceptHeader", clientAcceptHeader);
		_jparser.parseByNameThrow("clientJavaEnabled", clientJavaEnabled);
		_jparser.parseByNameThrow("clientScreenColorDepth", clientScreenColorDepth);
		_jparser.parseByNameThrow("clientScreenHeight", clientScreenHeight);
		_jparser.parseByNameThrow("clientScreenWidth", clientScreenWidth);
		_jparser.parseByName("clientUserAgent", clientUserAgent);
		_jparser.parseByName("clientTzOffsetInMin", clientTzOffsetInMin);
		_jparser.parseByName("clientBrowserLocale", clientBrowserLocale);
		_jparser.parseByName("clientChallengeWinSize", clientChallengeWinSize);
	}
}

/* static */ void CashierServer::cli::PaymentSpecificDataOne::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 dataId = 0;
	_jparser.validateByNameThrow("dataId", dataId);
	{ const UINT32 dataId_enum[] = {
				ePaymentSpecificData_Worldpay3DS2_ReferenceId, 
				ePaymentSpecificData_StarswalletMtan,          
				ePaymentSpecificData_ApplePay,                 
				ePaymentSpecificData_CbsUrl,                   
				ePaymentSpecificData_3dFormDone,               
				ePaymentSpecificData_ClientCapability          
			}; AtfValidator::validateEnum(_descr, "dataId", dataId, dataId_enum, _checker, __FILE__, __LINE__); }
	if (dataId == ePaymentSpecificData_Worldpay3DS2_ReferenceId)
	{
		PString worldpay3DS2_referenceId; _jparser.validateByNameThrow("worldpay3DS2_referenceId", worldpay3DS2_referenceId);
		AtfValidator::validateIntMax(_descr, "worldpay3DS2_referenceId", worldpay3DS2_referenceId.length(), 10000, _checker, __FILE__, __LINE__);
		PString worldpay3DS2_windowSize; _jparser.validateByNameThrow("worldpay3DS2_windowSize", worldpay3DS2_windowSize);
		AtfValidator::validateIntMax(_descr, "worldpay3DS2_windowSize", worldpay3DS2_windowSize.length(), 10000, _checker, __FILE__, __LINE__);
	}
	else if (dataId == ePaymentSpecificData_StarswalletMtan)
	{
		PString starswallet_mTan; _jparser.validateByNameThrow("starswallet_mTan", starswallet_mTan);
		AtfValidator::validateIntMax(_descr, "starswallet_mTan", starswallet_mTan.length(), 10000, _checker, __FILE__, __LINE__);
	}
	else if (dataId == ePaymentSpecificData_CbsUrl)
	{
		PString cbsUrl; _jparser.validateByNameThrow("cbsUrl", cbsUrl);
		AtfValidator::validateIntMax(_descr, "cbsUrl", cbsUrl.length(), 10000, _checker, __FILE__, __LINE__);
		PString cbsUrl_wc2mt; _jparser.validateByName("cbsUrl_wc2mt", cbsUrl_wc2mt);
		AtfValidator::validateIntMax(_descr, "cbsUrl_wc2mt", cbsUrl_wc2mt.length(), 10000, _checker, __FILE__, __LINE__);
	}
	else if (dataId == ePaymentSpecificData_ApplePay)
	{
		PString applePay_encrPaymentToken; _jparser.validateByNameThrow("applePay_encrPaymentToken", applePay_encrPaymentToken);
		AtfValidator::validateIntMax(_descr, "applePay_encrPaymentToken", applePay_encrPaymentToken.length(), 10000, _checker, __FILE__, __LINE__);
	}
	else if (dataId == ePaymentSpecificData_3dFormDone)
	{
		UINT32 childTransId; _jparser.validateByNameThrow("childTransId", childTransId);
		AtfValidator::validateInt(_descr, "childTransId", childTransId, _checker, __FILE__, __LINE__);
	}
	else if (dataId == ePaymentSpecificData_ClientCapability)
	{
		PString clientAcceptHeader; _jparser.validateByNameThrow("clientAcceptHeader", clientAcceptHeader);
		AtfValidator::validateIntMax(_descr, "clientAcceptHeader", clientAcceptHeader.length(), 10000, _checker, __FILE__, __LINE__);
		PString clientJavaEnabled; _jparser.validateByNameThrow("clientJavaEnabled", clientJavaEnabled);
		AtfValidator::validateIntMax(_descr, "clientJavaEnabled", clientJavaEnabled.length(), 10000, _checker, __FILE__, __LINE__);
		PString clientScreenColorDepth; _jparser.validateByNameThrow("clientScreenColorDepth", clientScreenColorDepth);
		AtfValidator::validateIntMax(_descr, "clientScreenColorDepth", clientScreenColorDepth.length(), 10000, _checker, __FILE__, __LINE__);
		PString clientScreenHeight; _jparser.validateByNameThrow("clientScreenHeight", clientScreenHeight);
		AtfValidator::validateIntMax(_descr, "clientScreenHeight", clientScreenHeight.length(), 10000, _checker, __FILE__, __LINE__);
		PString clientScreenWidth; _jparser.validateByNameThrow("clientScreenWidth", clientScreenWidth);
		AtfValidator::validateIntMax(_descr, "clientScreenWidth", clientScreenWidth.length(), 10000, _checker, __FILE__, __LINE__);
		PString clientUserAgent; _jparser.validateByName("clientUserAgent", clientUserAgent);
		AtfValidator::validateIntMax(_descr, "clientUserAgent", clientUserAgent.length(), 10000, _checker, __FILE__, __LINE__);
		PString clientTzOffsetInMin; _jparser.validateByName("clientTzOffsetInMin", clientTzOffsetInMin);
		AtfValidator::validateIntMax(_descr, "clientTzOffsetInMin", clientTzOffsetInMin.length(), 10000, _checker, __FILE__, __LINE__);
		PString clientBrowserLocale; _jparser.validateByName("clientBrowserLocale", clientBrowserLocale);
		AtfValidator::validateIntMax(_descr, "clientBrowserLocale", clientBrowserLocale.length(), 10000, _checker, __FILE__, __LINE__);
		PString clientChallengeWinSize; _jparser.validateByName("clientChallengeWinSize", clientChallengeWinSize);
		AtfValidator::validateIntMax(_descr, "clientChallengeWinSize", clientChallengeWinSize.length(), 10000, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::PaymentSpecificDataOne::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 dataId = 0;
	_parser.parseUINT32(dataId);
	{ const UINT32 dataId_enum[] = {
				ePaymentSpecificData_Worldpay3DS2_ReferenceId, 
				ePaymentSpecificData_StarswalletMtan,          
				ePaymentSpecificData_ApplePay,                 
				ePaymentSpecificData_CbsUrl,                   
				ePaymentSpecificData_3dFormDone,               
				ePaymentSpecificData_ClientCapability          
			}; AtfValidator::validateEnum(_descr, "dataId", dataId, dataId_enum, _checker, __FILE__, __LINE__); }
	if (dataId == ePaymentSpecificData_Worldpay3DS2_ReferenceId)
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (dataId == ePaymentSpecificData_StarswalletMtan)
	{
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (dataId == ePaymentSpecificData_CbsUrl)
	{
		validateAnonymousMsgBody2(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (dataId == ePaymentSpecificData_ApplePay)
	{
		validateAnonymousMsgBody3(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (dataId == ePaymentSpecificData_3dFormDone)
	{
		validateAnonymousMsgBody4(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (dataId == ePaymentSpecificData_ClientCapability)
	{
		validateAnonymousMsgBody5(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
}

void CashierServer::cli::PaymentSpecificDataOne::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(worldpay3DS2_referenceId);
	_parser0.parseStringP(worldpay3DS2_windowSize);
}

/*static*/ void CashierServer::cli::PaymentSpecificDataOne::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "worldpay3DS2_referenceId"); size_t szWorldpay3DS2_referenceId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "worldpay3DS2_referenceId", szWorldpay3DS2_referenceId, 10000, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "worldpay3DS2_windowSize"); size_t szWorldpay3DS2_windowSize = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "worldpay3DS2_windowSize", szWorldpay3DS2_windowSize, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::PaymentSpecificDataOne::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(starswallet_mTan);
}

/*static*/ void CashierServer::cli::PaymentSpecificDataOne::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "starswallet_mTan"); size_t szStarswallet_mTan = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "starswallet_mTan", szStarswallet_mTan, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::PaymentSpecificDataOne::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(cbsUrl);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(cbsUrl_wc2mt);
}

/*static*/ void CashierServer::cli::PaymentSpecificDataOne::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "cbsUrl"); size_t szCbsUrl = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cbsUrl", szCbsUrl, 10000, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "cbsUrl_wc2mt"); size_t szCbsUrl_wc2mt = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cbsUrl_wc2mt", szCbsUrl_wc2mt, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::PaymentSpecificDataOne::parseAnonymousMsgBody3(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(applePay_encrPaymentToken);
}

/*static*/ void CashierServer::cli::PaymentSpecificDataOne::validateAnonymousMsgBody3(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "applePay_encrPaymentToken"); size_t szApplePay_encrPaymentToken = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "applePay_encrPaymentToken", szApplePay_encrPaymentToken, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::PaymentSpecificDataOne::parseAnonymousMsgBody4(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(childTransId);
}

/*static*/ void CashierServer::cli::PaymentSpecificDataOne::validateAnonymousMsgBody4(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 childTransId; _parser0.parseUINT32(childTransId);
	AtfValidator::validateInt(_descr, "childTransId", childTransId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::PaymentSpecificDataOne::parseAnonymousMsgBody5(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(clientAcceptHeader);
	_parser0.parseStringP(clientJavaEnabled);
	_parser0.parseStringP(clientScreenColorDepth);
	_parser0.parseStringP(clientScreenHeight);
	_parser0.parseStringP(clientScreenWidth);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(clientUserAgent);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(clientTzOffsetInMin);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(clientBrowserLocale);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(clientChallengeWinSize);
}

/*static*/ void CashierServer::cli::PaymentSpecificDataOne::validateAnonymousMsgBody5(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "clientAcceptHeader"); size_t szClientAcceptHeader = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientAcceptHeader", szClientAcceptHeader, 10000, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "clientJavaEnabled"); size_t szClientJavaEnabled = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientJavaEnabled", szClientJavaEnabled, 10000, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "clientScreenColorDepth"); size_t szClientScreenColorDepth = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientScreenColorDepth", szClientScreenColorDepth, 10000, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "clientScreenHeight"); size_t szClientScreenHeight = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientScreenHeight", szClientScreenHeight, 10000, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "clientScreenWidth"); size_t szClientScreenWidth = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientScreenWidth", szClientScreenWidth, 10000, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "clientUserAgent"); size_t szClientUserAgent = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientUserAgent", szClientUserAgent, 10000, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "clientTzOffsetInMin"); size_t szClientTzOffsetInMin = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientTzOffsetInMin", szClientTzOffsetInMin, 10000, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "clientBrowserLocale"); size_t szClientBrowserLocale = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientBrowserLocale", szClientBrowserLocale, 10000, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "clientChallengeWinSize"); size_t szClientChallengeWinSize = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientChallengeWinSize", szClientChallengeWinSize, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PaymentSpecificDataVec
//=================================================================

CashierServer::cli::PaymentSpecificDataVec::PaymentSpecificDataVec()
{
	clear();
}

void CashierServer::cli::PaymentSpecificDataVec::clear()
{
	vec.clear();
}

bool CashierServer::cli::PaymentSpecificDataVec::equals(const PaymentSpecificDataVec& _o) const
{
	return vec.equals(_o.vec);
}

const char *CashierServer::cli::PaymentSpecificDataVec::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("vec=");
	vec.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::PaymentSpecificDataVec::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	vec.toXmlString("vec", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::PaymentSpecificDataVec::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("vec"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PaymentSpecificDataOne, 4 > >::FromXmlString(_value, vec)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::PaymentSpecificDataVec::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PaymentSpecificDataVec())) // not empty
	{
		vec.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::PaymentSpecificDataVec::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	vec.parseMsg(_parser0);
}

const char *CashierServer::cli::PaymentSpecificDataVec::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("vec", vec);
	return _buf.c_str();
}

void CashierServer::cli::PaymentSpecificDataVec::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("vec", vec);
}

/* static */ void CashierServer::cli::PaymentSpecificDataVec::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< PaymentSpecificDataOne > vec; _jparser.validateByNameThrow("vec", vec);
	AtfValidator::validateIntMax(_descr, "vec", vec.size(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::PaymentSpecificDataVec::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szVec = Atf::LAtfVector< PaymentSpecificDataOne, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("vec"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "vec", szVec, 1000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_CC
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::Protocol_MSG_CASHIER_CASHIN_CC()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::clear()
{
	userId.clear();
	amount = 0;
	paySystemByte = 0;
	cardNum.clear();
	cardCvv.clear();
	expYear = 0;
	expMonth = 0;
	bonusId = 0;
	doNotCancelCashouts = 0;
	currency.clear();
	issueNum.clear();
	startDate.clear();
	converted = 0;
	secNum.clear();
	bDate.setNull();
	dLicense.clear();
	userPhoneAch.clear();
	saveCardInfoRequested = false;
	bonusCode.clear();
	balanceCurrency.clear();
	clientBalance = 0;
	fastDepositTransaction = false;
	saveInfoForFastDeposit = false;
	ignoreRepeatedDeclines = false;
	cardInfoId = 0;
	awardId = 0;
	clientDepositFlags = 0;
	isLoadAmountProvided = false;
	loadAmount = 0;
	geoIpInfo.clear();
	depositPassword.clear();
	encryptedCardNumAndCvv.clear();
	paymentSpecificDataVec.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::equals(const Protocol_MSG_CASHIER_CASHIN_CC& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		amount == _o.amount &&
		paySystemByte == _o.paySystemByte &&
		Atf::atfPStringEquals(cardNum, _o.cardNum) &&
		Atf::atfPStringEquals(cardCvv, _o.cardCvv) &&
		expYear == _o.expYear &&
		expMonth == _o.expMonth &&
		bonusId == _o.bonusId &&
		doNotCancelCashouts == _o.doNotCancelCashouts &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		Atf::atfPStringEquals(issueNum, _o.issueNum) &&
		Atf::atfPStringEquals(startDate, _o.startDate) &&
		converted == _o.converted &&
		Atf::atfPStringEquals(secNum, _o.secNum) &&
		bDate.equals(_o.bDate) &&
		Atf::atfPStringEquals(dLicense, _o.dLicense) &&
		Atf::atfPStringEquals(userPhoneAch, _o.userPhoneAch) &&
		saveCardInfoRequested == _o.saveCardInfoRequested &&
		Atf::atfPStringEquals(bonusCode, _o.bonusCode) &&
		Atf::atfPStringEquals(balanceCurrency, _o.balanceCurrency) &&
		clientBalance == _o.clientBalance &&
		fastDepositTransaction == _o.fastDepositTransaction &&
		saveInfoForFastDeposit == _o.saveInfoForFastDeposit &&
		ignoreRepeatedDeclines == _o.ignoreRepeatedDeclines &&
		cardInfoId == _o.cardInfoId &&
		awardId == _o.awardId &&
		clientDepositFlags == _o.clientDepositFlags &&
		isLoadAmountProvided == _o.isLoadAmountProvided &&
		loadAmount == _o.loadAmount &&
		Atf::atfPStringEquals(geoIpInfo, _o.geoIpInfo) &&
		Atf::atfPStringEquals(depositPassword, _o.depositPassword) &&
		encryptedCardNumAndCvv.size() == _o.encryptedCardNumAndCvv.size() && memcmp(encryptedCardNumAndCvv.ptr(), _o.encryptedCardNumAndCvv.ptr(), encryptedCardNumAndCvv.size()) == 0 &&
		paymentSpecificDataVec.equals(_o.paymentSpecificDataVec);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CASHIN_CC != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CASHIN_CC*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_CC).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("cardNum=");
	_buf.append(cardNum);
	_buf.append(',');
	_buf.append("cardCvv=");
	_buf.append(cardCvv);
	_buf.append(',');
	_buf.append("expYear=");
	_buf.appendUint(expYear);
	_buf.append(',');
	_buf.append("expMonth=");
	_buf.appendUint(expMonth);
	_buf.append(',');
	_buf.append("bonusId=");
	_buf.appendUint(bonusId);
	_buf.append(',');
	_buf.append("doNotCancelCashouts=");
	_buf.appendUint(doNotCancelCashouts);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("issueNum=");
	_buf.append(issueNum);
	_buf.append(',');
	_buf.append("startDate=");
	_buf.append(startDate);
	_buf.append(',');
	_buf.append("converted=");
	_buf.appendInt(converted);
	_buf.append(',');
	_buf.append("secNum=");
	_buf.append(secNum);
	_buf.append(',');
	_buf.append("bDate=");
	Atf::AtfTempl<CommSrvDate>::ToTraceString(_buf, bDate);
	_buf.append(',');
	_buf.append("dLicense=");
	_buf.append(dLicense);
	_buf.append(',');
	_buf.append("userPhoneAch=");
	_buf.append(userPhoneAch);
	_buf.append(',');
	_buf.append("saveCardInfoRequested=");
	_buf.appendUint(saveCardInfoRequested);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	_buf.append(',');
	_buf.append("clientBalance=");
	_buf.appendInt(clientBalance);
	_buf.append(',');
	_buf.append("fastDepositTransaction=");
	_buf.appendUint(fastDepositTransaction);
	_buf.append(',');
	_buf.append("saveInfoForFastDeposit=");
	_buf.appendUint(saveInfoForFastDeposit);
	_buf.append(',');
	_buf.append("ignoreRepeatedDeclines=");
	_buf.appendUint(ignoreRepeatedDeclines);
	_buf.append(',');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	_buf.append(',');
	_buf.append("awardId=");
	_buf.appendUint(awardId);
	_buf.append(',');
	_buf.append("clientDepositFlags=");
	_buf.appendUint(clientDepositFlags);
	if (paySystemByte == cardTypePayLucky || paySystemByte == cardTypeSightline || paySystemByte == cardTypeSightlineNR)
	{
		_buf.append(',');
		_buf.append("isLoadAmountProvided=");
		_buf.appendUint(isLoadAmountProvided);
		_buf.append(',');
		_buf.append("loadAmount=");
		_buf.appendInt(loadAmount);
		_buf.append(',');
		_buf.append("geoIpInfo=");
		_buf.append(geoIpInfo);
	}
	else if (paySystemByte == cardTypeGamersCard)
	{
		_buf.append(',');
		_buf.append("depositPassword=");
		_buf.append(depositPassword);
	}
	else
	{
		_buf.append(',');
	}
	_buf.append(',');
	_buf.append("encryptedCardNumAndCvv=");
	Atf::AtfTempl<PBlock>::ToTraceString(_buf, encryptedCardNumAndCvv);
	_buf.append(',');
	_buf.append("paymentSpecificDataVec=");
	paymentSpecificDataVec.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CASHIN_CC).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardNum", cardNum, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardCvv", cardCvv, _buf);
	Atf::XmlElement::encodeAsXmlElement("expYear", expYear, _buf);
	Atf::XmlElement::encodeAsXmlElement("expMonth", expMonth, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusId", bonusId, _buf);
	Atf::XmlElement::encodeAsXmlElement("doNotCancelCashouts", doNotCancelCashouts, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("issueNum", issueNum, _buf);
	Atf::XmlElement::encodeAsXmlElement("startDate", startDate, _buf);
	Atf::XmlElement::encodeAsXmlElement("converted", converted, _buf);
	Atf::XmlElement::encodeAsXmlElement("secNum", secNum, _buf);
	Atf::AtfTempl<CommSrvDate>::ToXmlString(_buf, "bDate", bDate);
	Atf::XmlElement::encodeAsXmlElement("dLicense", dLicense, _buf);
	Atf::XmlElement::encodeAsXmlElement("userPhoneAch", userPhoneAch, _buf);
	Atf::XmlElement::encodeAsXmlElement("saveCardInfoRequested", saveCardInfoRequested, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusCode", bonusCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("balanceCurrency", balanceCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientBalance", clientBalance, _buf);
	Atf::XmlElement::encodeAsXmlElement("fastDepositTransaction", fastDepositTransaction, _buf);
	Atf::XmlElement::encodeAsXmlElement("saveInfoForFastDeposit", saveInfoForFastDeposit, _buf);
	Atf::XmlElement::encodeAsXmlElement("ignoreRepeatedDeclines", ignoreRepeatedDeclines, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardInfoId", cardInfoId, _buf);
	Atf::XmlElement::encodeAsXmlElement("awardId", awardId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientDepositFlags", clientDepositFlags, _buf);
	if (paySystemByte == cardTypePayLucky || paySystemByte == cardTypeSightline || paySystemByte == cardTypeSightlineNR)
	{
		Atf::XmlElement::encodeAsXmlElement("isLoadAmountProvided", isLoadAmountProvided, _buf);
		Atf::XmlElement::encodeAsXmlElement("loadAmount", loadAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("geoIpInfo", geoIpInfo, _buf);
	}
	else if (paySystemByte == cardTypeGamersCard)
	{
		Atf::XmlElement::encodeAsXmlElement("depositPassword", depositPassword, _buf);
	}
	else
	{
	}
	Atf::XmlElement::encodeAsXmlElement("encryptedCardNumAndCvv", encryptedCardNumAndCvv, _buf);
	paymentSpecificDataVec.toXmlString("paymentSpecificDataVec", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("amount"))
			{
				amount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cardNum"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, cardNum)) return false;
			}
			else if (_element.equals("cardCvv"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, cardCvv)) return false;
			}
			else if (_element.equals("expYear"))
			{
				expYear = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("expMonth"))
			{
				expMonth = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bonusId"))
			{
				bonusId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("doNotCancelCashouts"))
			{
				doNotCancelCashouts = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("issueNum"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, issueNum)) return false;
			}
			else if (_element.equals("startDate"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, startDate)) return false;
			}
			else if (_element.equals("converted"))
			{
				converted = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("secNum"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, secNum)) return false;
			}
			else if (_element.equals("bDate"))
			{
				Atf::AtfTempl<CommSrvDate>::FromXmlString(_value, bDate);
			}
			else if (_element.equals("dLicense"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, dLicense)) return false;
			}
			else if (_element.equals("userPhoneAch"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userPhoneAch)) return false;
			}
			else if (_element.equals("saveCardInfoRequested"))
			{
				saveCardInfoRequested = (*_value.ptr() == '1');
			}
			else if (_element.equals("bonusCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bonusCode)) return false;
			}
			else if (_element.equals("balanceCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, balanceCurrency)) return false;
			}
			else if (_element.equals("clientBalance"))
			{
				clientBalance = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fastDepositTransaction"))
			{
				fastDepositTransaction = (*_value.ptr() == '1');
			}
			else if (_element.equals("saveInfoForFastDeposit"))
			{
				saveInfoForFastDeposit = (*_value.ptr() == '1');
			}
			else if (_element.equals("ignoreRepeatedDeclines"))
			{
				ignoreRepeatedDeclines = (*_value.ptr() == '1');
			}
			else if (_element.equals("cardInfoId"))
			{
				cardInfoId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("awardId"))
			{
				awardId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientDepositFlags"))
			{
				clientDepositFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isLoadAmountProvided"))
			{
				isLoadAmountProvided = (*_value.ptr() == '1');
			}
			else if (_element.equals("loadAmount"))
			{
				loadAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("geoIpInfo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, geoIpInfo)) return false;
			}
			else if (_element.equals("depositPassword"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, depositPassword)) return false;
			}
			else if (_element.equals("encryptedCardNumAndCvv"))
			{
				Atf::XmlElement::_movePBlockWithNullStrip(_value, encryptedCardNumAndCvv);
			}
			else if (_element.equals("paymentSpecificDataVec"))
			{
				if(!Atf::AtfTempl< PaymentSpecificDataVec >::FromXmlString(_value, paymentSpecificDataVec)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeINT32(amount);
	_msg.composeBYTE(paySystemByte);
	_msg.composeString(cardNum);
	_msg.composeString(cardCvv);
	_msg.composeUINT16(expYear);
	_msg.composeBYTE(expMonth);
	_msg.composeUINT32(bonusId);
	_msg.composeBYTE(doNotCancelCashouts);
	_msg.composeString(currency);
	_msg.composeString(issueNum);
	_msg.composeString(startDate);
	_msg.composeINT32(converted);
	_msg.composeString(secNum);
	_msg.composeSrvDate(bDate);
	_msg.composeString(dLicense);
	_msg.composeString(userPhoneAch);
	_msg.composeBOOL(saveCardInfoRequested);
	_msg.composeString(bonusCode);
	_msg.composeString(balanceCurrency);
	_msg.composeINT32(clientBalance);
	_msg.composeBOOL(fastDepositTransaction);
	_msg.composeBOOL(saveInfoForFastDeposit);
	_msg.composeBOOL(ignoreRepeatedDeclines);
	_msg.composeUINT32(cardInfoId);
	_msg.composeUINT32(awardId);
	_msg.composeUINT32(clientDepositFlags);
	if (paySystemByte == cardTypePayLucky || paySystemByte == cardTypeSightline || paySystemByte == cardTypeSightlineNR)
	{
		CommMsgBody _msg0;
		_msg0.composeBOOL(isLoadAmountProvided);
		_msg0.composeINT32(loadAmount);
		_msg0.composeString(geoIpInfo);
		_msg.composeMsgBody(_msg0);
	}
	else if (paySystemByte == cardTypeGamersCard)
	{
		CommMsgBody _msg1;
		_msg1.composeString(depositPassword);
		_msg.composeMsgBody(_msg1);
	}
	else
	{
		CommMsgBody _msg2;
		_msg.composeMsgBody(_msg2);
	}
	_msg._composeVarBlock(encryptedCardNumAndCvv.ptr(), encryptedCardNumAndCvv.size());
	paymentSpecificDataVec.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(amount);
	_parser.parseBYTE(paySystemByte);
	_parser.parseStringP(cardNum);
	_parser.parseStringP(cardCvv);
	_parser.parseUINT16(expYear);
	_parser.parseBYTE(expMonth);
	_parser.parseUINT32(bonusId);
	_parser.parseBYTE(doNotCancelCashouts);
	_parser.parseStringP(currency);
	_parser.parseStringP(issueNum);
	_parser.parseStringP(startDate);
	_parser.parseINT32(converted);
	_parser.parseStringP(secNum);
	_parser.parseSrvDate(bDate);
	_parser.parseStringP(dLicense);
	_parser.parseStringP(userPhoneAch);
	_parser.parseBOOL(saveCardInfoRequested);
	_parser.parseStringP(bonusCode);
	_parser.parseStringP(balanceCurrency);
	_parser.parseINT32(clientBalance);
	_parser.parseBOOL(fastDepositTransaction);
	_parser.parseBOOL(saveInfoForFastDeposit);
	_parser.parseBOOL(ignoreRepeatedDeclines);
	_parser.parseUINT32(cardInfoId);
	_parser.parseUINT32(awardId);
	_parser.parseUINT32(clientDepositFlags);
	if (paySystemByte == cardTypePayLucky || paySystemByte == cardTypeSightline || paySystemByte == cardTypeSightlineNR)
	{
		if(_parser.parseEnded()) return;
		parseAnonymousMsgBody0(_parser);
	}
	else if (paySystemByte == cardTypeGamersCard)
	{
		if(_parser.parseEnded()) return;
		parseAnonymousMsgBody1(_parser);
	}
	else
	{
		if(_parser.parseEnded()) return;
		parseAnonymousMsgBody2(_parser);
	}
	if(_parser.parseEnded()) return;
	_parser.parsePBlock(encryptedCardNumAndCvv);
	if(_parser.parseEnded()) return;
	paymentSpecificDataVec.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("paySystemByte", paySystemByte);
	_jsonstr.compose("cardNum", cardNum);
	_jsonstr.compose("cardCvv", cardCvv);
	_jsonstr.compose("expYear", expYear);
	_jsonstr.compose("expMonth", expMonth);
	_jsonstr.compose("bonusId", bonusId);
	_jsonstr.compose("doNotCancelCashouts", doNotCancelCashouts);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("issueNum", issueNum);
	_jsonstr.compose("startDate", startDate);
	_jsonstr.compose("converted", converted);
	_jsonstr.compose("secNum", secNum);
	_jsonstr.compose("bDate", bDate);
	_jsonstr.compose("dLicense", dLicense);
	_jsonstr.compose("userPhoneAch", userPhoneAch);
	_jsonstr.compose("saveCardInfoRequested", saveCardInfoRequested);
	_jsonstr.compose("bonusCode", bonusCode);
	_jsonstr.compose("balanceCurrency", balanceCurrency);
	_jsonstr.compose("clientBalance", clientBalance);
	_jsonstr.compose("fastDepositTransaction", fastDepositTransaction);
	_jsonstr.compose("saveInfoForFastDeposit", saveInfoForFastDeposit);
	_jsonstr.compose("ignoreRepeatedDeclines", ignoreRepeatedDeclines);
	_jsonstr.compose("cardInfoId", cardInfoId);
	_jsonstr.compose("awardId", awardId);
	_jsonstr.compose("clientDepositFlags", clientDepositFlags);
	if (paySystemByte == cardTypePayLucky || paySystemByte == cardTypeSightline || paySystemByte == cardTypeSightlineNR)
	{
		_jsonstr.compose("isLoadAmountProvided", isLoadAmountProvided);
		_jsonstr.compose("loadAmount", loadAmount);
		_jsonstr.compose("geoIpInfo", geoIpInfo);
	}
	else if (paySystemByte == cardTypeGamersCard)
	{
		_jsonstr.compose("depositPassword", depositPassword);
	}
	else
	{
	}
	_jsonstr.compose("encryptedCardNumAndCvv", encryptedCardNumAndCvv);
	_jsonstr.compose("paymentSpecificDataVec", paymentSpecificDataVec);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
	_jparser.parseByNameThrow("cardNum", cardNum);
	_jparser.parseByNameThrow("cardCvv", cardCvv);
	_jparser.parseByNameThrow("expYear", expYear);
	_jparser.parseByNameThrow("expMonth", expMonth);
	_jparser.parseByNameThrow("bonusId", bonusId);
	_jparser.parseByNameThrow("doNotCancelCashouts", doNotCancelCashouts);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("issueNum", issueNum);
	_jparser.parseByNameThrow("startDate", startDate);
	_jparser.parseByNameThrow("converted", converted);
	_jparser.parseByNameThrow("secNum", secNum);
	_jparser.parseByNameThrow("bDate", bDate);
	_jparser.parseByNameThrow("dLicense", dLicense);
	_jparser.parseByNameThrow("userPhoneAch", userPhoneAch);
	_jparser.parseByNameThrow("saveCardInfoRequested", saveCardInfoRequested);
	_jparser.parseByNameThrow("bonusCode", bonusCode);
	_jparser.parseByNameThrow("balanceCurrency", balanceCurrency);
	_jparser.parseByNameThrow("clientBalance", clientBalance);
	_jparser.parseByNameThrow("fastDepositTransaction", fastDepositTransaction);
	_jparser.parseByNameThrow("saveInfoForFastDeposit", saveInfoForFastDeposit);
	_jparser.parseByNameThrow("ignoreRepeatedDeclines", ignoreRepeatedDeclines);
	_jparser.parseByNameThrow("cardInfoId", cardInfoId);
	_jparser.parseByNameThrow("awardId", awardId);
	_jparser.parseByNameThrow("clientDepositFlags", clientDepositFlags);
	if (paySystemByte == cardTypePayLucky || paySystemByte == cardTypeSightline || paySystemByte == cardTypeSightlineNR)
	{
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("isLoadAmountProvided", isLoadAmountProvided);
		_jparser.parseByNameThrow("loadAmount", loadAmount);
		_jparser.parseByNameThrow("geoIpInfo", geoIpInfo);
	}
	else if (paySystemByte == cardTypeGamersCard)
	{
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("depositPassword", depositPassword);
	}
	else
	{
		if(_jparser.parseEnded()) return;
	}
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("encryptedCardNumAndCvv", encryptedCardNumAndCvv);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("paymentSpecificDataVec", paymentSpecificDataVec);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_CC";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte = 0;
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	PString cardNum; _jparser.validateByNameThrow("cardNum", cardNum);
	AtfValidator::validateIntMax(_descr, "cardNum", cardNum.length(), CARDNUM_LEN, _checker, __FILE__, __LINE__);
	PString cardCvv; _jparser.validateByNameThrow("cardCvv", cardCvv);
	AtfValidator::validateIntMax(_descr, "cardCvv", cardCvv.length(), CARD_CVV_LEN, _checker, __FILE__, __LINE__);
	UINT16 expYear; _jparser.validateByNameThrow("expYear", expYear);
	AtfValidator::validateIntRange(_descr, "expYear", expYear, 0, 3000, _checker, __FILE__, __LINE__);
	BYTE expMonth; _jparser.validateByNameThrow("expMonth", expMonth);
	AtfValidator::validateIntRange(_descr, "expMonth", expMonth, 0, 12, _checker, __FILE__, __LINE__);
	UINT32 bonusId; _jparser.validateByNameThrow("bonusId", bonusId);
	AtfValidator::validateInt(_descr, "bonusId", bonusId, _checker, __FILE__, __LINE__);
	BYTE doNotCancelCashouts; _jparser.validateByNameThrow("doNotCancelCashouts", doNotCancelCashouts);
	AtfValidator::validateInt(_descr, "doNotCancelCashouts", doNotCancelCashouts, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	PString issueNum; _jparser.validateByNameThrow("issueNum", issueNum);
	AtfValidator::validateIntMax(_descr, "issueNum", issueNum.length(), ISSUE_NUM_LEN, _checker, __FILE__, __LINE__);
	PString startDate; _jparser.validateByNameThrow("startDate", startDate);
	AtfValidator::validateIntMax(_descr, "startDate", startDate.length(), START_DATE_LEN, _checker, __FILE__, __LINE__);
	INT32 converted; _jparser.validateByNameThrow("converted", converted);
	AtfValidator::validateIntRange(_descr, "converted", converted, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString secNum; _jparser.validateByNameThrow("secNum", secNum);
	AtfValidator::validateIntMax(_descr, "secNum", secNum.length(), 1000, _checker, __FILE__, __LINE__);
	CommSrvDate bDate; _jparser.validateByNameThrow("bDate", bDate);
	AtfValidator::validateSrvDateTime(_descr, "bDate", bDate, _checker, __FILE__, __LINE__);
	PString dLicense; _jparser.validateByNameThrow("dLicense", dLicense);
	AtfValidator::validateIntMax(_descr, "dLicense", dLicense.length(), 1000, _checker, __FILE__, __LINE__);
	PString userPhoneAch; _jparser.validateByNameThrow("userPhoneAch", userPhoneAch);
	AtfValidator::validateIntMax(_descr, "userPhoneAch", userPhoneAch.length(), 1000, _checker, __FILE__, __LINE__);
	bool saveCardInfoRequested; _jparser.validateByNameThrow("saveCardInfoRequested", saveCardInfoRequested);
	AtfValidator::validateInt(_descr, "saveCardInfoRequested", saveCardInfoRequested, _checker, __FILE__, __LINE__);
	PString bonusCode; _jparser.validateByNameThrow("bonusCode", bonusCode);
	AtfValidator::validateIntMax(_descr, "bonusCode", bonusCode.length(), BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	PString balanceCurrency; _jparser.validateByNameThrow("balanceCurrency", balanceCurrency);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", balanceCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 clientBalance; _jparser.validateByNameThrow("clientBalance", clientBalance);
	AtfValidator::validateIntMax(_descr, "clientBalance", clientBalance, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	bool fastDepositTransaction; _jparser.validateByNameThrow("fastDepositTransaction", fastDepositTransaction);
	AtfValidator::validateInt(_descr, "fastDepositTransaction", fastDepositTransaction, _checker, __FILE__, __LINE__);
	bool saveInfoForFastDeposit; _jparser.validateByNameThrow("saveInfoForFastDeposit", saveInfoForFastDeposit);
	AtfValidator::validateInt(_descr, "saveInfoForFastDeposit", saveInfoForFastDeposit, _checker, __FILE__, __LINE__);
	bool ignoreRepeatedDeclines; _jparser.validateByNameThrow("ignoreRepeatedDeclines", ignoreRepeatedDeclines);
	AtfValidator::validateInt(_descr, "ignoreRepeatedDeclines", ignoreRepeatedDeclines, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _jparser.validateByNameThrow("cardInfoId", cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	UINT32 awardId; _jparser.validateByNameThrow("awardId", awardId);
	AtfValidator::validateInt(_descr, "awardId", awardId, _checker, __FILE__, __LINE__);
	UINT32 clientDepositFlags; _jparser.validateByNameThrow("clientDepositFlags", clientDepositFlags);
	AtfValidator::validateIntMax(_descr, "clientDepositFlags", clientDepositFlags, ((((UINT32)eClientDepositFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
	if (paySystemByte == cardTypePayLucky || paySystemByte == cardTypeSightline || paySystemByte == cardTypeSightlineNR)
	{
		if(_jparser.parseEnded()) return;
		bool isLoadAmountProvided; _jparser.validateByNameThrow("isLoadAmountProvided", isLoadAmountProvided);
		AtfValidator::validateInt(_descr, "isLoadAmountProvided", isLoadAmountProvided, _checker, __FILE__, __LINE__);
		INT32 loadAmount; _jparser.validateByNameThrow("loadAmount", loadAmount);
		AtfValidator::validateIntRange(_descr, "loadAmount", loadAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
		PString geoIpInfo; _jparser.validateByNameThrow("geoIpInfo", geoIpInfo);
		AtfValidator::validateIntMax(_descr, "geoIpInfo", geoIpInfo.length(), 10000, _checker, __FILE__, __LINE__);
	}
	else if (paySystemByte == cardTypeGamersCard)
	{
		if(_jparser.parseEnded()) return;
		PString depositPassword; _jparser.validateByNameThrow("depositPassword", depositPassword);
		AtfValidator::validateIntMax(_descr, "depositPassword", depositPassword.length(), 10000, _checker, __FILE__, __LINE__);
	}
	else
	{
		if(_jparser.parseEnded()) return;
	}
	if(_jparser.parseEnded()) return;
	PBlock encryptedCardNumAndCvv; _jparser.validateByNameThrow("encryptedCardNumAndCvv", encryptedCardNumAndCvv);
	AtfValidator::validateIntMax(_descr, "encryptedCardNumAndCvv", encryptedCardNumAndCvv.size(), 4000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PaymentSpecificDataVec paymentSpecificDataVec; _jparser.validateByNameThrow("paymentSpecificDataVec", paymentSpecificDataVec);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_CC";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE paySystemByte = 0;
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cardNum"); size_t szCardNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cardNum", szCardNum, CARDNUM_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cardCvv"); size_t szCardCvv = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cardCvv", szCardCvv, CARD_CVV_LEN, _checker, __FILE__, __LINE__);
	UINT16 expYear; _parser.parseUINT16(expYear);
	AtfValidator::validateIntRange(_descr, "expYear", expYear, 0, 3000, _checker, __FILE__, __LINE__);
	BYTE expMonth; _parser.parseBYTE(expMonth);
	AtfValidator::validateIntRange(_descr, "expMonth", expMonth, 0, 12, _checker, __FILE__, __LINE__);
	UINT32 bonusId; _parser.parseUINT32(bonusId);
	AtfValidator::validateInt(_descr, "bonusId", bonusId, _checker, __FILE__, __LINE__);
	BYTE doNotCancelCashouts; _parser.parseBYTE(doNotCancelCashouts);
	AtfValidator::validateInt(_descr, "doNotCancelCashouts", doNotCancelCashouts, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "issueNum"); size_t szIssueNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "issueNum", szIssueNum, ISSUE_NUM_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "startDate"); size_t szStartDate = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "startDate", szStartDate, START_DATE_LEN, _checker, __FILE__, __LINE__);
	INT32 converted; _parser.parseINT32(converted);
	AtfValidator::validateIntRange(_descr, "converted", converted, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "secNum"); size_t szSecNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "secNum", szSecNum, 1000, _checker, __FILE__, __LINE__);
	CommSrvDate bDate; _parser.parseSrvDate(bDate);
	AtfValidator::validateSrvDateTime(_descr, "bDate", bDate, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "dLicense"); size_t szDLicense = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "dLicense", szDLicense, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userPhoneAch"); size_t szUserPhoneAch = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userPhoneAch", szUserPhoneAch, 1000, _checker, __FILE__, __LINE__);
	bool saveCardInfoRequested; _parser.parseBOOL(saveCardInfoRequested);
	AtfValidator::validateInt(_descr, "saveCardInfoRequested", saveCardInfoRequested, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", szBalanceCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 clientBalance; _parser.parseINT32(clientBalance);
	AtfValidator::validateIntMax(_descr, "clientBalance", clientBalance, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	bool fastDepositTransaction; _parser.parseBOOL(fastDepositTransaction);
	AtfValidator::validateInt(_descr, "fastDepositTransaction", fastDepositTransaction, _checker, __FILE__, __LINE__);
	bool saveInfoForFastDeposit; _parser.parseBOOL(saveInfoForFastDeposit);
	AtfValidator::validateInt(_descr, "saveInfoForFastDeposit", saveInfoForFastDeposit, _checker, __FILE__, __LINE__);
	bool ignoreRepeatedDeclines; _parser.parseBOOL(ignoreRepeatedDeclines);
	AtfValidator::validateInt(_descr, "ignoreRepeatedDeclines", ignoreRepeatedDeclines, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	UINT32 awardId; _parser.parseUINT32(awardId);
	AtfValidator::validateInt(_descr, "awardId", awardId, _checker, __FILE__, __LINE__);
	UINT32 clientDepositFlags; _parser.parseUINT32(clientDepositFlags);
	AtfValidator::validateIntMax(_descr, "clientDepositFlags", clientDepositFlags, ((((UINT32)eClientDepositFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
	if (paySystemByte == cardTypePayLucky || paySystemByte == cardTypeSightline || paySystemByte == cardTypeSightlineNR)
	{
		if(_parser.parseEnded()) return;
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (paySystemByte == cardTypeGamersCard)
	{
		if(_parser.parseEnded()) return;
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else
	{
		if(_parser.parseEnded()) return;
		validateAnonymousMsgBody2(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(_parser.parseEnded()) return;
	const BYTE* encryptedCardNumAndCvv; size_t szEncryptedCardNumAndCvv; _parser._parseVarBlock(encryptedCardNumAndCvv, szEncryptedCardNumAndCvv);  /*encryptedCardNumAndCvv*/
	AtfValidator::validateIntMax(_descr, "encryptedCardNumAndCvv", szEncryptedCardNumAndCvv, 4000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	PaymentSpecificDataVec::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("paymentSpecificDataVec"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isLoadAmountProvided);
	_parser0.parseINT32(loadAmount);
	_parser0.parseStringP(geoIpInfo);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	bool isLoadAmountProvided; _parser0.parseBOOL(isLoadAmountProvided);
	AtfValidator::validateInt(_descr, "isLoadAmountProvided", isLoadAmountProvided, _checker, __FILE__, __LINE__);
	INT32 loadAmount; _parser0.parseINT32(loadAmount);
	AtfValidator::validateIntRange(_descr, "loadAmount", loadAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "geoIpInfo"); size_t szGeoIpInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "geoIpInfo", szGeoIpInfo, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(depositPassword);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "depositPassword"); size_t szDepositPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "depositPassword", szDepositPassword, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::clear()
{
	errCode = 0;
	errDescr.clear();
	transId = 0;
	empty.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::equals(const Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		transId == _o.transId &&
		Atf::atfPStringEquals(empty, _o.empty);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CASHIN_CC_CONFIRM != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_CC_CONFIRM).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
		_buf.append(',');
		_buf.append("empty=");
		_buf.append(empty);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CASHIN_CC_CONFIRM).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
		Atf::XmlElement::encodeAsXmlElement("empty", empty, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("transId"))
			{
				transId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("empty"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, empty)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(transId);
		_msg.composeString(empty);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(transId);
		_parser.parseStringP(empty);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("transId", transId);
		_jsonstr.compose("empty", empty);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("transId", transId);
		_jparser.parseByNameThrow("empty", empty);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_CC_CONFIRM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _jparser.validateByNameThrow("transId", transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		PString empty; _jparser.validateByNameThrow("empty", empty);
		AtfValidator::validateInt(_descr, "empty", empty.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_CC_CONFIRM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "empty"); size_t szEmpty = strlen(_dummy);
		AtfValidator::validateInt(_descr, "empty", szEmpty, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashinResultInfo
//=================================================================

CashierServer::cli::CashinResultInfo::CashinResultInfo()
{
	clear();
}

void CashierServer::cli::CashinResultInfo::clear()
{
	type = 0;
	action = 0;
	amount = 0;
	reference.clear();
	systemFee = 0;
}

bool CashierServer::cli::CashinResultInfo::equals(const CashinResultInfo& _o) const
{
	return type == _o.type &&
		action == _o.action &&
		amount == _o.amount &&
		Atf::atfPStringEquals(reference, _o.reference) &&
		systemFee == _o.systemFee;
}

const char *CashierServer::cli::CashinResultInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("action=");
	_buf.appendUint(action);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("reference=");
	_buf.append(reference);
	_buf.append(',');
	_buf.append("systemFee=");
	_buf.appendInt(systemFee);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashinResultInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("action", action, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("reference", reference, _buf);
	Atf::XmlElement::encodeAsXmlElement("systemFee", systemFee, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashinResultInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("type"))
		{
			type = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("action"))
		{
			action = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("amount"))
		{
			amount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("reference"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, reference)) return false;
		}
		else if (_element.equals("systemFee"))
		{
			systemFee = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashinResultInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(type);
	_msg.composeBYTE(action);
	_msg.composeINT32(amount);
	_msg.composeString(reference);
	_msg.composeINT32(systemFee);
}

void CashierServer::cli::CashinResultInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(type);
	_parser.parseBYTE(action);
	_parser.parseINT32(amount);
	_parser.parseStringP(reference);
	_parser.parseINT32(systemFee);
}

const char *CashierServer::cli::CashinResultInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("type", type);
	_jsonstr.compose("action", action);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("reference", reference);
	_jsonstr.compose("systemFee", systemFee);
	return _buf.c_str();
}

void CashierServer::cli::CashinResultInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("action", action);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("reference", reference);
	_jparser.parseByNameThrow("systemFee", systemFee);
}

/* static */ void CashierServer::cli::CashinResultInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	BYTE action; _jparser.validateByNameThrow("action", action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	PString reference; _jparser.validateByNameThrow("reference", reference);
	AtfValidator::validateInt(_descr, "reference", reference.length(), _checker, __FILE__, __LINE__);
	INT32 systemFee; _jparser.validateByNameThrow("systemFee", systemFee);
	AtfValidator::validateInt(_descr, "systemFee", systemFee, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashinResultInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	BYTE type; _parser.parseBYTE(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	BYTE action; _parser.parseBYTE(action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "reference"); size_t szReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "reference", szReference, _checker, __FILE__, __LINE__);
	INT32 systemFee; _parser.parseINT32(systemFee);
	AtfValidator::validateInt(_descr, "systemFee", systemFee, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::clear()
{
	errCode = 0;
	errDescr.clear();
	cardTypeByte = 0;
	transId = 0;
	dadEligible = false;
	errDescrForClient.clear();
	balanceCurrency.clear();
	transStatusForClient = 0;
	totalAmount = 0;
	resultInfos.clear();
	rejectExplanationCode = 0;
	urlForUser.clear();
	errorTemplateText.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::equals(const Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		cardTypeByte == _o.cardTypeByte &&
		transId == _o.transId &&
		dadEligible == _o.dadEligible &&
		Atf::atfPStringEquals(errDescrForClient, _o.errDescrForClient) &&
		Atf::atfPStringEquals(balanceCurrency, _o.balanceCurrency) &&
		transStatusForClient == _o.transStatusForClient &&
		totalAmount == _o.totalAmount &&
		resultInfos.equals(_o.resultInfos) &&
		rejectExplanationCode == _o.rejectExplanationCode &&
		Atf::atfPStringEquals(urlForUser, _o.urlForUser) &&
		Atf::atfPStringEquals(errorTemplateText, _o.errorTemplateText);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CASHIN_CC_COMPLETE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_CC_COMPLETE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("cardTypeByte=");
		_buf.appendUint(cardTypeByte);
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
		_buf.append(',');
		_buf.append("dadEligible=");
		_buf.appendUint(dadEligible);
		_buf.append(',');
		_buf.append("errDescrForClient=");
		_buf.append(errDescrForClient);
		_buf.append(',');
		_buf.append("balanceCurrency=");
		_buf.append(balanceCurrency);
	}
	else
	{
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
		_buf.append(',');
		_buf.append("transStatusForClient=");
		_buf.appendUint(transStatusForClient);
		_buf.append(',');
		_buf.append("totalAmount=");
		_buf.appendInt(totalAmount);
		_buf.append(',');
		_buf.append("resultInfos=");
		resultInfos.toTraceString(_buf);
		_buf.append(',');
		_buf.append("rejectExplanationCode=");
		_buf.appendUint(rejectExplanationCode);
		_buf.append(',');
		_buf.append("urlForUser=");
		_buf.append(urlForUser);
		_buf.append(',');
		_buf.append("cardTypeByte=");
		_buf.appendUint(cardTypeByte);
		_buf.append(',');
		_buf.append("dadEligible=");
		_buf.appendUint(dadEligible);
		_buf.append(',');
		_buf.append("errorTemplateText=");
		_buf.append(errorTemplateText);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CASHIN_CC_COMPLETE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
		Atf::XmlElement::encodeAsXmlElement("cardTypeByte", cardTypeByte, _buf);
		Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
		Atf::XmlElement::encodeAsXmlElement("dadEligible", dadEligible, _buf);
		Atf::XmlElement::encodeAsXmlElement("errDescrForClient", errDescrForClient, _buf);
		Atf::XmlElement::encodeAsXmlElement("balanceCurrency", balanceCurrency, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
		Atf::XmlElement::encodeAsXmlElement("transStatusForClient", transStatusForClient, _buf);
		Atf::XmlElement::encodeAsXmlElement("totalAmount", totalAmount, _buf);
		resultInfos.toXmlString("resultInfos", _buf);
		Atf::XmlElement::encodeAsXmlElement("rejectExplanationCode", rejectExplanationCode, _buf);
		Atf::XmlElement::encodeAsXmlElement("urlForUser", urlForUser, _buf);
		Atf::XmlElement::encodeAsXmlElement("cardTypeByte", cardTypeByte, _buf);
		Atf::XmlElement::encodeAsXmlElement("dadEligible", dadEligible, _buf);
		Atf::XmlElement::encodeAsXmlElement("errorTemplateText", errorTemplateText, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("cardTypeByte"))
			{
				cardTypeByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("transId"))
			{
				transId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("dadEligible"))
			{
				dadEligible = (*_value.ptr() == '1');
			}
			else if (_element.equals("errDescrForClient"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescrForClient)) return false;
			}
			else if (_element.equals("balanceCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, balanceCurrency)) return false;
			}
			else if (_element.equals("transStatusForClient"))
			{
				transStatusForClient = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("totalAmount"))
			{
				totalAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("resultInfos"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashinResultInfo, 4 > >::FromXmlString(_value, resultInfos)) return false;
			}
			else if (_element.equals("rejectExplanationCode"))
			{
				rejectExplanationCode = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("urlForUser"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, urlForUser)) return false;
			}
			else if (_element.equals("errorTemplateText"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errorTemplateText)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
		_msg.composeBYTE(cardTypeByte);
		_msg.composeUINT32(transId);
		_msg.composeBOOL(dadEligible);
		_msg.composeString(errDescrForClient);
		_msg.composeString(balanceCurrency);
	}
	else
	{
		_msg.composeUINT32(transId);
		_msg.composeBYTE(transStatusForClient);
		_msg.composeINT32(totalAmount);
		resultInfos.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT32(rejectExplanationCode);
		_msg.composeString(urlForUser);
		_msg.composeBYTE(cardTypeByte);
		_msg.composeBOOL(dadEligible);
		_msg.composeString(errorTemplateText);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
		if(_parser.parseEnded()) return;
		_parser.parseBYTE(cardTypeByte);
		_parser.parseUINT32(transId);
		_parser.parseBOOL(dadEligible);
		_parser.parseStringP(errDescrForClient);
		_parser.parseStringP(balanceCurrency);
	}
	else
	{
		_parser.parseUINT32(transId);
		_parser.parseBYTE(transStatusForClient);
		_parser.parseINT32(totalAmount);
		resultInfos.parseMsg(_parser);
		_parser.parseUINT32(rejectExplanationCode);
		_parser.parseStringP(urlForUser);
		_parser.parseBYTE(cardTypeByte);
		_parser.parseBOOL(dadEligible);
		_parser.parseStringP(errorTemplateText);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
		_jsonstr.compose("cardTypeByte", cardTypeByte);
		_jsonstr.compose("transId", transId);
		_jsonstr.compose("dadEligible", dadEligible);
		_jsonstr.compose("errDescrForClient", errDescrForClient);
		_jsonstr.compose("balanceCurrency", balanceCurrency);
	}
	else
	{
		_jsonstr.compose("transId", transId);
		_jsonstr.compose("transStatusForClient", transStatusForClient);
		_jsonstr.compose("totalAmount", totalAmount);
		_jsonstr.compose("resultInfos", resultInfos);
		_jsonstr.compose("rejectExplanationCode", rejectExplanationCode);
		_jsonstr.compose("urlForUser", urlForUser);
		_jsonstr.compose("cardTypeByte", cardTypeByte);
		_jsonstr.compose("dadEligible", dadEligible);
		_jsonstr.compose("errorTemplateText", errorTemplateText);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("cardTypeByte", cardTypeByte);
		_jparser.parseByNameThrow("transId", transId);
		_jparser.parseByNameThrow("dadEligible", dadEligible);
		_jparser.parseByNameThrow("errDescrForClient", errDescrForClient);
		_jparser.parseByNameThrow("balanceCurrency", balanceCurrency);
	}
	else
	{
		_jparser.parseByNameThrow("transId", transId);
		_jparser.parseByNameThrow("transStatusForClient", transStatusForClient);
		_jparser.parseByNameThrow("totalAmount", totalAmount);
		_jparser.parseByNameThrow("resultInfos", resultInfos);
		_jparser.parseByNameThrow("rejectExplanationCode", rejectExplanationCode);
		_jparser.parseByNameThrow("urlForUser", urlForUser);
		_jparser.parseByNameThrow("cardTypeByte", cardTypeByte);
		_jparser.parseByNameThrow("dadEligible", dadEligible);
		_jparser.parseByNameThrow("errorTemplateText", errorTemplateText);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_CC_COMPLETE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		BYTE cardTypeByte; _jparser.validateByNameThrow("cardTypeByte", cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
		UINT32 transId; _jparser.validateByNameThrow("transId", transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		bool dadEligible; _jparser.validateByNameThrow("dadEligible", dadEligible);
		AtfValidator::validateInt(_descr, "dadEligible", dadEligible, _checker, __FILE__, __LINE__);
		PString errDescrForClient; _jparser.validateByNameThrow("errDescrForClient", errDescrForClient);
		AtfValidator::validateInt(_descr, "errDescrForClient", errDescrForClient.length(), _checker, __FILE__, __LINE__);
		PString balanceCurrency; _jparser.validateByNameThrow("balanceCurrency", balanceCurrency);
		AtfValidator::validateInt(_descr, "balanceCurrency", balanceCurrency.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _jparser.validateByNameThrow("transId", transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		BYTE transStatusForClient; _jparser.validateByNameThrow("transStatusForClient", transStatusForClient);
		AtfValidator::validateInt(_descr, "transStatusForClient", transStatusForClient, _checker, __FILE__, __LINE__);
		INT32 totalAmount; _jparser.validateByNameThrow("totalAmount", totalAmount);
		AtfValidator::validateInt(_descr, "totalAmount", totalAmount, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< CashinResultInfo > resultInfos; _jparser.validateByNameThrow("resultInfos", resultInfos);
		AtfValidator::validateInt(_descr, "resultInfos", resultInfos.size(), _checker, __FILE__, __LINE__);
		UINT32 rejectExplanationCode; _jparser.validateByNameThrow("rejectExplanationCode", rejectExplanationCode);
		AtfValidator::validateInt(_descr, "rejectExplanationCode", rejectExplanationCode, _checker, __FILE__, __LINE__);
		PString urlForUser; _jparser.validateByNameThrow("urlForUser", urlForUser);
		AtfValidator::validateInt(_descr, "urlForUser", urlForUser.length(), _checker, __FILE__, __LINE__);
		BYTE cardTypeByte; _jparser.validateByNameThrow("cardTypeByte", cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
		bool dadEligible; _jparser.validateByNameThrow("dadEligible", dadEligible);
		AtfValidator::validateInt(_descr, "dadEligible", dadEligible, _checker, __FILE__, __LINE__);
		PString errorTemplateText; _jparser.validateByNameThrow("errorTemplateText", errorTemplateText);
		AtfValidator::validateInt(_descr, "errorTemplateText", errorTemplateText.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_CC_COMPLETE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		bool dadEligible; _parser.parseBOOL(dadEligible);
		AtfValidator::validateInt(_descr, "dadEligible", dadEligible, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "errDescrForClient"); size_t szErrDescrForClient = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescrForClient", szErrDescrForClient, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "balanceCurrency", szBalanceCurrency, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		BYTE transStatusForClient; _parser.parseBYTE(transStatusForClient);
		AtfValidator::validateInt(_descr, "transStatusForClient", transStatusForClient, _checker, __FILE__, __LINE__);
		INT32 totalAmount; _parser.parseINT32(totalAmount);
		AtfValidator::validateInt(_descr, "totalAmount", totalAmount, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szResultInfos = Atf::LAtfVector< CashinResultInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("resultInfos"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "resultInfos", szResultInfos, _checker, __FILE__, __LINE__);
		UINT32 rejectExplanationCode; _parser.parseUINT32(rejectExplanationCode);
		AtfValidator::validateInt(_descr, "rejectExplanationCode", rejectExplanationCode, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "urlForUser"); size_t szUrlForUser = strlen(_dummy);
		AtfValidator::validateInt(_descr, "urlForUser", szUrlForUser, _checker, __FILE__, __LINE__);
		BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
		bool dadEligible; _parser.parseBOOL(dadEligible);
		AtfValidator::validateInt(_descr, "dadEligible", dadEligible, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "errorTemplateText"); size_t szErrorTemplateText = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorTemplateText", szErrorTemplateText, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHOUT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::Protocol_MSG_CASHIER_CASHOUT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::clear()
{
	userId.clear();
	amount = 0;
	paySystem = 0;
	bonusAware = 0;
	userPhone.clear();
	currency.clear();
	convRate = 0;
	balanceCurrency.clear();
	reference.clear();
	clientBalance_ignored = 0;
	convRate64 = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::equals(const Protocol_MSG_CASHIER_CASHOUT& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		amount == _o.amount &&
		paySystem == _o.paySystem &&
		bonusAware == _o.bonusAware &&
		Atf::atfPStringEquals(userPhone, _o.userPhone) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		convRate == _o.convRate &&
		Atf::atfPStringEquals(balanceCurrency, _o.balanceCurrency) &&
		Atf::atfPStringEquals(reference, _o.reference) &&
		clientBalance_ignored == _o.clientBalance_ignored &&
		convRate64 == _o.convRate64;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CASHOUT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CASHOUT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHOUT).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("paySystem=");
	_buf.appendUint(paySystem);
	_buf.append(',');
	_buf.append("bonusAware=");
	_buf.appendUint(bonusAware);
	_buf.append(',');
	_buf.append("userPhone=");
	_buf.append(userPhone);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("convRate=");
	_buf.appendInt(convRate);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	_buf.append(',');
	_buf.append("reference=");
	_buf.append(reference);
	_buf.append(',');
	_buf.append("clientBalance_ignored=");
	_buf.appendInt(clientBalance_ignored);
	_buf.append(',');
	_buf.append("convRate64=");
	_buf.appendInt64(convRate64);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CASHOUT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("paySystem", paySystem, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusAware", bonusAware, _buf);
	Atf::XmlElement::encodeAsXmlElement("userPhone", userPhone, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("convRate", convRate, _buf);
	Atf::XmlElement::encodeAsXmlElement("balanceCurrency", balanceCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("reference", reference, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientBalance_ignored", clientBalance_ignored, _buf);
	Atf::XmlElement::encodeAsXmlElement("convRate64", convRate64, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("amount"))
			{
				amount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("paySystem"))
			{
				paySystem = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bonusAware"))
			{
				bonusAware = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userPhone"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userPhone)) return false;
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("convRate"))
			{
				convRate = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("balanceCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, balanceCurrency)) return false;
			}
			else if (_element.equals("reference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, reference)) return false;
			}
			else if (_element.equals("clientBalance_ignored"))
			{
				clientBalance_ignored = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("convRate64"))
			{
				convRate64 = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeINT32(amount);
	_msg.composeBYTE(paySystem);
	_msg.composeBYTE(bonusAware);
	_msg.composeString(userPhone);
	_msg.composeString(currency);
	_msg.composeINT32(convRate);
	_msg.composeString(balanceCurrency);
	_msg.composeString(reference);
	_msg.composeINT32(clientBalance_ignored);
	_msg.composeINT64(convRate64);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(amount);
	_parser.parseBYTE(paySystem);
	_parser.parseBYTE(bonusAware);
	_parser.parseStringP(userPhone);
	_parser.parseStringP(currency);
	_parser.parseINT32(convRate);
	_parser.parseStringP(balanceCurrency);
	_parser.parseStringP(reference);
	_parser.parseINT32(clientBalance_ignored);
	if(_parser.parseEnded()) return;
	_parser.parseINT64(convRate64);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("paySystem", paySystem);
	_jsonstr.compose("bonusAware", bonusAware);
	_jsonstr.compose("userPhone", userPhone);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("convRate", convRate);
	_jsonstr.compose("balanceCurrency", balanceCurrency);
	_jsonstr.compose("reference", reference);
	_jsonstr.compose("clientBalance_ignored", clientBalance_ignored);
	_jsonstr.compose("convRate64", convRate64);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("paySystem", paySystem);
	_jparser.parseByNameThrow("bonusAware", bonusAware);
	_jparser.parseByNameThrow("userPhone", userPhone);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("convRate", convRate);
	_jparser.parseByNameThrow("balanceCurrency", balanceCurrency);
	_jparser.parseByNameThrow("reference", reference);
	_jparser.parseByNameThrow("clientBalance_ignored", clientBalance_ignored);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("convRate64", convRate64);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	BYTE paySystem; _jparser.validateByNameThrow("paySystem", paySystem);
	AtfValidator::validateIntRange(_descr, "paySystem", paySystem, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	BYTE bonusAware; _jparser.validateByNameThrow("bonusAware", bonusAware);
	AtfValidator::validateIntMax(_descr, "bonusAware", bonusAware, 1, _checker, __FILE__, __LINE__);
	PString userPhone; _jparser.validateByNameThrow("userPhone", userPhone);
	AtfValidator::validateIntMax(_descr, "userPhone", userPhone.length(), 100, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 convRate; _jparser.validateByNameThrow("convRate", convRate);
	AtfValidator::validateIntRange(_descr, "convRate", convRate, 0, std::numeric_limits<INT32>::max(), _checker, __FILE__, __LINE__);
	PString balanceCurrency; _jparser.validateByNameThrow("balanceCurrency", balanceCurrency);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", balanceCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	PString reference; _jparser.validateByNameThrow("reference", reference);
	AtfValidator::validateIntMax(_descr, "reference", reference.length(), 1000, _checker, __FILE__, __LINE__);
	INT32 clientBalance_ignored; _jparser.validateByNameThrow("clientBalance_ignored", clientBalance_ignored);
	AtfValidator::validateInt(_descr, "clientBalance_ignored", clientBalance_ignored, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT64 convRate64; _jparser.validateByNameThrow("convRate64", convRate64);
	AtfValidator::validateIntRange(_descr, "convRate64", convRate64, 0, 1000000000000LL, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	BYTE paySystem; _parser.parseBYTE(paySystem);
	AtfValidator::validateIntRange(_descr, "paySystem", paySystem, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	BYTE bonusAware; _parser.parseBYTE(bonusAware);
	AtfValidator::validateIntMax(_descr, "bonusAware", bonusAware, 1, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userPhone"); size_t szUserPhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userPhone", szUserPhone, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 convRate; _parser.parseINT32(convRate);
	AtfValidator::validateIntRange(_descr, "convRate", convRate, 0, std::numeric_limits<INT32>::max(), _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", szBalanceCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "reference"); size_t szReference = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "reference", szReference, 1000, _checker, __FILE__, __LINE__);
	INT32 clientBalance_ignored; _parser.parseINT32(clientBalance_ignored);
	AtfValidator::validateInt(_descr, "clientBalance_ignored", clientBalance_ignored, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT64 convRate64; _parser.parseINT64(convRate64);
	AtfValidator::validateIntRange(_descr, "convRate64", convRate64, 0, 1000000000000LL, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ResultInfos
//=================================================================

CashierServer::cli::ResultInfos::ResultInfos()
{
	clear();
}

void CashierServer::cli::ResultInfos::clear()
{
	type = 0;
	action = 0;
	amount = 0;
	reference.clear();
	systemFee = 0;
}

bool CashierServer::cli::ResultInfos::equals(const ResultInfos& _o) const
{
	return type == _o.type &&
		action == _o.action &&
		amount == _o.amount &&
		Atf::atfPStringEquals(reference, _o.reference) &&
		systemFee == _o.systemFee;
}

const char *CashierServer::cli::ResultInfos::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("action=");
	_buf.appendUint(action);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("reference=");
	_buf.append(reference);
	_buf.append(',');
	_buf.append("systemFee=");
	_buf.appendInt(systemFee);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::ResultInfos::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("action", action, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("reference", reference, _buf);
	Atf::XmlElement::encodeAsXmlElement("systemFee", systemFee, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::ResultInfos::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("type"))
		{
			type = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("action"))
		{
			action = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("amount"))
		{
			amount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("reference"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, reference)) return false;
		}
		else if (_element.equals("systemFee"))
		{
			systemFee = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::ResultInfos::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(type);
	_msg.composeBYTE(action);
	_msg.composeINT32(amount);
	_msg.composeString(reference);
	_msg.composeINT32(systemFee);
}

void CashierServer::cli::ResultInfos::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(type);
	_parser.parseBYTE(action);
	_parser.parseINT32(amount);
	_parser.parseStringP(reference);
	_parser.parseINT32(systemFee);
}

const char *CashierServer::cli::ResultInfos::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("type", type);
	_jsonstr.compose("action", action);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("reference", reference);
	_jsonstr.compose("systemFee", systemFee);
	return _buf.c_str();
}

void CashierServer::cli::ResultInfos::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("action", action);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("reference", reference);
	_jparser.parseByNameThrow("systemFee", systemFee);
}

/* static */ void CashierServer::cli::ResultInfos::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	BYTE action; _jparser.validateByNameThrow("action", action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	PString reference; _jparser.validateByNameThrow("reference", reference);
	AtfValidator::validateInt(_descr, "reference", reference.length(), _checker, __FILE__, __LINE__);
	INT32 systemFee; _jparser.validateByNameThrow("systemFee", systemFee);
	AtfValidator::validateInt(_descr, "systemFee", systemFee, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::ResultInfos::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	BYTE type; _parser.parseBYTE(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	BYTE action; _parser.parseBYTE(action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "reference"); size_t szReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "reference", szReference, _checker, __FILE__, __LINE__);
	INT32 systemFee; _parser.parseINT32(systemFee);
	AtfValidator::validateInt(_descr, "systemFee", systemFee, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHOUT_COMPLETE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::Protocol_MSG_CASHIER_CASHOUT_COMPLETE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::clear()
{
	errCode = 0;
	errDescr.clear();
	transId = 0;
	statusByte = 0;
	returnedAmount = 0;
	resultInfos.clear();
	parentPaySystem = 0;
	empty.clear();
	balanceCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::equals(const Protocol_MSG_CASHIER_CASHOUT_COMPLETE& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		transId == _o.transId &&
		statusByte == _o.statusByte &&
		returnedAmount == _o.returnedAmount &&
		resultInfos.equals(_o.resultInfos) &&
		parentPaySystem == _o.parentPaySystem &&
		Atf::atfPStringEquals(empty, _o.empty) &&
		Atf::atfPStringEquals(balanceCurrency, _o.balanceCurrency);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CASHOUT_COMPLETE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CASHOUT_COMPLETE*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHOUT_COMPLETE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
		_buf.append(',');
		_buf.append("statusByte=");
		_buf.appendUint(statusByte);
		_buf.append(',');
		_buf.append("returnedAmount=");
		_buf.appendInt(returnedAmount);
		_buf.append(',');
		_buf.append("resultInfos=");
		resultInfos.toTraceString(_buf);
		_buf.append(',');
		_buf.append("parentPaySystem=");
		_buf.appendUint(parentPaySystem);
		_buf.append(',');
		_buf.append("empty=");
		_buf.append(empty);
		_buf.append(',');
		_buf.append("balanceCurrency=");
		_buf.append(balanceCurrency);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CASHOUT_COMPLETE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
		Atf::XmlElement::encodeAsXmlElement("statusByte", statusByte, _buf);
		Atf::XmlElement::encodeAsXmlElement("returnedAmount", returnedAmount, _buf);
		resultInfos.toXmlString("resultInfos", _buf);
		Atf::XmlElement::encodeAsXmlElement("parentPaySystem", parentPaySystem, _buf);
		Atf::XmlElement::encodeAsXmlElement("empty", empty, _buf);
		Atf::XmlElement::encodeAsXmlElement("balanceCurrency", balanceCurrency, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("transId"))
			{
				transId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("statusByte"))
			{
				statusByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("returnedAmount"))
			{
				returnedAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("resultInfos"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ResultInfos, 4 > >::FromXmlString(_value, resultInfos)) return false;
			}
			else if (_element.equals("parentPaySystem"))
			{
				parentPaySystem = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("empty"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, empty)) return false;
			}
			else if (_element.equals("balanceCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, balanceCurrency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(transId);
		_msg.composeBYTE(statusByte);
		_msg.composeINT32(returnedAmount);
		resultInfos.composeMsg(_msg, _ignoreJSON);
		_msg.composeBYTE(parentPaySystem);
		_msg.composeString(empty);
		_msg.composeString(balanceCurrency);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(transId);
		_parser.parseBYTE(statusByte);
		_parser.parseINT32(returnedAmount);
		resultInfos.parseMsg(_parser);
		_parser.parseBYTE(parentPaySystem);
		_parser.parseStringP(empty);
		_parser.parseStringP(balanceCurrency);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("transId", transId);
		_jsonstr.compose("statusByte", statusByte);
		_jsonstr.compose("returnedAmount", returnedAmount);
		_jsonstr.compose("resultInfos", resultInfos);
		_jsonstr.compose("parentPaySystem", parentPaySystem);
		_jsonstr.compose("empty", empty);
		_jsonstr.compose("balanceCurrency", balanceCurrency);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("transId", transId);
		_jparser.parseByNameThrow("statusByte", statusByte);
		_jparser.parseByNameThrow("returnedAmount", returnedAmount);
		_jparser.parseByNameThrow("resultInfos", resultInfos);
		_jparser.parseByNameThrow("parentPaySystem", parentPaySystem);
		_jparser.parseByNameThrow("empty", empty);
		_jparser.parseByNameThrow("balanceCurrency", balanceCurrency);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHOUT_COMPLETE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _jparser.validateByNameThrow("transId", transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		BYTE statusByte; _jparser.validateByNameThrow("statusByte", statusByte);
		AtfValidator::validateInt(_descr, "statusByte", statusByte, _checker, __FILE__, __LINE__);
		INT32 returnedAmount; _jparser.validateByNameThrow("returnedAmount", returnedAmount);
		AtfValidator::validateInt(_descr, "returnedAmount", returnedAmount, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< ResultInfos > resultInfos; _jparser.validateByNameThrow("resultInfos", resultInfos);
		AtfValidator::validateInt(_descr, "resultInfos", resultInfos.size(), _checker, __FILE__, __LINE__);
		BYTE parentPaySystem; _jparser.validateByNameThrow("parentPaySystem", parentPaySystem);
		AtfValidator::validateInt(_descr, "parentPaySystem", parentPaySystem, _checker, __FILE__, __LINE__);
		PString empty; _jparser.validateByNameThrow("empty", empty);
		AtfValidator::validateInt(_descr, "empty", empty.length(), _checker, __FILE__, __LINE__);
		PString balanceCurrency; _jparser.validateByNameThrow("balanceCurrency", balanceCurrency);
		AtfValidator::validateInt(_descr, "balanceCurrency", balanceCurrency.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHOUT_COMPLETE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		BYTE statusByte; _parser.parseBYTE(statusByte);
		AtfValidator::validateInt(_descr, "statusByte", statusByte, _checker, __FILE__, __LINE__);
		INT32 returnedAmount; _parser.parseINT32(returnedAmount);
		AtfValidator::validateInt(_descr, "returnedAmount", returnedAmount, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szResultInfos = Atf::LAtfVector< ResultInfos, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("resultInfos"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "resultInfos", szResultInfos, _checker, __FILE__, __LINE__);
		BYTE parentPaySystem; _parser.parseBYTE(parentPaySystem);
		AtfValidator::validateInt(_descr, "parentPaySystem", parentPaySystem, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "empty"); size_t szEmpty = strlen(_dummy);
		AtfValidator::validateInt(_descr, "empty", szEmpty, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "balanceCurrency", szBalanceCurrency, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_HISTORY2
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::Protocol_MSG_CASHIER_HISTORY2()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::clear()
{
	userId.clear();
	nLastDays = 0;
	requestFlags = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::equals(const Protocol_MSG_CASHIER_HISTORY2& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		nLastDays == _o.nLastDays &&
		requestFlags == _o.requestFlags;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_HISTORY2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_HISTORY2*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_HISTORY2).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("nLastDays=");
	_buf.appendUint(nLastDays);
	_buf.append(',');
	_buf.append("requestFlags=");
	_buf.appendUint(requestFlags);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_HISTORY2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("nLastDays", nLastDays, _buf);
	Atf::XmlElement::encodeAsXmlElement("requestFlags", requestFlags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("nLastDays"))
			{
				nLastDays = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("requestFlags"))
			{
				requestFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(nLastDays);
	_msg.composeUINT32(requestFlags);
}

void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(nLastDays);
	_parser.parseUINT32(requestFlags);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("nLastDays", nLastDays);
	_jsonstr.compose("requestFlags", requestFlags);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("nLastDays", nLastDays);
	_jparser.parseByNameThrow("requestFlags", requestFlags);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_HISTORY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 nLastDays; _jparser.validateByNameThrow("nLastDays", nLastDays);
	AtfValidator::validateIntMax(_descr, "nLastDays", nLastDays, 400, _checker, __FILE__, __LINE__);
	UINT32 requestFlags; _jparser.validateByNameThrow("requestFlags", requestFlags);
	AtfValidator::validateIntMax(_descr, "requestFlags", requestFlags, 1, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_HISTORY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 nLastDays; _parser.parseUINT32(nLastDays);
	AtfValidator::validateIntMax(_descr, "nLastDays", nLastDays, 400, _checker, __FILE__, __LINE__);
	UINT32 requestFlags; _parser.parseUINT32(requestFlags);
	AtfValidator::validateIntMax(_descr, "requestFlags", requestFlags, 1, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashTransactionWithReferenceBody
//=================================================================

CashierServer::cli::CashTransactionWithReferenceBody::CashTransactionWithReferenceBody()
{
	clear();
}

void CashierServer::cli::CashTransactionWithReferenceBody::clear()
{
	typeDescr.clear();
	transAcctAmount = 0;
	zero = 0;
	cardMaskedOrReference.clear();
	transId = 0;
	normalizedBalanceCurrency.clear();
	descriptor.clear();
	transConverted = 0;
	transCurrency.clear();
	cardTypeByte = 0;
	referenceHint.clear();
	historyFlags = 0;
}

bool CashierServer::cli::CashTransactionWithReferenceBody::equals(const CashTransactionWithReferenceBody& _o) const
{
	return Atf::atfPStringEquals(typeDescr, _o.typeDescr) &&
		transAcctAmount == _o.transAcctAmount &&
		zero == _o.zero &&
		Atf::atfPStringEquals(cardMaskedOrReference, _o.cardMaskedOrReference) &&
		transId == _o.transId &&
		Atf::atfPStringEquals(normalizedBalanceCurrency, _o.normalizedBalanceCurrency) &&
		Atf::atfPStringEquals(descriptor, _o.descriptor) &&
		transConverted == _o.transConverted &&
		Atf::atfPStringEquals(transCurrency, _o.transCurrency) &&
		cardTypeByte == _o.cardTypeByte &&
		Atf::atfPStringEquals(referenceHint, _o.referenceHint) &&
		historyFlags == _o.historyFlags;
}

const char *CashierServer::cli::CashTransactionWithReferenceBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("typeDescr=");
	_buf.append(typeDescr);
	_buf.append(',');
	_buf.append("transAcctAmount=");
	_buf.appendInt(transAcctAmount);
	_buf.append(',');
	_buf.append("zero=");
	_buf.appendUint(zero);
	_buf.append(',');
	_buf.append("cardMaskedOrReference=");
	_buf.append(cardMaskedOrReference);
	_buf.append(',');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("normalizedBalanceCurrency=");
	_buf.append(normalizedBalanceCurrency);
	_buf.append(',');
	_buf.append("descriptor=");
	_buf.append(descriptor);
	_buf.append(',');
	_buf.append("transConverted=");
	_buf.appendInt(transConverted);
	_buf.append(',');
	_buf.append("transCurrency=");
	_buf.append(transCurrency);
	_buf.append(',');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	_buf.append(',');
	_buf.append("referenceHint=");
	_buf.append(referenceHint);
	_buf.append(',');
	_buf.append("historyFlags=");
	_buf.appendUint(historyFlags);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashTransactionWithReferenceBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("typeDescr", typeDescr, _buf);
	Atf::XmlElement::encodeAsXmlElement("transAcctAmount", transAcctAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("zero", zero, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardMaskedOrReference", cardMaskedOrReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
	Atf::XmlElement::encodeAsXmlElement("normalizedBalanceCurrency", normalizedBalanceCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("descriptor", descriptor, _buf);
	Atf::XmlElement::encodeAsXmlElement("transConverted", transConverted, _buf);
	Atf::XmlElement::encodeAsXmlElement("transCurrency", transCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardTypeByte", cardTypeByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("referenceHint", referenceHint, _buf);
	Atf::XmlElement::encodeAsXmlElement("historyFlags", historyFlags, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashTransactionWithReferenceBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("typeDescr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, typeDescr)) return false;
		}
		else if (_element.equals("transAcctAmount"))
		{
			transAcctAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("zero"))
		{
			zero = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cardMaskedOrReference"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cardMaskedOrReference)) return false;
		}
		else if (_element.equals("transId"))
		{
			transId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("normalizedBalanceCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, normalizedBalanceCurrency)) return false;
		}
		else if (_element.equals("descriptor"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, descriptor)) return false;
		}
		else if (_element.equals("transConverted"))
		{
			transConverted = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("transCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, transCurrency)) return false;
		}
		else if (_element.equals("cardTypeByte"))
		{
			cardTypeByte = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("referenceHint"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, referenceHint)) return false;
		}
		else if (_element.equals("historyFlags"))
		{
			historyFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashTransactionWithReferenceBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashTransactionWithReferenceBody())) // not empty
	{
		_body.composeString(typeDescr);
		_body.composeINT32(transAcctAmount);
		_body.composeUINT32(zero);
		_body.composeString(cardMaskedOrReference);
		_body.composeUINT32(transId);
		_body.composeString(normalizedBalanceCurrency);
		_body.composeString(descriptor);
		_body.composeINT32(transConverted);
		_body.composeString(transCurrency);
		_body.composeBYTE(cardTypeByte);
		_body.composeString(referenceHint);
		_body.composeUINT32(historyFlags);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashTransactionWithReferenceBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(typeDescr);
	_parser0.parseINT32(transAcctAmount);
	_parser0.parseUINT32(zero);
	_parser0.parseStringP(cardMaskedOrReference);
	_parser0.parseUINT32(transId);
	_parser0.parseStringP(normalizedBalanceCurrency);
	_parser0.parseStringP(descriptor);
	_parser0.parseINT32(transConverted);
	_parser0.parseStringP(transCurrency);
	_parser0.parseBYTE(cardTypeByte);
	_parser0.parseStringP(referenceHint);
	_parser0.parseUINT32(historyFlags);
}

const char *CashierServer::cli::CashTransactionWithReferenceBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("typeDescr", typeDescr);
	_jsonstr.compose("transAcctAmount", transAcctAmount);
	_jsonstr.compose("zero", zero);
	_jsonstr.compose("cardMaskedOrReference", cardMaskedOrReference);
	_jsonstr.compose("transId", transId);
	_jsonstr.compose("normalizedBalanceCurrency", normalizedBalanceCurrency);
	_jsonstr.compose("descriptor", descriptor);
	_jsonstr.compose("transConverted", transConverted);
	_jsonstr.compose("transCurrency", transCurrency);
	_jsonstr.compose("cardTypeByte", cardTypeByte);
	_jsonstr.compose("referenceHint", referenceHint);
	_jsonstr.compose("historyFlags", historyFlags);
	return _buf.c_str();
}

void CashierServer::cli::CashTransactionWithReferenceBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("typeDescr", typeDescr);
	_jparser.parseByNameThrow("transAcctAmount", transAcctAmount);
	_jparser.parseByNameThrow("zero", zero);
	_jparser.parseByNameThrow("cardMaskedOrReference", cardMaskedOrReference);
	_jparser.parseByNameThrow("transId", transId);
	_jparser.parseByNameThrow("normalizedBalanceCurrency", normalizedBalanceCurrency);
	_jparser.parseByNameThrow("descriptor", descriptor);
	_jparser.parseByNameThrow("transConverted", transConverted);
	_jparser.parseByNameThrow("transCurrency", transCurrency);
	_jparser.parseByNameThrow("cardTypeByte", cardTypeByte);
	_jparser.parseByNameThrow("referenceHint", referenceHint);
	_jparser.parseByNameThrow("historyFlags", historyFlags);
}

/* static */ void CashierServer::cli::CashTransactionWithReferenceBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString typeDescr; _jparser.validateByNameThrow("typeDescr", typeDescr);
	AtfValidator::validateInt(_descr, "typeDescr", typeDescr.length(), _checker, __FILE__, __LINE__);
	INT32 transAcctAmount; _jparser.validateByNameThrow("transAcctAmount", transAcctAmount);
	AtfValidator::validateInt(_descr, "transAcctAmount", transAcctAmount, _checker, __FILE__, __LINE__);
	UINT32 zero; _jparser.validateByNameThrow("zero", zero);
	AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
	PString cardMaskedOrReference; _jparser.validateByNameThrow("cardMaskedOrReference", cardMaskedOrReference);
	AtfValidator::validateInt(_descr, "cardMaskedOrReference", cardMaskedOrReference.length(), _checker, __FILE__, __LINE__);
	UINT32 transId; _jparser.validateByNameThrow("transId", transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	PString normalizedBalanceCurrency; _jparser.validateByNameThrow("normalizedBalanceCurrency", normalizedBalanceCurrency);
	AtfValidator::validateInt(_descr, "normalizedBalanceCurrency", normalizedBalanceCurrency.length(), _checker, __FILE__, __LINE__);
	PString descriptor; _jparser.validateByNameThrow("descriptor", descriptor);
	AtfValidator::validateInt(_descr, "descriptor", descriptor.length(), _checker, __FILE__, __LINE__);
	INT32 transConverted; _jparser.validateByNameThrow("transConverted", transConverted);
	AtfValidator::validateInt(_descr, "transConverted", transConverted, _checker, __FILE__, __LINE__);
	PString transCurrency; _jparser.validateByNameThrow("transCurrency", transCurrency);
	AtfValidator::validateInt(_descr, "transCurrency", transCurrency.length(), _checker, __FILE__, __LINE__);
	BYTE cardTypeByte; _jparser.validateByNameThrow("cardTypeByte", cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	PString referenceHint; _jparser.validateByNameThrow("referenceHint", referenceHint);
	AtfValidator::validateInt(_descr, "referenceHint", referenceHint.length(), _checker, __FILE__, __LINE__);
	UINT32 historyFlags; _jparser.validateByNameThrow("historyFlags", historyFlags);
	AtfValidator::validateInt(_descr, "historyFlags", historyFlags, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashTransactionWithReferenceBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "typeDescr"); size_t szTypeDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "typeDescr", szTypeDescr, _checker, __FILE__, __LINE__);
	INT32 transAcctAmount; _parser0.parseINT32(transAcctAmount);
	AtfValidator::validateInt(_descr, "transAcctAmount", transAcctAmount, _checker, __FILE__, __LINE__);
	UINT32 zero; _parser0.parseUINT32(zero);
	AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "cardMaskedOrReference"); size_t szCardMaskedOrReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cardMaskedOrReference", szCardMaskedOrReference, _checker, __FILE__, __LINE__);
	UINT32 transId; _parser0.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "normalizedBalanceCurrency"); size_t szNormalizedBalanceCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "normalizedBalanceCurrency", szNormalizedBalanceCurrency, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "descriptor"); size_t szDescriptor = strlen(_dummy);
	AtfValidator::validateInt(_descr, "descriptor", szDescriptor, _checker, __FILE__, __LINE__);
	INT32 transConverted; _parser0.parseINT32(transConverted);
	AtfValidator::validateInt(_descr, "transConverted", transConverted, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "transCurrency"); size_t szTransCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "transCurrency", szTransCurrency, _checker, __FILE__, __LINE__);
	BYTE cardTypeByte; _parser0.parseBYTE(cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "referenceHint"); size_t szReferenceHint = strlen(_dummy);
	AtfValidator::validateInt(_descr, "referenceHint", szReferenceHint, _checker, __FILE__, __LINE__);
	UINT32 historyFlags; _parser0.parseUINT32(historyFlags);
	AtfValidator::validateInt(_descr, "historyFlags", historyFlags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_HISTORY2_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::Protocol_MSG_CASHIER_HISTORY2_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	transactions.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::equals(const Protocol_MSG_CASHIER_HISTORY2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		transactions.equals(_o.transactions);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_HISTORY2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_HISTORY2_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_HISTORY2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("transactions=");
		transactions.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_HISTORY2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		transactions.toXmlString("transactions", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("transactions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashTransactionWithReferenceBody, 4 > >::FromXmlString(_value, transactions)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		transactions.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		transactions.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("transactions", transactions);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("transactions", transactions);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_HISTORY2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CashTransactionWithReferenceBody > transactions; _jparser.validateByNameThrow("transactions", transactions);
		AtfValidator::validateInt(_descr, "transactions", transactions.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_HISTORY2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTransactions = Atf::LAtfVector< CashTransactionWithReferenceBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("transactions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "transactions", szTransactions, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_USER_BONUSHIST_NEW
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::clear()
{
	userId.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::equals(const Protocol_MSG_CASHIER_USER_BONUSHIST_NEW& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_USER_BONUSHIST_NEW != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_USER_BONUSHIST_NEW*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_USER_BONUSHIST_NEW).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_USER_BONUSHIST_NEW).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_BONUSHIST_NEW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_BONUSHIST_NEW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserBonusBody
//=================================================================

CashierServer::cli::UserBonusBody::UserBonusBody()
{
	clear();
}

void CashierServer::cli::UserBonusBody::clear()
{
	bonusName.clear();
	when.setNull();
	createdTransId = 0;
	bonusAmount = 0;
	fppToCollect = 0;
	fppCollected = 0;
	credited = 0;
	creditTransId = 0;
	expDate.setNull();
	currency.clear();
	bonusInTickets = 0;
	creditedTickets = 0;
	bonusClearedFlags = 0;
}

bool CashierServer::cli::UserBonusBody::equals(const UserBonusBody& _o) const
{
	return Atf::atfPStringEquals(bonusName, _o.bonusName) &&
		when.equals(_o.when) &&
		createdTransId == _o.createdTransId &&
		bonusAmount == _o.bonusAmount &&
		fppToCollect == _o.fppToCollect &&
		fppCollected == _o.fppCollected &&
		credited == _o.credited &&
		creditTransId == _o.creditTransId &&
		expDate.equals(_o.expDate) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		bonusInTickets == _o.bonusInTickets &&
		creditedTickets == _o.creditedTickets &&
		bonusClearedFlags == _o.bonusClearedFlags;
}

const char *CashierServer::cli::UserBonusBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("bonusName=");
	_buf.append(bonusName);
	_buf.append(',');
	_buf.append("when=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("createdTransId=");
	_buf.appendUint(createdTransId);
	_buf.append(',');
	_buf.append("bonusAmount=");
	_buf.appendInt(bonusAmount);
	_buf.append(',');
	_buf.append("fppToCollect=");
	_buf.appendInt(fppToCollect);
	_buf.append(',');
	_buf.append("fppCollected=");
	_buf.appendInt(fppCollected);
	_buf.append(',');
	_buf.append("credited=");
	_buf.appendInt(credited);
	_buf.append(',');
	_buf.append("creditTransId=");
	_buf.appendUint(creditTransId);
	_buf.append(',');
	_buf.append("expDate=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, expDate);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("bonusInTickets=");
	_buf.appendInt(bonusInTickets);
	_buf.append(',');
	_buf.append("creditedTickets=");
	_buf.appendInt(creditedTickets);
	_buf.append(',');
	_buf.append("bonusClearedFlags=");
	_buf.appendUint(bonusClearedFlags);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::UserBonusBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("bonusName", bonusName, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "when", when);
	Atf::XmlElement::encodeAsXmlElement("createdTransId", createdTransId, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusAmount", bonusAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppToCollect", fppToCollect, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppCollected", fppCollected, _buf);
	Atf::XmlElement::encodeAsXmlElement("credited", credited, _buf);
	Atf::XmlElement::encodeAsXmlElement("creditTransId", creditTransId, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "expDate", expDate);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusInTickets", bonusInTickets, _buf);
	Atf::XmlElement::encodeAsXmlElement("creditedTickets", creditedTickets, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusClearedFlags", bonusClearedFlags, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::UserBonusBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("bonusName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, bonusName)) return false;
		}
		else if (_element.equals("when"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, when);
		}
		else if (_element.equals("createdTransId"))
		{
			createdTransId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bonusAmount"))
		{
			bonusAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppToCollect"))
		{
			fppToCollect = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppCollected"))
		{
			fppCollected = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("credited"))
		{
			credited = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("creditTransId"))
		{
			creditTransId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("expDate"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, expDate);
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("bonusInTickets"))
		{
			bonusInTickets = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("creditedTickets"))
		{
			creditedTickets = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bonusClearedFlags"))
		{
			bonusClearedFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::UserBonusBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(UserBonusBody())) // not empty
	{
		_body.composeString(bonusName);
		_body.composeSrvTime(when);
		_body.composeUINT32(createdTransId);
		_body.composeINT32(bonusAmount);
		_body.composeINT32(fppToCollect);
		_body.composeINT32(fppCollected);
		_body.composeINT32(credited);
		_body.composeUINT32(creditTransId);
		_body.composeSrvTime(expDate);
		_body.composeString(currency);
		_body.composeINT32(bonusInTickets);
		_body.composeINT32(creditedTickets);
		_body.composeUINT32(bonusClearedFlags);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::UserBonusBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(bonusName);
	_parser0.parseSrvTime(when);
	_parser0.parseUINT32(createdTransId);
	_parser0.parseINT32(bonusAmount);
	_parser0.parseINT32(fppToCollect);
	_parser0.parseINT32(fppCollected);
	_parser0.parseINT32(credited);
	_parser0.parseUINT32(creditTransId);
	_parser0.parseSrvTime(expDate);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(bonusInTickets);
	_parser0.parseINT32(creditedTickets);
	_parser0.parseUINT32(bonusClearedFlags);
}

const char *CashierServer::cli::UserBonusBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("bonusName", bonusName);
	_jsonstr.compose("when", when);
	_jsonstr.compose("createdTransId", createdTransId);
	_jsonstr.compose("bonusAmount", bonusAmount);
	_jsonstr.compose("fppToCollect", fppToCollect);
	_jsonstr.compose("fppCollected", fppCollected);
	_jsonstr.compose("credited", credited);
	_jsonstr.compose("creditTransId", creditTransId);
	_jsonstr.compose("expDate", expDate);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("bonusInTickets", bonusInTickets);
	_jsonstr.compose("creditedTickets", creditedTickets);
	_jsonstr.compose("bonusClearedFlags", bonusClearedFlags);
	return _buf.c_str();
}

void CashierServer::cli::UserBonusBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("bonusName", bonusName);
	_jparser.parseByNameThrow("when", when);
	_jparser.parseByNameThrow("createdTransId", createdTransId);
	_jparser.parseByNameThrow("bonusAmount", bonusAmount);
	_jparser.parseByNameThrow("fppToCollect", fppToCollect);
	_jparser.parseByNameThrow("fppCollected", fppCollected);
	_jparser.parseByNameThrow("credited", credited);
	_jparser.parseByNameThrow("creditTransId", creditTransId);
	_jparser.parseByNameThrow("expDate", expDate);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("bonusInTickets", bonusInTickets);
	_jparser.parseByNameThrow("creditedTickets", creditedTickets);
	_jparser.parseByNameThrow("bonusClearedFlags", bonusClearedFlags);
}

/* static */ void CashierServer::cli::UserBonusBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString bonusName; _jparser.validateByNameThrow("bonusName", bonusName);
	AtfValidator::validateIntMax(_descr, "bonusName", bonusName.length(), 1000, _checker, __FILE__, __LINE__);
	CommSrvTime when; _jparser.validateByNameThrow("when", when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 createdTransId; _jparser.validateByNameThrow("createdTransId", createdTransId);
	AtfValidator::validateInt(_descr, "createdTransId", createdTransId, _checker, __FILE__, __LINE__);
	INT32 bonusAmount; _jparser.validateByNameThrow("bonusAmount", bonusAmount);
	AtfValidator::validateInt(_descr, "bonusAmount", bonusAmount, _checker, __FILE__, __LINE__);
	INT32 fppToCollect; _jparser.validateByNameThrow("fppToCollect", fppToCollect);
	AtfValidator::validateInt(_descr, "fppToCollect", fppToCollect, _checker, __FILE__, __LINE__);
	INT32 fppCollected; _jparser.validateByNameThrow("fppCollected", fppCollected);
	AtfValidator::validateInt(_descr, "fppCollected", fppCollected, _checker, __FILE__, __LINE__);
	INT32 credited; _jparser.validateByNameThrow("credited", credited);
	AtfValidator::validateInt(_descr, "credited", credited, _checker, __FILE__, __LINE__);
	UINT32 creditTransId; _jparser.validateByNameThrow("creditTransId", creditTransId);
	AtfValidator::validateInt(_descr, "creditTransId", creditTransId, _checker, __FILE__, __LINE__);
	CommSrvTime expDate; _jparser.validateByNameThrow("expDate", expDate);
	AtfValidator::validateSrvDateTime(_descr, "expDate", expDate, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 bonusInTickets; _jparser.validateByNameThrow("bonusInTickets", bonusInTickets);
	AtfValidator::validateInt(_descr, "bonusInTickets", bonusInTickets, _checker, __FILE__, __LINE__);
	INT32 creditedTickets; _jparser.validateByNameThrow("creditedTickets", creditedTickets);
	AtfValidator::validateInt(_descr, "creditedTickets", creditedTickets, _checker, __FILE__, __LINE__);
	UINT32 bonusClearedFlags; _jparser.validateByNameThrow("bonusClearedFlags", bonusClearedFlags);
	AtfValidator::validateInt(_descr, "bonusClearedFlags", bonusClearedFlags, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::UserBonusBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "bonusName"); size_t szBonusName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusName", szBonusName, 1000, _checker, __FILE__, __LINE__);
	CommSrvTime when; _parser0.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 createdTransId; _parser0.parseUINT32(createdTransId);
	AtfValidator::validateInt(_descr, "createdTransId", createdTransId, _checker, __FILE__, __LINE__);
	INT32 bonusAmount; _parser0.parseINT32(bonusAmount);
	AtfValidator::validateInt(_descr, "bonusAmount", bonusAmount, _checker, __FILE__, __LINE__);
	INT32 fppToCollect; _parser0.parseINT32(fppToCollect);
	AtfValidator::validateInt(_descr, "fppToCollect", fppToCollect, _checker, __FILE__, __LINE__);
	INT32 fppCollected; _parser0.parseINT32(fppCollected);
	AtfValidator::validateInt(_descr, "fppCollected", fppCollected, _checker, __FILE__, __LINE__);
	INT32 credited; _parser0.parseINT32(credited);
	AtfValidator::validateInt(_descr, "credited", credited, _checker, __FILE__, __LINE__);
	UINT32 creditTransId; _parser0.parseUINT32(creditTransId);
	AtfValidator::validateInt(_descr, "creditTransId", creditTransId, _checker, __FILE__, __LINE__);
	CommSrvTime expDate; _parser0.parseSrvTime(expDate);
	AtfValidator::validateSrvDateTime(_descr, "expDate", expDate, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 bonusInTickets; _parser0.parseINT32(bonusInTickets);
	AtfValidator::validateInt(_descr, "bonusInTickets", bonusInTickets, _checker, __FILE__, __LINE__);
	INT32 creditedTickets; _parser0.parseINT32(creditedTickets);
	AtfValidator::validateInt(_descr, "creditedTickets", creditedTickets, _checker, __FILE__, __LINE__);
	UINT32 bonusClearedFlags; _parser0.parseUINT32(bonusClearedFlags);
	AtfValidator::validateInt(_descr, "bonusClearedFlags", bonusClearedFlags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	bonuses.clear();
	bonusDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::equals(const Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		bonuses.equals(_o.bonuses) &&
		Atf::atfPStringEquals(bonusDescr, _o.bonusDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_USER_BONUSHIST_NEW_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_USER_BONUSHIST_NEW_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("bonuses=");
		bonuses.toTraceString(_buf);
		_buf.append(',');
		_buf.append("bonusDescr=");
		_buf.append(bonusDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_USER_BONUSHIST_NEW_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		bonuses.toXmlString("bonuses", _buf);
		Atf::XmlElement::encodeAsXmlElement("bonusDescr", bonusDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("bonuses"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserBonusBody, 4 > >::FromXmlString(_value, bonuses)) return false;
			}
			else if (_element.equals("bonusDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bonusDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		bonuses.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(bonusDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		bonuses.parseMsg(_parser);
		_parser.parseStringP(bonusDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("bonuses", bonuses);
		_jsonstr.compose("bonusDescr", bonusDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("bonuses", bonuses);
		_jparser.parseByNameThrow("bonusDescr", bonusDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_BONUSHIST_NEW_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< UserBonusBody > bonuses; _jparser.validateByNameThrow("bonuses", bonuses);
		AtfValidator::validateInt(_descr, "bonuses", bonuses.size(), _checker, __FILE__, __LINE__);
		PString bonusDescr; _jparser.validateByNameThrow("bonusDescr", bonusDescr);
		AtfValidator::validateInt(_descr, "bonusDescr", bonusDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_BONUSHIST_NEW_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szBonuses = Atf::LAtfVector< UserBonusBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("bonuses"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "bonuses", szBonuses, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bonusDescr"); size_t szBonusDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bonusDescr", szBonusDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PRE_CASHIN2
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::Protocol_MSG_CASHIER_PRE_CASHIN2()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::clear()
{
	userId.clear();
	accountAmount = 0;
	bytePaySystem = 0;
	processorCurrency.clear();
	bonusCode.clear();
	accountCurrency.clear();
	validationDigits = 0;
	validationAttempts = 0;
	processorAmount = 0;
	nonZeroPaysystemFeeApplies = false;
	cardNum.clear();
	encryptedCardNum.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::equals(const Protocol_MSG_CASHIER_PRE_CASHIN2& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		accountAmount == _o.accountAmount &&
		bytePaySystem == _o.bytePaySystem &&
		Atf::atfPStringEquals(processorCurrency, _o.processorCurrency) &&
		Atf::atfPStringEquals(bonusCode, _o.bonusCode) &&
		Atf::atfPStringEquals(accountCurrency, _o.accountCurrency) &&
		validationDigits == _o.validationDigits &&
		validationAttempts == _o.validationAttempts &&
		processorAmount == _o.processorAmount &&
		nonZeroPaysystemFeeApplies == _o.nonZeroPaysystemFeeApplies &&
		Atf::atfPStringEquals(cardNum, _o.cardNum) &&
		encryptedCardNum.size() == _o.encryptedCardNum.size() && memcmp(encryptedCardNum.ptr(), _o.encryptedCardNum.ptr(), encryptedCardNum.size()) == 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PRE_CASHIN2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PRE_CASHIN2*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PRE_CASHIN2).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("accountAmount=");
	_buf.appendInt(accountAmount);
	_buf.append(',');
	_buf.append("bytePaySystem=");
	_buf.appendUint(bytePaySystem);
	_buf.append(',');
	_buf.append("processorCurrency=");
	_buf.append(processorCurrency);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("accountCurrency=");
	_buf.append(accountCurrency);
	_buf.append(',');
	_buf.append("validationDigits=");
	_buf.appendUint(validationDigits);
	_buf.append(',');
	_buf.append("validationAttempts=");
	_buf.appendUint(validationAttempts);
	_buf.append(',');
	_buf.append("processorAmount=");
	_buf.appendInt(processorAmount);
	_buf.append(',');
	_buf.append("nonZeroPaysystemFeeApplies=");
	_buf.appendUint(nonZeroPaysystemFeeApplies);
	_buf.append(',');
	_buf.append("cardNum=");
	_buf.append(cardNum);
	_buf.append(',');
	_buf.append("encryptedCardNum=");
	Atf::AtfTempl<PBlock>::ToTraceString(_buf, encryptedCardNum);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PRE_CASHIN2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("accountAmount", accountAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("bytePaySystem", bytePaySystem, _buf);
	Atf::XmlElement::encodeAsXmlElement("processorCurrency", processorCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusCode", bonusCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("accountCurrency", accountCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("validationDigits", validationDigits, _buf);
	Atf::XmlElement::encodeAsXmlElement("validationAttempts", validationAttempts, _buf);
	Atf::XmlElement::encodeAsXmlElement("processorAmount", processorAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("nonZeroPaysystemFeeApplies", nonZeroPaysystemFeeApplies, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardNum", cardNum, _buf);
	Atf::XmlElement::encodeAsXmlElement("encryptedCardNum", encryptedCardNum, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("accountAmount"))
			{
				accountAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bytePaySystem"))
			{
				bytePaySystem = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("processorCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, processorCurrency)) return false;
			}
			else if (_element.equals("bonusCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bonusCode)) return false;
			}
			else if (_element.equals("accountCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, accountCurrency)) return false;
			}
			else if (_element.equals("validationDigits"))
			{
				validationDigits = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("validationAttempts"))
			{
				validationAttempts = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("processorAmount"))
			{
				processorAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("nonZeroPaysystemFeeApplies"))
			{
				nonZeroPaysystemFeeApplies = (*_value.ptr() == '1');
			}
			else if (_element.equals("cardNum"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, cardNum)) return false;
			}
			else if (_element.equals("encryptedCardNum"))
			{
				Atf::XmlElement::_movePBlockWithNullStrip(_value, encryptedCardNum);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeINT32(accountAmount);
	_msg.composeBYTE(bytePaySystem);
	_msg.composeString(processorCurrency);
	_msg.composeString(bonusCode);
	_msg.composeString(accountCurrency);
	CommMsgBody _msg0;
	_msg0.composeUINT32(validationDigits);
	_msg0.composeUINT32(validationAttempts);
	_msg.composeMsgBody(_msg0);
	_msg.composeINT32(processorAmount);
	_msg.composeBOOL(nonZeroPaysystemFeeApplies);
	_msg.composeString(cardNum);
	_msg._composeVarBlock(encryptedCardNum.ptr(), encryptedCardNum.size());
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(accountAmount);
	_parser.parseBYTE(bytePaySystem);
	_parser.parseStringP(processorCurrency);
	_parser.parseStringP(bonusCode);
	_parser.parseStringP(accountCurrency);
	parseAnonymousMsgBody0(_parser);
	_parser.parseINT32(processorAmount);
	_parser.parseBOOL(nonZeroPaysystemFeeApplies);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(cardNum);
	if(_parser.parseEnded()) return;
	_parser.parsePBlock(encryptedCardNum);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("accountAmount", accountAmount);
	_jsonstr.compose("bytePaySystem", bytePaySystem);
	_jsonstr.compose("processorCurrency", processorCurrency);
	_jsonstr.compose("bonusCode", bonusCode);
	_jsonstr.compose("accountCurrency", accountCurrency);
	_jsonstr.compose("validationDigits", validationDigits);
	_jsonstr.compose("validationAttempts", validationAttempts);
	_jsonstr.compose("processorAmount", processorAmount);
	_jsonstr.compose("nonZeroPaysystemFeeApplies", nonZeroPaysystemFeeApplies);
	_jsonstr.compose("cardNum", cardNum);
	_jsonstr.compose("encryptedCardNum", encryptedCardNum);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("accountAmount", accountAmount);
	_jparser.parseByNameThrow("bytePaySystem", bytePaySystem);
	_jparser.parseByNameThrow("processorCurrency", processorCurrency);
	_jparser.parseByNameThrow("bonusCode", bonusCode);
	_jparser.parseByNameThrow("accountCurrency", accountCurrency);
	_jparser.parseByNameThrow("validationDigits", validationDigits);
	_jparser.parseByNameThrow("validationAttempts", validationAttempts);
	_jparser.parseByNameThrow("processorAmount", processorAmount);
	_jparser.parseByNameThrow("nonZeroPaysystemFeeApplies", nonZeroPaysystemFeeApplies);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("cardNum", cardNum);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("encryptedCardNum", encryptedCardNum);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PRE_CASHIN2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 accountAmount; _jparser.validateByNameThrow("accountAmount", accountAmount);
	AtfValidator::validateIntRange(_descr, "accountAmount", accountAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	BYTE bytePaySystem; _jparser.validateByNameThrow("bytePaySystem", bytePaySystem);
	AtfValidator::validateIntRange(_descr, "bytePaySystem", bytePaySystem, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	PString processorCurrency; _jparser.validateByNameThrow("processorCurrency", processorCurrency);
	AtfValidator::validateIntMax(_descr, "processorCurrency", processorCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	PString bonusCode; _jparser.validateByNameThrow("bonusCode", bonusCode);
	AtfValidator::validateIntMax(_descr, "bonusCode", bonusCode.length(), 40, _checker, __FILE__, __LINE__);
	PString accountCurrency; _jparser.validateByNameThrow("accountCurrency", accountCurrency);
	AtfValidator::validateIntMax(_descr, "accountCurrency", accountCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	UINT32 validationDigits; _jparser.validateByNameThrow("validationDigits", validationDigits);
	AtfValidator::validateInt(_descr, "validationDigits", validationDigits, _checker, __FILE__, __LINE__);
	UINT32 validationAttempts; _jparser.validateByNameThrow("validationAttempts", validationAttempts);
	AtfValidator::validateInt(_descr, "validationAttempts", validationAttempts, _checker, __FILE__, __LINE__);
	INT32 processorAmount; _jparser.validateByNameThrow("processorAmount", processorAmount);
	AtfValidator::validateIntRange(_descr, "processorAmount", processorAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	bool nonZeroPaysystemFeeApplies; _jparser.validateByNameThrow("nonZeroPaysystemFeeApplies", nonZeroPaysystemFeeApplies);
	AtfValidator::validateInt(_descr, "nonZeroPaysystemFeeApplies", nonZeroPaysystemFeeApplies, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString cardNum; _jparser.validateByNameThrow("cardNum", cardNum);
	AtfValidator::validateIntMax(_descr, "cardNum", cardNum.length(), CARDNUM_LEN, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PBlock encryptedCardNum; _jparser.validateByNameThrow("encryptedCardNum", encryptedCardNum);
	AtfValidator::validateIntMax(_descr, "encryptedCardNum", encryptedCardNum.size(), 4000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PRE_CASHIN2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 accountAmount; _parser.parseINT32(accountAmount);
	AtfValidator::validateIntRange(_descr, "accountAmount", accountAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	BYTE bytePaySystem; _parser.parseBYTE(bytePaySystem);
	AtfValidator::validateIntRange(_descr, "bytePaySystem", bytePaySystem, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "processorCurrency"); size_t szProcessorCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "processorCurrency", szProcessorCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, 40, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "accountCurrency"); size_t szAccountCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "accountCurrency", szAccountCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 processorAmount; _parser.parseINT32(processorAmount);
	AtfValidator::validateIntRange(_descr, "processorAmount", processorAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	bool nonZeroPaysystemFeeApplies; _parser.parseBOOL(nonZeroPaysystemFeeApplies);
	AtfValidator::validateInt(_descr, "nonZeroPaysystemFeeApplies", nonZeroPaysystemFeeApplies, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "cardNum"); size_t szCardNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cardNum", szCardNum, CARDNUM_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	const BYTE* encryptedCardNum; size_t szEncryptedCardNum; _parser._parseVarBlock(encryptedCardNum, szEncryptedCardNum);  /*encryptedCardNum*/
	AtfValidator::validateIntMax(_descr, "encryptedCardNum", szEncryptedCardNum, 4000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(validationDigits);
	_parser0.parseUINT32(validationAttempts);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 validationDigits; _parser0.parseUINT32(validationDigits);
	AtfValidator::validateInt(_descr, "validationDigits", validationDigits, _checker, __FILE__, __LINE__);
	UINT32 validationAttempts; _parser0.parseUINT32(validationAttempts);
	AtfValidator::validateInt(_descr, "validationAttempts", validationAttempts, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierTicketBody
//=================================================================

CashierServer::cli::CashierTicketBody::CashierTicketBody()
{
	clear();
}

void CashierServer::cli::CashierTicketBody::clear()
{
	admission.clear();
	ticketsCount = 0;
}

bool CashierServer::cli::CashierTicketBody::equals(const CashierTicketBody& _o) const
{
	return Atf::atfPStringEquals(admission, _o.admission) &&
		ticketsCount == _o.ticketsCount;
}

const char *CashierServer::cli::CashierTicketBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("admission=");
	_buf.append(admission);
	_buf.append(',');
	_buf.append("ticketsCount=");
	_buf.appendInt(ticketsCount);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierTicketBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("admission", admission, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketsCount", ticketsCount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierTicketBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("admission"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, admission)) return false;
		}
		else if (_element.equals("ticketsCount"))
		{
			ticketsCount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierTicketBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierTicketBody())) // not empty
	{
		_body.composeString(admission);
		_body.composeINT32(ticketsCount);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierTicketBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(admission);
	_parser0.parseINT32(ticketsCount);
}

const char *CashierServer::cli::CashierTicketBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("admission", admission);
	_jsonstr.compose("ticketsCount", ticketsCount);
	return _buf.c_str();
}

void CashierServer::cli::CashierTicketBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("admission", admission);
	_jparser.parseByNameThrow("ticketsCount", ticketsCount);
}

/* static */ void CashierServer::cli::CashierTicketBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString admission; _jparser.validateByNameThrow("admission", admission);
	AtfValidator::validateInt(_descr, "admission", admission.length(), _checker, __FILE__, __LINE__);
	INT32 ticketsCount; _jparser.validateByNameThrow("ticketsCount", ticketsCount);
	AtfValidator::validateInt(_descr, "ticketsCount", ticketsCount, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierTicketBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "admission"); size_t szAdmission = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admission", szAdmission, _checker, __FILE__, __LINE__);
	INT32 ticketsCount; _parser0.parseINT32(ticketsCount);
	AtfValidator::validateInt(_descr, "ticketsCount", ticketsCount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierGatewayDisclaimerBodyOne
//=================================================================

CashierServer::cli::CashierGatewayDisclaimerBodyOne::CashierGatewayDisclaimerBodyOne()
{
	clear();
}

void CashierServer::cli::CashierGatewayDisclaimerBodyOne::clear()
{
	text.clear();
}

bool CashierServer::cli::CashierGatewayDisclaimerBodyOne::equals(const CashierGatewayDisclaimerBodyOne& _o) const
{
	return Atf::atfPStringEquals(text, _o.text);
}

const char *CashierServer::cli::CashierGatewayDisclaimerBodyOne::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("text=");
	_buf.append(text);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierGatewayDisclaimerBodyOne::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("text", text, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierGatewayDisclaimerBodyOne::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("text"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, text)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierGatewayDisclaimerBodyOne::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierGatewayDisclaimerBodyOne())) // not empty
	{
		_body.composeString(text);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierGatewayDisclaimerBodyOne::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(text);
}

const char *CashierServer::cli::CashierGatewayDisclaimerBodyOne::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("text", text);
	return _buf.c_str();
}

void CashierServer::cli::CashierGatewayDisclaimerBodyOne::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("text", text);
}

/* static */ void CashierServer::cli::CashierGatewayDisclaimerBodyOne::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString text; _jparser.validateByNameThrow("text", text);
	AtfValidator::validateInt(_descr, "text", text.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierGatewayDisclaimerBodyOne::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "text"); size_t szText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "text", szText, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierGatewayDisclaimerBody
//=================================================================

CashierServer::cli::CashierGatewayDisclaimerBody::CashierGatewayDisclaimerBody()
{
	clear();
}

void CashierServer::cli::CashierGatewayDisclaimerBody::clear()
{
	header.clear();
	text.clear();
	buttons.clear();
}

bool CashierServer::cli::CashierGatewayDisclaimerBody::equals(const CashierGatewayDisclaimerBody& _o) const
{
	return Atf::atfPStringEquals(header, _o.header) &&
		Atf::atfPStringEquals(text, _o.text) &&
		buttons.equals(_o.buttons);
}

const char *CashierServer::cli::CashierGatewayDisclaimerBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	_buf.append(header);
	_buf.append(',');
	_buf.append("text=");
	_buf.append(text);
	_buf.append(',');
	_buf.append("buttons=");
	buttons.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierGatewayDisclaimerBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("header", header, _buf);
	Atf::XmlElement::encodeAsXmlElement("text", text, _buf);
	buttons.toXmlString("buttons", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierGatewayDisclaimerBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, header)) return false;
		}
		else if (_element.equals("text"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, text)) return false;
		}
		else if (_element.equals("buttons"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CashierGatewayDisclaimerBodyOne, 4 > >::FromXmlString(_value, buttons)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierGatewayDisclaimerBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierGatewayDisclaimerBody())) // not empty
	{
		_body.composeString(header);
		_body.composeString(text);
		buttons.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierGatewayDisclaimerBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(header);
	_parser0.parseStringP(text);
	buttons.parseMsg(_parser0);
}

const char *CashierServer::cli::CashierGatewayDisclaimerBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("text", text);
	_jsonstr.compose("buttons", buttons);
	return _buf.c_str();
}

void CashierServer::cli::CashierGatewayDisclaimerBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("text", text);
	_jparser.parseByNameThrow("buttons", buttons);
}

/* static */ void CashierServer::cli::CashierGatewayDisclaimerBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString header; _jparser.validateByNameThrow("header", header);
	AtfValidator::validateInt(_descr, "header", header.length(), _checker, __FILE__, __LINE__);
	PString text; _jparser.validateByNameThrow("text", text);
	AtfValidator::validateInt(_descr, "text", text.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< CashierGatewayDisclaimerBodyOne > buttons; _jparser.validateByNameThrow("buttons", buttons);
	AtfValidator::validateInt(_descr, "buttons", buttons.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierGatewayDisclaimerBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "header"); size_t szHeader = strlen(_dummy);
	AtfValidator::validateInt(_descr, "header", szHeader, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "text"); size_t szText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "text", szText, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szButtons = Atf::LAtfVector< CashierGatewayDisclaimerBodyOne, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("buttons"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "buttons", szButtons, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	bestBonusAmount = 0;
	bestBonusFppToEarn = 0;
	availAmount = 0;
	bestBonusId = 0;
	bestBonusPercent = 0;
	bestBonusMaxAvailableAmount = 0;
	bestBonusName.clear();
	bestBonusStart.setNull();
	bestBonusEnd.setNull();
	bestBonusUrl.clear();
	zero = 0;
	bestBonusReleasePortion = 0;
	bestBonusFppReleasePortion = 0;
	bestBonusBonusFlags = 0;
	bestBonusMaxNumDepositsLeft = 0;
	bestBonusLastAllowedDepositTime.setNull();
	bestBonusCurrency.clear();
	bestBonusDaysToDeposit = 0;
	bestBonusMaxDepositNumber = 0;
	acctAmount = 0;
	beDepositExceedsLossLimit = false;
	ticketOnlyBonusBodies.clear();
	rollMsgBody.clear();
	disclaimerMsgBody.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::equals(const Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		bestBonusAmount == _o.bestBonusAmount &&
		bestBonusFppToEarn == _o.bestBonusFppToEarn &&
		availAmount == _o.availAmount &&
		bestBonusId == _o.bestBonusId &&
		bestBonusPercent == _o.bestBonusPercent &&
		bestBonusMaxAvailableAmount == _o.bestBonusMaxAvailableAmount &&
		Atf::atfPStringEquals(bestBonusName, _o.bestBonusName) &&
		bestBonusStart.equals(_o.bestBonusStart) &&
		bestBonusEnd.equals(_o.bestBonusEnd) &&
		Atf::atfPStringEquals(bestBonusUrl, _o.bestBonusUrl) &&
		zero == _o.zero &&
		bestBonusReleasePortion == _o.bestBonusReleasePortion &&
		bestBonusFppReleasePortion == _o.bestBonusFppReleasePortion &&
		bestBonusBonusFlags == _o.bestBonusBonusFlags &&
		bestBonusMaxNumDepositsLeft == _o.bestBonusMaxNumDepositsLeft &&
		bestBonusLastAllowedDepositTime.equals(_o.bestBonusLastAllowedDepositTime) &&
		Atf::atfPStringEquals(bestBonusCurrency, _o.bestBonusCurrency) &&
		bestBonusDaysToDeposit == _o.bestBonusDaysToDeposit &&
		bestBonusMaxDepositNumber == _o.bestBonusMaxDepositNumber &&
		acctAmount == _o.acctAmount &&
		beDepositExceedsLossLimit == _o.beDepositExceedsLossLimit &&
		ticketOnlyBonusBodies.equals(_o.ticketOnlyBonusBodies) &&
		rollMsgBody.equals(_o.rollMsgBody) &&
		disclaimerMsgBody.equals(_o.disclaimerMsgBody);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PRE_CASHIN2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PRE_CASHIN2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("bestBonusAmount=");
		_buf.appendInt(bestBonusAmount);
		_buf.append(',');
		_buf.append("bestBonusFppToEarn=");
		_buf.appendInt(bestBonusFppToEarn);
		_buf.append(',');
		_buf.append("availAmount=");
		_buf.appendInt(availAmount);
		_buf.append(',');
		_buf.append("bestBonusId=");
		_buf.appendUint(bestBonusId);
		_buf.append(',');
		_buf.append("bestBonusPercent=");
		_buf.appendInt(bestBonusPercent);
		_buf.append(',');
		_buf.append("bestBonusMaxAvailableAmount=");
		_buf.appendInt(bestBonusMaxAvailableAmount);
		_buf.append(',');
		_buf.append("bestBonusName=");
		_buf.append(bestBonusName);
		_buf.append(',');
		_buf.append("bestBonusStart=");
		Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, bestBonusStart);
		_buf.append(',');
		_buf.append("bestBonusEnd=");
		Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, bestBonusEnd);
		_buf.append(',');
		_buf.append("bestBonusUrl=");
		_buf.append(bestBonusUrl);
		_buf.append(',');
		_buf.append("zero=");
		_buf.appendUint(zero);
		_buf.append(',');
		_buf.append("bestBonusReleasePortion=");
		_buf.appendInt(bestBonusReleasePortion);
		_buf.append(',');
		_buf.append("bestBonusFppReleasePortion=");
		_buf.appendInt(bestBonusFppReleasePortion);
		_buf.append(',');
		_buf.append("bestBonusBonusFlags=");
		_buf.appendUint(bestBonusBonusFlags);
		_buf.append(',');
		_buf.append("bestBonusMaxNumDepositsLeft=");
		_buf.appendUint(bestBonusMaxNumDepositsLeft);
		_buf.append(',');
		_buf.append("bestBonusLastAllowedDepositTime=");
		Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, bestBonusLastAllowedDepositTime);
		_buf.append(',');
		_buf.append("bestBonusCurrency=");
		_buf.append(bestBonusCurrency);
		_buf.append(',');
		_buf.append("bestBonusDaysToDeposit=");
		_buf.appendInt(bestBonusDaysToDeposit);
		_buf.append(',');
		_buf.append("bestBonusMaxDepositNumber=");
		_buf.appendInt(bestBonusMaxDepositNumber);
		_buf.append(',');
		_buf.append("acctAmount=");
		_buf.appendInt(acctAmount);
		_buf.append(',');
		_buf.append("beDepositExceedsLossLimit=");
		_buf.appendUint(beDepositExceedsLossLimit);
		_buf.append(',');
		_buf.append("ticketOnlyBonusBodies=");
		ticketOnlyBonusBodies.toTraceString(_buf);
		_buf.append(',');
		_buf.append("rollMsgBody=");
		rollMsgBody.toTraceString(_buf);
		_buf.append(',');
		_buf.append("disclaimerMsgBody=");
		disclaimerMsgBody.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PRE_CASHIN2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("bestBonusAmount", bestBonusAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("bestBonusFppToEarn", bestBonusFppToEarn, _buf);
		Atf::XmlElement::encodeAsXmlElement("availAmount", availAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("bestBonusId", bestBonusId, _buf);
		Atf::XmlElement::encodeAsXmlElement("bestBonusPercent", bestBonusPercent, _buf);
		Atf::XmlElement::encodeAsXmlElement("bestBonusMaxAvailableAmount", bestBonusMaxAvailableAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("bestBonusName", bestBonusName, _buf);
		Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "bestBonusStart", bestBonusStart);
		Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "bestBonusEnd", bestBonusEnd);
		Atf::XmlElement::encodeAsXmlElement("bestBonusUrl", bestBonusUrl, _buf);
		Atf::XmlElement::encodeAsXmlElement("zero", zero, _buf);
		Atf::XmlElement::encodeAsXmlElement("bestBonusReleasePortion", bestBonusReleasePortion, _buf);
		Atf::XmlElement::encodeAsXmlElement("bestBonusFppReleasePortion", bestBonusFppReleasePortion, _buf);
		Atf::XmlElement::encodeAsXmlElement("bestBonusBonusFlags", bestBonusBonusFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("bestBonusMaxNumDepositsLeft", bestBonusMaxNumDepositsLeft, _buf);
		Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "bestBonusLastAllowedDepositTime", bestBonusLastAllowedDepositTime);
		Atf::XmlElement::encodeAsXmlElement("bestBonusCurrency", bestBonusCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("bestBonusDaysToDeposit", bestBonusDaysToDeposit, _buf);
		Atf::XmlElement::encodeAsXmlElement("bestBonusMaxDepositNumber", bestBonusMaxDepositNumber, _buf);
		Atf::XmlElement::encodeAsXmlElement("acctAmount", acctAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("beDepositExceedsLossLimit", beDepositExceedsLossLimit, _buf);
		ticketOnlyBonusBodies.toXmlString("ticketOnlyBonusBodies", _buf);
		rollMsgBody.toXmlString("rollMsgBody", _buf);
		disclaimerMsgBody.toXmlString("disclaimerMsgBody", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("bestBonusAmount"))
			{
				bestBonusAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bestBonusFppToEarn"))
			{
				bestBonusFppToEarn = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("availAmount"))
			{
				availAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bestBonusId"))
			{
				bestBonusId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bestBonusPercent"))
			{
				bestBonusPercent = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bestBonusMaxAvailableAmount"))
			{
				bestBonusMaxAvailableAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bestBonusName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bestBonusName)) return false;
			}
			else if (_element.equals("bestBonusStart"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, bestBonusStart);
			}
			else if (_element.equals("bestBonusEnd"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, bestBonusEnd);
			}
			else if (_element.equals("bestBonusUrl"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bestBonusUrl)) return false;
			}
			else if (_element.equals("zero"))
			{
				zero = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bestBonusReleasePortion"))
			{
				bestBonusReleasePortion = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bestBonusFppReleasePortion"))
			{
				bestBonusFppReleasePortion = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bestBonusBonusFlags"))
			{
				bestBonusBonusFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bestBonusMaxNumDepositsLeft"))
			{
				bestBonusMaxNumDepositsLeft = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bestBonusLastAllowedDepositTime"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, bestBonusLastAllowedDepositTime);
			}
			else if (_element.equals("bestBonusCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bestBonusCurrency)) return false;
			}
			else if (_element.equals("bestBonusDaysToDeposit"))
			{
				bestBonusDaysToDeposit = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bestBonusMaxDepositNumber"))
			{
				bestBonusMaxDepositNumber = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("acctAmount"))
			{
				acctAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("beDepositExceedsLossLimit"))
			{
				beDepositExceedsLossLimit = (*_value.ptr() == '1');
			}
			else if (_element.equals("ticketOnlyBonusBodies"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierTicketBody, 4 > >::FromXmlString(_value, ticketOnlyBonusBodies)) return false;
			}
			else if (_element.equals("rollMsgBody"))
			{
				if(!Atf::AtfTempl< common_structs::CashierRollBody >::FromXmlString(_value, rollMsgBody)) return false;
			}
			else if (_element.equals("disclaimerMsgBody"))
			{
				if(!Atf::AtfTempl< CashierGatewayDisclaimerBody >::FromXmlString(_value, disclaimerMsgBody)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(bestBonusAmount);
		_msg.composeINT32(bestBonusFppToEarn);
		_msg.composeINT32(availAmount);
		_msg.composeUINT32(bestBonusId);
		_msg.composeINT32(bestBonusPercent);
		_msg.composeINT32(bestBonusMaxAvailableAmount);
		_msg.composeString(bestBonusName);
		_msg.composeSrvTime(bestBonusStart);
		_msg.composeSrvTime(bestBonusEnd);
		_msg.composeString(bestBonusUrl);
		_msg.composeUINT32(zero);
		_msg.composeINT32(bestBonusReleasePortion);
		_msg.composeINT32(bestBonusFppReleasePortion);
		_msg.composeUINT32(bestBonusBonusFlags);
		_msg.composeUINT32(bestBonusMaxNumDepositsLeft);
		_msg.composeSrvTime(bestBonusLastAllowedDepositTime);
		_msg.composeString(bestBonusCurrency);
		_msg.composeINT32(bestBonusDaysToDeposit);
		_msg.composeINT32(bestBonusMaxDepositNumber);
		_msg.composeINT32(acctAmount);
		_msg.composeBOOL(beDepositExceedsLossLimit);
		CommMsgBody _msg0;
		ticketOnlyBonusBodies.composeMsg(_msg0, _ignoreJSON);
		_msg.composeMsgBody(_msg0);
		rollMsgBody.composeMsg(_msg, _ignoreJSON);
		disclaimerMsgBody.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(bestBonusAmount);
		_parser.parseINT32(bestBonusFppToEarn);
		_parser.parseINT32(availAmount);
		_parser.parseUINT32(bestBonusId);
		_parser.parseINT32(bestBonusPercent);
		_parser.parseINT32(bestBonusMaxAvailableAmount);
		_parser.parseStringP(bestBonusName);
		_parser.parseSrvTime(bestBonusStart);
		_parser.parseSrvTime(bestBonusEnd);
		_parser.parseStringP(bestBonusUrl);
		_parser.parseUINT32(zero);
		_parser.parseINT32(bestBonusReleasePortion);
		_parser.parseINT32(bestBonusFppReleasePortion);
		_parser.parseUINT32(bestBonusBonusFlags);
		_parser.parseUINT32(bestBonusMaxNumDepositsLeft);
		_parser.parseSrvTime(bestBonusLastAllowedDepositTime);
		_parser.parseStringP(bestBonusCurrency);
		_parser.parseINT32(bestBonusDaysToDeposit);
		_parser.parseINT32(bestBonusMaxDepositNumber);
		_parser.parseINT32(acctAmount);
		_parser.parseBOOL(beDepositExceedsLossLimit);
		parseAnonymousMsgBody0(_parser);
		rollMsgBody.parseMsg(_parser);
		disclaimerMsgBody.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("bestBonusAmount", bestBonusAmount);
		_jsonstr.compose("bestBonusFppToEarn", bestBonusFppToEarn);
		_jsonstr.compose("availAmount", availAmount);
		_jsonstr.compose("bestBonusId", bestBonusId);
		_jsonstr.compose("bestBonusPercent", bestBonusPercent);
		_jsonstr.compose("bestBonusMaxAvailableAmount", bestBonusMaxAvailableAmount);
		_jsonstr.compose("bestBonusName", bestBonusName);
		_jsonstr.compose("bestBonusStart", bestBonusStart);
		_jsonstr.compose("bestBonusEnd", bestBonusEnd);
		_jsonstr.compose("bestBonusUrl", bestBonusUrl);
		_jsonstr.compose("zero", zero);
		_jsonstr.compose("bestBonusReleasePortion", bestBonusReleasePortion);
		_jsonstr.compose("bestBonusFppReleasePortion", bestBonusFppReleasePortion);
		_jsonstr.compose("bestBonusBonusFlags", bestBonusBonusFlags);
		_jsonstr.compose("bestBonusMaxNumDepositsLeft", bestBonusMaxNumDepositsLeft);
		_jsonstr.compose("bestBonusLastAllowedDepositTime", bestBonusLastAllowedDepositTime);
		_jsonstr.compose("bestBonusCurrency", bestBonusCurrency);
		_jsonstr.compose("bestBonusDaysToDeposit", bestBonusDaysToDeposit);
		_jsonstr.compose("bestBonusMaxDepositNumber", bestBonusMaxDepositNumber);
		_jsonstr.compose("acctAmount", acctAmount);
		_jsonstr.compose("beDepositExceedsLossLimit", beDepositExceedsLossLimit);
		_jsonstr.compose("ticketOnlyBonusBodies", ticketOnlyBonusBodies);
		_jsonstr.compose("rollMsgBody", rollMsgBody);
		_jsonstr.compose("disclaimerMsgBody", disclaimerMsgBody);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("bestBonusAmount", bestBonusAmount);
		_jparser.parseByNameThrow("bestBonusFppToEarn", bestBonusFppToEarn);
		_jparser.parseByNameThrow("availAmount", availAmount);
		_jparser.parseByNameThrow("bestBonusId", bestBonusId);
		_jparser.parseByNameThrow("bestBonusPercent", bestBonusPercent);
		_jparser.parseByNameThrow("bestBonusMaxAvailableAmount", bestBonusMaxAvailableAmount);
		_jparser.parseByNameThrow("bestBonusName", bestBonusName);
		_jparser.parseByNameThrow("bestBonusStart", bestBonusStart);
		_jparser.parseByNameThrow("bestBonusEnd", bestBonusEnd);
		_jparser.parseByNameThrow("bestBonusUrl", bestBonusUrl);
		_jparser.parseByNameThrow("zero", zero);
		_jparser.parseByNameThrow("bestBonusReleasePortion", bestBonusReleasePortion);
		_jparser.parseByNameThrow("bestBonusFppReleasePortion", bestBonusFppReleasePortion);
		_jparser.parseByNameThrow("bestBonusBonusFlags", bestBonusBonusFlags);
		_jparser.parseByNameThrow("bestBonusMaxNumDepositsLeft", bestBonusMaxNumDepositsLeft);
		_jparser.parseByNameThrow("bestBonusLastAllowedDepositTime", bestBonusLastAllowedDepositTime);
		_jparser.parseByNameThrow("bestBonusCurrency", bestBonusCurrency);
		_jparser.parseByNameThrow("bestBonusDaysToDeposit", bestBonusDaysToDeposit);
		_jparser.parseByNameThrow("bestBonusMaxDepositNumber", bestBonusMaxDepositNumber);
		_jparser.parseByNameThrow("acctAmount", acctAmount);
		_jparser.parseByNameThrow("beDepositExceedsLossLimit", beDepositExceedsLossLimit);
		_jparser.parseByNameThrow("ticketOnlyBonusBodies", ticketOnlyBonusBodies);
		_jparser.parseByNameThrow("rollMsgBody", rollMsgBody);
		_jparser.parseByNameThrow("disclaimerMsgBody", disclaimerMsgBody);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PRE_CASHIN2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 bestBonusAmount; _jparser.validateByNameThrow("bestBonusAmount", bestBonusAmount);
		AtfValidator::validateInt(_descr, "bestBonusAmount", bestBonusAmount, _checker, __FILE__, __LINE__);
		INT32 bestBonusFppToEarn; _jparser.validateByNameThrow("bestBonusFppToEarn", bestBonusFppToEarn);
		AtfValidator::validateInt(_descr, "bestBonusFppToEarn", bestBonusFppToEarn, _checker, __FILE__, __LINE__);
		INT32 availAmount; _jparser.validateByNameThrow("availAmount", availAmount);
		AtfValidator::validateInt(_descr, "availAmount", availAmount, _checker, __FILE__, __LINE__);
		UINT32 bestBonusId; _jparser.validateByNameThrow("bestBonusId", bestBonusId);
		AtfValidator::validateInt(_descr, "bestBonusId", bestBonusId, _checker, __FILE__, __LINE__);
		INT32 bestBonusPercent; _jparser.validateByNameThrow("bestBonusPercent", bestBonusPercent);
		AtfValidator::validateInt(_descr, "bestBonusPercent", bestBonusPercent, _checker, __FILE__, __LINE__);
		INT32 bestBonusMaxAvailableAmount; _jparser.validateByNameThrow("bestBonusMaxAvailableAmount", bestBonusMaxAvailableAmount);
		AtfValidator::validateInt(_descr, "bestBonusMaxAvailableAmount", bestBonusMaxAvailableAmount, _checker, __FILE__, __LINE__);
		PString bestBonusName; _jparser.validateByNameThrow("bestBonusName", bestBonusName);
		AtfValidator::validateInt(_descr, "bestBonusName", bestBonusName.length(), _checker, __FILE__, __LINE__);
		CommSrvTime bestBonusStart; _jparser.validateByNameThrow("bestBonusStart", bestBonusStart);
		AtfValidator::validateSrvDateTime(_descr, "bestBonusStart", bestBonusStart, _checker, __FILE__, __LINE__);
		CommSrvTime bestBonusEnd; _jparser.validateByNameThrow("bestBonusEnd", bestBonusEnd);
		AtfValidator::validateSrvDateTime(_descr, "bestBonusEnd", bestBonusEnd, _checker, __FILE__, __LINE__);
		PString bestBonusUrl; _jparser.validateByNameThrow("bestBonusUrl", bestBonusUrl);
		AtfValidator::validateInt(_descr, "bestBonusUrl", bestBonusUrl.length(), _checker, __FILE__, __LINE__);
		UINT32 zero; _jparser.validateByNameThrow("zero", zero);
		AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
		INT32 bestBonusReleasePortion; _jparser.validateByNameThrow("bestBonusReleasePortion", bestBonusReleasePortion);
		AtfValidator::validateInt(_descr, "bestBonusReleasePortion", bestBonusReleasePortion, _checker, __FILE__, __LINE__);
		INT32 bestBonusFppReleasePortion; _jparser.validateByNameThrow("bestBonusFppReleasePortion", bestBonusFppReleasePortion);
		AtfValidator::validateInt(_descr, "bestBonusFppReleasePortion", bestBonusFppReleasePortion, _checker, __FILE__, __LINE__);
		UINT32 bestBonusBonusFlags; _jparser.validateByNameThrow("bestBonusBonusFlags", bestBonusBonusFlags);
		AtfValidator::validateInt(_descr, "bestBonusBonusFlags", bestBonusBonusFlags, _checker, __FILE__, __LINE__);
		UINT32 bestBonusMaxNumDepositsLeft; _jparser.validateByNameThrow("bestBonusMaxNumDepositsLeft", bestBonusMaxNumDepositsLeft);
		AtfValidator::validateInt(_descr, "bestBonusMaxNumDepositsLeft", bestBonusMaxNumDepositsLeft, _checker, __FILE__, __LINE__);
		CommSrvTime bestBonusLastAllowedDepositTime; _jparser.validateByNameThrow("bestBonusLastAllowedDepositTime", bestBonusLastAllowedDepositTime);
		AtfValidator::validateSrvDateTime(_descr, "bestBonusLastAllowedDepositTime", bestBonusLastAllowedDepositTime, _checker, __FILE__, __LINE__);
		PString bestBonusCurrency; _jparser.validateByNameThrow("bestBonusCurrency", bestBonusCurrency);
		AtfValidator::validateInt(_descr, "bestBonusCurrency", bestBonusCurrency.length(), _checker, __FILE__, __LINE__);
		INT32 bestBonusDaysToDeposit; _jparser.validateByNameThrow("bestBonusDaysToDeposit", bestBonusDaysToDeposit);
		AtfValidator::validateInt(_descr, "bestBonusDaysToDeposit", bestBonusDaysToDeposit, _checker, __FILE__, __LINE__);
		INT32 bestBonusMaxDepositNumber; _jparser.validateByNameThrow("bestBonusMaxDepositNumber", bestBonusMaxDepositNumber);
		AtfValidator::validateInt(_descr, "bestBonusMaxDepositNumber", bestBonusMaxDepositNumber, _checker, __FILE__, __LINE__);
		INT32 acctAmount; _jparser.validateByNameThrow("acctAmount", acctAmount);
		AtfValidator::validateInt(_descr, "acctAmount", acctAmount, _checker, __FILE__, __LINE__);
		bool beDepositExceedsLossLimit; _jparser.validateByNameThrow("beDepositExceedsLossLimit", beDepositExceedsLossLimit);
		AtfValidator::validateInt(_descr, "beDepositExceedsLossLimit", beDepositExceedsLossLimit, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< CashierTicketBody > ticketOnlyBonusBodies; _jparser.validateByNameThrow("ticketOnlyBonusBodies", ticketOnlyBonusBodies);
		AtfValidator::validateInt(_descr, "ticketOnlyBonusBodies", ticketOnlyBonusBodies.size(), _checker, __FILE__, __LINE__);
		common_structs::CashierRollBody rollMsgBody; _jparser.validateByNameThrow("rollMsgBody", rollMsgBody);
		CashierGatewayDisclaimerBody disclaimerMsgBody; _jparser.validateByNameThrow("disclaimerMsgBody", disclaimerMsgBody);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PRE_CASHIN2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 bestBonusAmount; _parser.parseINT32(bestBonusAmount);
		AtfValidator::validateInt(_descr, "bestBonusAmount", bestBonusAmount, _checker, __FILE__, __LINE__);
		INT32 bestBonusFppToEarn; _parser.parseINT32(bestBonusFppToEarn);
		AtfValidator::validateInt(_descr, "bestBonusFppToEarn", bestBonusFppToEarn, _checker, __FILE__, __LINE__);
		INT32 availAmount; _parser.parseINT32(availAmount);
		AtfValidator::validateInt(_descr, "availAmount", availAmount, _checker, __FILE__, __LINE__);
		UINT32 bestBonusId; _parser.parseUINT32(bestBonusId);
		AtfValidator::validateInt(_descr, "bestBonusId", bestBonusId, _checker, __FILE__, __LINE__);
		INT32 bestBonusPercent; _parser.parseINT32(bestBonusPercent);
		AtfValidator::validateInt(_descr, "bestBonusPercent", bestBonusPercent, _checker, __FILE__, __LINE__);
		INT32 bestBonusMaxAvailableAmount; _parser.parseINT32(bestBonusMaxAvailableAmount);
		AtfValidator::validateInt(_descr, "bestBonusMaxAvailableAmount", bestBonusMaxAvailableAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bestBonusName"); size_t szBestBonusName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bestBonusName", szBestBonusName, _checker, __FILE__, __LINE__);
		CommSrvTime bestBonusStart; _parser.parseSrvTime(bestBonusStart);
		AtfValidator::validateSrvDateTime(_descr, "bestBonusStart", bestBonusStart, _checker, __FILE__, __LINE__);
		CommSrvTime bestBonusEnd; _parser.parseSrvTime(bestBonusEnd);
		AtfValidator::validateSrvDateTime(_descr, "bestBonusEnd", bestBonusEnd, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bestBonusUrl"); size_t szBestBonusUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bestBonusUrl", szBestBonusUrl, _checker, __FILE__, __LINE__);
		UINT32 zero; _parser.parseUINT32(zero);
		AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
		INT32 bestBonusReleasePortion; _parser.parseINT32(bestBonusReleasePortion);
		AtfValidator::validateInt(_descr, "bestBonusReleasePortion", bestBonusReleasePortion, _checker, __FILE__, __LINE__);
		INT32 bestBonusFppReleasePortion; _parser.parseINT32(bestBonusFppReleasePortion);
		AtfValidator::validateInt(_descr, "bestBonusFppReleasePortion", bestBonusFppReleasePortion, _checker, __FILE__, __LINE__);
		UINT32 bestBonusBonusFlags; _parser.parseUINT32(bestBonusBonusFlags);
		AtfValidator::validateInt(_descr, "bestBonusBonusFlags", bestBonusBonusFlags, _checker, __FILE__, __LINE__);
		UINT32 bestBonusMaxNumDepositsLeft; _parser.parseUINT32(bestBonusMaxNumDepositsLeft);
		AtfValidator::validateInt(_descr, "bestBonusMaxNumDepositsLeft", bestBonusMaxNumDepositsLeft, _checker, __FILE__, __LINE__);
		CommSrvTime bestBonusLastAllowedDepositTime; _parser.parseSrvTime(bestBonusLastAllowedDepositTime);
		AtfValidator::validateSrvDateTime(_descr, "bestBonusLastAllowedDepositTime", bestBonusLastAllowedDepositTime, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bestBonusCurrency"); size_t szBestBonusCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bestBonusCurrency", szBestBonusCurrency, _checker, __FILE__, __LINE__);
		INT32 bestBonusDaysToDeposit; _parser.parseINT32(bestBonusDaysToDeposit);
		AtfValidator::validateInt(_descr, "bestBonusDaysToDeposit", bestBonusDaysToDeposit, _checker, __FILE__, __LINE__);
		INT32 bestBonusMaxDepositNumber; _parser.parseINT32(bestBonusMaxDepositNumber);
		AtfValidator::validateInt(_descr, "bestBonusMaxDepositNumber", bestBonusMaxDepositNumber, _checker, __FILE__, __LINE__);
		INT32 acctAmount; _parser.parseINT32(acctAmount);
		AtfValidator::validateInt(_descr, "acctAmount", acctAmount, _checker, __FILE__, __LINE__);
		bool beDepositExceedsLossLimit; _parser.parseBOOL(beDepositExceedsLossLimit);
		AtfValidator::validateInt(_descr, "beDepositExceedsLossLimit", beDepositExceedsLossLimit, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		PString _descbuf;
		common_structs::CashierRollBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("rollMsgBody"), _fieldsWithUnparsedContent);
		CashierGatewayDisclaimerBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("disclaimerMsgBody"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	ticketOnlyBonusBodies.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szTicketOnlyBonusBodies = Atf::LAtfVector< CashierTicketBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("ticketOnlyBonusBodies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "ticketOnlyBonusBodies", szTicketOnlyBonusBodies, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_NT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::Protocol_MSG_CASHIER_CASHIN_NT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::clear()
{
	userId.clear();
	netAccount.clear();
	secureId.clear();
	transAmount = 0;
	bonusId = 0;
	doNotCancel_ignored = 0;
	bank_acct_num.clear();
	saveCardInfoRequested = false;
	bonusCode.clear();
	currency.clear();
	converted = 0;
	balanceCurrency.clear();
	clientBalance_ignored = 0;
	fastDepositTransaction = false;
	saveInfoForFastDeposit = false;
	ignoreRepeatedDeclines = false;
	cardInfoId = 0;
	awardId = 0;
	clientDepositFlags = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::equals(const Protocol_MSG_CASHIER_CASHIN_NT& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(netAccount, _o.netAccount) &&
		Atf::atfPStringEquals(secureId, _o.secureId) &&
		transAmount == _o.transAmount &&
		bonusId == _o.bonusId &&
		doNotCancel_ignored == _o.doNotCancel_ignored &&
		Atf::atfPStringEquals(bank_acct_num, _o.bank_acct_num) &&
		saveCardInfoRequested == _o.saveCardInfoRequested &&
		Atf::atfPStringEquals(bonusCode, _o.bonusCode) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		converted == _o.converted &&
		Atf::atfPStringEquals(balanceCurrency, _o.balanceCurrency) &&
		clientBalance_ignored == _o.clientBalance_ignored &&
		fastDepositTransaction == _o.fastDepositTransaction &&
		saveInfoForFastDeposit == _o.saveInfoForFastDeposit &&
		ignoreRepeatedDeclines == _o.ignoreRepeatedDeclines &&
		cardInfoId == _o.cardInfoId &&
		awardId == _o.awardId &&
		clientDepositFlags == _o.clientDepositFlags;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CASHIN_NT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CASHIN_NT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_NT).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("netAccount=");
	_buf.append(netAccount);
	_buf.append(',');
	_buf.append("secureId=");
	_buf.append(secureId);
	_buf.append(',');
	_buf.append("transAmount=");
	_buf.appendInt(transAmount);
	_buf.append(',');
	_buf.append("bonusId=");
	_buf.appendUint(bonusId);
	_buf.append(',');
	_buf.append("doNotCancel_ignored=");
	_buf.appendUint(doNotCancel_ignored);
	_buf.append(',');
	_buf.append("bank_acct_num=");
	_buf.append(bank_acct_num);
	_buf.append(',');
	_buf.append("saveCardInfoRequested=");
	_buf.appendUint(saveCardInfoRequested);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("converted=");
	_buf.appendInt(converted);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	_buf.append(',');
	_buf.append("clientBalance_ignored=");
	_buf.appendInt(clientBalance_ignored);
	_buf.append(',');
	_buf.append("fastDepositTransaction=");
	_buf.appendUint(fastDepositTransaction);
	_buf.append(',');
	_buf.append("saveInfoForFastDeposit=");
	_buf.appendUint(saveInfoForFastDeposit);
	_buf.append(',');
	_buf.append("ignoreRepeatedDeclines=");
	_buf.appendUint(ignoreRepeatedDeclines);
	_buf.append(',');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	_buf.append(',');
	_buf.append("awardId=");
	_buf.appendUint(awardId);
	_buf.append(',');
	_buf.append("clientDepositFlags=");
	_buf.appendUint(clientDepositFlags);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CASHIN_NT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("netAccount", netAccount, _buf);
	Atf::XmlElement::encodeAsXmlElement("secureId", secureId, _buf);
	Atf::XmlElement::encodeAsXmlElement("transAmount", transAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusId", bonusId, _buf);
	Atf::XmlElement::encodeAsXmlElement("doNotCancel_ignored", doNotCancel_ignored, _buf);
	Atf::XmlElement::encodeAsXmlElement("bank_acct_num", bank_acct_num, _buf);
	Atf::XmlElement::encodeAsXmlElement("saveCardInfoRequested", saveCardInfoRequested, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusCode", bonusCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("converted", converted, _buf);
	Atf::XmlElement::encodeAsXmlElement("balanceCurrency", balanceCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientBalance_ignored", clientBalance_ignored, _buf);
	Atf::XmlElement::encodeAsXmlElement("fastDepositTransaction", fastDepositTransaction, _buf);
	Atf::XmlElement::encodeAsXmlElement("saveInfoForFastDeposit", saveInfoForFastDeposit, _buf);
	Atf::XmlElement::encodeAsXmlElement("ignoreRepeatedDeclines", ignoreRepeatedDeclines, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardInfoId", cardInfoId, _buf);
	Atf::XmlElement::encodeAsXmlElement("awardId", awardId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientDepositFlags", clientDepositFlags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("netAccount"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, netAccount)) return false;
			}
			else if (_element.equals("secureId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, secureId)) return false;
			}
			else if (_element.equals("transAmount"))
			{
				transAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bonusId"))
			{
				bonusId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("doNotCancel_ignored"))
			{
				doNotCancel_ignored = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bank_acct_num"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bank_acct_num)) return false;
			}
			else if (_element.equals("saveCardInfoRequested"))
			{
				saveCardInfoRequested = (*_value.ptr() == '1');
			}
			else if (_element.equals("bonusCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bonusCode)) return false;
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("converted"))
			{
				converted = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("balanceCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, balanceCurrency)) return false;
			}
			else if (_element.equals("clientBalance_ignored"))
			{
				clientBalance_ignored = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fastDepositTransaction"))
			{
				fastDepositTransaction = (*_value.ptr() == '1');
			}
			else if (_element.equals("saveInfoForFastDeposit"))
			{
				saveInfoForFastDeposit = (*_value.ptr() == '1');
			}
			else if (_element.equals("ignoreRepeatedDeclines"))
			{
				ignoreRepeatedDeclines = (*_value.ptr() == '1');
			}
			else if (_element.equals("cardInfoId"))
			{
				cardInfoId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("awardId"))
			{
				awardId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientDepositFlags"))
			{
				clientDepositFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeString(netAccount);
	_msg.composeString(secureId);
	_msg.composeINT32(transAmount);
	_msg.composeUINT32(bonusId);
	_msg.composeBYTE(doNotCancel_ignored);
	_msg.composeString(bank_acct_num);
	_msg.composeBOOL(saveCardInfoRequested);
	_msg.composeString(bonusCode);
	_msg.composeString(currency);
	_msg.composeINT32(converted);
	_msg.composeString(balanceCurrency);
	_msg.composeINT32(clientBalance_ignored);
	_msg.composeBOOL(fastDepositTransaction);
	_msg.composeBOOL(saveInfoForFastDeposit);
	_msg.composeBOOL(ignoreRepeatedDeclines);
	_msg.composeUINT32(cardInfoId);
	_msg.composeUINT32(awardId);
	_msg.composeUINT32(clientDepositFlags);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseStringP(netAccount);
	_parser.parseStringP(secureId);
	_parser.parseINT32(transAmount);
	_parser.parseUINT32(bonusId);
	_parser.parseBYTE(doNotCancel_ignored);
	_parser.parseStringP(bank_acct_num);
	_parser.parseBOOL(saveCardInfoRequested);
	_parser.parseStringP(bonusCode);
	_parser.parseStringP(currency);
	_parser.parseINT32(converted);
	_parser.parseStringP(balanceCurrency);
	_parser.parseINT32(clientBalance_ignored);
	_parser.parseBOOL(fastDepositTransaction);
	_parser.parseBOOL(saveInfoForFastDeposit);
	_parser.parseBOOL(ignoreRepeatedDeclines);
	_parser.parseUINT32(cardInfoId);
	_parser.parseUINT32(awardId);
	_parser.parseUINT32(clientDepositFlags);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("netAccount", netAccount);
	_jsonstr.compose("secureId", secureId);
	_jsonstr.compose("transAmount", transAmount);
	_jsonstr.compose("bonusId", bonusId);
	_jsonstr.compose("doNotCancel_ignored", doNotCancel_ignored);
	_jsonstr.compose("bank_acct_num", bank_acct_num);
	_jsonstr.compose("saveCardInfoRequested", saveCardInfoRequested);
	_jsonstr.compose("bonusCode", bonusCode);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("converted", converted);
	_jsonstr.compose("balanceCurrency", balanceCurrency);
	_jsonstr.compose("clientBalance_ignored", clientBalance_ignored);
	_jsonstr.compose("fastDepositTransaction", fastDepositTransaction);
	_jsonstr.compose("saveInfoForFastDeposit", saveInfoForFastDeposit);
	_jsonstr.compose("ignoreRepeatedDeclines", ignoreRepeatedDeclines);
	_jsonstr.compose("cardInfoId", cardInfoId);
	_jsonstr.compose("awardId", awardId);
	_jsonstr.compose("clientDepositFlags", clientDepositFlags);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("netAccount", netAccount);
	_jparser.parseByNameThrow("secureId", secureId);
	_jparser.parseByNameThrow("transAmount", transAmount);
	_jparser.parseByNameThrow("bonusId", bonusId);
	_jparser.parseByNameThrow("doNotCancel_ignored", doNotCancel_ignored);
	_jparser.parseByNameThrow("bank_acct_num", bank_acct_num);
	_jparser.parseByNameThrow("saveCardInfoRequested", saveCardInfoRequested);
	_jparser.parseByNameThrow("bonusCode", bonusCode);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("converted", converted);
	_jparser.parseByNameThrow("balanceCurrency", balanceCurrency);
	_jparser.parseByNameThrow("clientBalance_ignored", clientBalance_ignored);
	_jparser.parseByNameThrow("fastDepositTransaction", fastDepositTransaction);
	_jparser.parseByNameThrow("saveInfoForFastDeposit", saveInfoForFastDeposit);
	_jparser.parseByNameThrow("ignoreRepeatedDeclines", ignoreRepeatedDeclines);
	_jparser.parseByNameThrow("cardInfoId", cardInfoId);
	_jparser.parseByNameThrow("awardId", awardId);
	_jparser.parseByNameThrow("clientDepositFlags", clientDepositFlags);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_NT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString netAccount; _jparser.validateByNameThrow("netAccount", netAccount);
	AtfValidator::validateIntMax(_descr, "netAccount", netAccount.length(), 1000, _checker, __FILE__, __LINE__);
	PString secureId; _jparser.validateByNameThrow("secureId", secureId);
	AtfValidator::validateIntMax(_descr, "secureId", secureId.length(), 1000, _checker, __FILE__, __LINE__);
	INT32 transAmount; _jparser.validateByNameThrow("transAmount", transAmount);
	AtfValidator::validateIntRange(_descr, "transAmount", transAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	UINT32 bonusId; _jparser.validateByNameThrow("bonusId", bonusId);
	AtfValidator::validateInt(_descr, "bonusId", bonusId, _checker, __FILE__, __LINE__);
	BYTE doNotCancel_ignored; _jparser.validateByNameThrow("doNotCancel_ignored", doNotCancel_ignored);
	AtfValidator::validateInt(_descr, "doNotCancel_ignored", doNotCancel_ignored, _checker, __FILE__, __LINE__);
	PString bank_acct_num; _jparser.validateByNameThrow("bank_acct_num", bank_acct_num);
	AtfValidator::validateIntMax(_descr, "bank_acct_num", bank_acct_num.length(), 1000, _checker, __FILE__, __LINE__);
	bool saveCardInfoRequested; _jparser.validateByNameThrow("saveCardInfoRequested", saveCardInfoRequested);
	AtfValidator::validateInt(_descr, "saveCardInfoRequested", saveCardInfoRequested, _checker, __FILE__, __LINE__);
	PString bonusCode; _jparser.validateByNameThrow("bonusCode", bonusCode);
	AtfValidator::validateIntMax(_descr, "bonusCode", bonusCode.length(), BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 converted; _jparser.validateByNameThrow("converted", converted);
	AtfValidator::validateIntRange(_descr, "converted", converted, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString balanceCurrency; _jparser.validateByNameThrow("balanceCurrency", balanceCurrency);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", balanceCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 clientBalance_ignored; _jparser.validateByNameThrow("clientBalance_ignored", clientBalance_ignored);
	AtfValidator::validateInt(_descr, "clientBalance_ignored", clientBalance_ignored, _checker, __FILE__, __LINE__);
	bool fastDepositTransaction; _jparser.validateByNameThrow("fastDepositTransaction", fastDepositTransaction);
	AtfValidator::validateInt(_descr, "fastDepositTransaction", fastDepositTransaction, _checker, __FILE__, __LINE__);
	bool saveInfoForFastDeposit; _jparser.validateByNameThrow("saveInfoForFastDeposit", saveInfoForFastDeposit);
	AtfValidator::validateInt(_descr, "saveInfoForFastDeposit", saveInfoForFastDeposit, _checker, __FILE__, __LINE__);
	bool ignoreRepeatedDeclines; _jparser.validateByNameThrow("ignoreRepeatedDeclines", ignoreRepeatedDeclines);
	AtfValidator::validateInt(_descr, "ignoreRepeatedDeclines", ignoreRepeatedDeclines, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _jparser.validateByNameThrow("cardInfoId", cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	UINT32 awardId; _jparser.validateByNameThrow("awardId", awardId);
	AtfValidator::validateInt(_descr, "awardId", awardId, _checker, __FILE__, __LINE__);
	UINT32 clientDepositFlags; _jparser.validateByNameThrow("clientDepositFlags", clientDepositFlags);
	AtfValidator::validateIntMax(_descr, "clientDepositFlags", clientDepositFlags, ((((UINT32)eClientDepositFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_NT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "netAccount"); size_t szNetAccount = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "netAccount", szNetAccount, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "secureId"); size_t szSecureId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "secureId", szSecureId, 1000, _checker, __FILE__, __LINE__);
	INT32 transAmount; _parser.parseINT32(transAmount);
	AtfValidator::validateIntRange(_descr, "transAmount", transAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	UINT32 bonusId; _parser.parseUINT32(bonusId);
	AtfValidator::validateInt(_descr, "bonusId", bonusId, _checker, __FILE__, __LINE__);
	BYTE doNotCancel_ignored; _parser.parseBYTE(doNotCancel_ignored);
	AtfValidator::validateInt(_descr, "doNotCancel_ignored", doNotCancel_ignored, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bank_acct_num"); size_t szBank_acct_num = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bank_acct_num", szBank_acct_num, 1000, _checker, __FILE__, __LINE__);
	bool saveCardInfoRequested; _parser.parseBOOL(saveCardInfoRequested);
	AtfValidator::validateInt(_descr, "saveCardInfoRequested", saveCardInfoRequested, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 converted; _parser.parseINT32(converted);
	AtfValidator::validateIntRange(_descr, "converted", converted, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", szBalanceCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 clientBalance_ignored; _parser.parseINT32(clientBalance_ignored);
	AtfValidator::validateInt(_descr, "clientBalance_ignored", clientBalance_ignored, _checker, __FILE__, __LINE__);
	bool fastDepositTransaction; _parser.parseBOOL(fastDepositTransaction);
	AtfValidator::validateInt(_descr, "fastDepositTransaction", fastDepositTransaction, _checker, __FILE__, __LINE__);
	bool saveInfoForFastDeposit; _parser.parseBOOL(saveInfoForFastDeposit);
	AtfValidator::validateInt(_descr, "saveInfoForFastDeposit", saveInfoForFastDeposit, _checker, __FILE__, __LINE__);
	bool ignoreRepeatedDeclines; _parser.parseBOOL(ignoreRepeatedDeclines);
	AtfValidator::validateInt(_descr, "ignoreRepeatedDeclines", ignoreRepeatedDeclines, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	UINT32 awardId; _parser.parseUINT32(awardId);
	AtfValidator::validateInt(_descr, "awardId", awardId, _checker, __FILE__, __LINE__);
	UINT32 clientDepositFlags; _parser.parseUINT32(clientDepositFlags);
	AtfValidator::validateIntMax(_descr, "clientDepositFlags", clientDepositFlags, ((((UINT32)eClientDepositFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::clear()
{
	errCode = 0;
	errDescr.clear();
	transId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::equals(const Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		transId == _o.transId;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CASHIN_NT_CONFIRM != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_NT_CONFIRM).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CASHIN_NT_CONFIRM).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("transId"))
			{
				transId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(transId);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(transId);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("transId", transId);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("transId", transId);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_NT_CONFIRM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _jparser.validateByNameThrow("transId", transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_NT_CONFIRM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    Cashier3DSecureRedirectionParams
//=================================================================

CashierServer::cli::Cashier3DSecureRedirectionParams::Cashier3DSecureRedirectionParams()
{
	clear();
}

void CashierServer::cli::Cashier3DSecureRedirectionParams::clear()
{
	first.clear();
	second.clear();
}

bool CashierServer::cli::Cashier3DSecureRedirectionParams::equals(const Cashier3DSecureRedirectionParams& _o) const
{
	return Atf::atfPStringEquals(first, _o.first) &&
		Atf::atfPStringEquals(second, _o.second);
}

const char *CashierServer::cli::Cashier3DSecureRedirectionParams::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("first=");
	_buf.append(first);
	_buf.append(',');
	_buf.append("second=");
	_buf.append(second);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::Cashier3DSecureRedirectionParams::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("first", first, _buf);
	Atf::XmlElement::encodeAsXmlElement("second", second, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::Cashier3DSecureRedirectionParams::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("first"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, first)) return false;
		}
		else if (_element.equals("second"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, second)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::Cashier3DSecureRedirectionParams::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(first);
	_msg.composeString(second);
}

void CashierServer::cli::Cashier3DSecureRedirectionParams::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(first);
	_parser.parseStringP(second);
}

const char *CashierServer::cli::Cashier3DSecureRedirectionParams::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("first", first);
	_jsonstr.compose("second", second);
	return _buf.c_str();
}

void CashierServer::cli::Cashier3DSecureRedirectionParams::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("first", first);
	_jparser.parseByNameThrow("second", second);
}

/* static */ void CashierServer::cli::Cashier3DSecureRedirectionParams::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString first; _jparser.validateByNameThrow("first", first);
	AtfValidator::validateInt(_descr, "first", first.length(), _checker, __FILE__, __LINE__);
	PString second; _jparser.validateByNameThrow("second", second);
	AtfValidator::validateInt(_descr, "second", second.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Cashier3DSecureRedirectionParams::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "first"); size_t szFirst = strlen(_dummy);
	AtfValidator::validateInt(_descr, "first", szFirst, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "second"); size_t szSecond = strlen(_dummy);
	AtfValidator::validateInt(_descr, "second", szSecond, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CashierCashinCompleteSpecificInfoBody
//=================================================================

CashierServer::cli::CashierCashinCompleteSpecificInfoBody::CashierCashinCompleteSpecificInfoBody()
{
	clear();
}

void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::clear()
{
	type = 0;
	text.clear();
}

bool CashierServer::cli::CashierCashinCompleteSpecificInfoBody::equals(const CashierCashinCompleteSpecificInfoBody& _o) const
{
	return type == _o.type &&
		Atf::atfPStringEquals(text, _o.text);
}

const char *CashierServer::cli::CashierCashinCompleteSpecificInfoBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendUint(type);
	if (type == eCashinCompleteSpecificInfo_UnverifiedPayment )
	{
		_buf.append(',');
	}
	else if (type == eCashinCompleteSpecificInfo_AdditionalText)
	{
		_buf.append(',');
		_buf.append("text=");
		_buf.append(text);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierCashinCompleteSpecificInfoBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	if (type == eCashinCompleteSpecificInfo_UnverifiedPayment )
	{
	}
	else if (type == eCashinCompleteSpecificInfo_AdditionalText)
	{
		Atf::XmlElement::encodeAsXmlElement("text", text, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierCashinCompleteSpecificInfoBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("type"))
		{
			type = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("text"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, text)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(type);
	if (type == eCashinCompleteSpecificInfo_UnverifiedPayment )
	{
		CommMsgBody _msg0;
		_msg.composeMsgBody(_msg0);
	}
	else if (type == eCashinCompleteSpecificInfo_AdditionalText)
	{
		CommMsgBody _msg1;
		_msg1.composeString(text);
		_msg.composeMsgBody(_msg1);
	}
}

void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(type);
	if (type == eCashinCompleteSpecificInfo_UnverifiedPayment )
	{
		parseAnonymousMsgBody0(_parser);
	}
	else if (type == eCashinCompleteSpecificInfo_AdditionalText)
	{
		parseAnonymousMsgBody1(_parser);
	}
}

const char *CashierServer::cli::CashierCashinCompleteSpecificInfoBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("type", type);
	if (type == eCashinCompleteSpecificInfo_UnverifiedPayment )
	{
	}
	else if (type == eCashinCompleteSpecificInfo_AdditionalText)
	{
		_jsonstr.compose("text", text);
	}
	return _buf.c_str();
}

void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("type", type);
	if (type == eCashinCompleteSpecificInfo_UnverifiedPayment )
	{
	}
	else if (type == eCashinCompleteSpecificInfo_AdditionalText)
	{
		_jparser.parseByNameThrow("text", text);
	}
}

/* static */ void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 type = 0;
	_jparser.validateByNameThrow("type", type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	if (type == eCashinCompleteSpecificInfo_UnverifiedPayment )
	{
	}
	else if (type == eCashinCompleteSpecificInfo_AdditionalText)
	{
		PString text; _jparser.validateByNameThrow("text", text);
		AtfValidator::validateInt(_descr, "text", text.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 type = 0;
	_parser.parseUINT32(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	if (type == eCashinCompleteSpecificInfo_UnverifiedPayment )
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (type == eCashinCompleteSpecificInfo_AdditionalText)
	{
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
}

void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
}

/*static*/ void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(text);
}

/*static*/ void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "text"); size_t szText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "text", szText, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::clear()
{
	errCode = 0;
	errDescr.clear();
	transId = 0;
	transStatusByte = 0;
	totalAmount = 0;
	resultInfos.clear();
	rejectExplanationCode = 0;
	errorInfo.clear();
	ntUrl.clear();
	ntUrlMsg.clear();
	ntPhone.clear();
	dadEligible = false;
	rejectMsg.clear();
	transBalanceCurrency.clear();
	transConverted = 0;
	transCurrency.clear();
	threeDSecureRedirectionParams.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::equals(const Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		transId == _o.transId &&
		transStatusByte == _o.transStatusByte &&
		totalAmount == _o.totalAmount &&
		resultInfos.equals(_o.resultInfos) &&
		rejectExplanationCode == _o.rejectExplanationCode &&
		Atf::atfPStringEquals(errorInfo, _o.errorInfo) &&
		Atf::atfPStringEquals(ntUrl, _o.ntUrl) &&
		Atf::atfPStringEquals(ntUrlMsg, _o.ntUrlMsg) &&
		Atf::atfPStringEquals(ntPhone, _o.ntPhone) &&
		dadEligible == _o.dadEligible &&
		Atf::atfPStringEquals(rejectMsg, _o.rejectMsg) &&
		Atf::atfPStringEquals(transBalanceCurrency, _o.transBalanceCurrency) &&
		transConverted == _o.transConverted &&
		Atf::atfPStringEquals(transCurrency, _o.transCurrency) &&
		threeDSecureRedirectionParams.equals(_o.threeDSecureRedirectionParams);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CASHIN_NT_COMPLETE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_NT_COMPLETE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
		_buf.append(',');
		_buf.append("transStatusByte=");
		_buf.appendUint(transStatusByte);
		_buf.append(',');
		_buf.append("totalAmount=");
		_buf.appendInt(totalAmount);
		_buf.append(',');
		_buf.append("resultInfos=");
		resultInfos.toTraceString(_buf);
		_buf.append(',');
		_buf.append("rejectExplanationCode=");
		_buf.appendUint(rejectExplanationCode);
		_buf.append(',');
		_buf.append("errorInfo=");
		_buf.append(errorInfo);
		_buf.append(',');
		_buf.append("ntUrl=");
		_buf.append(ntUrl);
		_buf.append(',');
		_buf.append("ntUrlMsg=");
		_buf.append(ntUrlMsg);
		_buf.append(',');
		_buf.append("ntPhone=");
		_buf.append(ntPhone);
		_buf.append(',');
		_buf.append("dadEligible=");
		_buf.appendUint(dadEligible);
		_buf.append(',');
		_buf.append("rejectMsg=");
		_buf.append(rejectMsg);
		_buf.append(',');
		_buf.append("transBalanceCurrency=");
		_buf.append(transBalanceCurrency);
		_buf.append(',');
		_buf.append("transConverted=");
		_buf.appendInt(transConverted);
		_buf.append(',');
		_buf.append("transCurrency=");
		_buf.append(transCurrency);
		_buf.append(',');
		_buf.append("threeDSecureRedirectionParams=");
		threeDSecureRedirectionParams.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CASHIN_NT_COMPLETE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
		Atf::XmlElement::encodeAsXmlElement("transStatusByte", transStatusByte, _buf);
		Atf::XmlElement::encodeAsXmlElement("totalAmount", totalAmount, _buf);
		resultInfos.toXmlString("resultInfos", _buf);
		Atf::XmlElement::encodeAsXmlElement("rejectExplanationCode", rejectExplanationCode, _buf);
		Atf::XmlElement::encodeAsXmlElement("errorInfo", errorInfo, _buf);
		Atf::XmlElement::encodeAsXmlElement("ntUrl", ntUrl, _buf);
		Atf::XmlElement::encodeAsXmlElement("ntUrlMsg", ntUrlMsg, _buf);
		Atf::XmlElement::encodeAsXmlElement("ntPhone", ntPhone, _buf);
		Atf::XmlElement::encodeAsXmlElement("dadEligible", dadEligible, _buf);
		Atf::XmlElement::encodeAsXmlElement("rejectMsg", rejectMsg, _buf);
		Atf::XmlElement::encodeAsXmlElement("transBalanceCurrency", transBalanceCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("transConverted", transConverted, _buf);
		Atf::XmlElement::encodeAsXmlElement("transCurrency", transCurrency, _buf);
		threeDSecureRedirectionParams.toXmlString("threeDSecureRedirectionParams", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("transId"))
			{
				transId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("transStatusByte"))
			{
				transStatusByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("totalAmount"))
			{
				totalAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("resultInfos"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ResultInfos, 4 > >::FromXmlString(_value, resultInfos)) return false;
			}
			else if (_element.equals("rejectExplanationCode"))
			{
				rejectExplanationCode = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errorInfo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errorInfo)) return false;
			}
			else if (_element.equals("ntUrl"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, ntUrl)) return false;
			}
			else if (_element.equals("ntUrlMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, ntUrlMsg)) return false;
			}
			else if (_element.equals("ntPhone"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, ntPhone)) return false;
			}
			else if (_element.equals("dadEligible"))
			{
				dadEligible = (*_value.ptr() == '1');
			}
			else if (_element.equals("rejectMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, rejectMsg)) return false;
			}
			else if (_element.equals("transBalanceCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, transBalanceCurrency)) return false;
			}
			else if (_element.equals("transConverted"))
			{
				transConverted = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("transCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, transCurrency)) return false;
			}
			else if (_element.equals("threeDSecureRedirectionParams"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< Cashier3DSecureRedirectionParams, 4 > >::FromXmlString(_value, threeDSecureRedirectionParams)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(transId);
		_msg.composeBYTE(transStatusByte);
		_msg.composeINT32(totalAmount);
		resultInfos.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT32(rejectExplanationCode);
		_msg.composeString(errorInfo);
		_msg.composeString(ntUrl);
		_msg.composeString(ntUrlMsg);
		_msg.composeString(ntPhone);
		_msg.composeBOOL(dadEligible);
		_msg.composeString(rejectMsg);
		_msg.composeString(transBalanceCurrency);
		_msg.composeINT32(transConverted);
		_msg.composeString(transCurrency);
		threeDSecureRedirectionParams.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(transId);
		_parser.parseBYTE(transStatusByte);
		_parser.parseINT32(totalAmount);
		resultInfos.parseMsg(_parser);
		_parser.parseUINT32(rejectExplanationCode);
		_parser.parseStringP(errorInfo);
		_parser.parseStringP(ntUrl);
		_parser.parseStringP(ntUrlMsg);
		_parser.parseStringP(ntPhone);
		_parser.parseBOOL(dadEligible);
		_parser.parseStringP(rejectMsg);
		_parser.parseStringP(transBalanceCurrency);
		_parser.parseINT32(transConverted);
		_parser.parseStringP(transCurrency);
		threeDSecureRedirectionParams.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("transId", transId);
		_jsonstr.compose("transStatusByte", transStatusByte);
		_jsonstr.compose("totalAmount", totalAmount);
		_jsonstr.compose("resultInfos", resultInfos);
		_jsonstr.compose("rejectExplanationCode", rejectExplanationCode);
		_jsonstr.compose("errorInfo", errorInfo);
		_jsonstr.compose("ntUrl", ntUrl);
		_jsonstr.compose("ntUrlMsg", ntUrlMsg);
		_jsonstr.compose("ntPhone", ntPhone);
		_jsonstr.compose("dadEligible", dadEligible);
		_jsonstr.compose("rejectMsg", rejectMsg);
		_jsonstr.compose("transBalanceCurrency", transBalanceCurrency);
		_jsonstr.compose("transConverted", transConverted);
		_jsonstr.compose("transCurrency", transCurrency);
		_jsonstr.compose("threeDSecureRedirectionParams", threeDSecureRedirectionParams);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("transId", transId);
		_jparser.parseByNameThrow("transStatusByte", transStatusByte);
		_jparser.parseByNameThrow("totalAmount", totalAmount);
		_jparser.parseByNameThrow("resultInfos", resultInfos);
		_jparser.parseByNameThrow("rejectExplanationCode", rejectExplanationCode);
		_jparser.parseByNameThrow("errorInfo", errorInfo);
		_jparser.parseByNameThrow("ntUrl", ntUrl);
		_jparser.parseByNameThrow("ntUrlMsg", ntUrlMsg);
		_jparser.parseByNameThrow("ntPhone", ntPhone);
		_jparser.parseByNameThrow("dadEligible", dadEligible);
		_jparser.parseByNameThrow("rejectMsg", rejectMsg);
		_jparser.parseByNameThrow("transBalanceCurrency", transBalanceCurrency);
		_jparser.parseByNameThrow("transConverted", transConverted);
		_jparser.parseByNameThrow("transCurrency", transCurrency);
		_jparser.parseByNameThrow("threeDSecureRedirectionParams", threeDSecureRedirectionParams);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_NT_COMPLETE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _jparser.validateByNameThrow("transId", transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		BYTE transStatusByte; _jparser.validateByNameThrow("transStatusByte", transStatusByte);
		AtfValidator::validateInt(_descr, "transStatusByte", transStatusByte, _checker, __FILE__, __LINE__);
		INT32 totalAmount; _jparser.validateByNameThrow("totalAmount", totalAmount);
		AtfValidator::validateInt(_descr, "totalAmount", totalAmount, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< ResultInfos > resultInfos; _jparser.validateByNameThrow("resultInfos", resultInfos);
		AtfValidator::validateInt(_descr, "resultInfos", resultInfos.size(), _checker, __FILE__, __LINE__);
		UINT32 rejectExplanationCode; _jparser.validateByNameThrow("rejectExplanationCode", rejectExplanationCode);
		AtfValidator::validateInt(_descr, "rejectExplanationCode", rejectExplanationCode, _checker, __FILE__, __LINE__);
		PString errorInfo; _jparser.validateByNameThrow("errorInfo", errorInfo);
		AtfValidator::validateInt(_descr, "errorInfo", errorInfo.length(), _checker, __FILE__, __LINE__);
		PString ntUrl; _jparser.validateByNameThrow("ntUrl", ntUrl);
		AtfValidator::validateInt(_descr, "ntUrl", ntUrl.length(), _checker, __FILE__, __LINE__);
		PString ntUrlMsg; _jparser.validateByNameThrow("ntUrlMsg", ntUrlMsg);
		AtfValidator::validateInt(_descr, "ntUrlMsg", ntUrlMsg.length(), _checker, __FILE__, __LINE__);
		PString ntPhone; _jparser.validateByNameThrow("ntPhone", ntPhone);
		AtfValidator::validateInt(_descr, "ntPhone", ntPhone.length(), _checker, __FILE__, __LINE__);
		bool dadEligible; _jparser.validateByNameThrow("dadEligible", dadEligible);
		AtfValidator::validateInt(_descr, "dadEligible", dadEligible, _checker, __FILE__, __LINE__);
		PString rejectMsg; _jparser.validateByNameThrow("rejectMsg", rejectMsg);
		AtfValidator::validateInt(_descr, "rejectMsg", rejectMsg.length(), _checker, __FILE__, __LINE__);
		PString transBalanceCurrency; _jparser.validateByNameThrow("transBalanceCurrency", transBalanceCurrency);
		AtfValidator::validateInt(_descr, "transBalanceCurrency", transBalanceCurrency.length(), _checker, __FILE__, __LINE__);
		INT32 transConverted; _jparser.validateByNameThrow("transConverted", transConverted);
		AtfValidator::validateInt(_descr, "transConverted", transConverted, _checker, __FILE__, __LINE__);
		PString transCurrency; _jparser.validateByNameThrow("transCurrency", transCurrency);
		AtfValidator::validateInt(_descr, "transCurrency", transCurrency.length(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< Cashier3DSecureRedirectionParams > threeDSecureRedirectionParams; _jparser.validateByNameThrow("threeDSecureRedirectionParams", threeDSecureRedirectionParams);
		AtfValidator::validateInt(_descr, "threeDSecureRedirectionParams", threeDSecureRedirectionParams.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_NT_COMPLETE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		BYTE transStatusByte; _parser.parseBYTE(transStatusByte);
		AtfValidator::validateInt(_descr, "transStatusByte", transStatusByte, _checker, __FILE__, __LINE__);
		INT32 totalAmount; _parser.parseINT32(totalAmount);
		AtfValidator::validateInt(_descr, "totalAmount", totalAmount, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szResultInfos = Atf::LAtfVector< ResultInfos, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("resultInfos"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "resultInfos", szResultInfos, _checker, __FILE__, __LINE__);
		UINT32 rejectExplanationCode; _parser.parseUINT32(rejectExplanationCode);
		AtfValidator::validateInt(_descr, "rejectExplanationCode", rejectExplanationCode, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "errorInfo"); size_t szErrorInfo = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorInfo", szErrorInfo, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "ntUrl"); size_t szNtUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "ntUrl", szNtUrl, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "ntUrlMsg"); size_t szNtUrlMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "ntUrlMsg", szNtUrlMsg, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "ntPhone"); size_t szNtPhone = strlen(_dummy);
		AtfValidator::validateInt(_descr, "ntPhone", szNtPhone, _checker, __FILE__, __LINE__);
		bool dadEligible; _parser.parseBOOL(dadEligible);
		AtfValidator::validateInt(_descr, "dadEligible", dadEligible, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "rejectMsg"); size_t szRejectMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "rejectMsg", szRejectMsg, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "transBalanceCurrency"); size_t szTransBalanceCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "transBalanceCurrency", szTransBalanceCurrency, _checker, __FILE__, __LINE__);
		INT32 transConverted; _parser.parseINT32(transConverted);
		AtfValidator::validateInt(_descr, "transConverted", transConverted, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "transCurrency"); size_t szTransCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "transCurrency", szTransCurrency, _checker, __FILE__, __LINE__);
		int szThreeDSecureRedirectionParams = Atf::LAtfVector< Cashier3DSecureRedirectionParams, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("threeDSecureRedirectionParams"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "threeDSecureRedirectionParams", szThreeDSecureRedirectionParams, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::clear()
{
	transId = 0;
	amount = 0;
	isError = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::equals(const Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED& _o) const
{
	return transId == _o.transId &&
		amount == _o.amount &&
		isError == _o.isError &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CASHIN_CC_REDIRECTED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_CC_REDIRECTED).append(")");
	_buf.append(',');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("isError=");
	_buf.appendInt(isError);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CASHIN_CC_REDIRECTED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("isError", isError, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("transId"))
			{
				transId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("amount"))
			{
				amount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isError"))
			{
				isError = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(transId);
	_msg.composeINT32(amount);
	_msg.composeINT32(isError);
	_msg.composeString(errDescr);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(transId);
	_parser.parseINT32(amount);
	_parser.parseINT32(isError);
	_parser.parseStringP(errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("transId", transId);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("isError", isError);
	_jsonstr.compose("errDescr", errDescr);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("transId", transId);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("isError", isError);
	_jparser.parseByNameThrow("errDescr", errDescr);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_CC_REDIRECTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 transId; _jparser.validateByNameThrow("transId", transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 isError; _jparser.validateByNameThrow("isError", isError);
	AtfValidator::validateIntRange(_descr, "isError", isError, 0, 1, _checker, __FILE__, __LINE__);
	PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
	AtfValidator::validateIntMax(_descr, "errDescr", errDescr.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_CC_REDIRECTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 transId; _parser.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 isError; _parser.parseINT32(isError);
	AtfValidator::validateIntRange(_descr, "isError", isError, 0, 1, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "errDescr", szErrDescr, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PRE_CASHOUT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::Protocol_MSG_CASHIER_PRE_CASHOUT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::clear()
{
	userId.clear();
	cashoutAmount = 0;
	balanceCurrency.clear();
	isForFTPkr = false;
	userRollbackOption = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::equals(const Protocol_MSG_CASHIER_PRE_CASHOUT& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		cashoutAmount == _o.cashoutAmount &&
		Atf::atfPStringEquals(balanceCurrency, _o.balanceCurrency) &&
		isForFTPkr == _o.isForFTPkr &&
		userRollbackOption == _o.userRollbackOption;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PRE_CASHOUT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PRE_CASHOUT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PRE_CASHOUT).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("cashoutAmount=");
	_buf.appendInt(cashoutAmount);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	_buf.append(',');
	_buf.append("isForFTPkr=");
	_buf.appendUint(isForFTPkr);
	_buf.append(',');
	_buf.append("userRollbackOption=");
	_buf.appendUint(userRollbackOption);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PRE_CASHOUT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("cashoutAmount", cashoutAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("balanceCurrency", balanceCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("isForFTPkr", isForFTPkr, _buf);
	Atf::XmlElement::encodeAsXmlElement("userRollbackOption", userRollbackOption, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("cashoutAmount"))
			{
				cashoutAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("balanceCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, balanceCurrency)) return false;
			}
			else if (_element.equals("isForFTPkr"))
			{
				isForFTPkr = (*_value.ptr() == '1');
			}
			else if (_element.equals("userRollbackOption"))
			{
				userRollbackOption = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeINT32(cashoutAmount);
	_msg.composeString(balanceCurrency);
	_msg.composeBOOL(isForFTPkr);
	_msg.composeBYTE(userRollbackOption);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(cashoutAmount);
	_parser.parseStringP(balanceCurrency);
	_parser.parseBOOL(isForFTPkr);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(userRollbackOption);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("cashoutAmount", cashoutAmount);
	_jsonstr.compose("balanceCurrency", balanceCurrency);
	_jsonstr.compose("isForFTPkr", isForFTPkr);
	_jsonstr.compose("userRollbackOption", userRollbackOption);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("cashoutAmount", cashoutAmount);
	_jparser.parseByNameThrow("balanceCurrency", balanceCurrency);
	_jparser.parseByNameThrow("isForFTPkr", isForFTPkr);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("userRollbackOption", userRollbackOption);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PRE_CASHOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 cashoutAmount; _jparser.validateByNameThrow("cashoutAmount", cashoutAmount);
	AtfValidator::validateIntRange(_descr, "cashoutAmount", cashoutAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString balanceCurrency; _jparser.validateByNameThrow("balanceCurrency", balanceCurrency);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", balanceCurrency.length(), 7, _checker, __FILE__, __LINE__);
	bool isForFTPkr; _jparser.validateByNameThrow("isForFTPkr", isForFTPkr);
	AtfValidator::validateInt(_descr, "isForFTPkr", isForFTPkr, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE userRollbackOption; _jparser.validateByNameThrow("userRollbackOption", userRollbackOption);
	AtfValidator::validateInt(_descr, "userRollbackOption", userRollbackOption, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PRE_CASHOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 cashoutAmount; _parser.parseINT32(cashoutAmount);
	AtfValidator::validateIntRange(_descr, "cashoutAmount", cashoutAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", szBalanceCurrency, 7, _checker, __FILE__, __LINE__);
	bool isForFTPkr; _parser.parseBOOL(isForFTPkr);
	AtfValidator::validateInt(_descr, "isForFTPkr", isForFTPkr, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE userRollbackOption; _parser.parseBYTE(userRollbackOption);
	AtfValidator::validateInt(_descr, "userRollbackOption", userRollbackOption, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CardRollback
//=================================================================

CashierServer::cli::CardRollback::CardRollback()
{
	clear();
}

void CashierServer::cli::CardRollback::clear()
{
	cardType.clear();
	cardMasked.clear();
	amount = 0;
}

bool CashierServer::cli::CardRollback::equals(const CardRollback& _o) const
{
	return Atf::atfPStringEquals(cardType, _o.cardType) &&
		Atf::atfPStringEquals(cardMasked, _o.cardMasked) &&
		amount == _o.amount;
}

const char *CashierServer::cli::CardRollback::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cardType=");
	_buf.append(cardType);
	_buf.append(',');
	_buf.append("cardMasked=");
	_buf.append(cardMasked);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CardRollback::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("cardType", cardType, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardMasked", cardMasked, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CardRollback::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cardType"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cardType)) return false;
		}
		else if (_element.equals("cardMasked"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cardMasked)) return false;
		}
		else if (_element.equals("amount"))
		{
			amount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CardRollback::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(cardType);
	_msg.composeString(cardMasked);
	_msg.composeINT32(amount);
}

void CashierServer::cli::CardRollback::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(cardType);
	_parser.parseStringP(cardMasked);
	_parser.parseINT32(amount);
}

const char *CashierServer::cli::CardRollback::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cardType", cardType);
	_jsonstr.compose("cardMasked", cardMasked);
	_jsonstr.compose("amount", amount);
	return _buf.c_str();
}

void CashierServer::cli::CardRollback::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cardType", cardType);
	_jparser.parseByNameThrow("cardMasked", cardMasked);
	_jparser.parseByNameThrow("amount", amount);
}

/* static */ void CashierServer::cli::CardRollback::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString cardType; _jparser.validateByNameThrow("cardType", cardType);
	AtfValidator::validateInt(_descr, "cardType", cardType.length(), _checker, __FILE__, __LINE__);
	PString cardMasked; _jparser.validateByNameThrow("cardMasked", cardMasked);
	AtfValidator::validateInt(_descr, "cardMasked", cardMasked.length(), _checker, __FILE__, __LINE__);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CardRollback::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "cardType"); size_t szCardType = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cardType", szCardType, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cardMasked"); size_t szCardMasked = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cardMasked", szCardMasked, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CardRollbackExtBody
//=================================================================

CashierServer::cli::CardRollbackExtBody::CardRollbackExtBody()
{
	clear();
}

void CashierServer::cli::CardRollbackExtBody::clear()
{
	cardType.clear();
	cardMasked.clear();
	amount = 0;
	cardTypeByte = 0;
	convRate64 = 0;
	cardCurrency.clear();
	processorAmount = 0;
	cardId = 0;
	flagsForClient = 0;
}

bool CashierServer::cli::CardRollbackExtBody::equals(const CardRollbackExtBody& _o) const
{
	return Atf::atfPStringEquals(cardType, _o.cardType) &&
		Atf::atfPStringEquals(cardMasked, _o.cardMasked) &&
		amount == _o.amount &&
		cardTypeByte == _o.cardTypeByte &&
		convRate64 == _o.convRate64 &&
		Atf::atfPStringEquals(cardCurrency, _o.cardCurrency) &&
		processorAmount == _o.processorAmount &&
		cardId == _o.cardId &&
		flagsForClient == _o.flagsForClient;
}

const char *CashierServer::cli::CardRollbackExtBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cardType=");
	_buf.append(cardType);
	_buf.append(',');
	_buf.append("cardMasked=");
	_buf.append(cardMasked);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	_buf.append(',');
	_buf.append("convRate64=");
	_buf.appendInt64(convRate64);
	_buf.append(',');
	_buf.append("cardCurrency=");
	_buf.append(cardCurrency);
	_buf.append(',');
	_buf.append("processorAmount=");
	_buf.appendInt(processorAmount);
	_buf.append(',');
	_buf.append("cardId=");
	_buf.appendUint(cardId);
	_buf.append(',');
	_buf.append("flagsForClient=");
	_buf.appendUint(flagsForClient);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CardRollbackExtBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("cardType", cardType, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardMasked", cardMasked, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardTypeByte", cardTypeByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("convRate64", convRate64, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardCurrency", cardCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("processorAmount", processorAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardId", cardId, _buf);
	Atf::XmlElement::encodeAsXmlElement("flagsForClient", flagsForClient, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CardRollbackExtBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cardType"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cardType)) return false;
		}
		else if (_element.equals("cardMasked"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cardMasked)) return false;
		}
		else if (_element.equals("amount"))
		{
			amount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cardTypeByte"))
		{
			cardTypeByte = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("convRate64"))
		{
			convRate64 = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cardCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cardCurrency)) return false;
		}
		else if (_element.equals("processorAmount"))
		{
			processorAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cardId"))
		{
			cardId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flagsForClient"))
		{
			flagsForClient = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CardRollbackExtBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CardRollbackExtBody())) // not empty
	{
		_body.composeString(cardType);
		_body.composeString(cardMasked);
		_body.composeINT32(amount);
		_body.composeBYTE(cardTypeByte);
		_body.composeINT64(convRate64);
		_body.composeString(cardCurrency);
		_body.composeINT32(processorAmount);
		_body.composeUINT32(cardId);
		_body.composeUINT32(flagsForClient);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CardRollbackExtBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(cardType);
	_parser0.parseStringP(cardMasked);
	_parser0.parseINT32(amount);
	_parser0.parseBYTE(cardTypeByte);
	_parser0.parseINT64(convRate64);
	_parser0.parseStringP(cardCurrency);
	_parser0.parseINT32(processorAmount);
	_parser0.parseUINT32(cardId);
	_parser0.parseUINT32(flagsForClient);
}

const char *CashierServer::cli::CardRollbackExtBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cardType", cardType);
	_jsonstr.compose("cardMasked", cardMasked);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("cardTypeByte", cardTypeByte);
	_jsonstr.compose("convRate64", convRate64);
	_jsonstr.compose("cardCurrency", cardCurrency);
	_jsonstr.compose("processorAmount", processorAmount);
	_jsonstr.compose("cardId", cardId);
	_jsonstr.compose("flagsForClient", flagsForClient);
	return _buf.c_str();
}

void CashierServer::cli::CardRollbackExtBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cardType", cardType);
	_jparser.parseByNameThrow("cardMasked", cardMasked);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("cardTypeByte", cardTypeByte);
	_jparser.parseByNameThrow("convRate64", convRate64);
	_jparser.parseByNameThrow("cardCurrency", cardCurrency);
	_jparser.parseByNameThrow("processorAmount", processorAmount);
	_jparser.parseByNameThrow("cardId", cardId);
	_jparser.parseByNameThrow("flagsForClient", flagsForClient);
}

/* static */ void CashierServer::cli::CardRollbackExtBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString cardType; _jparser.validateByNameThrow("cardType", cardType);
	AtfValidator::validateInt(_descr, "cardType", cardType.length(), _checker, __FILE__, __LINE__);
	PString cardMasked; _jparser.validateByNameThrow("cardMasked", cardMasked);
	AtfValidator::validateInt(_descr, "cardMasked", cardMasked.length(), _checker, __FILE__, __LINE__);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	BYTE cardTypeByte; _jparser.validateByNameThrow("cardTypeByte", cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	INT64 convRate64; _jparser.validateByNameThrow("convRate64", convRate64);
	AtfValidator::validateInt(_descr, "convRate64", convRate64, _checker, __FILE__, __LINE__);
	PString cardCurrency; _jparser.validateByNameThrow("cardCurrency", cardCurrency);
	AtfValidator::validateInt(_descr, "cardCurrency", cardCurrency.length(), _checker, __FILE__, __LINE__);
	INT32 processorAmount; _jparser.validateByNameThrow("processorAmount", processorAmount);
	AtfValidator::validateInt(_descr, "processorAmount", processorAmount, _checker, __FILE__, __LINE__);
	UINT32 cardId; _jparser.validateByNameThrow("cardId", cardId);
	AtfValidator::validateInt(_descr, "cardId", cardId, _checker, __FILE__, __LINE__);
	UINT32 flagsForClient; _jparser.validateByNameThrow("flagsForClient", flagsForClient);
	AtfValidator::validateInt(_descr, "flagsForClient", flagsForClient, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CardRollbackExtBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "cardType"); size_t szCardType = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cardType", szCardType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "cardMasked"); size_t szCardMasked = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cardMasked", szCardMasked, _checker, __FILE__, __LINE__);
	INT32 amount; _parser0.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	BYTE cardTypeByte; _parser0.parseBYTE(cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	INT64 convRate64; _parser0.parseINT64(convRate64);
	AtfValidator::validateInt(_descr, "convRate64", convRate64, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "cardCurrency"); size_t szCardCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cardCurrency", szCardCurrency, _checker, __FILE__, __LINE__);
	INT32 processorAmount; _parser0.parseINT32(processorAmount);
	AtfValidator::validateInt(_descr, "processorAmount", processorAmount, _checker, __FILE__, __LINE__);
	UINT32 cardId; _parser0.parseUINT32(cardId);
	AtfValidator::validateInt(_descr, "cardId", cardId, _checker, __FILE__, __LINE__);
	UINT32 flagsForClient; _parser0.parseUINT32(flagsForClient);
	AtfValidator::validateInt(_descr, "flagsForClient", flagsForClient, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashoutOptionBody
//=================================================================

CashierServer::cli::CashoutOptionBody::CashoutOptionBody()
{
	clear();
}

void CashierServer::cli::CashoutOptionBody::clear()
{
	cardTypeByte = 0;
	when.setNull();
	maskedReference.clear();
	currCode.clear();
	convRate = 0;
	isAllowed = false;
	limitAmount = 0;
	explanation.clear();
	psForCashoutI18n.clear();
	coConvRate = 0;
	additionalText.clear();
	isTagged = false;
	cardId = 0;
	coFlagsForClient = 0;
}

bool CashierServer::cli::CashoutOptionBody::equals(const CashoutOptionBody& _o) const
{
	return cardTypeByte == _o.cardTypeByte &&
		when.equals(_o.when) &&
		Atf::atfPStringEquals(maskedReference, _o.maskedReference) &&
		Atf::atfPStringEquals(currCode, _o.currCode) &&
		convRate == _o.convRate &&
		isAllowed == _o.isAllowed &&
		limitAmount == _o.limitAmount &&
		Atf::atfPStringEquals(explanation, _o.explanation) &&
		Atf::atfPStringEquals(psForCashoutI18n, _o.psForCashoutI18n) &&
		coConvRate == _o.coConvRate &&
		Atf::atfPStringEquals(additionalText, _o.additionalText) &&
		isTagged == _o.isTagged &&
		cardId == _o.cardId &&
		coFlagsForClient == _o.coFlagsForClient;
}

const char *CashierServer::cli::CashoutOptionBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	_buf.append(',');
	_buf.append("when=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("maskedReference=");
	_buf.append(maskedReference);
	_buf.append(',');
	_buf.append("currCode=");
	_buf.append(currCode);
	_buf.append(',');
	_buf.append("convRate=");
	_buf.appendUint(convRate);
	_buf.append(',');
	_buf.append("isAllowed=");
	_buf.appendUint(isAllowed);
	_buf.append(',');
	_buf.append("limitAmount=");
	_buf.appendInt(limitAmount);
	_buf.append(',');
	_buf.append("explanation=");
	_buf.append(explanation);
	_buf.append(',');
	_buf.append("psForCashoutI18n=");
	_buf.append(psForCashoutI18n);
	_buf.append(',');
	_buf.append("coConvRate=");
	_buf.appendInt64(coConvRate);
	_buf.append(',');
	_buf.append("additionalText=");
	_buf.append(additionalText);
	_buf.append(',');
	_buf.append("isTagged=");
	_buf.appendUint(isTagged);
	_buf.append(',');
	_buf.append("cardId=");
	_buf.appendUint(cardId);
	_buf.append(',');
	_buf.append("coFlagsForClient=");
	_buf.appendUint(coFlagsForClient);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashoutOptionBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("cardTypeByte", cardTypeByte, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "when", when);
	Atf::XmlElement::encodeAsXmlElement("maskedReference", maskedReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("currCode", currCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("convRate", convRate, _buf);
	Atf::XmlElement::encodeAsXmlElement("isAllowed", isAllowed, _buf);
	Atf::XmlElement::encodeAsXmlElement("limitAmount", limitAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("explanation", explanation, _buf);
	Atf::XmlElement::encodeAsXmlElement("psForCashoutI18n", psForCashoutI18n, _buf);
	Atf::XmlElement::encodeAsXmlElement("coConvRate", coConvRate, _buf);
	Atf::XmlElement::encodeAsXmlElement("additionalText", additionalText, _buf);
	Atf::XmlElement::encodeAsXmlElement("isTagged", isTagged, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardId", cardId, _buf);
	Atf::XmlElement::encodeAsXmlElement("coFlagsForClient", coFlagsForClient, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashoutOptionBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cardTypeByte"))
		{
			cardTypeByte = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("when"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, when);
		}
		else if (_element.equals("maskedReference"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, maskedReference)) return false;
		}
		else if (_element.equals("currCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currCode)) return false;
		}
		else if (_element.equals("convRate"))
		{
			convRate = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isAllowed"))
		{
			isAllowed = (*_value.ptr() == '1');
		}
		else if (_element.equals("limitAmount"))
		{
			limitAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("explanation"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, explanation)) return false;
		}
		else if (_element.equals("psForCashoutI18n"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, psForCashoutI18n)) return false;
		}
		else if (_element.equals("coConvRate"))
		{
			coConvRate = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("additionalText"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, additionalText)) return false;
		}
		else if (_element.equals("isTagged"))
		{
			isTagged = (*_value.ptr() == '1');
		}
		else if (_element.equals("cardId"))
		{
			cardId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("coFlagsForClient"))
		{
			coFlagsForClient = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashoutOptionBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashoutOptionBody())) // not empty
	{
		_body.composeBYTE(cardTypeByte);
		_body.composeSrvTime(when);
		_body.composeString(maskedReference);
		_body.composeString(currCode);
		_body.composeUINT32(convRate);
		_body.composeBOOL(isAllowed);
		_body.composeINT32(limitAmount);
		_body.composeString(explanation);
		_body.composeString(psForCashoutI18n);
		_body.composeINT64(coConvRate);
		_body.composeString(additionalText);
		_body.composeBOOL(isTagged);
		_body.composeUINT32(cardId);
		_body.composeUINT32(coFlagsForClient);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashoutOptionBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(cardTypeByte);
	_parser0.parseSrvTime(when);
	_parser0.parseStringP(maskedReference);
	_parser0.parseStringP(currCode);
	_parser0.parseUINT32(convRate);
	_parser0.parseBOOL(isAllowed);
	_parser0.parseINT32(limitAmount);
	_parser0.parseStringP(explanation);
	_parser0.parseStringP(psForCashoutI18n);
	_parser0.parseINT64(coConvRate);
	_parser0.parseStringP(additionalText);
	_parser0.parseBOOL(isTagged);
	_parser0.parseUINT32(cardId);
	_parser0.parseUINT32(coFlagsForClient);
}

const char *CashierServer::cli::CashoutOptionBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cardTypeByte", cardTypeByte);
	_jsonstr.compose("when", when);
	_jsonstr.compose("maskedReference", maskedReference);
	_jsonstr.compose("currCode", currCode);
	_jsonstr.compose("convRate", convRate);
	_jsonstr.compose("isAllowed", isAllowed);
	_jsonstr.compose("limitAmount", limitAmount);
	_jsonstr.compose("explanation", explanation);
	_jsonstr.compose("psForCashoutI18n", psForCashoutI18n);
	_jsonstr.compose("coConvRate", coConvRate);
	_jsonstr.compose("additionalText", additionalText);
	_jsonstr.compose("isTagged", isTagged);
	_jsonstr.compose("cardId", cardId);
	_jsonstr.compose("coFlagsForClient", coFlagsForClient);
	return _buf.c_str();
}

void CashierServer::cli::CashoutOptionBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cardTypeByte", cardTypeByte);
	_jparser.parseByNameThrow("when", when);
	_jparser.parseByNameThrow("maskedReference", maskedReference);
	_jparser.parseByNameThrow("currCode", currCode);
	_jparser.parseByNameThrow("convRate", convRate);
	_jparser.parseByNameThrow("isAllowed", isAllowed);
	_jparser.parseByNameThrow("limitAmount", limitAmount);
	_jparser.parseByNameThrow("explanation", explanation);
	_jparser.parseByNameThrow("psForCashoutI18n", psForCashoutI18n);
	_jparser.parseByNameThrow("coConvRate", coConvRate);
	_jparser.parseByNameThrow("additionalText", additionalText);
	_jparser.parseByNameThrow("isTagged", isTagged);
	_jparser.parseByNameThrow("cardId", cardId);
	_jparser.parseByNameThrow("coFlagsForClient", coFlagsForClient);
}

/* static */ void CashierServer::cli::CashoutOptionBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE cardTypeByte; _jparser.validateByNameThrow("cardTypeByte", cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	CommSrvTime when; _jparser.validateByNameThrow("when", when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	PString maskedReference; _jparser.validateByNameThrow("maskedReference", maskedReference);
	AtfValidator::validateInt(_descr, "maskedReference", maskedReference.length(), _checker, __FILE__, __LINE__);
	PString currCode; _jparser.validateByNameThrow("currCode", currCode);
	AtfValidator::validateInt(_descr, "currCode", currCode.length(), _checker, __FILE__, __LINE__);
	UINT32 convRate; _jparser.validateByNameThrow("convRate", convRate);
	AtfValidator::validateInt(_descr, "convRate", convRate, _checker, __FILE__, __LINE__);
	bool isAllowed; _jparser.validateByNameThrow("isAllowed", isAllowed);
	AtfValidator::validateInt(_descr, "isAllowed", isAllowed, _checker, __FILE__, __LINE__);
	INT32 limitAmount; _jparser.validateByNameThrow("limitAmount", limitAmount);
	AtfValidator::validateInt(_descr, "limitAmount", limitAmount, _checker, __FILE__, __LINE__);
	PString explanation; _jparser.validateByNameThrow("explanation", explanation);
	AtfValidator::validateInt(_descr, "explanation", explanation.length(), _checker, __FILE__, __LINE__);
	PString psForCashoutI18n; _jparser.validateByNameThrow("psForCashoutI18n", psForCashoutI18n);
	AtfValidator::validateInt(_descr, "psForCashoutI18n", psForCashoutI18n.length(), _checker, __FILE__, __LINE__);
	INT64 coConvRate; _jparser.validateByNameThrow("coConvRate", coConvRate);
	AtfValidator::validateInt(_descr, "coConvRate", coConvRate, _checker, __FILE__, __LINE__);
	PString additionalText; _jparser.validateByNameThrow("additionalText", additionalText);
	AtfValidator::validateInt(_descr, "additionalText", additionalText.length(), _checker, __FILE__, __LINE__);
	bool isTagged; _jparser.validateByNameThrow("isTagged", isTagged);
	AtfValidator::validateInt(_descr, "isTagged", isTagged, _checker, __FILE__, __LINE__);
	UINT32 cardId; _jparser.validateByNameThrow("cardId", cardId);
	AtfValidator::validateInt(_descr, "cardId", cardId, _checker, __FILE__, __LINE__);
	UINT32 coFlagsForClient; _jparser.validateByNameThrow("coFlagsForClient", coFlagsForClient);
	AtfValidator::validateInt(_descr, "coFlagsForClient", coFlagsForClient, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashoutOptionBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE cardTypeByte; _parser0.parseBYTE(cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	CommSrvTime when; _parser0.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "maskedReference"); size_t szMaskedReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "maskedReference", szMaskedReference, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currCode"); size_t szCurrCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currCode", szCurrCode, _checker, __FILE__, __LINE__);
	UINT32 convRate; _parser0.parseUINT32(convRate);
	AtfValidator::validateInt(_descr, "convRate", convRate, _checker, __FILE__, __LINE__);
	bool isAllowed; _parser0.parseBOOL(isAllowed);
	AtfValidator::validateInt(_descr, "isAllowed", isAllowed, _checker, __FILE__, __LINE__);
	INT32 limitAmount; _parser0.parseINT32(limitAmount);
	AtfValidator::validateInt(_descr, "limitAmount", limitAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "explanation"); size_t szExplanation = strlen(_dummy);
	AtfValidator::validateInt(_descr, "explanation", szExplanation, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "psForCashoutI18n"); size_t szPsForCashoutI18n = strlen(_dummy);
	AtfValidator::validateInt(_descr, "psForCashoutI18n", szPsForCashoutI18n, _checker, __FILE__, __LINE__);
	INT64 coConvRate; _parser0.parseINT64(coConvRate);
	AtfValidator::validateInt(_descr, "coConvRate", coConvRate, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "additionalText"); size_t szAdditionalText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "additionalText", szAdditionalText, _checker, __FILE__, __LINE__);
	bool isTagged; _parser0.parseBOOL(isTagged);
	AtfValidator::validateInt(_descr, "isTagged", isTagged, _checker, __FILE__, __LINE__);
	UINT32 cardId; _parser0.parseUINT32(cardId);
	AtfValidator::validateInt(_descr, "cardId", cardId, _checker, __FILE__, __LINE__);
	UINT32 coFlagsForClient; _parser0.parseUINT32(coFlagsForClient);
	AtfValidator::validateInt(_descr, "coFlagsForClient", coFlagsForClient, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	needsBonusWarning = 0;
	bonusName.clear();
	bonusUrl.clear();
	bonusPercent = 0;
	bonusMaxAmount = 0;
	estimatedRollback = 0;
	zero = 0;
	userPhone.clear();
	zero2 = 0;
	rollbacks.clear();
	cashoutOptions.clear();
	rollbacksExt.clear();
	preCashoutReplyFlags = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::equals(const Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		needsBonusWarning == _o.needsBonusWarning &&
		Atf::atfPStringEquals(bonusName, _o.bonusName) &&
		Atf::atfPStringEquals(bonusUrl, _o.bonusUrl) &&
		bonusPercent == _o.bonusPercent &&
		bonusMaxAmount == _o.bonusMaxAmount &&
		estimatedRollback == _o.estimatedRollback &&
		zero == _o.zero &&
		Atf::atfPStringEquals(userPhone, _o.userPhone) &&
		zero2 == _o.zero2 &&
		rollbacks.equals(_o.rollbacks) &&
		cashoutOptions.equals(_o.cashoutOptions) &&
		rollbacksExt.equals(_o.rollbacksExt) &&
		preCashoutReplyFlags == _o.preCashoutReplyFlags;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PRE_CASHOUT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PRE_CASHOUT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("needsBonusWarning=");
		_buf.appendUint(needsBonusWarning);
		_buf.append(',');
		_buf.append("bonusName=");
		_buf.append(bonusName);
		_buf.append(',');
		_buf.append("bonusUrl=");
		_buf.append(bonusUrl);
		_buf.append(',');
		_buf.append("bonusPercent=");
		_buf.appendInt(bonusPercent);
		_buf.append(',');
		_buf.append("bonusMaxAmount=");
		_buf.appendInt(bonusMaxAmount);
		_buf.append(',');
		_buf.append("estimatedRollback=");
		_buf.appendInt(estimatedRollback);
		_buf.append(',');
		_buf.append("zero=");
		_buf.appendInt(zero);
		_buf.append(',');
		_buf.append("userPhone=");
		_buf.append(userPhone);
		_buf.append(',');
		_buf.append("zero2=");
		_buf.appendInt(zero2);
		_buf.append(',');
		_buf.append("rollbacks=");
		rollbacks.toTraceString(_buf);
		_buf.append(',');
		_buf.append("cashoutOptions=");
		cashoutOptions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("rollbacksExt=");
		rollbacksExt.toTraceString(_buf);
		_buf.append(',');
		_buf.append("preCashoutReplyFlags=");
		_buf.appendUint(preCashoutReplyFlags);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PRE_CASHOUT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("needsBonusWarning", needsBonusWarning, _buf);
		Atf::XmlElement::encodeAsXmlElement("bonusName", bonusName, _buf);
		Atf::XmlElement::encodeAsXmlElement("bonusUrl", bonusUrl, _buf);
		Atf::XmlElement::encodeAsXmlElement("bonusPercent", bonusPercent, _buf);
		Atf::XmlElement::encodeAsXmlElement("bonusMaxAmount", bonusMaxAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("estimatedRollback", estimatedRollback, _buf);
		Atf::XmlElement::encodeAsXmlElement("zero", zero, _buf);
		Atf::XmlElement::encodeAsXmlElement("userPhone", userPhone, _buf);
		Atf::XmlElement::encodeAsXmlElement("zero2", zero2, _buf);
		rollbacks.toXmlString("rollbacks", _buf);
		cashoutOptions.toXmlString("cashoutOptions", _buf);
		rollbacksExt.toXmlString("rollbacksExt", _buf);
		Atf::XmlElement::encodeAsXmlElement("preCashoutReplyFlags", preCashoutReplyFlags, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("needsBonusWarning"))
			{
				needsBonusWarning = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bonusName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bonusName)) return false;
			}
			else if (_element.equals("bonusUrl"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bonusUrl)) return false;
			}
			else if (_element.equals("bonusPercent"))
			{
				bonusPercent = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bonusMaxAmount"))
			{
				bonusMaxAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("estimatedRollback"))
			{
				estimatedRollback = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("zero"))
			{
				zero = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userPhone"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userPhone)) return false;
			}
			else if (_element.equals("zero2"))
			{
				zero2 = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rollbacks"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CardRollback, 2 > >::FromXmlString(_value, rollbacks)) return false;
			}
			else if (_element.equals("cashoutOptions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashoutOptionBody, 4 > >::FromXmlString(_value, cashoutOptions)) return false;
			}
			else if (_element.equals("rollbacksExt"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CardRollbackExtBody, 4 > >::FromXmlString(_value, rollbacksExt)) return false;
			}
			else if (_element.equals("preCashoutReplyFlags"))
			{
				preCashoutReplyFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBYTE(needsBonusWarning);
		_msg.composeString(bonusName);
		_msg.composeString(bonusUrl);
		_msg.composeINT32(bonusPercent);
		_msg.composeINT32(bonusMaxAmount);
		_msg.composeINT32(estimatedRollback);
		_msg.composeINT16(zero);
		_msg.composeString(userPhone);
		_msg.composeINT16(zero2);
		rollbacks.composeMsg(_msg, _ignoreJSON);
		cashoutOptions.composeMsg(_msg, _ignoreJSON);
		rollbacksExt.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT32(preCashoutReplyFlags);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBYTE(needsBonusWarning);
		_parser.parseStringP(bonusName);
		_parser.parseStringP(bonusUrl);
		_parser.parseINT32(bonusPercent);
		_parser.parseINT32(bonusMaxAmount);
		_parser.parseINT32(estimatedRollback);
		_parser.parseINT16(zero);
		_parser.parseStringP(userPhone);
		_parser.parseINT16(zero2);
		rollbacks.parseMsg(_parser);
		cashoutOptions.parseMsg(_parser);
		rollbacksExt.parseMsg(_parser);
		_parser.parseUINT32(preCashoutReplyFlags);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("needsBonusWarning", needsBonusWarning);
		_jsonstr.compose("bonusName", bonusName);
		_jsonstr.compose("bonusUrl", bonusUrl);
		_jsonstr.compose("bonusPercent", bonusPercent);
		_jsonstr.compose("bonusMaxAmount", bonusMaxAmount);
		_jsonstr.compose("estimatedRollback", estimatedRollback);
		_jsonstr.compose("zero", zero);
		_jsonstr.compose("userPhone", userPhone);
		_jsonstr.compose("zero2", zero2);
		_jsonstr.compose("rollbacks", rollbacks);
		_jsonstr.compose("cashoutOptions", cashoutOptions);
		_jsonstr.compose("rollbacksExt", rollbacksExt);
		_jsonstr.compose("preCashoutReplyFlags", preCashoutReplyFlags);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("needsBonusWarning", needsBonusWarning);
		_jparser.parseByNameThrow("bonusName", bonusName);
		_jparser.parseByNameThrow("bonusUrl", bonusUrl);
		_jparser.parseByNameThrow("bonusPercent", bonusPercent);
		_jparser.parseByNameThrow("bonusMaxAmount", bonusMaxAmount);
		_jparser.parseByNameThrow("estimatedRollback", estimatedRollback);
		_jparser.parseByNameThrow("zero", zero);
		_jparser.parseByNameThrow("userPhone", userPhone);
		_jparser.parseByNameThrow("zero2", zero2);
		_jparser.parseByNameThrow("rollbacks", rollbacks);
		_jparser.parseByNameThrow("cashoutOptions", cashoutOptions);
		_jparser.parseByNameThrow("rollbacksExt", rollbacksExt);
		_jparser.parseByNameThrow("preCashoutReplyFlags", preCashoutReplyFlags);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PRE_CASHOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE needsBonusWarning; _jparser.validateByNameThrow("needsBonusWarning", needsBonusWarning);
		AtfValidator::validateInt(_descr, "needsBonusWarning", needsBonusWarning, _checker, __FILE__, __LINE__);
		PString bonusName; _jparser.validateByNameThrow("bonusName", bonusName);
		AtfValidator::validateInt(_descr, "bonusName", bonusName.length(), _checker, __FILE__, __LINE__);
		PString bonusUrl; _jparser.validateByNameThrow("bonusUrl", bonusUrl);
		AtfValidator::validateInt(_descr, "bonusUrl", bonusUrl.length(), _checker, __FILE__, __LINE__);
		INT32 bonusPercent; _jparser.validateByNameThrow("bonusPercent", bonusPercent);
		AtfValidator::validateInt(_descr, "bonusPercent", bonusPercent, _checker, __FILE__, __LINE__);
		INT32 bonusMaxAmount; _jparser.validateByNameThrow("bonusMaxAmount", bonusMaxAmount);
		AtfValidator::validateInt(_descr, "bonusMaxAmount", bonusMaxAmount, _checker, __FILE__, __LINE__);
		INT32 estimatedRollback; _jparser.validateByNameThrow("estimatedRollback", estimatedRollback);
		AtfValidator::validateInt(_descr, "estimatedRollback", estimatedRollback, _checker, __FILE__, __LINE__);
		INT16 zero; _jparser.validateByNameThrow("zero", zero);
		AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
		PString userPhone; _jparser.validateByNameThrow("userPhone", userPhone);
		AtfValidator::validateInt(_descr, "userPhone", userPhone.length(), _checker, __FILE__, __LINE__);
		INT16 zero2; _jparser.validateByNameThrow("zero2", zero2);
		AtfValidator::validateInt(_descr, "zero2", zero2, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< CardRollback > rollbacks; _jparser.validateByNameThrow("rollbacks", rollbacks);
		AtfValidator::validateInt(_descr, "rollbacks", rollbacks.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< CashoutOptionBody > cashoutOptions; _jparser.validateByNameThrow("cashoutOptions", cashoutOptions);
		AtfValidator::validateInt(_descr, "cashoutOptions", cashoutOptions.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< CardRollbackExtBody > rollbacksExt; _jparser.validateByNameThrow("rollbacksExt", rollbacksExt);
		AtfValidator::validateInt(_descr, "rollbacksExt", rollbacksExt.size(), _checker, __FILE__, __LINE__);
		UINT32 preCashoutReplyFlags; _jparser.validateByNameThrow("preCashoutReplyFlags", preCashoutReplyFlags);
		AtfValidator::validateInt(_descr, "preCashoutReplyFlags", preCashoutReplyFlags, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PRE_CASHOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE needsBonusWarning; _parser.parseBYTE(needsBonusWarning);
		AtfValidator::validateInt(_descr, "needsBonusWarning", needsBonusWarning, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bonusName"); size_t szBonusName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bonusName", szBonusName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bonusUrl"); size_t szBonusUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bonusUrl", szBonusUrl, _checker, __FILE__, __LINE__);
		INT32 bonusPercent; _parser.parseINT32(bonusPercent);
		AtfValidator::validateInt(_descr, "bonusPercent", bonusPercent, _checker, __FILE__, __LINE__);
		INT32 bonusMaxAmount; _parser.parseINT32(bonusMaxAmount);
		AtfValidator::validateInt(_descr, "bonusMaxAmount", bonusMaxAmount, _checker, __FILE__, __LINE__);
		INT32 estimatedRollback; _parser.parseINT32(estimatedRollback);
		AtfValidator::validateInt(_descr, "estimatedRollback", estimatedRollback, _checker, __FILE__, __LINE__);
		INT16 zero; _parser.parseINT16(zero);
		AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userPhone"); size_t szUserPhone = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userPhone", szUserPhone, _checker, __FILE__, __LINE__);
		INT16 zero2; _parser.parseINT16(zero2);
		AtfValidator::validateInt(_descr, "zero2", zero2, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szRollbacks = Atf::LAtfVector< CardRollback, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("rollbacks"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "rollbacks", szRollbacks, _checker, __FILE__, __LINE__);
		int szCashoutOptions = Atf::LAtfVector< CashoutOptionBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cashoutOptions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "cashoutOptions", szCashoutOptions, _checker, __FILE__, __LINE__);
		int szRollbacksExt = Atf::LAtfVector< CardRollbackExtBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("rollbacksExt"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "rollbacksExt", szRollbacksExt, _checker, __FILE__, __LINE__);
		UINT32 preCashoutReplyFlags; _parser.parseUINT32(preCashoutReplyFlags);
		AtfValidator::validateInt(_descr, "preCashoutReplyFlags", preCashoutReplyFlags, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VIP_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::Protocol_MSG_CASHIER_VIP_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::clear()
{
	userId.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::equals(const Protocol_MSG_CASHIER_VIP_INFO& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_VIP_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_VIP_INFO*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VIP_INFO).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_VIP_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VIP_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VIP_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    VipLevelBody
//=================================================================

CashierServer::cli::VipLevelBody::VipLevelBody()
{
	clear();
}

void CashierServer::cli::VipLevelBody::clear()
{
	statusId = 0;
	type = 0;
	minFpp = 0;
	fppBonusRate = 0;
	vipToKeepYearlyStatus = 0;
	lastMonthForYearly = 0;
	missableMonthsYearly = 0;
}

bool CashierServer::cli::VipLevelBody::equals(const VipLevelBody& _o) const
{
	return statusId == _o.statusId &&
		type == _o.type &&
		minFpp == _o.minFpp &&
		fppBonusRate == _o.fppBonusRate &&
		vipToKeepYearlyStatus == _o.vipToKeepYearlyStatus &&
		lastMonthForYearly == _o.lastMonthForYearly &&
		missableMonthsYearly == _o.missableMonthsYearly;
}

const char *CashierServer::cli::VipLevelBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("statusId=");
	_buf.appendInt(statusId);
	_buf.append(',');
	_buf.append("type=");
	_buf.appendInt(type);
	_buf.append(',');
	_buf.append("minFpp=");
	_buf.appendInt(minFpp);
	_buf.append(',');
	_buf.append("fppBonusRate=");
	_buf.appendInt(fppBonusRate);
	_buf.append(',');
	_buf.append("vipToKeepYearlyStatus=");
	_buf.appendInt(vipToKeepYearlyStatus);
	_buf.append(',');
	_buf.append("lastMonthForYearly=");
	_buf.appendInt(lastMonthForYearly);
	_buf.append(',');
	_buf.append("missableMonthsYearly=");
	_buf.appendInt(missableMonthsYearly);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::VipLevelBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("statusId", statusId, _buf);
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("minFpp", minFpp, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBonusRate", fppBonusRate, _buf);
	Atf::XmlElement::encodeAsXmlElement("vipToKeepYearlyStatus", vipToKeepYearlyStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("lastMonthForYearly", lastMonthForYearly, _buf);
	Atf::XmlElement::encodeAsXmlElement("missableMonthsYearly", missableMonthsYearly, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::VipLevelBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("statusId"))
		{
			statusId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("type"))
		{
			type = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minFpp"))
		{
			minFpp = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppBonusRate"))
		{
			fppBonusRate = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("vipToKeepYearlyStatus"))
		{
			vipToKeepYearlyStatus = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lastMonthForYearly"))
		{
			lastMonthForYearly = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("missableMonthsYearly"))
		{
			missableMonthsYearly = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::VipLevelBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(VipLevelBody())) // not empty
	{
		_body.composeINT32(statusId);
		_body.composeINT32(type);
		_body.composeINT32(minFpp);
		_body.composeINT32(fppBonusRate);
		_body.composeINT32(vipToKeepYearlyStatus);
		_body.composeINT32(lastMonthForYearly);
		_body.composeINT32(missableMonthsYearly);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::VipLevelBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(statusId);
	_parser0.parseINT32(type);
	_parser0.parseINT32(minFpp);
	_parser0.parseINT32(fppBonusRate);
	_parser0.parseINT32(vipToKeepYearlyStatus);
	_parser0.parseINT32(lastMonthForYearly);
	_parser0.parseINT32(missableMonthsYearly);
}

const char *CashierServer::cli::VipLevelBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("statusId", statusId);
	_jsonstr.compose("type", type);
	_jsonstr.compose("minFpp", minFpp);
	_jsonstr.compose("fppBonusRate", fppBonusRate);
	_jsonstr.compose("vipToKeepYearlyStatus", vipToKeepYearlyStatus);
	_jsonstr.compose("lastMonthForYearly", lastMonthForYearly);
	_jsonstr.compose("missableMonthsYearly", missableMonthsYearly);
	return _buf.c_str();
}

void CashierServer::cli::VipLevelBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("statusId", statusId);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("minFpp", minFpp);
	_jparser.parseByNameThrow("fppBonusRate", fppBonusRate);
	_jparser.parseByNameThrow("vipToKeepYearlyStatus", vipToKeepYearlyStatus);
	_jparser.parseByNameThrow("lastMonthForYearly", lastMonthForYearly);
	_jparser.parseByNameThrow("missableMonthsYearly", missableMonthsYearly);
}

/* static */ void CashierServer::cli::VipLevelBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 statusId; _jparser.validateByNameThrow("statusId", statusId);
	AtfValidator::validateInt(_descr, "statusId", statusId, _checker, __FILE__, __LINE__);
	INT32 type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	INT32 minFpp; _jparser.validateByNameThrow("minFpp", minFpp);
	AtfValidator::validateInt(_descr, "minFpp", minFpp, _checker, __FILE__, __LINE__);
	INT32 fppBonusRate; _jparser.validateByNameThrow("fppBonusRate", fppBonusRate);
	AtfValidator::validateInt(_descr, "fppBonusRate", fppBonusRate, _checker, __FILE__, __LINE__);
	INT32 vipToKeepYearlyStatus; _jparser.validateByNameThrow("vipToKeepYearlyStatus", vipToKeepYearlyStatus);
	AtfValidator::validateInt(_descr, "vipToKeepYearlyStatus", vipToKeepYearlyStatus, _checker, __FILE__, __LINE__);
	INT32 lastMonthForYearly; _jparser.validateByNameThrow("lastMonthForYearly", lastMonthForYearly);
	AtfValidator::validateInt(_descr, "lastMonthForYearly", lastMonthForYearly, _checker, __FILE__, __LINE__);
	INT32 missableMonthsYearly; _jparser.validateByNameThrow("missableMonthsYearly", missableMonthsYearly);
	AtfValidator::validateInt(_descr, "missableMonthsYearly", missableMonthsYearly, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::VipLevelBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 statusId; _parser0.parseINT32(statusId);
	AtfValidator::validateInt(_descr, "statusId", statusId, _checker, __FILE__, __LINE__);
	INT32 type; _parser0.parseINT32(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	INT32 minFpp; _parser0.parseINT32(minFpp);
	AtfValidator::validateInt(_descr, "minFpp", minFpp, _checker, __FILE__, __LINE__);
	INT32 fppBonusRate; _parser0.parseINT32(fppBonusRate);
	AtfValidator::validateInt(_descr, "fppBonusRate", fppBonusRate, _checker, __FILE__, __LINE__);
	INT32 vipToKeepYearlyStatus; _parser0.parseINT32(vipToKeepYearlyStatus);
	AtfValidator::validateInt(_descr, "vipToKeepYearlyStatus", vipToKeepYearlyStatus, _checker, __FILE__, __LINE__);
	INT32 lastMonthForYearly; _parser0.parseINT32(lastMonthForYearly);
	AtfValidator::validateInt(_descr, "lastMonthForYearly", lastMonthForYearly, _checker, __FILE__, __LINE__);
	INT32 missableMonthsYearly; _parser0.parseINT32(missableMonthsYearly);
	AtfValidator::validateInt(_descr, "missableMonthsYearly", missableMonthsYearly, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    StellarBonusLevel
//=================================================================

CashierServer::cli::StellarBonusLevel::StellarBonusLevel()
{
	clear();
}

void CashierServer::cli::StellarBonusLevel::clear()
{
	groupId = 0;
	vppThreshold = 0;
	amount = 0;
}

bool CashierServer::cli::StellarBonusLevel::equals(const StellarBonusLevel& _o) const
{
	return groupId == _o.groupId &&
		vppThreshold == _o.vppThreshold &&
		amount == _o.amount;
}

const char *CashierServer::cli::StellarBonusLevel::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("groupId=");
	_buf.appendUint(groupId);
	_buf.append(',');
	_buf.append("vppThreshold=");
	_buf.appendInt(vppThreshold);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::StellarBonusLevel::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("groupId", groupId, _buf);
	Atf::XmlElement::encodeAsXmlElement("vppThreshold", vppThreshold, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::StellarBonusLevel::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("groupId"))
		{
			groupId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("vppThreshold"))
		{
			vppThreshold = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("amount"))
		{
			amount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::StellarBonusLevel::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(groupId);
	_msg.composeINT32(vppThreshold);
	_msg.composeINT32(amount);
}

void CashierServer::cli::StellarBonusLevel::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(groupId);
	_parser.parseINT32(vppThreshold);
	_parser.parseINT32(amount);
}

const char *CashierServer::cli::StellarBonusLevel::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("groupId", groupId);
	_jsonstr.compose("vppThreshold", vppThreshold);
	_jsonstr.compose("amount", amount);
	return _buf.c_str();
}

void CashierServer::cli::StellarBonusLevel::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("groupId", groupId);
	_jparser.parseByNameThrow("vppThreshold", vppThreshold);
	_jparser.parseByNameThrow("amount", amount);
}

/* static */ void CashierServer::cli::StellarBonusLevel::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 groupId; _jparser.validateByNameThrow("groupId", groupId);
	AtfValidator::validateInt(_descr, "groupId", groupId, _checker, __FILE__, __LINE__);
	INT32 vppThreshold; _jparser.validateByNameThrow("vppThreshold", vppThreshold);
	AtfValidator::validateInt(_descr, "vppThreshold", vppThreshold, _checker, __FILE__, __LINE__);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::StellarBonusLevel::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 groupId; _parser.parseUINT32(groupId);
	AtfValidator::validateInt(_descr, "groupId", groupId, _checker, __FILE__, __LINE__);
	INT32 vppThreshold; _parser.parseINT32(vppThreshold);
	AtfValidator::validateInt(_descr, "vppThreshold", vppThreshold, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_VIP_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::Protocol_MSG_CASHIER_VIP_INFO_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	zero = 0;
	lastMonthForYearlyOld = 0;
	stellarBonuses.clear();
	previousYearVPP = 0;
	zero2 = 0;
	dailyCnt = 0;
	vipLevelBodies.clear();
	ltVppInCents = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::equals(const Protocol_MSG_CASHIER_VIP_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		zero == _o.zero &&
		lastMonthForYearlyOld == _o.lastMonthForYearlyOld &&
		stellarBonuses.equals(_o.stellarBonuses) &&
		previousYearVPP == _o.previousYearVPP &&
		zero2 == _o.zero2 &&
		dailyCnt == _o.dailyCnt &&
		vipLevelBodies.equals(_o.vipLevelBodies) &&
		ltVppInCents == _o.ltVppInCents;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_VIP_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_VIP_INFO_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VIP_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("zero=");
		_buf.appendUint(zero);
		_buf.append(',');
		_buf.append("lastMonthForYearlyOld=");
		_buf.appendInt(lastMonthForYearlyOld);
		_buf.append(',');
		_buf.append("stellarBonuses=");
		stellarBonuses.toTraceString(_buf);
		_buf.append(',');
		_buf.append("previousYearVPP=");
		_buf.appendInt(previousYearVPP);
		_buf.append(',');
		_buf.append("zero2=");
		_buf.appendUint(zero2);
		_buf.append(',');
		_buf.append("dailyCnt=");
		_buf.appendInt(dailyCnt);
		_buf.append(',');
		_buf.append("vipLevelBodies=");
		vipLevelBodies.toTraceString(_buf);
		_buf.append(',');
		_buf.append("ltVppInCents=");
		_buf.appendInt64(ltVppInCents);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_VIP_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("zero", zero, _buf);
		Atf::XmlElement::encodeAsXmlElement("lastMonthForYearlyOld", lastMonthForYearlyOld, _buf);
		stellarBonuses.toXmlString("stellarBonuses", _buf);
		Atf::XmlElement::encodeAsXmlElement("previousYearVPP", previousYearVPP, _buf);
		Atf::XmlElement::encodeAsXmlElement("zero2", zero2, _buf);
		Atf::XmlElement::encodeAsXmlElement("dailyCnt", dailyCnt, _buf);
		vipLevelBodies.toXmlString("vipLevelBodies", _buf);
		Atf::XmlElement::encodeAsXmlElement("ltVppInCents", ltVppInCents, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("zero"))
			{
				zero = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("lastMonthForYearlyOld"))
			{
				lastMonthForYearlyOld = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("stellarBonuses"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< StellarBonusLevel, 4 > >::FromXmlString(_value, stellarBonuses)) return false;
			}
			else if (_element.equals("previousYearVPP"))
			{
				previousYearVPP = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("zero2"))
			{
				zero2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("dailyCnt"))
			{
				dailyCnt = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vipLevelBodies"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< VipLevelBody, 4 > >::FromXmlString(_value, vipLevelBodies)) return false;
			}
			else if (_element.equals("ltVppInCents"))
			{
				ltVppInCents = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(zero);
		_msg.composeINT32(lastMonthForYearlyOld);
		stellarBonuses.composeMsg(_msg, _ignoreJSON);
		_msg.composeINT32(previousYearVPP);
		_msg.composeUINT32(zero2);
		_msg.composeINT32(dailyCnt);
		vipLevelBodies.composeMsg(_msg, _ignoreJSON);
		_msg.composeINT64(ltVppInCents);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(zero);
		_parser.parseINT32(lastMonthForYearlyOld);
		stellarBonuses.parseMsg(_parser);
		_parser.parseINT32(previousYearVPP);
		_parser.parseUINT32(zero2);
		_parser.parseINT32(dailyCnt);
		vipLevelBodies.parseMsg(_parser);
		_parser.parseINT64(ltVppInCents);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("zero", zero);
		_jsonstr.compose("lastMonthForYearlyOld", lastMonthForYearlyOld);
		_jsonstr.compose("stellarBonuses", stellarBonuses);
		_jsonstr.compose("previousYearVPP", previousYearVPP);
		_jsonstr.compose("zero2", zero2);
		_jsonstr.compose("dailyCnt", dailyCnt);
		_jsonstr.compose("vipLevelBodies", vipLevelBodies);
		_jsonstr.compose("ltVppInCents", ltVppInCents);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("zero", zero);
		_jparser.parseByNameThrow("lastMonthForYearlyOld", lastMonthForYearlyOld);
		_jparser.parseByNameThrow("stellarBonuses", stellarBonuses);
		_jparser.parseByNameThrow("previousYearVPP", previousYearVPP);
		_jparser.parseByNameThrow("zero2", zero2);
		_jparser.parseByNameThrow("dailyCnt", dailyCnt);
		_jparser.parseByNameThrow("vipLevelBodies", vipLevelBodies);
		_jparser.parseByNameThrow("ltVppInCents", ltVppInCents);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VIP_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 zero; _jparser.validateByNameThrow("zero", zero);
		AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
		INT32 lastMonthForYearlyOld; _jparser.validateByNameThrow("lastMonthForYearlyOld", lastMonthForYearlyOld);
		AtfValidator::validateInt(_descr, "lastMonthForYearlyOld", lastMonthForYearlyOld, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< StellarBonusLevel > stellarBonuses; _jparser.validateByNameThrow("stellarBonuses", stellarBonuses);
		AtfValidator::validateInt(_descr, "stellarBonuses", stellarBonuses.size(), _checker, __FILE__, __LINE__);
		INT32 previousYearVPP; _jparser.validateByNameThrow("previousYearVPP", previousYearVPP);
		AtfValidator::validateInt(_descr, "previousYearVPP", previousYearVPP, _checker, __FILE__, __LINE__);
		UINT32 zero2; _jparser.validateByNameThrow("zero2", zero2);
		AtfValidator::validateInt(_descr, "zero2", zero2, _checker, __FILE__, __LINE__);
		INT32 dailyCnt; _jparser.validateByNameThrow("dailyCnt", dailyCnt);
		AtfValidator::validateInt(_descr, "dailyCnt", dailyCnt, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< VipLevelBody > vipLevelBodies; _jparser.validateByNameThrow("vipLevelBodies", vipLevelBodies);
		AtfValidator::validateInt(_descr, "vipLevelBodies", vipLevelBodies.size(), _checker, __FILE__, __LINE__);
		INT64 ltVppInCents; _jparser.validateByNameThrow("ltVppInCents", ltVppInCents);
		AtfValidator::validateInt(_descr, "ltVppInCents", ltVppInCents, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VIP_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 zero; _parser.parseUINT32(zero);
		AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
		INT32 lastMonthForYearlyOld; _parser.parseINT32(lastMonthForYearlyOld);
		AtfValidator::validateInt(_descr, "lastMonthForYearlyOld", lastMonthForYearlyOld, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szStellarBonuses = Atf::LAtfVector< StellarBonusLevel, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("stellarBonuses"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "stellarBonuses", szStellarBonuses, _checker, __FILE__, __LINE__);
		INT32 previousYearVPP; _parser.parseINT32(previousYearVPP);
		AtfValidator::validateInt(_descr, "previousYearVPP", previousYearVPP, _checker, __FILE__, __LINE__);
		UINT32 zero2; _parser.parseUINT32(zero2);
		AtfValidator::validateInt(_descr, "zero2", zero2, _checker, __FILE__, __LINE__);
		INT32 dailyCnt; _parser.parseINT32(dailyCnt);
		AtfValidator::validateInt(_descr, "dailyCnt", dailyCnt, _checker, __FILE__, __LINE__);
		int szVipLevelBodies = Atf::LAtfVector< VipLevelBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("vipLevelBodies"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "vipLevelBodies", szVipLevelBodies, _checker, __FILE__, __LINE__);
		INT64 ltVppInCents; _parser.parseINT64(ltVppInCents);
		AtfValidator::validateInt(_descr, "ltVppInCents", ltVppInCents, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SAVED_CARD
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::Protocol_MSG_CASHIER_SAVED_CARD()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::clear()
{
	userId.clear();
	paySystem.clear();
	cardInfoId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::equals(const Protocol_MSG_CASHIER_SAVED_CARD& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(paySystem, _o.paySystem) &&
		cardInfoId == _o.cardInfoId;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SAVED_CARD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SAVED_CARD*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SAVED_CARD).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("paySystem=");
	_buf.append(paySystem);
	_buf.append(',');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SAVED_CARD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("paySystem", paySystem, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardInfoId", cardInfoId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("paySystem"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, paySystem)) return false;
			}
			else if (_element.equals("cardInfoId"))
			{
				cardInfoId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeString(paySystem);
	_msg.composeUINT32(cardInfoId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseStringP(paySystem);
	_parser.parseUINT32(cardInfoId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("paySystem", paySystem);
	_jsonstr.compose("cardInfoId", cardInfoId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("paySystem", paySystem);
	_jparser.parseByNameThrow("cardInfoId", cardInfoId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVED_CARD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString paySystem; _jparser.validateByNameThrow("paySystem", paySystem);
	AtfValidator::validateIntRange(_descr, "paySystem", paySystem.length(), 1, 1000, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _jparser.validateByNameThrow("cardInfoId", cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVED_CARD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "paySystem"); size_t szPaySystem = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "paySystem", szPaySystem, 1, 1000, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SAVED_CARD_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::Protocol_MSG_CASHIER_SAVED_CARD_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	infoId = 0;
	userId.clear();
	paySystem.clear();
	plainCardNumForOldClient.clear();
	ssNumPlain.clear();
	dLicensePlain.clear();
	expYear = 0;
	expMonth = 0;
	encryptedCardNum.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::equals(const Protocol_MSG_CASHIER_SAVED_CARD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		infoId == _o.infoId &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(paySystem, _o.paySystem) &&
		Atf::atfPStringEquals(plainCardNumForOldClient, _o.plainCardNumForOldClient) &&
		Atf::atfPStringEquals(ssNumPlain, _o.ssNumPlain) &&
		Atf::atfPStringEquals(dLicensePlain, _o.dLicensePlain) &&
		expYear == _o.expYear &&
		expMonth == _o.expMonth &&
		encryptedCardNum.size() == _o.encryptedCardNum.size() && memcmp(encryptedCardNum.ptr(), _o.encryptedCardNum.ptr(), encryptedCardNum.size()) == 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SAVED_CARD_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SAVED_CARD_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SAVED_CARD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("infoId=");
		_buf.appendUint(infoId);
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
		_buf.append(',');
		_buf.append("paySystem=");
		_buf.append(paySystem);
		_buf.append(',');
		_buf.append("plainCardNumForOldClient=");
		_buf.append(plainCardNumForOldClient);
		_buf.append(',');
		_buf.append("ssNumPlain=");
		_buf.append(ssNumPlain);
		_buf.append(',');
		_buf.append("dLicensePlain=");
		_buf.append(dLicensePlain);
		_buf.append(',');
		_buf.append("expYear=");
		_buf.appendUint(expYear);
		_buf.append(',');
		_buf.append("expMonth=");
		_buf.appendUint(expMonth);
		_buf.append(',');
		_buf.append("encryptedCardNum=");
		Atf::AtfTempl<PBlock>::ToTraceString(_buf, encryptedCardNum);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SAVED_CARD_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("infoId", infoId, _buf);
		Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
		Atf::XmlElement::encodeAsXmlElement("paySystem", paySystem, _buf);
		Atf::XmlElement::encodeAsXmlElement("plainCardNumForOldClient", plainCardNumForOldClient, _buf);
		Atf::XmlElement::encodeAsXmlElement("ssNumPlain", ssNumPlain, _buf);
		Atf::XmlElement::encodeAsXmlElement("dLicensePlain", dLicensePlain, _buf);
		Atf::XmlElement::encodeAsXmlElement("expYear", expYear, _buf);
		Atf::XmlElement::encodeAsXmlElement("expMonth", expMonth, _buf);
		Atf::XmlElement::encodeAsXmlElement("encryptedCardNum", encryptedCardNum, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("infoId"))
			{
				infoId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("paySystem"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, paySystem)) return false;
			}
			else if (_element.equals("plainCardNumForOldClient"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, plainCardNumForOldClient)) return false;
			}
			else if (_element.equals("ssNumPlain"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, ssNumPlain)) return false;
			}
			else if (_element.equals("dLicensePlain"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, dLicensePlain)) return false;
			}
			else if (_element.equals("expYear"))
			{
				expYear = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("expMonth"))
			{
				expMonth = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("encryptedCardNum"))
			{
				Atf::XmlElement::_movePBlockWithNullStrip(_value, encryptedCardNum);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(infoId);
		_msg.composeString(userId);
		_msg.composeString(paySystem);
		_msg.composeString(plainCardNumForOldClient);
		_msg.composeString(ssNumPlain);
		_msg.composeString(dLicensePlain);
		_msg.composeUINT16(expYear);
		_msg.composeBYTE(expMonth);
		_msg._composeVarBlock(encryptedCardNum.ptr(), encryptedCardNum.size());
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(infoId);
		_parser.parseStringP(userId);
		_parser.parseStringP(paySystem);
		_parser.parseStringP(plainCardNumForOldClient);
		_parser.parseStringP(ssNumPlain);
		_parser.parseStringP(dLicensePlain);
		_parser.parseUINT16(expYear);
		_parser.parseBYTE(expMonth);
		_parser.parsePBlock(encryptedCardNum);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("infoId", infoId);
		_jsonstr.compose("userId", userId);
		_jsonstr.compose("paySystem", paySystem);
		_jsonstr.compose("plainCardNumForOldClient", plainCardNumForOldClient);
		_jsonstr.compose("ssNumPlain", ssNumPlain);
		_jsonstr.compose("dLicensePlain", dLicensePlain);
		_jsonstr.compose("expYear", expYear);
		_jsonstr.compose("expMonth", expMonth);
		_jsonstr.compose("encryptedCardNum", encryptedCardNum);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("infoId", infoId);
		_jparser.parseByNameThrow("userId", userId);
		_jparser.parseByNameThrow("paySystem", paySystem);
		_jparser.parseByNameThrow("plainCardNumForOldClient", plainCardNumForOldClient);
		_jparser.parseByNameThrow("ssNumPlain", ssNumPlain);
		_jparser.parseByNameThrow("dLicensePlain", dLicensePlain);
		_jparser.parseByNameThrow("expYear", expYear);
		_jparser.parseByNameThrow("expMonth", expMonth);
		_jparser.parseByNameThrow("encryptedCardNum", encryptedCardNum);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVED_CARD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 infoId; _jparser.validateByNameThrow("infoId", infoId);
		AtfValidator::validateInt(_descr, "infoId", infoId, _checker, __FILE__, __LINE__);
		PString userId; _jparser.validateByNameThrow("userId", userId);
		AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
		PString paySystem; _jparser.validateByNameThrow("paySystem", paySystem);
		AtfValidator::validateInt(_descr, "paySystem", paySystem.length(), _checker, __FILE__, __LINE__);
		PString plainCardNumForOldClient; _jparser.validateByNameThrow("plainCardNumForOldClient", plainCardNumForOldClient);
		AtfValidator::validateInt(_descr, "plainCardNumForOldClient", plainCardNumForOldClient.length(), _checker, __FILE__, __LINE__);
		PString ssNumPlain; _jparser.validateByNameThrow("ssNumPlain", ssNumPlain);
		AtfValidator::validateInt(_descr, "ssNumPlain", ssNumPlain.length(), _checker, __FILE__, __LINE__);
		PString dLicensePlain; _jparser.validateByNameThrow("dLicensePlain", dLicensePlain);
		AtfValidator::validateInt(_descr, "dLicensePlain", dLicensePlain.length(), _checker, __FILE__, __LINE__);
		UINT16 expYear; _jparser.validateByNameThrow("expYear", expYear);
		AtfValidator::validateInt(_descr, "expYear", expYear, _checker, __FILE__, __LINE__);
		BYTE expMonth; _jparser.validateByNameThrow("expMonth", expMonth);
		AtfValidator::validateInt(_descr, "expMonth", expMonth, _checker, __FILE__, __LINE__);
		PBlock encryptedCardNum; _jparser.validateByNameThrow("encryptedCardNum", encryptedCardNum);
		AtfValidator::validateInt(_descr, "encryptedCardNum", encryptedCardNum.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVED_CARD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 infoId; _parser.parseUINT32(infoId);
		AtfValidator::validateInt(_descr, "infoId", infoId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "paySystem"); size_t szPaySystem = strlen(_dummy);
		AtfValidator::validateInt(_descr, "paySystem", szPaySystem, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "plainCardNumForOldClient"); size_t szPlainCardNumForOldClient = strlen(_dummy);
		AtfValidator::validateInt(_descr, "plainCardNumForOldClient", szPlainCardNumForOldClient, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "ssNumPlain"); size_t szSsNumPlain = strlen(_dummy);
		AtfValidator::validateInt(_descr, "ssNumPlain", szSsNumPlain, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "dLicensePlain"); size_t szDLicensePlain = strlen(_dummy);
		AtfValidator::validateInt(_descr, "dLicensePlain", szDLicensePlain, _checker, __FILE__, __LINE__);
		UINT16 expYear; _parser.parseUINT16(expYear);
		AtfValidator::validateInt(_descr, "expYear", expYear, _checker, __FILE__, __LINE__);
		BYTE expMonth; _parser.parseBYTE(expMonth);
		AtfValidator::validateInt(_descr, "expMonth", expMonth, _checker, __FILE__, __LINE__);
		const BYTE* encryptedCardNum; size_t szEncryptedCardNum; _parser._parseVarBlock(encryptedCardNum, szEncryptedCardNum);  /*encryptedCardNum*/
		AtfValidator::validateInt(_descr, "encryptedCardNum", szEncryptedCardNum, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    DadRequest
//=================================================================

CashierServer::cli::DadRequest::DadRequest()
{
	clear();
}

void CashierServer::cli::DadRequest::clear()
{
	requestType = 0;
	userId.clear();
	phoneToContact.clear();
	timeToContact.clear();
	transactionId = 0;
}

bool CashierServer::cli::DadRequest::equals(const DadRequest& _o) const
{
	return requestType == _o.requestType &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(phoneToContact, _o.phoneToContact) &&
		Atf::atfPStringEquals(timeToContact, _o.timeToContact) &&
		transactionId == _o.transactionId;
}

const char *CashierServer::cli::DadRequest::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("requestType=");
	_buf.appendUint(requestType);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("phoneToContact=");
	_buf.append(phoneToContact);
	_buf.append(',');
	_buf.append("timeToContact=");
	_buf.append(timeToContact);
	_buf.append(',');
	_buf.append("transactionId=");
	_buf.appendUint(transactionId);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::DadRequest::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("requestType", requestType, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("phoneToContact", phoneToContact, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeToContact", timeToContact, _buf);
	Atf::XmlElement::encodeAsXmlElement("transactionId", transactionId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::DadRequest::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("requestType"))
		{
			requestType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("phoneToContact"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, phoneToContact)) return false;
		}
		else if (_element.equals("timeToContact"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, timeToContact)) return false;
		}
		else if (_element.equals("transactionId"))
		{
			transactionId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::DadRequest::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(requestType);
	_msg.composeString(userId);
	_msg.composeString(phoneToContact);
	_msg.composeString(timeToContact);
	_msg.composeUINT32(transactionId);
}

void CashierServer::cli::DadRequest::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(requestType);
	_parser.parseStringP(userId);
	_parser.parseStringP(phoneToContact);
	_parser.parseStringP(timeToContact);
	_parser.parseUINT32(transactionId);
}

const char *CashierServer::cli::DadRequest::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestType", requestType);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("phoneToContact", phoneToContact);
	_jsonstr.compose("timeToContact", timeToContact);
	_jsonstr.compose("transactionId", transactionId);
	return _buf.c_str();
}

void CashierServer::cli::DadRequest::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestType", requestType);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("phoneToContact", phoneToContact);
	_jparser.parseByNameThrow("timeToContact", timeToContact);
	_jparser.parseByNameThrow("transactionId", transactionId);
}

/* static */ void CashierServer::cli::DadRequest::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 requestType; _jparser.validateByNameThrow("requestType", requestType);
	{ const UINT32 requestType_enum[] = { eLiveSupportRequestChat, eLiveSupportRequestPhone, eLiveSupportRequestNone, eLiveSupportRequestEmail, eLiveSupportRequestIndirect }; AtfValidator::validateEnum(_descr, "requestType", requestType, requestType_enum, _checker, __FILE__, __LINE__); }
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString phoneToContact; _jparser.validateByNameThrow("phoneToContact", phoneToContact);
	AtfValidator::validateIntMax(_descr, "phoneToContact", phoneToContact.length(), 100, _checker, __FILE__, __LINE__);
	PString timeToContact; _jparser.validateByNameThrow("timeToContact", timeToContact);
	AtfValidator::validateIntMax(_descr, "timeToContact", timeToContact.length(), 1000, _checker, __FILE__, __LINE__);
	UINT32 transactionId; _jparser.validateByNameThrow("transactionId", transactionId);
	AtfValidator::validateInt(_descr, "transactionId", transactionId, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::DadRequest::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 requestType; _parser.parseUINT32(requestType);
	{ const UINT32 requestType_enum[] = { eLiveSupportRequestChat, eLiveSupportRequestPhone, eLiveSupportRequestNone, eLiveSupportRequestEmail, eLiveSupportRequestIndirect }; AtfValidator::validateEnum(_descr, "requestType", requestType, requestType_enum, _checker, __FILE__, __LINE__); }
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "phoneToContact"); size_t szPhoneToContact = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phoneToContact", szPhoneToContact, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "timeToContact"); size_t szTimeToContact = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "timeToContact", szTimeToContact, 1000, _checker, __FILE__, __LINE__);
	UINT32 transactionId; _parser.parseUINT32(transactionId);
	AtfValidator::validateInt(_descr, "transactionId", transactionId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_DAD_REQUEST
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::Protocol_MSG_CASHIER_DAD_REQUEST()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::clear()
{
	dadRequest.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::equals(const Protocol_MSG_CASHIER_DAD_REQUEST& _o) const
{
	return dadRequest.equals(_o.dadRequest);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_DAD_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_DAD_REQUEST*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DAD_REQUEST).append(")");
	_buf.append(',');
	_buf.append("dadRequest=");
	dadRequest.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_DAD_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	dadRequest.toXmlString("dadRequest", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("dadRequest"))
			{
				if(!Atf::AtfTempl< DadRequest >::FromXmlString(_value, dadRequest)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	dadRequest.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::parseMsg(CommMsgParser& _parser)
{
	dadRequest.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("dadRequest", dadRequest);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("dadRequest", dadRequest);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DAD_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	DadRequest dadRequest; _jparser.validateByNameThrow("dadRequest", dadRequest);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DAD_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	DadRequest::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("dadRequest"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DAD_REQUEST_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	requestType = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::equals(const Protocol_MSG_CASHIER_DAD_REQUEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		requestType == _o.requestType;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_DAD_REQUEST_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_DAD_REQUEST_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DAD_REQUEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("requestType=");
		_buf.appendUint(requestType);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_DAD_REQUEST_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("requestType", requestType, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("requestType"))
			{
				requestType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(requestType);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(requestType);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("requestType", requestType);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("requestType", requestType);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DAD_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 requestType; _jparser.validateByNameThrow("requestType", requestType);
		AtfValidator::validateInt(_descr, "requestType", requestType, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DAD_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 requestType; _parser.parseUINT32(requestType);
		AtfValidator::validateInt(_descr, "requestType", requestType, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::clear()
{
	dadRequest.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::equals(const Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT& _o) const
{
	return dadRequest.equals(_o.dadRequest);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_FRMIGRATION_LIVESUPPORT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_LIVESUPPORT).append(")");
	_buf.append(',');
	_buf.append("dadRequest=");
	dadRequest.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_FRMIGRATION_LIVESUPPORT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	dadRequest.toXmlString("dadRequest", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("dadRequest"))
			{
				if(!Atf::AtfTempl< DadRequest >::FromXmlString(_value, dadRequest)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	dadRequest.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::parseMsg(CommMsgParser& _parser)
{
	dadRequest.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("dadRequest", dadRequest);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("dadRequest", dadRequest);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_LIVESUPPORT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	DadRequest dadRequest; _jparser.validateByNameThrow("dadRequest", dadRequest);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_LIVESUPPORT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	DadRequest::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("dadRequest"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	requestType = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::equals(const Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		requestType == _o.requestType;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("requestType=");
		_buf.appendUint(requestType);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("requestType", requestType, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("requestType"))
			{
				requestType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(requestType);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(requestType);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("requestType", requestType);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("requestType", requestType);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 requestType; _jparser.validateByNameThrow("requestType", requestType);
		AtfValidator::validateInt(_descr, "requestType", requestType, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 requestType; _parser.parseUINT32(requestType);
		AtfValidator::validateInt(_descr, "requestType", requestType, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_WIRE_REQUEST
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::Protocol_MSG_CASHIER_WIRE_REQUEST()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::clear()
{
	userId.clear();
	procAmount = 0;
	currency_not.clear();
	bonusCode.clear();
	personalInfo.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::equals(const Protocol_MSG_CASHIER_WIRE_REQUEST& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		procAmount == _o.procAmount &&
		Atf::atfPStringEquals(currency_not, _o.currency_not) &&
		Atf::atfPStringEquals(bonusCode, _o.bonusCode) &&
		Atf::atfPStringEquals(personalInfo, _o.personalInfo);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_WIRE_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_WIRE_REQUEST*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_WIRE_REQUEST).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("procAmount=");
	_buf.appendInt(procAmount);
	_buf.append(',');
	_buf.append("currency_not=");
	_buf.append(currency_not);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("personalInfo=");
	_buf.append(personalInfo);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_WIRE_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("procAmount", procAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency_not", currency_not, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusCode", bonusCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("personalInfo", personalInfo, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("procAmount"))
			{
				procAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency_not"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency_not)) return false;
			}
			else if (_element.equals("bonusCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bonusCode)) return false;
			}
			else if (_element.equals("personalInfo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, personalInfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeINT32(procAmount);
	_msg.composeString(currency_not);
	_msg.composeString(bonusCode);
	_msg.composeString(personalInfo);
}

void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(procAmount);
	_parser.parseStringP(currency_not);
	_parser.parseStringP(bonusCode);
	_parser.parseStringP(personalInfo);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("procAmount", procAmount);
	_jsonstr.compose("currency_not", currency_not);
	_jsonstr.compose("bonusCode", bonusCode);
	_jsonstr.compose("personalInfo", personalInfo);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("procAmount", procAmount);
	_jparser.parseByNameThrow("currency_not", currency_not);
	_jparser.parseByNameThrow("bonusCode", bonusCode);
	_jparser.parseByNameThrow("personalInfo", personalInfo);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_WIRE_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 procAmount; _jparser.validateByNameThrow("procAmount", procAmount);
	AtfValidator::validateIntRange(_descr, "procAmount", procAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString currency_not; _jparser.validateByNameThrow("currency_not", currency_not);
	AtfValidator::validateInt(_descr, "currency_not", currency_not.length(), _checker, __FILE__, __LINE__);
	PString bonusCode; _jparser.validateByNameThrow("bonusCode", bonusCode);
	AtfValidator::validateIntMax(_descr, "bonusCode", bonusCode.length(), BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	PString personalInfo; _jparser.validateByNameThrow("personalInfo", personalInfo);
	AtfValidator::validateIntMax(_descr, "personalInfo", personalInfo.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_WIRE_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 procAmount; _parser.parseINT32(procAmount);
	AtfValidator::validateIntRange(_descr, "procAmount", procAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency_not"); size_t szCurrency_not = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency_not", szCurrency_not, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "personalInfo"); size_t szPersonalInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "personalInfo", szPersonalInfo, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	paymentReference.clear();
	accountHolder.clear();
	bankName.clear();
	city.clear();
	swift.clear();
	specialId.clear();
	bankAcct.clear();
	country.clear();
	additionalRef.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::equals(const Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(paymentReference, _o.paymentReference) &&
		Atf::atfPStringEquals(accountHolder, _o.accountHolder) &&
		Atf::atfPStringEquals(bankName, _o.bankName) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(swift, _o.swift) &&
		Atf::atfPStringEquals(specialId, _o.specialId) &&
		Atf::atfPStringEquals(bankAcct, _o.bankAcct) &&
		Atf::atfPStringEquals(country, _o.country) &&
		Atf::atfPStringEquals(additionalRef, _o.additionalRef);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_WIRE_REQUEST_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_WIRE_REQUEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("paymentReference=");
		_buf.append(paymentReference);
		_buf.append(',');
		_buf.append("accountHolder=");
		_buf.append(accountHolder);
		_buf.append(',');
		_buf.append("bankName=");
		_buf.append(bankName);
		_buf.append(',');
		_buf.append("city=");
		_buf.append(city);
		_buf.append(',');
		_buf.append("swift=");
		_buf.append(swift);
		_buf.append(',');
		_buf.append("specialId=");
		_buf.append(specialId);
		_buf.append(',');
		_buf.append("bankAcct=");
		_buf.append(bankAcct);
		_buf.append(',');
		_buf.append("country=");
		_buf.append(country);
		_buf.append(',');
		_buf.append("additionalRef=");
		_buf.append(additionalRef);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_WIRE_REQUEST_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("paymentReference", paymentReference, _buf);
		Atf::XmlElement::encodeAsXmlElement("accountHolder", accountHolder, _buf);
		Atf::XmlElement::encodeAsXmlElement("bankName", bankName, _buf);
		Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
		Atf::XmlElement::encodeAsXmlElement("swift", swift, _buf);
		Atf::XmlElement::encodeAsXmlElement("specialId", specialId, _buf);
		Atf::XmlElement::encodeAsXmlElement("bankAcct", bankAcct, _buf);
		Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
		Atf::XmlElement::encodeAsXmlElement("additionalRef", additionalRef, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("paymentReference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, paymentReference)) return false;
			}
			else if (_element.equals("accountHolder"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, accountHolder)) return false;
			}
			else if (_element.equals("bankName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bankName)) return false;
			}
			else if (_element.equals("city"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
			}
			else if (_element.equals("swift"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, swift)) return false;
			}
			else if (_element.equals("specialId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, specialId)) return false;
			}
			else if (_element.equals("bankAcct"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bankAcct)) return false;
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("additionalRef"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, additionalRef)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(paymentReference);
		_msg.composeString(accountHolder);
		_msg.composeString(bankName);
		_msg.composeString(city);
		_msg.composeString(swift);
		_msg.composeString(specialId);
		_msg.composeString(bankAcct);
		_msg.composeString(country);
		_msg.composeString(additionalRef);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(paymentReference);
		_parser.parseStringP(accountHolder);
		_parser.parseStringP(bankName);
		_parser.parseStringP(city);
		_parser.parseStringP(swift);
		_parser.parseStringP(specialId);
		_parser.parseStringP(bankAcct);
		_parser.parseStringP(country);
		_parser.parseStringP(additionalRef);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("paymentReference", paymentReference);
		_jsonstr.compose("accountHolder", accountHolder);
		_jsonstr.compose("bankName", bankName);
		_jsonstr.compose("city", city);
		_jsonstr.compose("swift", swift);
		_jsonstr.compose("specialId", specialId);
		_jsonstr.compose("bankAcct", bankAcct);
		_jsonstr.compose("country", country);
		_jsonstr.compose("additionalRef", additionalRef);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("paymentReference", paymentReference);
		_jparser.parseByNameThrow("accountHolder", accountHolder);
		_jparser.parseByNameThrow("bankName", bankName);
		_jparser.parseByNameThrow("city", city);
		_jparser.parseByNameThrow("swift", swift);
		_jparser.parseByNameThrow("specialId", specialId);
		_jparser.parseByNameThrow("bankAcct", bankAcct);
		_jparser.parseByNameThrow("country", country);
		_jparser.parseByNameThrow("additionalRef", additionalRef);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_WIRE_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString paymentReference; _jparser.validateByNameThrow("paymentReference", paymentReference);
		AtfValidator::validateInt(_descr, "paymentReference", paymentReference.length(), _checker, __FILE__, __LINE__);
		PString accountHolder; _jparser.validateByNameThrow("accountHolder", accountHolder);
		AtfValidator::validateInt(_descr, "accountHolder", accountHolder.length(), _checker, __FILE__, __LINE__);
		PString bankName; _jparser.validateByNameThrow("bankName", bankName);
		AtfValidator::validateInt(_descr, "bankName", bankName.length(), _checker, __FILE__, __LINE__);
		PString city; _jparser.validateByNameThrow("city", city);
		AtfValidator::validateInt(_descr, "city", city.length(), _checker, __FILE__, __LINE__);
		PString swift; _jparser.validateByNameThrow("swift", swift);
		AtfValidator::validateInt(_descr, "swift", swift.length(), _checker, __FILE__, __LINE__);
		PString specialId; _jparser.validateByNameThrow("specialId", specialId);
		AtfValidator::validateInt(_descr, "specialId", specialId.length(), _checker, __FILE__, __LINE__);
		PString bankAcct; _jparser.validateByNameThrow("bankAcct", bankAcct);
		AtfValidator::validateInt(_descr, "bankAcct", bankAcct.length(), _checker, __FILE__, __LINE__);
		PString country; _jparser.validateByNameThrow("country", country);
		AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
		PString additionalRef; _jparser.validateByNameThrow("additionalRef", additionalRef);
		AtfValidator::validateInt(_descr, "additionalRef", additionalRef.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_WIRE_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "paymentReference"); size_t szPaymentReference = strlen(_dummy);
		AtfValidator::validateInt(_descr, "paymentReference", szPaymentReference, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "accountHolder"); size_t szAccountHolder = strlen(_dummy);
		AtfValidator::validateInt(_descr, "accountHolder", szAccountHolder, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bankName"); size_t szBankName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bankName", szBankName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
		AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "swift"); size_t szSwift = strlen(_dummy);
		AtfValidator::validateInt(_descr, "swift", szSwift, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "specialId"); size_t szSpecialId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "specialId", szSpecialId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bankAcct"); size_t szBankAcct = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bankAcct", szBankAcct, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
		AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "additionalRef"); size_t szAdditionalRef = strlen(_dummy);
		AtfValidator::validateInt(_descr, "additionalRef", szAdditionalRef, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BPAY_REQUEST
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::Protocol_MSG_CASHIER_BPAY_REQUEST()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::clear()
{
	userId.clear();
	procAmount = 0;
	currency_not.clear();
	bonusCode.clear();
	personalInfo.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::equals(const Protocol_MSG_CASHIER_BPAY_REQUEST& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		procAmount == _o.procAmount &&
		Atf::atfPStringEquals(currency_not, _o.currency_not) &&
		Atf::atfPStringEquals(bonusCode, _o.bonusCode) &&
		Atf::atfPStringEquals(personalInfo, _o.personalInfo);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_BPAY_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_BPAY_REQUEST*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BPAY_REQUEST).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("procAmount=");
	_buf.appendInt(procAmount);
	_buf.append(',');
	_buf.append("currency_not=");
	_buf.append(currency_not);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("personalInfo=");
	_buf.append(personalInfo);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_BPAY_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("procAmount", procAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency_not", currency_not, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusCode", bonusCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("personalInfo", personalInfo, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("procAmount"))
			{
				procAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency_not"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency_not)) return false;
			}
			else if (_element.equals("bonusCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bonusCode)) return false;
			}
			else if (_element.equals("personalInfo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, personalInfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeINT32(procAmount);
	_msg.composeString(currency_not);
	_msg.composeString(bonusCode);
	_msg.composeString(personalInfo);
}

void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(procAmount);
	_parser.parseStringP(currency_not);
	_parser.parseStringP(bonusCode);
	_parser.parseStringP(personalInfo);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("procAmount", procAmount);
	_jsonstr.compose("currency_not", currency_not);
	_jsonstr.compose("bonusCode", bonusCode);
	_jsonstr.compose("personalInfo", personalInfo);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("procAmount", procAmount);
	_jparser.parseByNameThrow("currency_not", currency_not);
	_jparser.parseByNameThrow("bonusCode", bonusCode);
	_jparser.parseByNameThrow("personalInfo", personalInfo);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BPAY_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 procAmount; _jparser.validateByNameThrow("procAmount", procAmount);
	AtfValidator::validateIntRange(_descr, "procAmount", procAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString currency_not; _jparser.validateByNameThrow("currency_not", currency_not);
	AtfValidator::validateIntMax(_descr, "currency_not", currency_not.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	PString bonusCode; _jparser.validateByNameThrow("bonusCode", bonusCode);
	AtfValidator::validateIntMax(_descr, "bonusCode", bonusCode.length(), BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	PString personalInfo; _jparser.validateByNameThrow("personalInfo", personalInfo);
	AtfValidator::validateIntMax(_descr, "personalInfo", personalInfo.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BPAY_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 procAmount; _parser.parseINT32(procAmount);
	AtfValidator::validateIntRange(_descr, "procAmount", procAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency_not"); size_t szCurrency_not = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency_not", szCurrency_not, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "personalInfo"); size_t szPersonalInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "personalInfo", szPersonalInfo, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	paymentReference.clear();
	billerId.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::equals(const Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(paymentReference, _o.paymentReference) &&
		Atf::atfPStringEquals(billerId, _o.billerId);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_BPAY_REQUEST_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BPAY_REQUEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("paymentReference=");
		_buf.append(paymentReference);
		_buf.append(',');
		_buf.append("billerId=");
		_buf.append(billerId);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_BPAY_REQUEST_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("paymentReference", paymentReference, _buf);
		Atf::XmlElement::encodeAsXmlElement("billerId", billerId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("paymentReference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, paymentReference)) return false;
			}
			else if (_element.equals("billerId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, billerId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(paymentReference);
		_msg.composeString(billerId);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(paymentReference);
		_parser.parseStringP(billerId);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("paymentReference", paymentReference);
		_jsonstr.compose("billerId", billerId);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("paymentReference", paymentReference);
		_jparser.parseByNameThrow("billerId", billerId);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BPAY_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString paymentReference; _jparser.validateByNameThrow("paymentReference", paymentReference);
		AtfValidator::validateInt(_descr, "paymentReference", paymentReference.length(), _checker, __FILE__, __LINE__);
		PString billerId; _jparser.validateByNameThrow("billerId", billerId);
		AtfValidator::validateInt(_descr, "billerId", billerId.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BPAY_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "paymentReference"); size_t szPaymentReference = strlen(_dummy);
		AtfValidator::validateInt(_descr, "paymentReference", szPaymentReference, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "billerId"); size_t szBillerId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "billerId", szBillerId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::clear()
{
	userId.clear();
	amount = 0;
	currency.clear();
	bonusCode.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::equals(const Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		amount == _o.amount &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		Atf::atfPStringEquals(bonusCode, _o.bonusCode);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_INIT_WIRECARD_DEPOSIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_INIT_WIRECARD_DEPOSIT).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_INIT_WIRECARD_DEPOSIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusCode", bonusCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("amount"))
			{
				amount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("bonusCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bonusCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeINT32(amount);
	_msg.composeString(currency);
	_msg.composeString(bonusCode);
}

void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(amount);
	_parser.parseStringP(currency);
	_parser.parseStringP(bonusCode);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("bonusCode", bonusCode);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("bonusCode", bonusCode);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_INIT_WIRECARD_DEPOSIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	PString bonusCode; _jparser.validateByNameThrow("bonusCode", bonusCode);
	AtfValidator::validateIntMax(_descr, "bonusCode", bonusCode.length(), BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_INIT_WIRECARD_DEPOSIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	popUpText.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::equals(const Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(popUpText, _o.popUpText);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("popUpText=");
		_buf.append(popUpText);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("popUpText", popUpText, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("popUpText"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, popUpText)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(popUpText);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(popUpText);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("popUpText", popUpText);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("popUpText", popUpText);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString popUpText; _jparser.validateByNameThrow("popUpText", popUpText);
		AtfValidator::validateInt(_descr, "popUpText", popUpText.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "popUpText"); size_t szPopUpText = strlen(_dummy);
		AtfValidator::validateInt(_descr, "popUpText", szPopUpText, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_AGE_CHECK_UK
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::Protocol_MSG_CASHIER_AGE_CHECK_UK()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::clear()
{
	title.clear();
	fullName.clear();
	gender.clear();
	dateOfBirth.setNull();
	address.clear();
	city.clear();
	zip.clear();
	state.clear();
	country.clear();
	passportNumber1.clear();
	passportNumber2.clear();
	passportNumber3.clear();
	passportNumber4.clear();
	passportNumber5.clear();
	passportNumber6.clear();
	passportExprireDate.setNull();
	driverNumber1.clear();
	driverNumber2.clear();
	driverNumber3.clear();
	driverNumber4.clear();
	driverpostcode.clear();
	attemptNumber = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::equals(const Protocol_MSG_CASHIER_AGE_CHECK_UK& _o) const
{
	return Atf::atfPStringEquals(title, _o.title) &&
		Atf::atfPStringEquals(fullName, _o.fullName) &&
		Atf::atfPStringEquals(gender, _o.gender) &&
		dateOfBirth.equals(_o.dateOfBirth) &&
		Atf::atfPStringEquals(address, _o.address) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(zip, _o.zip) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(country, _o.country) &&
		Atf::atfPStringEquals(passportNumber1, _o.passportNumber1) &&
		Atf::atfPStringEquals(passportNumber2, _o.passportNumber2) &&
		Atf::atfPStringEquals(passportNumber3, _o.passportNumber3) &&
		Atf::atfPStringEquals(passportNumber4, _o.passportNumber4) &&
		Atf::atfPStringEquals(passportNumber5, _o.passportNumber5) &&
		Atf::atfPStringEquals(passportNumber6, _o.passportNumber6) &&
		passportExprireDate.equals(_o.passportExprireDate) &&
		Atf::atfPStringEquals(driverNumber1, _o.driverNumber1) &&
		Atf::atfPStringEquals(driverNumber2, _o.driverNumber2) &&
		Atf::atfPStringEquals(driverNumber3, _o.driverNumber3) &&
		Atf::atfPStringEquals(driverNumber4, _o.driverNumber4) &&
		Atf::atfPStringEquals(driverpostcode, _o.driverpostcode) &&
		attemptNumber == _o.attemptNumber;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_AGE_CHECK_UK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_AGE_CHECK_UK*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_AGE_CHECK_UK).append(")");
	_buf.append(',');
	_buf.append("title=");
	_buf.append(title);
	_buf.append(',');
	_buf.append("fullName=");
	_buf.append(fullName);
	_buf.append(',');
	_buf.append("gender=");
	_buf.append(gender);
	_buf.append(',');
	_buf.append("dateOfBirth=");
	Atf::AtfTempl<CommSrvDate>::ToTraceString(_buf, dateOfBirth);
	_buf.append(',');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("zip=");
	_buf.append(zip);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("passportNumber1=");
	_buf.append(passportNumber1);
	_buf.append(',');
	_buf.append("passportNumber2=");
	_buf.append(passportNumber2);
	_buf.append(',');
	_buf.append("passportNumber3=");
	_buf.append(passportNumber3);
	_buf.append(',');
	_buf.append("passportNumber4=");
	_buf.append(passportNumber4);
	_buf.append(',');
	_buf.append("passportNumber5=");
	_buf.append(passportNumber5);
	_buf.append(',');
	_buf.append("passportNumber6=");
	_buf.append(passportNumber6);
	_buf.append(',');
	_buf.append("passportExprireDate=");
	Atf::AtfTempl<CommSrvDate>::ToTraceString(_buf, passportExprireDate);
	_buf.append(',');
	_buf.append("driverNumber1=");
	_buf.append(driverNumber1);
	_buf.append(',');
	_buf.append("driverNumber2=");
	_buf.append(driverNumber2);
	_buf.append(',');
	_buf.append("driverNumber3=");
	_buf.append(driverNumber3);
	_buf.append(',');
	_buf.append("driverNumber4=");
	_buf.append(driverNumber4);
	_buf.append(',');
	_buf.append("driverpostcode=");
	_buf.append(driverpostcode);
	_buf.append(',');
	_buf.append("attemptNumber=");
	_buf.appendUint(attemptNumber);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_AGE_CHECK_UK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("title", title, _buf);
	Atf::XmlElement::encodeAsXmlElement("fullName", fullName, _buf);
	Atf::XmlElement::encodeAsXmlElement("gender", gender, _buf);
	Atf::AtfTempl<CommSrvDate>::ToXmlString(_buf, "dateOfBirth", dateOfBirth);
	Atf::XmlElement::encodeAsXmlElement("address", address, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::encodeAsXmlElement("zip", zip, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("passportNumber1", passportNumber1, _buf);
	Atf::XmlElement::encodeAsXmlElement("passportNumber2", passportNumber2, _buf);
	Atf::XmlElement::encodeAsXmlElement("passportNumber3", passportNumber3, _buf);
	Atf::XmlElement::encodeAsXmlElement("passportNumber4", passportNumber4, _buf);
	Atf::XmlElement::encodeAsXmlElement("passportNumber5", passportNumber5, _buf);
	Atf::XmlElement::encodeAsXmlElement("passportNumber6", passportNumber6, _buf);
	Atf::AtfTempl<CommSrvDate>::ToXmlString(_buf, "passportExprireDate", passportExprireDate);
	Atf::XmlElement::encodeAsXmlElement("driverNumber1", driverNumber1, _buf);
	Atf::XmlElement::encodeAsXmlElement("driverNumber2", driverNumber2, _buf);
	Atf::XmlElement::encodeAsXmlElement("driverNumber3", driverNumber3, _buf);
	Atf::XmlElement::encodeAsXmlElement("driverNumber4", driverNumber4, _buf);
	Atf::XmlElement::encodeAsXmlElement("driverpostcode", driverpostcode, _buf);
	Atf::XmlElement::encodeAsXmlElement("attemptNumber", attemptNumber, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("title"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, title)) return false;
			}
			else if (_element.equals("fullName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fullName)) return false;
			}
			else if (_element.equals("gender"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, gender)) return false;
			}
			else if (_element.equals("dateOfBirth"))
			{
				Atf::AtfTempl<CommSrvDate>::FromXmlString(_value, dateOfBirth);
			}
			else if (_element.equals("address"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, address)) return false;
			}
			else if (_element.equals("city"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
			}
			else if (_element.equals("zip"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, zip)) return false;
			}
			else if (_element.equals("state"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("passportNumber1"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, passportNumber1)) return false;
			}
			else if (_element.equals("passportNumber2"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, passportNumber2)) return false;
			}
			else if (_element.equals("passportNumber3"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, passportNumber3)) return false;
			}
			else if (_element.equals("passportNumber4"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, passportNumber4)) return false;
			}
			else if (_element.equals("passportNumber5"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, passportNumber5)) return false;
			}
			else if (_element.equals("passportNumber6"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, passportNumber6)) return false;
			}
			else if (_element.equals("passportExprireDate"))
			{
				Atf::AtfTempl<CommSrvDate>::FromXmlString(_value, passportExprireDate);
			}
			else if (_element.equals("driverNumber1"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, driverNumber1)) return false;
			}
			else if (_element.equals("driverNumber2"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, driverNumber2)) return false;
			}
			else if (_element.equals("driverNumber3"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, driverNumber3)) return false;
			}
			else if (_element.equals("driverNumber4"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, driverNumber4)) return false;
			}
			else if (_element.equals("driverpostcode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, driverpostcode)) return false;
			}
			else if (_element.equals("attemptNumber"))
			{
				attemptNumber = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(title);
	_msg.composeString(fullName);
	_msg.composeString(gender);
	_msg.composeSrvDate(dateOfBirth);
	_msg.composeString(address);
	_msg.composeString(city);
	_msg.composeString(zip);
	_msg.composeString(state);
	_msg.composeString(country);
	_msg.composeString(passportNumber1);
	_msg.composeString(passportNumber2);
	_msg.composeString(passportNumber3);
	_msg.composeString(passportNumber4);
	_msg.composeString(passportNumber5);
	_msg.composeString(passportNumber6);
	_msg.composeSrvDate(passportExprireDate);
	_msg.composeString(driverNumber1);
	_msg.composeString(driverNumber2);
	_msg.composeString(driverNumber3);
	_msg.composeString(driverNumber4);
	_msg.composeString(driverpostcode);
	_msg.composeUINT32(attemptNumber);
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(title);
	_parser.parseStringP(fullName);
	_parser.parseStringP(gender);
	_parser.parseSrvDate(dateOfBirth);
	_parser.parseStringP(address);
	_parser.parseStringP(city);
	_parser.parseStringP(zip);
	_parser.parseStringP(state);
	_parser.parseStringP(country);
	_parser.parseStringP(passportNumber1);
	_parser.parseStringP(passportNumber2);
	_parser.parseStringP(passportNumber3);
	_parser.parseStringP(passportNumber4);
	_parser.parseStringP(passportNumber5);
	_parser.parseStringP(passportNumber6);
	_parser.parseSrvDate(passportExprireDate);
	_parser.parseStringP(driverNumber1);
	_parser.parseStringP(driverNumber2);
	_parser.parseStringP(driverNumber3);
	_parser.parseStringP(driverNumber4);
	_parser.parseStringP(driverpostcode);
	_parser.parseUINT32(attemptNumber);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("title", title);
	_jsonstr.compose("fullName", fullName);
	_jsonstr.compose("gender", gender);
	_jsonstr.compose("dateOfBirth", dateOfBirth);
	_jsonstr.compose("address", address);
	_jsonstr.compose("city", city);
	_jsonstr.compose("zip", zip);
	_jsonstr.compose("state", state);
	_jsonstr.compose("country", country);
	_jsonstr.compose("passportNumber1", passportNumber1);
	_jsonstr.compose("passportNumber2", passportNumber2);
	_jsonstr.compose("passportNumber3", passportNumber3);
	_jsonstr.compose("passportNumber4", passportNumber4);
	_jsonstr.compose("passportNumber5", passportNumber5);
	_jsonstr.compose("passportNumber6", passportNumber6);
	_jsonstr.compose("passportExprireDate", passportExprireDate);
	_jsonstr.compose("driverNumber1", driverNumber1);
	_jsonstr.compose("driverNumber2", driverNumber2);
	_jsonstr.compose("driverNumber3", driverNumber3);
	_jsonstr.compose("driverNumber4", driverNumber4);
	_jsonstr.compose("driverpostcode", driverpostcode);
	_jsonstr.compose("attemptNumber", attemptNumber);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("title", title);
	_jparser.parseByNameThrow("fullName", fullName);
	_jparser.parseByNameThrow("gender", gender);
	_jparser.parseByNameThrow("dateOfBirth", dateOfBirth);
	_jparser.parseByNameThrow("address", address);
	_jparser.parseByNameThrow("city", city);
	_jparser.parseByNameThrow("zip", zip);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("passportNumber1", passportNumber1);
	_jparser.parseByNameThrow("passportNumber2", passportNumber2);
	_jparser.parseByNameThrow("passportNumber3", passportNumber3);
	_jparser.parseByNameThrow("passportNumber4", passportNumber4);
	_jparser.parseByNameThrow("passportNumber5", passportNumber5);
	_jparser.parseByNameThrow("passportNumber6", passportNumber6);
	_jparser.parseByNameThrow("passportExprireDate", passportExprireDate);
	_jparser.parseByNameThrow("driverNumber1", driverNumber1);
	_jparser.parseByNameThrow("driverNumber2", driverNumber2);
	_jparser.parseByNameThrow("driverNumber3", driverNumber3);
	_jparser.parseByNameThrow("driverNumber4", driverNumber4);
	_jparser.parseByNameThrow("driverpostcode", driverpostcode);
	_jparser.parseByNameThrow("attemptNumber", attemptNumber);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGE_CHECK_UK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString title; _jparser.validateByNameThrow("title", title);
	AtfValidator::validateIntMax(_descr, "title", title.length(), 100, _checker, __FILE__, __LINE__);
	PString fullName; _jparser.validateByNameThrow("fullName", fullName);
	AtfValidator::validateIntMax(_descr, "fullName", fullName.length(), USER_FULLNAME_LEN, _checker, __FILE__, __LINE__);
	PString gender; _jparser.validateByNameThrow("gender", gender);
	AtfValidator::validateIntMax(_descr, "gender", gender.length(), 6, _checker, __FILE__, __LINE__);
	CommSrvDate dateOfBirth; _jparser.validateByNameThrow("dateOfBirth", dateOfBirth);
	AtfValidator::validateSrvDateTime(_descr, "dateOfBirth", dateOfBirth, _checker, __FILE__, __LINE__);
	PString address; _jparser.validateByNameThrow("address", address);
	AtfValidator::validateIntMax(_descr, "address", address.length(), USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateIntMax(_descr, "city", city.length(), USER_CITY_LEN, _checker, __FILE__, __LINE__);
	PString zip; _jparser.validateByNameThrow("zip", zip);
	AtfValidator::validateIntMax(_descr, "zip", zip.length(), USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateIntMax(_descr, "state", state.length(), USER_STATE_LEN, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	PString passportNumber1; _jparser.validateByNameThrow("passportNumber1", passportNumber1);
	AtfValidator::validateIntMax(_descr, "passportNumber1", passportNumber1.length(), 100, _checker, __FILE__, __LINE__);
	PString passportNumber2; _jparser.validateByNameThrow("passportNumber2", passportNumber2);
	AtfValidator::validateIntMax(_descr, "passportNumber2", passportNumber2.length(), 100, _checker, __FILE__, __LINE__);
	PString passportNumber3; _jparser.validateByNameThrow("passportNumber3", passportNumber3);
	AtfValidator::validateIntMax(_descr, "passportNumber3", passportNumber3.length(), 100, _checker, __FILE__, __LINE__);
	PString passportNumber4; _jparser.validateByNameThrow("passportNumber4", passportNumber4);
	AtfValidator::validateIntMax(_descr, "passportNumber4", passportNumber4.length(), 100, _checker, __FILE__, __LINE__);
	PString passportNumber5; _jparser.validateByNameThrow("passportNumber5", passportNumber5);
	AtfValidator::validateIntMax(_descr, "passportNumber5", passportNumber5.length(), 100, _checker, __FILE__, __LINE__);
	PString passportNumber6; _jparser.validateByNameThrow("passportNumber6", passportNumber6);
	AtfValidator::validateIntMax(_descr, "passportNumber6", passportNumber6.length(), 100, _checker, __FILE__, __LINE__);
	CommSrvDate passportExprireDate; _jparser.validateByNameThrow("passportExprireDate", passportExprireDate);
	AtfValidator::validateSrvDateTime(_descr, "passportExprireDate", passportExprireDate, _checker, __FILE__, __LINE__);
	PString driverNumber1; _jparser.validateByNameThrow("driverNumber1", driverNumber1);
	AtfValidator::validateIntMax(_descr, "driverNumber1", driverNumber1.length(), 100, _checker, __FILE__, __LINE__);
	PString driverNumber2; _jparser.validateByNameThrow("driverNumber2", driverNumber2);
	AtfValidator::validateIntMax(_descr, "driverNumber2", driverNumber2.length(), 100, _checker, __FILE__, __LINE__);
	PString driverNumber3; _jparser.validateByNameThrow("driverNumber3", driverNumber3);
	AtfValidator::validateIntMax(_descr, "driverNumber3", driverNumber3.length(), 100, _checker, __FILE__, __LINE__);
	PString driverNumber4; _jparser.validateByNameThrow("driverNumber4", driverNumber4);
	AtfValidator::validateIntMax(_descr, "driverNumber4", driverNumber4.length(), 100, _checker, __FILE__, __LINE__);
	PString driverpostcode; _jparser.validateByNameThrow("driverpostcode", driverpostcode);
	AtfValidator::validateIntMax(_descr, "driverpostcode", driverpostcode.length(), 100, _checker, __FILE__, __LINE__);
	UINT32 attemptNumber; _jparser.validateByNameThrow("attemptNumber", attemptNumber);
	AtfValidator::validateIntMax(_descr, "attemptNumber", attemptNumber, 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGE_CHECK_UK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "title"); size_t szTitle = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "title", szTitle, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "fullName"); size_t szFullName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fullName", szFullName, USER_FULLNAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "gender"); size_t szGender = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "gender", szGender, 6, _checker, __FILE__, __LINE__);
	CommSrvDate dateOfBirth; _parser.parseSrvDate(dateOfBirth);
	AtfValidator::validateSrvDateTime(_descr, "dateOfBirth", dateOfBirth, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "address", szAddress, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "zip"); size_t szZip = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zip", szZip, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "passportNumber1"); size_t szPassportNumber1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber1", szPassportNumber1, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "passportNumber2"); size_t szPassportNumber2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber2", szPassportNumber2, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "passportNumber3"); size_t szPassportNumber3 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber3", szPassportNumber3, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "passportNumber4"); size_t szPassportNumber4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber4", szPassportNumber4, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "passportNumber5"); size_t szPassportNumber5 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber5", szPassportNumber5, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "passportNumber6"); size_t szPassportNumber6 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber6", szPassportNumber6, 100, _checker, __FILE__, __LINE__);
	CommSrvDate passportExprireDate; _parser.parseSrvDate(passportExprireDate);
	AtfValidator::validateSrvDateTime(_descr, "passportExprireDate", passportExprireDate, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "driverNumber1"); size_t szDriverNumber1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverNumber1", szDriverNumber1, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "driverNumber2"); size_t szDriverNumber2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverNumber2", szDriverNumber2, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "driverNumber3"); size_t szDriverNumber3 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverNumber3", szDriverNumber3, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "driverNumber4"); size_t szDriverNumber4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverNumber4", szDriverNumber4, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "driverpostcode"); size_t szDriverpostcode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverpostcode", szDriverpostcode, 100, _checker, __FILE__, __LINE__);
	UINT32 attemptNumber; _parser.parseUINT32(attemptNumber);
	AtfValidator::validateIntMax(_descr, "attemptNumber", attemptNumber, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::equals(const Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_AGE_CHECK_UK_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_AGE_CHECK_UK_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_AGE_CHECK_UK_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGE_CHECK_UK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGE_CHECK_UK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    AgeVerificationCommonBody
//=================================================================

CashierServer::cli::AgeVerificationCommonBody::AgeVerificationCommonBody()
{
	clear();
}

void CashierServer::cli::AgeVerificationCommonBody::clear()
{
	title = 0;
	fullName.clear();
	gender.clear();
	dateOfBirth.setNull();
	address.clear();
	city.clear();
	zip.clear();
	state.clear();
	country.clear();
	phone.clear();
	firstName.clear();
	lastName.clear();
}

bool CashierServer::cli::AgeVerificationCommonBody::equals(const AgeVerificationCommonBody& _o) const
{
	return title == _o.title &&
		Atf::atfPStringEquals(fullName, _o.fullName) &&
		Atf::atfPStringEquals(gender, _o.gender) &&
		dateOfBirth.equals(_o.dateOfBirth) &&
		Atf::atfPStringEquals(address, _o.address) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(zip, _o.zip) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(country, _o.country) &&
		Atf::atfPStringEquals(phone, _o.phone) &&
		Atf::atfPStringEquals(firstName, _o.firstName) &&
		Atf::atfPStringEquals(lastName, _o.lastName);
}

const char *CashierServer::cli::AgeVerificationCommonBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("title=");
	_buf.appendInt(title);
	_buf.append(',');
	_buf.append("fullName=");
	_buf.append(fullName);
	_buf.append(',');
	_buf.append("gender=");
	_buf.append(gender);
	_buf.append(',');
	_buf.append("dateOfBirth=");
	Atf::AtfTempl<CommSrvDate>::ToTraceString(_buf, dateOfBirth);
	_buf.append(',');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("zip=");
	_buf.append(zip);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("phone=");
	_buf.append(phone);
	_buf.append(',');
	_buf.append("firstName=");
	_buf.append(firstName);
	_buf.append(',');
	_buf.append("lastName=");
	_buf.append(lastName);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::AgeVerificationCommonBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("title", title, _buf);
	Atf::XmlElement::encodeAsXmlElement("fullName", fullName, _buf);
	Atf::XmlElement::encodeAsXmlElement("gender", gender, _buf);
	Atf::AtfTempl<CommSrvDate>::ToXmlString(_buf, "dateOfBirth", dateOfBirth);
	Atf::XmlElement::encodeAsXmlElement("address", address, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::encodeAsXmlElement("zip", zip, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("phone", phone, _buf);
	Atf::XmlElement::encodeAsXmlElement("firstName", firstName, _buf);
	Atf::XmlElement::encodeAsXmlElement("lastName", lastName, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::AgeVerificationCommonBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("title"))
		{
			title = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fullName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, fullName)) return false;
		}
		else if (_element.equals("gender"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, gender)) return false;
		}
		else if (_element.equals("dateOfBirth"))
		{
			Atf::AtfTempl<CommSrvDate>::FromXmlString(_value, dateOfBirth);
		}
		else if (_element.equals("address"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, address)) return false;
		}
		else if (_element.equals("city"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
		}
		else if (_element.equals("zip"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, zip)) return false;
		}
		else if (_element.equals("state"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("phone"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, phone)) return false;
		}
		else if (_element.equals("firstName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, firstName)) return false;
		}
		else if (_element.equals("lastName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, lastName)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::AgeVerificationCommonBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(AgeVerificationCommonBody())) // not empty
	{
		_body.composeINT32(title);
		_body.composeString(fullName);
		_body.composeString(gender);
		_body.composeSrvDate(dateOfBirth);
		_body.composeString(address);
		_body.composeString(city);
		_body.composeString(zip);
		_body.composeString(state);
		_body.composeString(country);
		_body.composeString(phone);
		_body.composeString(firstName);
		_body.composeString(lastName);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::AgeVerificationCommonBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(title);
	_parser0.parseStringP(fullName);
	_parser0.parseStringP(gender);
	_parser0.parseSrvDate(dateOfBirth);
	_parser0.parseStringP(address);
	_parser0.parseStringP(city);
	_parser0.parseStringP(zip);
	_parser0.parseStringP(state);
	_parser0.parseStringP(country);
	_parser0.parseStringP(phone);
	_parser0.parseStringP(firstName);
	_parser0.parseStringP(lastName);
}

const char *CashierServer::cli::AgeVerificationCommonBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("title", title);
	_jsonstr.compose("fullName", fullName);
	_jsonstr.compose("gender", gender);
	_jsonstr.compose("dateOfBirth", dateOfBirth);
	_jsonstr.compose("address", address);
	_jsonstr.compose("city", city);
	_jsonstr.compose("zip", zip);
	_jsonstr.compose("state", state);
	_jsonstr.compose("country", country);
	_jsonstr.compose("phone", phone);
	_jsonstr.compose("firstName", firstName);
	_jsonstr.compose("lastName", lastName);
	return _buf.c_str();
}

void CashierServer::cli::AgeVerificationCommonBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("title", title);
	_jparser.parseByNameThrow("fullName", fullName);
	_jparser.parseByNameThrow("gender", gender);
	_jparser.parseByNameThrow("dateOfBirth", dateOfBirth);
	_jparser.parseByNameThrow("address", address);
	_jparser.parseByNameThrow("city", city);
	_jparser.parseByNameThrow("zip", zip);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("phone", phone);
	_jparser.parseByNameThrow("firstName", firstName);
	_jparser.parseByNameThrow("lastName", lastName);
}

/* static */ void CashierServer::cli::AgeVerificationCommonBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 title; _jparser.validateByNameThrow("title", title);
	{ const INT32 title_enum[] = { eUserTitleNone, eUserTitleMr, eUserTitleMrs, eUserTitleMiss, eUserTitleMs, eUserTitleDr }; AtfValidator::validateEnum(_descr, "title", title, title_enum, _checker, __FILE__, __LINE__); }
	PString fullName; _jparser.validateByNameThrow("fullName", fullName);
	AtfValidator::validateIntMax(_descr, "fullName", fullName.length(), USER_FULLNAME_LEN, _checker, __FILE__, __LINE__);
	PString gender; _jparser.validateByNameThrow("gender", gender);
	AtfValidator::validateIntMax(_descr, "gender", gender.length(), GENDER_LEN, _checker, __FILE__, __LINE__);
	CommSrvDate dateOfBirth; _jparser.validateByNameThrow("dateOfBirth", dateOfBirth);
	AtfValidator::validateSrvDateTime(_descr, "dateOfBirth", dateOfBirth, _checker, __FILE__, __LINE__);
	PString address; _jparser.validateByNameThrow("address", address);
	AtfValidator::validateIntMax(_descr, "address", address.length(), USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateIntMax(_descr, "city", city.length(), USER_CITY_LEN, _checker, __FILE__, __LINE__);
	PString zip; _jparser.validateByNameThrow("zip", zip);
	AtfValidator::validateIntMax(_descr, "zip", zip.length(), USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateIntMax(_descr, "state", state.length(), USER_STATE_LEN, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	PString phone; _jparser.validateByNameThrow("phone", phone);
	AtfValidator::validateIntMax(_descr, "phone", phone.length(), 100, _checker, __FILE__, __LINE__);
	PString firstName; _jparser.validateByNameThrow("firstName", firstName);
	AtfValidator::validateIntMax(_descr, "firstName", firstName.length(), USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	PString lastName; _jparser.validateByNameThrow("lastName", lastName);
	AtfValidator::validateIntMax(_descr, "lastName", lastName.length(), USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::AgeVerificationCommonBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 title; _parser0.parseINT32(title);
	{ const INT32 title_enum[] = { eUserTitleNone, eUserTitleMr, eUserTitleMrs, eUserTitleMiss, eUserTitleMs, eUserTitleDr }; AtfValidator::validateEnum(_descr, "title", title, title_enum, _checker, __FILE__, __LINE__); }
	_parser0.parseStringN(_dummy, 0, "fullName"); size_t szFullName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fullName", szFullName, USER_FULLNAME_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "gender"); size_t szGender = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "gender", szGender, GENDER_LEN, _checker, __FILE__, __LINE__);
	CommSrvDate dateOfBirth; _parser0.parseSrvDate(dateOfBirth);
	AtfValidator::validateSrvDateTime(_descr, "dateOfBirth", dateOfBirth, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "address", szAddress, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "zip"); size_t szZip = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zip", szZip, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phone", szPhone, 100, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "firstName", szFirstName, USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "lastName"); size_t szLastName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "lastName", szLastName, USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    AgeVerificationPassportBody
//=================================================================

CashierServer::cli::AgeVerificationPassportBody::AgeVerificationPassportBody()
{
	clear();
}

void CashierServer::cli::AgeVerificationPassportBody::clear()
{
	passportNumber1.clear();
	passportNumber2.clear();
	passportNumber3.clear();
	passportNumber4.clear();
	passportNumber5.clear();
	passportNumber6.clear();
	passportExprireDate.setNull();
}

bool CashierServer::cli::AgeVerificationPassportBody::equals(const AgeVerificationPassportBody& _o) const
{
	return Atf::atfPStringEquals(passportNumber1, _o.passportNumber1) &&
		Atf::atfPStringEquals(passportNumber2, _o.passportNumber2) &&
		Atf::atfPStringEquals(passportNumber3, _o.passportNumber3) &&
		Atf::atfPStringEquals(passportNumber4, _o.passportNumber4) &&
		Atf::atfPStringEquals(passportNumber5, _o.passportNumber5) &&
		Atf::atfPStringEquals(passportNumber6, _o.passportNumber6) &&
		passportExprireDate.equals(_o.passportExprireDate);
}

const char *CashierServer::cli::AgeVerificationPassportBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("passportNumber1=");
	_buf.append(passportNumber1);
	_buf.append(',');
	_buf.append("passportNumber2=");
	_buf.append(passportNumber2);
	_buf.append(',');
	_buf.append("passportNumber3=");
	_buf.append(passportNumber3);
	_buf.append(',');
	_buf.append("passportNumber4=");
	_buf.append(passportNumber4);
	_buf.append(',');
	_buf.append("passportNumber5=");
	_buf.append(passportNumber5);
	_buf.append(',');
	_buf.append("passportNumber6=");
	_buf.append(passportNumber6);
	_buf.append(',');
	_buf.append("passportExprireDate=");
	Atf::AtfTempl<CommSrvDate>::ToTraceString(_buf, passportExprireDate);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::AgeVerificationPassportBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("passportNumber1", passportNumber1, _buf);
	Atf::XmlElement::encodeAsXmlElement("passportNumber2", passportNumber2, _buf);
	Atf::XmlElement::encodeAsXmlElement("passportNumber3", passportNumber3, _buf);
	Atf::XmlElement::encodeAsXmlElement("passportNumber4", passportNumber4, _buf);
	Atf::XmlElement::encodeAsXmlElement("passportNumber5", passportNumber5, _buf);
	Atf::XmlElement::encodeAsXmlElement("passportNumber6", passportNumber6, _buf);
	Atf::AtfTempl<CommSrvDate>::ToXmlString(_buf, "passportExprireDate", passportExprireDate);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::AgeVerificationPassportBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("passportNumber1"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, passportNumber1)) return false;
		}
		else if (_element.equals("passportNumber2"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, passportNumber2)) return false;
		}
		else if (_element.equals("passportNumber3"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, passportNumber3)) return false;
		}
		else if (_element.equals("passportNumber4"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, passportNumber4)) return false;
		}
		else if (_element.equals("passportNumber5"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, passportNumber5)) return false;
		}
		else if (_element.equals("passportNumber6"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, passportNumber6)) return false;
		}
		else if (_element.equals("passportExprireDate"))
		{
			Atf::AtfTempl<CommSrvDate>::FromXmlString(_value, passportExprireDate);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::AgeVerificationPassportBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(AgeVerificationPassportBody())) // not empty
	{
		_body.composeString(passportNumber1);
		_body.composeString(passportNumber2);
		_body.composeString(passportNumber3);
		_body.composeString(passportNumber4);
		_body.composeString(passportNumber5);
		_body.composeString(passportNumber6);
		_body.composeSrvDate(passportExprireDate);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::AgeVerificationPassportBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(passportNumber1);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(passportNumber2);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(passportNumber3);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(passportNumber4);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(passportNumber5);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(passportNumber6);
	if(_parser0.parseEnded()) return;
	_parser0.parseSrvDate(passportExprireDate);
}

const char *CashierServer::cli::AgeVerificationPassportBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("passportNumber1", passportNumber1);
	_jsonstr.compose("passportNumber2", passportNumber2);
	_jsonstr.compose("passportNumber3", passportNumber3);
	_jsonstr.compose("passportNumber4", passportNumber4);
	_jsonstr.compose("passportNumber5", passportNumber5);
	_jsonstr.compose("passportNumber6", passportNumber6);
	_jsonstr.compose("passportExprireDate", passportExprireDate);
	return _buf.c_str();
}

void CashierServer::cli::AgeVerificationPassportBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("passportNumber1", passportNumber1);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("passportNumber2", passportNumber2);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("passportNumber3", passportNumber3);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("passportNumber4", passportNumber4);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("passportNumber5", passportNumber5);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("passportNumber6", passportNumber6);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("passportExprireDate", passportExprireDate);
}

/* static */ void CashierServer::cli::AgeVerificationPassportBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString passportNumber1; _jparser.validateByNameThrow("passportNumber1", passportNumber1);
	AtfValidator::validateIntMax(_descr, "passportNumber1", passportNumber1.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString passportNumber2; _jparser.validateByNameThrow("passportNumber2", passportNumber2);
	AtfValidator::validateIntMax(_descr, "passportNumber2", passportNumber2.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString passportNumber3; _jparser.validateByNameThrow("passportNumber3", passportNumber3);
	AtfValidator::validateIntMax(_descr, "passportNumber3", passportNumber3.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString passportNumber4; _jparser.validateByNameThrow("passportNumber4", passportNumber4);
	AtfValidator::validateIntMax(_descr, "passportNumber4", passportNumber4.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString passportNumber5; _jparser.validateByNameThrow("passportNumber5", passportNumber5);
	AtfValidator::validateIntMax(_descr, "passportNumber5", passportNumber5.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString passportNumber6; _jparser.validateByNameThrow("passportNumber6", passportNumber6);
	AtfValidator::validateIntMax(_descr, "passportNumber6", passportNumber6.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	CommSrvDate passportExprireDate; _jparser.validateByNameThrow("passportExprireDate", passportExprireDate);
	AtfValidator::validateSrvDateTime(_descr, "passportExprireDate", passportExprireDate, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::AgeVerificationPassportBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "passportNumber1"); size_t szPassportNumber1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber1", szPassportNumber1, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "passportNumber2"); size_t szPassportNumber2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber2", szPassportNumber2, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "passportNumber3"); size_t szPassportNumber3 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber3", szPassportNumber3, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "passportNumber4"); size_t szPassportNumber4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber4", szPassportNumber4, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "passportNumber5"); size_t szPassportNumber5 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber5", szPassportNumber5, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "passportNumber6"); size_t szPassportNumber6 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber6", szPassportNumber6, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	CommSrvDate passportExprireDate; _parser0.parseSrvDate(passportExprireDate);
	AtfValidator::validateSrvDateTime(_descr, "passportExprireDate", passportExprireDate, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    AgeVerificationDrivLicBody
//=================================================================

CashierServer::cli::AgeVerificationDrivLicBody::AgeVerificationDrivLicBody()
{
	clear();
}

void CashierServer::cli::AgeVerificationDrivLicBody::clear()
{
	driverLicenseCountry.clear();
	driverNumber1.clear();
	driverNumber2.clear();
	driverNumber3.clear();
	driverNumber4.clear();
}

bool CashierServer::cli::AgeVerificationDrivLicBody::equals(const AgeVerificationDrivLicBody& _o) const
{
	return Atf::atfPStringEquals(driverLicenseCountry, _o.driverLicenseCountry) &&
		Atf::atfPStringEquals(driverNumber1, _o.driverNumber1) &&
		Atf::atfPStringEquals(driverNumber2, _o.driverNumber2) &&
		Atf::atfPStringEquals(driverNumber3, _o.driverNumber3) &&
		Atf::atfPStringEquals(driverNumber4, _o.driverNumber4);
}

const char *CashierServer::cli::AgeVerificationDrivLicBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("driverLicenseCountry=");
	_buf.append(driverLicenseCountry);
	_buf.append(',');
	_buf.append("driverNumber1=");
	_buf.append(driverNumber1);
	_buf.append(',');
	_buf.append("driverNumber2=");
	_buf.append(driverNumber2);
	_buf.append(',');
	_buf.append("driverNumber3=");
	_buf.append(driverNumber3);
	_buf.append(',');
	_buf.append("driverNumber4=");
	_buf.append(driverNumber4);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::AgeVerificationDrivLicBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("driverLicenseCountry", driverLicenseCountry, _buf);
	Atf::XmlElement::encodeAsXmlElement("driverNumber1", driverNumber1, _buf);
	Atf::XmlElement::encodeAsXmlElement("driverNumber2", driverNumber2, _buf);
	Atf::XmlElement::encodeAsXmlElement("driverNumber3", driverNumber3, _buf);
	Atf::XmlElement::encodeAsXmlElement("driverNumber4", driverNumber4, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::AgeVerificationDrivLicBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("driverLicenseCountry"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, driverLicenseCountry)) return false;
		}
		else if (_element.equals("driverNumber1"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, driverNumber1)) return false;
		}
		else if (_element.equals("driverNumber2"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, driverNumber2)) return false;
		}
		else if (_element.equals("driverNumber3"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, driverNumber3)) return false;
		}
		else if (_element.equals("driverNumber4"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, driverNumber4)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::AgeVerificationDrivLicBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(AgeVerificationDrivLicBody())) // not empty
	{
		_body.composeString(driverLicenseCountry);
		_body.composeString(driverNumber1);
		_body.composeString(driverNumber2);
		_body.composeString(driverNumber3);
		_body.composeString(driverNumber4);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::AgeVerificationDrivLicBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(driverLicenseCountry);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(driverNumber1);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(driverNumber2);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(driverNumber3);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(driverNumber4);
}

const char *CashierServer::cli::AgeVerificationDrivLicBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("driverLicenseCountry", driverLicenseCountry);
	_jsonstr.compose("driverNumber1", driverNumber1);
	_jsonstr.compose("driverNumber2", driverNumber2);
	_jsonstr.compose("driverNumber3", driverNumber3);
	_jsonstr.compose("driverNumber4", driverNumber4);
	return _buf.c_str();
}

void CashierServer::cli::AgeVerificationDrivLicBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("driverLicenseCountry", driverLicenseCountry);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("driverNumber1", driverNumber1);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("driverNumber2", driverNumber2);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("driverNumber3", driverNumber3);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("driverNumber4", driverNumber4);
}

/* static */ void CashierServer::cli::AgeVerificationDrivLicBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString driverLicenseCountry; _jparser.validateByNameThrow("driverLicenseCountry", driverLicenseCountry);
	AtfValidator::validateIntMax(_descr, "driverLicenseCountry", driverLicenseCountry.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString driverNumber1; _jparser.validateByNameThrow("driverNumber1", driverNumber1);
	AtfValidator::validateIntMax(_descr, "driverNumber1", driverNumber1.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString driverNumber2; _jparser.validateByNameThrow("driverNumber2", driverNumber2);
	AtfValidator::validateIntMax(_descr, "driverNumber2", driverNumber2.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString driverNumber3; _jparser.validateByNameThrow("driverNumber3", driverNumber3);
	AtfValidator::validateIntMax(_descr, "driverNumber3", driverNumber3.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString driverNumber4; _jparser.validateByNameThrow("driverNumber4", driverNumber4);
	AtfValidator::validateIntMax(_descr, "driverNumber4", driverNumber4.length(), 100, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::AgeVerificationDrivLicBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "driverLicenseCountry"); size_t szDriverLicenseCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverLicenseCountry", szDriverLicenseCountry, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "driverNumber1"); size_t szDriverNumber1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverNumber1", szDriverNumber1, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "driverNumber2"); size_t szDriverNumber2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverNumber2", szDriverNumber2, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "driverNumber3"); size_t szDriverNumber3 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverNumber3", szDriverNumber3, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "driverNumber4"); size_t szDriverNumber4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverNumber4", szDriverNumber4, 100, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_AGEVERIVICATION2
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::Protocol_MSG_CASHIER_AGEVERIVICATION2()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::clear()
{
	common.clear();
	passport.clear();
	drivLic.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::equals(const Protocol_MSG_CASHIER_AGEVERIVICATION2& _o) const
{
	return common.equals(_o.common) &&
		passport.equals(_o.passport) &&
		drivLic.equals(_o.drivLic);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_AGEVERIVICATION2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_AGEVERIVICATION2*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_AGEVERIVICATION2).append(")");
	_buf.append(',');
	_buf.append("common=");
	common.toTraceString(_buf);
	_buf.append(',');
	_buf.append("passport=");
	passport.toTraceString(_buf);
	_buf.append(',');
	_buf.append("drivLic=");
	drivLic.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_AGEVERIVICATION2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	common.toXmlString("common", _buf);
	passport.toXmlString("passport", _buf);
	drivLic.toXmlString("drivLic", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("common"))
			{
				if(!Atf::AtfTempl< AgeVerificationCommonBody >::FromXmlString(_value, common)) return false;
			}
			else if (_element.equals("passport"))
			{
				if(!Atf::AtfTempl< AgeVerificationPassportBody >::FromXmlString(_value, passport)) return false;
			}
			else if (_element.equals("drivLic"))
			{
				if(!Atf::AtfTempl< AgeVerificationDrivLicBody >::FromXmlString(_value, drivLic)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	common.composeMsg(_msg, _ignoreJSON);
	passport.composeMsg(_msg, _ignoreJSON);
	drivLic.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::parseMsg(CommMsgParser& _parser)
{
	common.parseMsg(_parser);
	passport.parseMsg(_parser);
	drivLic.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("common", common);
	_jsonstr.compose("passport", passport);
	_jsonstr.compose("drivLic", drivLic);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("common", common);
	_jparser.parseByNameThrow("passport", passport);
	_jparser.parseByNameThrow("drivLic", drivLic);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGEVERIVICATION2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	AgeVerificationCommonBody common; _jparser.validateByNameThrow("common", common);
	AgeVerificationPassportBody passport; _jparser.validateByNameThrow("passport", passport);
	AgeVerificationDrivLicBody drivLic; _jparser.validateByNameThrow("drivLic", drivLic);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGEVERIVICATION2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	AgeVerificationCommonBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("common"), _fieldsWithUnparsedContent);
	AgeVerificationPassportBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("passport"), _fieldsWithUnparsedContent);
	AgeVerificationDrivLicBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("drivLic"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    AgeVerificationDrivLicCountryBody
//=================================================================

CashierServer::cli::AgeVerificationDrivLicCountryBody::AgeVerificationDrivLicCountryBody()
{
	clear();
}

void CashierServer::cli::AgeVerificationDrivLicCountryBody::clear()
{
	country.clear();
}

bool CashierServer::cli::AgeVerificationDrivLicCountryBody::equals(const AgeVerificationDrivLicCountryBody& _o) const
{
	return Atf::atfPStringEquals(country, _o.country);
}

const char *CashierServer::cli::AgeVerificationDrivLicCountryBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("country=");
	_buf.append(country);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::AgeVerificationDrivLicCountryBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::AgeVerificationDrivLicCountryBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::AgeVerificationDrivLicCountryBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(AgeVerificationDrivLicCountryBody())) // not empty
	{
		_body.composeString(country);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::AgeVerificationDrivLicCountryBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(country);
}

const char *CashierServer::cli::AgeVerificationDrivLicCountryBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("country", country);
	return _buf.c_str();
}

void CashierServer::cli::AgeVerificationDrivLicCountryBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("country", country);
}

/* static */ void CashierServer::cli::AgeVerificationDrivLicCountryBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::AgeVerificationDrivLicCountryBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	ageCheckDrivLicCountries.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::equals(const Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		ageCheckDrivLicCountries.equals(_o.ageCheckDrivLicCountries);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_AGEVERIVICATION2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_AGEVERIVICATION2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("ageCheckDrivLicCountries=");
		ageCheckDrivLicCountries.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_AGEVERIVICATION2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		ageCheckDrivLicCountries.toXmlString("ageCheckDrivLicCountries", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("ageCheckDrivLicCountries"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< AgeVerificationDrivLicCountryBody, 4 > >::FromXmlString(_value, ageCheckDrivLicCountries)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		ageCheckDrivLicCountries.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		if(_parser.parseEnded()) return;
		ageCheckDrivLicCountries.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("ageCheckDrivLicCountries", ageCheckDrivLicCountries);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("ageCheckDrivLicCountries", ageCheckDrivLicCountries);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGEVERIVICATION2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		if(_jparser.parseEnded()) return;
		Atf::AtfVectorBase< AgeVerificationDrivLicCountryBody > ageCheckDrivLicCountries; _jparser.validateByNameThrow("ageCheckDrivLicCountries", ageCheckDrivLicCountries);
		AtfValidator::validateInt(_descr, "ageCheckDrivLicCountries", ageCheckDrivLicCountries.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGEVERIVICATION2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		if(_parser.parseEnded()) return;
		PString _descbuf;
		int szAgeCheckDrivLicCountries = Atf::LAtfVector< AgeVerificationDrivLicCountryBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ageCheckDrivLicCountries"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ageCheckDrivLicCountries", szAgeCheckDrivLicCountries, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::equals(const Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_AGEVERIVICATION2_CANCEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_AGEVERIVICATION2_CANCEL).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_AGEVERIVICATION2_CANCEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGEVERIVICATION2_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGEVERIVICATION2_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::equals(const Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHECK_PAYSYSTEM
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::clear()
{
	paySystemByte = 0;
	requestCurrency.clear();
	cardInfoId = 0;
	notUsedNum1 = 0;
	notUsedNum2 = 0;
	notUsedNum3 = 0;
	notUsedNum4 = 0;
	notUsedNum5 = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::equals(const Protocol_MSG_CASHIER_CHECK_PAYSYSTEM& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		Atf::atfPStringEquals(requestCurrency, _o.requestCurrency) &&
		cardInfoId == _o.cardInfoId &&
		notUsedNum1 == _o.notUsedNum1 &&
		notUsedNum2 == _o.notUsedNum2 &&
		notUsedNum3 == _o.notUsedNum3 &&
		notUsedNum4 == _o.notUsedNum4 &&
		notUsedNum5 == _o.notUsedNum5;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CHECK_PAYSYSTEM != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CHECK_PAYSYSTEM*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHECK_PAYSYSTEM).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("requestCurrency=");
	_buf.append(requestCurrency);
	_buf.append(',');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	_buf.append(',');
	_buf.append("notUsedNum1=");
	_buf.appendUint(notUsedNum1);
	_buf.append(',');
	_buf.append("notUsedNum2=");
	_buf.appendUint(notUsedNum2);
	_buf.append(',');
	_buf.append("notUsedNum3=");
	_buf.appendUint(notUsedNum3);
	_buf.append(',');
	_buf.append("notUsedNum4=");
	_buf.appendUint(notUsedNum4);
	_buf.append(',');
	_buf.append("notUsedNum5=");
	_buf.appendUint(notUsedNum5);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CHECK_PAYSYSTEM).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("requestCurrency", requestCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardInfoId", cardInfoId, _buf);
	Atf::XmlElement::encodeAsXmlElement("notUsedNum1", notUsedNum1, _buf);
	Atf::XmlElement::encodeAsXmlElement("notUsedNum2", notUsedNum2, _buf);
	Atf::XmlElement::encodeAsXmlElement("notUsedNum3", notUsedNum3, _buf);
	Atf::XmlElement::encodeAsXmlElement("notUsedNum4", notUsedNum4, _buf);
	Atf::XmlElement::encodeAsXmlElement("notUsedNum5", notUsedNum5, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("requestCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, requestCurrency)) return false;
			}
			else if (_element.equals("cardInfoId"))
			{
				cardInfoId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notUsedNum1"))
			{
				notUsedNum1 = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notUsedNum2"))
			{
				notUsedNum2 = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notUsedNum3"))
			{
				notUsedNum3 = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notUsedNum4"))
			{
				notUsedNum4 = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notUsedNum5"))
			{
				notUsedNum5 = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeString(requestCurrency);
	_msg.composeUINT32(cardInfoId);
	_msg.composeBYTE(notUsedNum1);
	_msg.composeBYTE(notUsedNum2);
	_msg.composeBYTE(notUsedNum3);
	_msg.composeBYTE(notUsedNum4);
	_msg.composeBYTE(notUsedNum5);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseStringP(requestCurrency);
	_parser.parseUINT32(cardInfoId);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(notUsedNum1);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(notUsedNum2);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(notUsedNum3);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(notUsedNum4);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(notUsedNum5);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemByte", paySystemByte);
	_jsonstr.compose("requestCurrency", requestCurrency);
	_jsonstr.compose("cardInfoId", cardInfoId);
	_jsonstr.compose("notUsedNum1", notUsedNum1);
	_jsonstr.compose("notUsedNum2", notUsedNum2);
	_jsonstr.compose("notUsedNum3", notUsedNum3);
	_jsonstr.compose("notUsedNum4", notUsedNum4);
	_jsonstr.compose("notUsedNum5", notUsedNum5);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
	_jparser.parseByNameThrow("requestCurrency", requestCurrency);
	_jparser.parseByNameThrow("cardInfoId", cardInfoId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("notUsedNum1", notUsedNum1);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("notUsedNum2", notUsedNum2);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("notUsedNum3", notUsedNum3);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("notUsedNum4", notUsedNum4);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("notUsedNum5", notUsedNum5);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PAYSYSTEM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	PString requestCurrency; _jparser.validateByNameThrow("requestCurrency", requestCurrency);
	AtfValidator::validateIntMax(_descr, "requestCurrency", requestCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _jparser.validateByNameThrow("cardInfoId", cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE notUsedNum1; _jparser.validateByNameThrow("notUsedNum1", notUsedNum1);
	AtfValidator::validateInt(_descr, "notUsedNum1", notUsedNum1, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE notUsedNum2; _jparser.validateByNameThrow("notUsedNum2", notUsedNum2);
	AtfValidator::validateInt(_descr, "notUsedNum2", notUsedNum2, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE notUsedNum3; _jparser.validateByNameThrow("notUsedNum3", notUsedNum3);
	AtfValidator::validateInt(_descr, "notUsedNum3", notUsedNum3, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE notUsedNum4; _jparser.validateByNameThrow("notUsedNum4", notUsedNum4);
	AtfValidator::validateInt(_descr, "notUsedNum4", notUsedNum4, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE notUsedNum5; _jparser.validateByNameThrow("notUsedNum5", notUsedNum5);
	AtfValidator::validateInt(_descr, "notUsedNum5", notUsedNum5, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PAYSYSTEM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "requestCurrency"); size_t szRequestCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "requestCurrency", szRequestCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE notUsedNum1; _parser.parseBYTE(notUsedNum1);
	AtfValidator::validateInt(_descr, "notUsedNum1", notUsedNum1, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE notUsedNum2; _parser.parseBYTE(notUsedNum2);
	AtfValidator::validateInt(_descr, "notUsedNum2", notUsedNum2, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE notUsedNum3; _parser.parseBYTE(notUsedNum3);
	AtfValidator::validateInt(_descr, "notUsedNum3", notUsedNum3, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE notUsedNum4; _parser.parseBYTE(notUsedNum4);
	AtfValidator::validateInt(_descr, "notUsedNum4", notUsedNum4, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE notUsedNum5; _parser.parseBYTE(notUsedNum5);
	AtfValidator::validateInt(_descr, "notUsedNum5", notUsedNum5, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierAvailableCurrency
//=================================================================

CashierServer::cli::CashierAvailableCurrency::CashierAvailableCurrency()
{
	clear();
}

void CashierServer::cli::CashierAvailableCurrency::clear()
{
	currency.clear();
	depositRate64 = 0;
	depositRate64Inverted = 0;
}

bool CashierServer::cli::CashierAvailableCurrency::equals(const CashierAvailableCurrency& _o) const
{
	return Atf::atfPStringEquals(currency, _o.currency) &&
		depositRate64 == _o.depositRate64 &&
		depositRate64Inverted == _o.depositRate64Inverted;
}

const char *CashierServer::cli::CashierAvailableCurrency::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("depositRate64=");
	_buf.appendUint64(depositRate64);
	_buf.append(',');
	_buf.append("depositRate64Inverted=");
	_buf.appendUint64(depositRate64Inverted);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierAvailableCurrency::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("depositRate64", depositRate64, _buf);
	Atf::XmlElement::encodeAsXmlElement("depositRate64Inverted", depositRate64Inverted, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierAvailableCurrency::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("depositRate64"))
		{
			depositRate64 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("depositRate64Inverted"))
		{
			depositRate64Inverted = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierAvailableCurrency::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierAvailableCurrency())) // not empty
	{
		_body.composeString(currency);
		_body.composeUINT64(depositRate64);
		_body.composeUINT64(depositRate64Inverted);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierAvailableCurrency::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseUINT64(depositRate64);
	_parser0.parseUINT64(depositRate64Inverted);
}

const char *CashierServer::cli::CashierAvailableCurrency::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("depositRate64", depositRate64);
	_jsonstr.compose("depositRate64Inverted", depositRate64Inverted);
	return _buf.c_str();
}

void CashierServer::cli::CashierAvailableCurrency::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("depositRate64", depositRate64);
	_jparser.parseByNameThrow("depositRate64Inverted", depositRate64Inverted);
}

/* static */ void CashierServer::cli::CashierAvailableCurrency::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT64 depositRate64; _jparser.validateByNameThrow("depositRate64", depositRate64);
	AtfValidator::validateUint(_descr, "depositRate64", depositRate64, _checker, __FILE__, __LINE__);
	UINT64 depositRate64Inverted; _jparser.validateByNameThrow("depositRate64Inverted", depositRate64Inverted);
	AtfValidator::validateUint(_descr, "depositRate64Inverted", depositRate64Inverted, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierAvailableCurrency::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT64 depositRate64; _parser0.parseUINT64(depositRate64);
	AtfValidator::validateUint(_descr, "depositRate64", depositRate64, _checker, __FILE__, __LINE__);
	UINT64 depositRate64Inverted; _parser0.parseUINT64(depositRate64Inverted);
	AtfValidator::validateUint(_descr, "depositRate64Inverted", depositRate64Inverted, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierFeeBody
//=================================================================

CashierServer::cli::CashierFeeBody::CashierFeeBody()
{
	clear();
}

void CashierServer::cli::CashierFeeBody::clear()
{
	graceDepositsPeriodDays = 0;
	graceDeposits = 0;
	leftGraceDeposits = 0;
	calcRate_x_100K = 0;
	calcMinFee = 0;
	calcMaxFee = 0;
	altPaysystemByte = 0;
}

bool CashierServer::cli::CashierFeeBody::equals(const CashierFeeBody& _o) const
{
	return graceDepositsPeriodDays == _o.graceDepositsPeriodDays &&
		graceDeposits == _o.graceDeposits &&
		leftGraceDeposits == _o.leftGraceDeposits &&
		calcRate_x_100K == _o.calcRate_x_100K &&
		calcMinFee == _o.calcMinFee &&
		calcMaxFee == _o.calcMaxFee &&
		altPaysystemByte == _o.altPaysystemByte;
}

const char *CashierServer::cli::CashierFeeBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("graceDepositsPeriodDays=");
	_buf.appendInt(graceDepositsPeriodDays);
	_buf.append(',');
	_buf.append("graceDeposits=");
	_buf.appendInt(graceDeposits);
	_buf.append(',');
	_buf.append("leftGraceDeposits=");
	_buf.appendInt(leftGraceDeposits);
	_buf.append(',');
	_buf.append("calcRate_x_100K=");
	_buf.appendInt(calcRate_x_100K);
	_buf.append(',');
	_buf.append("calcMinFee=");
	_buf.appendInt(calcMinFee);
	_buf.append(',');
	_buf.append("calcMaxFee=");
	_buf.appendInt(calcMaxFee);
	_buf.append(',');
	_buf.append("altPaysystemByte=");
	_buf.appendUint(altPaysystemByte);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierFeeBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("graceDepositsPeriodDays", graceDepositsPeriodDays, _buf);
	Atf::XmlElement::encodeAsXmlElement("graceDeposits", graceDeposits, _buf);
	Atf::XmlElement::encodeAsXmlElement("leftGraceDeposits", leftGraceDeposits, _buf);
	Atf::XmlElement::encodeAsXmlElement("calcRate_x_100K", calcRate_x_100K, _buf);
	Atf::XmlElement::encodeAsXmlElement("calcMinFee", calcMinFee, _buf);
	Atf::XmlElement::encodeAsXmlElement("calcMaxFee", calcMaxFee, _buf);
	Atf::XmlElement::encodeAsXmlElement("altPaysystemByte", altPaysystemByte, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierFeeBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("graceDepositsPeriodDays"))
		{
			graceDepositsPeriodDays = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("graceDeposits"))
		{
			graceDeposits = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("leftGraceDeposits"))
		{
			leftGraceDeposits = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("calcRate_x_100K"))
		{
			calcRate_x_100K = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("calcMinFee"))
		{
			calcMinFee = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("calcMaxFee"))
		{
			calcMaxFee = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("altPaysystemByte"))
		{
			altPaysystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierFeeBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierFeeBody())) // not empty
	{
		_body.composeINT32(graceDepositsPeriodDays);
		_body.composeINT32(graceDeposits);
		_body.composeINT32(leftGraceDeposits);
		_body.composeINT32(calcRate_x_100K);
		_body.composeINT32(calcMinFee);
		_body.composeINT32(calcMaxFee);
		_body.composeBYTE(altPaysystemByte);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierFeeBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(graceDepositsPeriodDays);
	_parser0.parseINT32(graceDeposits);
	_parser0.parseINT32(leftGraceDeposits);
	_parser0.parseINT32(calcRate_x_100K);
	_parser0.parseINT32(calcMinFee);
	_parser0.parseINT32(calcMaxFee);
	_parser0.parseBYTE(altPaysystemByte);
}

const char *CashierServer::cli::CashierFeeBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("graceDepositsPeriodDays", graceDepositsPeriodDays);
	_jsonstr.compose("graceDeposits", graceDeposits);
	_jsonstr.compose("leftGraceDeposits", leftGraceDeposits);
	_jsonstr.compose("calcRate_x_100K", calcRate_x_100K);
	_jsonstr.compose("calcMinFee", calcMinFee);
	_jsonstr.compose("calcMaxFee", calcMaxFee);
	_jsonstr.compose("altPaysystemByte", altPaysystemByte);
	return _buf.c_str();
}

void CashierServer::cli::CashierFeeBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("graceDepositsPeriodDays", graceDepositsPeriodDays);
	_jparser.parseByNameThrow("graceDeposits", graceDeposits);
	_jparser.parseByNameThrow("leftGraceDeposits", leftGraceDeposits);
	_jparser.parseByNameThrow("calcRate_x_100K", calcRate_x_100K);
	_jparser.parseByNameThrow("calcMinFee", calcMinFee);
	_jparser.parseByNameThrow("calcMaxFee", calcMaxFee);
	_jparser.parseByNameThrow("altPaysystemByte", altPaysystemByte);
}

/* static */ void CashierServer::cli::CashierFeeBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 graceDepositsPeriodDays; _jparser.validateByNameThrow("graceDepositsPeriodDays", graceDepositsPeriodDays);
	AtfValidator::validateInt(_descr, "graceDepositsPeriodDays", graceDepositsPeriodDays, _checker, __FILE__, __LINE__);
	INT32 graceDeposits; _jparser.validateByNameThrow("graceDeposits", graceDeposits);
	AtfValidator::validateInt(_descr, "graceDeposits", graceDeposits, _checker, __FILE__, __LINE__);
	INT32 leftGraceDeposits; _jparser.validateByNameThrow("leftGraceDeposits", leftGraceDeposits);
	AtfValidator::validateInt(_descr, "leftGraceDeposits", leftGraceDeposits, _checker, __FILE__, __LINE__);
	INT32 calcRate_x_100K; _jparser.validateByNameThrow("calcRate_x_100K", calcRate_x_100K);
	AtfValidator::validateInt(_descr, "calcRate_x_100K", calcRate_x_100K, _checker, __FILE__, __LINE__);
	INT32 calcMinFee; _jparser.validateByNameThrow("calcMinFee", calcMinFee);
	AtfValidator::validateInt(_descr, "calcMinFee", calcMinFee, _checker, __FILE__, __LINE__);
	INT32 calcMaxFee; _jparser.validateByNameThrow("calcMaxFee", calcMaxFee);
	AtfValidator::validateInt(_descr, "calcMaxFee", calcMaxFee, _checker, __FILE__, __LINE__);
	BYTE altPaysystemByte; _jparser.validateByNameThrow("altPaysystemByte", altPaysystemByte);
	AtfValidator::validateInt(_descr, "altPaysystemByte", altPaysystemByte, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierFeeBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 graceDepositsPeriodDays; _parser0.parseINT32(graceDepositsPeriodDays);
	AtfValidator::validateInt(_descr, "graceDepositsPeriodDays", graceDepositsPeriodDays, _checker, __FILE__, __LINE__);
	INT32 graceDeposits; _parser0.parseINT32(graceDeposits);
	AtfValidator::validateInt(_descr, "graceDeposits", graceDeposits, _checker, __FILE__, __LINE__);
	INT32 leftGraceDeposits; _parser0.parseINT32(leftGraceDeposits);
	AtfValidator::validateInt(_descr, "leftGraceDeposits", leftGraceDeposits, _checker, __FILE__, __LINE__);
	INT32 calcRate_x_100K; _parser0.parseINT32(calcRate_x_100K);
	AtfValidator::validateInt(_descr, "calcRate_x_100K", calcRate_x_100K, _checker, __FILE__, __LINE__);
	INT32 calcMinFee; _parser0.parseINT32(calcMinFee);
	AtfValidator::validateInt(_descr, "calcMinFee", calcMinFee, _checker, __FILE__, __LINE__);
	INT32 calcMaxFee; _parser0.parseINT32(calcMaxFee);
	AtfValidator::validateInt(_descr, "calcMaxFee", calcMaxFee, _checker, __FILE__, __LINE__);
	BYTE altPaysystemByte; _parser0.parseBYTE(altPaysystemByte);
	AtfValidator::validateInt(_descr, "altPaysystemByte", altPaysystemByte, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierPredefinedButtonsBody
//=================================================================

CashierServer::cli::CashierPredefinedButtonsBody::CashierPredefinedButtonsBody()
{
	clear();
}

void CashierServer::cli::CashierPredefinedButtonsBody::clear()
{
	roundedValidSuggestedAmounts.clear();
	selectedInd = 0;
}

bool CashierServer::cli::CashierPredefinedButtonsBody::equals(const CashierPredefinedButtonsBody& _o) const
{
	return roundedValidSuggestedAmounts.equals(_o.roundedValidSuggestedAmounts) &&
		selectedInd == _o.selectedInd;
}

const char *CashierServer::cli::CashierPredefinedButtonsBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("roundedValidSuggestedAmounts=");
	roundedValidSuggestedAmounts.toTraceString(_buf);
	_buf.append(',');
	_buf.append("selectedInd=");
	_buf.appendInt(selectedInd);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierPredefinedButtonsBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	roundedValidSuggestedAmounts.toXmlString("roundedValidSuggestedAmounts", _buf);
	Atf::XmlElement::encodeAsXmlElement("selectedInd", selectedInd, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierPredefinedButtonsBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("roundedValidSuggestedAmounts"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, roundedValidSuggestedAmounts)) return false;
		}
		else if (_element.equals("selectedInd"))
		{
			selectedInd = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierPredefinedButtonsBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierPredefinedButtonsBody())) // not empty
	{
		roundedValidSuggestedAmounts.composeMsg(_body, _ignoreJSON);
		_body.composeINT32(selectedInd);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierPredefinedButtonsBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	roundedValidSuggestedAmounts.parseMsg(_parser0);
	_parser0.parseINT32(selectedInd);
}

const char *CashierServer::cli::CashierPredefinedButtonsBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("roundedValidSuggestedAmounts", roundedValidSuggestedAmounts);
	_jsonstr.compose("selectedInd", selectedInd);
	return _buf.c_str();
}

void CashierServer::cli::CashierPredefinedButtonsBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("roundedValidSuggestedAmounts", roundedValidSuggestedAmounts);
	_jparser.parseByNameThrow("selectedInd", selectedInd);
}

/* static */ void CashierServer::cli::CashierPredefinedButtonsBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< INT32 > roundedValidSuggestedAmounts; _jparser.validateByNameThrow("roundedValidSuggestedAmounts", roundedValidSuggestedAmounts);
	AtfValidator::validateInt(_descr, "roundedValidSuggestedAmounts", roundedValidSuggestedAmounts.size(), _checker, __FILE__, __LINE__);
	INT32 selectedInd; _jparser.validateByNameThrow("selectedInd", selectedInd);
	AtfValidator::validateInt(_descr, "selectedInd", selectedInd, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierPredefinedButtonsBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szRoundedValidSuggestedAmounts = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("roundedValidSuggestedAmounts"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "roundedValidSuggestedAmounts", szRoundedValidSuggestedAmounts, _checker, __FILE__, __LINE__);
	INT32 selectedInd; _parser0.parseINT32(selectedInd);
	AtfValidator::validateInt(_descr, "selectedInd", selectedInd, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierOpenValueBody
//=================================================================

CashierServer::cli::CashierOpenValueBody::CashierOpenValueBody()
{
	clear();
}

void CashierServer::cli::CashierOpenValueBody::clear()
{
	openValue = false;
}

bool CashierServer::cli::CashierOpenValueBody::equals(const CashierOpenValueBody& _o) const
{
	return openValue == _o.openValue;
}

const char *CashierServer::cli::CashierOpenValueBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("openValue=");
	_buf.appendUint(openValue);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierOpenValueBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("openValue", openValue, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierOpenValueBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("openValue"))
		{
			openValue = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierOpenValueBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierOpenValueBody())) // not empty
	{
		_body.composeBOOL(openValue);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierOpenValueBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(openValue);
}

const char *CashierServer::cli::CashierOpenValueBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("openValue", openValue);
	return _buf.c_str();
}

void CashierServer::cli::CashierOpenValueBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("openValue", openValue);
}

/* static */ void CashierServer::cli::CashierOpenValueBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool openValue; _jparser.validateByNameThrow("openValue", openValue);
	AtfValidator::validateInt(_descr, "openValue", openValue, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierOpenValueBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool openValue; _parser0.parseBOOL(openValue);
	AtfValidator::validateInt(_descr, "openValue", openValue, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierDepositCurrencyBody
//=================================================================

CashierServer::cli::CashierDepositCurrencyBody::CashierDepositCurrencyBody()
{
	clear();
}

void CashierServer::cli::CashierDepositCurrencyBody::clear()
{
	processorCurr.clear();
	predefinedButtons.clear();
	openValue.clear();
}

bool CashierServer::cli::CashierDepositCurrencyBody::equals(const CashierDepositCurrencyBody& _o) const
{
	return Atf::atfPStringEquals(processorCurr, _o.processorCurr) &&
		predefinedButtons.equals(_o.predefinedButtons) &&
		openValue.equals(_o.openValue);
}

const char *CashierServer::cli::CashierDepositCurrencyBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("processorCurr=");
	_buf.append(processorCurr);
	_buf.append(',');
	_buf.append("predefinedButtons=");
	predefinedButtons.toTraceString(_buf);
	_buf.append(',');
	_buf.append("openValue=");
	openValue.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierDepositCurrencyBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("processorCurr", processorCurr, _buf);
	predefinedButtons.toXmlString("predefinedButtons", _buf);
	openValue.toXmlString("openValue", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierDepositCurrencyBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("processorCurr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, processorCurr)) return false;
		}
		else if (_element.equals("predefinedButtons"))
		{
			if(!Atf::AtfTempl< CashierPredefinedButtonsBody >::FromXmlString(_value, predefinedButtons)) return false;
		}
		else if (_element.equals("openValue"))
		{
			if(!Atf::AtfTempl< CashierOpenValueBody >::FromXmlString(_value, openValue)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierDepositCurrencyBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierDepositCurrencyBody())) // not empty
	{
		_body.composeString(processorCurr);
		predefinedButtons.composeMsg(_body, _ignoreJSON);
		openValue.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierDepositCurrencyBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(processorCurr);
	predefinedButtons.parseMsg(_parser0);
	openValue.parseMsg(_parser0);
}

const char *CashierServer::cli::CashierDepositCurrencyBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("processorCurr", processorCurr);
	_jsonstr.compose("predefinedButtons", predefinedButtons);
	_jsonstr.compose("openValue", openValue);
	return _buf.c_str();
}

void CashierServer::cli::CashierDepositCurrencyBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("processorCurr", processorCurr);
	_jparser.parseByNameThrow("predefinedButtons", predefinedButtons);
	_jparser.parseByNameThrow("openValue", openValue);
}

/* static */ void CashierServer::cli::CashierDepositCurrencyBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString processorCurr; _jparser.validateByNameThrow("processorCurr", processorCurr);
	AtfValidator::validateInt(_descr, "processorCurr", processorCurr.length(), _checker, __FILE__, __LINE__);
	CashierPredefinedButtonsBody predefinedButtons; _jparser.validateByNameThrow("predefinedButtons", predefinedButtons);
	CashierOpenValueBody openValue; _jparser.validateByNameThrow("openValue", openValue);
}

/*static*/ void CashierServer::cli::CashierDepositCurrencyBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "processorCurr"); size_t szProcessorCurr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "processorCurr", szProcessorCurr, _checker, __FILE__, __LINE__);
	PString _descbuf;
	CashierPredefinedButtonsBody::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("predefinedButtons"), _fieldsWithUnparsedContent);
	CashierOpenValueBody::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("openValue"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierPrepopulatedCodeBody
//=================================================================

CashierServer::cli::CashierPrepopulatedCodeBody::CashierPrepopulatedCodeBody()
{
	clear();
}

void CashierServer::cli::CashierPrepopulatedCodeBody::clear()
{
	bonusCode.clear();
}

bool CashierServer::cli::CashierPrepopulatedCodeBody::equals(const CashierPrepopulatedCodeBody& _o) const
{
	return Atf::atfPStringEquals(bonusCode, _o.bonusCode);
}

const char *CashierServer::cli::CashierPrepopulatedCodeBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierPrepopulatedCodeBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("bonusCode", bonusCode, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierPrepopulatedCodeBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("bonusCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, bonusCode)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierPrepopulatedCodeBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierPrepopulatedCodeBody())) // not empty
	{
		_body.composeString(bonusCode);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierPrepopulatedCodeBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(bonusCode);
}

const char *CashierServer::cli::CashierPrepopulatedCodeBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("bonusCode", bonusCode);
	return _buf.c_str();
}

void CashierServer::cli::CashierPrepopulatedCodeBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("bonusCode", bonusCode);
}

/* static */ void CashierServer::cli::CashierPrepopulatedCodeBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString bonusCode; _jparser.validateByNameThrow("bonusCode", bonusCode);
	AtfValidator::validateInt(_descr, "bonusCode", bonusCode.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierPrepopulatedCodeBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "bonusCode", szBonusCode, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierSubType
//=================================================================

CashierServer::cli::CashierSubType::CashierSubType()
{
	clear();
}

void CashierServer::cli::CashierSubType::clear()
{
	productId.clear();
	subTypeName.clear();
	logoImageId = 0;
	currencies.clear();
}

bool CashierServer::cli::CashierSubType::equals(const CashierSubType& _o) const
{
	return Atf::atfPStringEquals(productId, _o.productId) &&
		Atf::atfPStringEquals(subTypeName, _o.subTypeName) &&
		logoImageId == _o.logoImageId &&
		currencies.equals(_o.currencies);
}

const char *CashierServer::cli::CashierSubType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("productId=");
	_buf.append(productId);
	_buf.append(',');
	_buf.append("subTypeName=");
	_buf.append(subTypeName);
	_buf.append(',');
	_buf.append("logoImageId=");
	_buf.appendUint(logoImageId);
	_buf.append(',');
	_buf.append("currencies=");
	currencies.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierSubType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("productId", productId, _buf);
	Atf::XmlElement::encodeAsXmlElement("subTypeName", subTypeName, _buf);
	Atf::XmlElement::encodeAsXmlElement("logoImageId", logoImageId, _buf);
	currencies.toXmlString("currencies", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierSubType::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("productId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, productId)) return false;
		}
		else if (_element.equals("subTypeName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, subTypeName)) return false;
		}
		else if (_element.equals("logoImageId"))
		{
			logoImageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currencies"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, currencies)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierSubType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(productId);
	_msg.composeString(subTypeName);
	_msg.composeUINT32(logoImageId);
	currencies.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::CashierSubType::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(productId);
	_parser.parseStringP(subTypeName);
	_parser.parseUINT32(logoImageId);
	currencies.parseMsg(_parser);
}

const char *CashierServer::cli::CashierSubType::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("productId", productId);
	_jsonstr.compose("subTypeName", subTypeName);
	_jsonstr.compose("logoImageId", logoImageId);
	_jsonstr.compose("currencies", currencies);
	return _buf.c_str();
}

void CashierServer::cli::CashierSubType::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("productId", productId);
	_jparser.parseByNameThrow("subTypeName", subTypeName);
	_jparser.parseByNameThrow("logoImageId", logoImageId);
	_jparser.parseByNameThrow("currencies", currencies);
}

/* static */ void CashierServer::cli::CashierSubType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString productId; _jparser.validateByNameThrow("productId", productId);
	AtfValidator::validateInt(_descr, "productId", productId.length(), _checker, __FILE__, __LINE__);
	PString subTypeName; _jparser.validateByNameThrow("subTypeName", subTypeName);
	AtfValidator::validateInt(_descr, "subTypeName", subTypeName.length(), _checker, __FILE__, __LINE__);
	UINT32 logoImageId; _jparser.validateByNameThrow("logoImageId", logoImageId);
	AtfValidator::validateInt(_descr, "logoImageId", logoImageId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > currencies; _jparser.validateByNameThrow("currencies", currencies);
	AtfValidator::validateInt(_descr, "currencies", currencies.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierSubType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "productId"); size_t szProductId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "productId", szProductId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "subTypeName"); size_t szSubTypeName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "subTypeName", szSubTypeName, _checker, __FILE__, __LINE__);
	UINT32 logoImageId; _parser.parseUINT32(logoImageId);
	AtfValidator::validateInt(_descr, "logoImageId", logoImageId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCurrencies = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("currencies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "currencies", szCurrencies, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CashierUrlPair
//=================================================================

CashierServer::cli::CashierUrlPair::CashierUrlPair()
{
	clear();
}

void CashierServer::cli::CashierUrlPair::clear()
{
	openAccountStr.clear();
	signUpLink.clear();
	linkFlags = 0;
}

bool CashierServer::cli::CashierUrlPair::equals(const CashierUrlPair& _o) const
{
	return Atf::atfPStringEquals(openAccountStr, _o.openAccountStr) &&
		Atf::atfPStringEquals(signUpLink, _o.signUpLink) &&
		linkFlags == _o.linkFlags;
}

const char *CashierServer::cli::CashierUrlPair::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("openAccountStr=");
	_buf.append(openAccountStr);
	_buf.append(',');
	_buf.append("signUpLink=");
	_buf.append(signUpLink);
	_buf.append(',');
	_buf.append("linkFlags=");
	_buf.appendUint(linkFlags);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierUrlPair::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("openAccountStr", openAccountStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("signUpLink", signUpLink, _buf);
	Atf::XmlElement::encodeAsXmlElement("linkFlags", linkFlags, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierUrlPair::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("openAccountStr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, openAccountStr)) return false;
		}
		else if (_element.equals("signUpLink"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, signUpLink)) return false;
		}
		else if (_element.equals("linkFlags"))
		{
			linkFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierUrlPair::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(openAccountStr);
	_msg.composeString(signUpLink);
	_msg.composeUINT32(linkFlags);
}

void CashierServer::cli::CashierUrlPair::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(openAccountStr);
	_parser.parseStringP(signUpLink);
	_parser.parseUINT32(linkFlags);
}

const char *CashierServer::cli::CashierUrlPair::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("openAccountStr", openAccountStr);
	_jsonstr.compose("signUpLink", signUpLink);
	_jsonstr.compose("linkFlags", linkFlags);
	return _buf.c_str();
}

void CashierServer::cli::CashierUrlPair::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("openAccountStr", openAccountStr);
	_jparser.parseByNameThrow("signUpLink", signUpLink);
	_jparser.parseByNameThrow("linkFlags", linkFlags);
}

/* static */ void CashierServer::cli::CashierUrlPair::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString openAccountStr; _jparser.validateByNameThrow("openAccountStr", openAccountStr);
	AtfValidator::validateInt(_descr, "openAccountStr", openAccountStr.length(), _checker, __FILE__, __LINE__);
	PString signUpLink; _jparser.validateByNameThrow("signUpLink", signUpLink);
	AtfValidator::validateInt(_descr, "signUpLink", signUpLink.length(), _checker, __FILE__, __LINE__);
	UINT32 linkFlags; _jparser.validateByNameThrow("linkFlags", linkFlags);
	AtfValidator::validateInt(_descr, "linkFlags", linkFlags, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierUrlPair::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "openAccountStr"); size_t szOpenAccountStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "openAccountStr", szOpenAccountStr, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "signUpLink"); size_t szSignUpLink = strlen(_dummy);
	AtfValidator::validateInt(_descr, "signUpLink", szSignUpLink, _checker, __FILE__, __LINE__);
	UINT32 linkFlags; _parser.parseUINT32(linkFlags);
	AtfValidator::validateInt(_descr, "linkFlags", linkFlags, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CashierAgeVerifyOne
//=================================================================

CashierServer::cli::CashierAgeVerifyOne::CashierAgeVerifyOne()
{
	clear();
}

void CashierServer::cli::CashierAgeVerifyOne::clear()
{
	id_type = 0;
	id_descr.clear();
}

bool CashierServer::cli::CashierAgeVerifyOne::equals(const CashierAgeVerifyOne& _o) const
{
	return id_type == _o.id_type &&
		Atf::atfPStringEquals(id_descr, _o.id_descr);
}

const char *CashierServer::cli::CashierAgeVerifyOne::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id_type=");
	_buf.appendUint(id_type);
	_buf.append(',');
	_buf.append("id_descr=");
	_buf.append(id_descr);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierAgeVerifyOne::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id_type", id_type, _buf);
	Atf::XmlElement::encodeAsXmlElement("id_descr", id_descr, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierAgeVerifyOne::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("id_type"))
		{
			id_type = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("id_descr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, id_descr)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierAgeVerifyOne::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(id_type);
	_msg.composeString(id_descr);
}

void CashierServer::cli::CashierAgeVerifyOne::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id_type);
	_parser.parseStringP(id_descr);
}

const char *CashierServer::cli::CashierAgeVerifyOne::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id_type", id_type);
	_jsonstr.compose("id_descr", id_descr);
	return _buf.c_str();
}

void CashierServer::cli::CashierAgeVerifyOne::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id_type", id_type);
	_jparser.parseByNameThrow("id_descr", id_descr);
}

/* static */ void CashierServer::cli::CashierAgeVerifyOne::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id_type; _jparser.validateByNameThrow("id_type", id_type);
	AtfValidator::validateInt(_descr, "id_type", id_type, _checker, __FILE__, __LINE__);
	PString id_descr; _jparser.validateByNameThrow("id_descr", id_descr);
	AtfValidator::validateInt(_descr, "id_descr", id_descr.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierAgeVerifyOne::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 id_type; _parser.parseUINT32(id_type);
	AtfValidator::validateInt(_descr, "id_type", id_type, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "id_descr"); size_t szId_descr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "id_descr", szId_descr, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CashierPaysystemReply
//=================================================================

CashierServer::cli::CashierPaysystemReply::CashierPaysystemReply()
{
	clear();
}

void CashierServer::cli::CashierPaysystemReply::clear()
{
	errCode = 0;
	errDescr.clear();
	paySystemByte = 0;
	isAvailable = false;
	paysystemMessage.clear();
	subTypes.clear();
	urlPairs.clear();
	ageVerifyNeeded = false;
	ageVerifications.clear();
	ageVerifyProcessorId = 0;
	daysToClear = 0;
	availableCurrencies.clear();
	bonusWithCodeExists = false;
	validationFailuresThreshold = 0;
	selfImposedLimit = 0;
	allowedAmount = 0;
	fastDepositIsOk = false;
	isItPs4AuthUser = false;
	maxCashinDaily = 0;
	maxCashinWeekly = 0;
	maxCashinMonthly = 0;
	paysystemFeeApplies = false;
	cardNumLength = 0;
	depositAvailableCurrencies.clear();
	prepopulatedCodes.clear();
}

bool CashierServer::cli::CashierPaysystemReply::equals(const CashierPaysystemReply& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		paySystemByte == _o.paySystemByte &&
		isAvailable == _o.isAvailable &&
		Atf::atfPStringEquals(paysystemMessage, _o.paysystemMessage) &&
		subTypes.equals(_o.subTypes) &&
		urlPairs.equals(_o.urlPairs) &&
		ageVerifyNeeded == _o.ageVerifyNeeded &&
		ageVerifications.equals(_o.ageVerifications) &&
		ageVerifyProcessorId == _o.ageVerifyProcessorId &&
		daysToClear == _o.daysToClear &&
		availableCurrencies.equals(_o.availableCurrencies) &&
		bonusWithCodeExists == _o.bonusWithCodeExists &&
		validationFailuresThreshold == _o.validationFailuresThreshold &&
		selfImposedLimit == _o.selfImposedLimit &&
		allowedAmount == _o.allowedAmount &&
		fastDepositIsOk == _o.fastDepositIsOk &&
		isItPs4AuthUser == _o.isItPs4AuthUser &&
		maxCashinDaily == _o.maxCashinDaily &&
		maxCashinWeekly == _o.maxCashinWeekly &&
		maxCashinMonthly == _o.maxCashinMonthly &&
		paysystemFeeApplies == _o.paysystemFeeApplies &&
		cardNumLength == _o.cardNumLength &&
		depositAvailableCurrencies.equals(_o.depositAvailableCurrencies) &&
		prepopulatedCodes.equals(_o.prepopulatedCodes);
}

const char *CashierServer::cli::CashierPaysystemReply::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("paySystemByte=");
		_buf.appendUint(paySystemByte);
		_buf.append(',');
		_buf.append("isAvailable=");
		_buf.appendUint(isAvailable);
		_buf.append(',');
		_buf.append("paysystemMessage=");
		_buf.append(paysystemMessage);
		_buf.append(',');
		_buf.append("subTypes=");
		subTypes.toTraceString(_buf);
		_buf.append(',');
		_buf.append("urlPairs=");
		urlPairs.toTraceString(_buf);
		_buf.append(',');
		_buf.append("ageVerifyNeeded=");
		_buf.appendUint(ageVerifyNeeded);
		_buf.append(',');
		_buf.append("ageVerifications=");
		ageVerifications.toTraceString(_buf);
		_buf.append(',');
		_buf.append("ageVerifyProcessorId=");
		_buf.appendUint(ageVerifyProcessorId);
		_buf.append(',');
		_buf.append("daysToClear=");
		_buf.appendInt(daysToClear);
		_buf.append(',');
		_buf.append("availableCurrencies=");
		availableCurrencies.toTraceString(_buf);
		_buf.append(',');
		_buf.append("bonusWithCodeExists=");
		_buf.appendUint(bonusWithCodeExists);
		_buf.append(',');
		_buf.append("validationFailuresThreshold=");
		_buf.appendUint(validationFailuresThreshold);
		_buf.append(',');
		_buf.append("selfImposedLimit=");
		_buf.appendInt(selfImposedLimit);
		_buf.append(',');
		_buf.append("allowedAmount=");
		_buf.appendInt(allowedAmount);
		_buf.append(',');
		_buf.append("fastDepositIsOk=");
		_buf.appendUint(fastDepositIsOk);
		_buf.append(',');
		_buf.append("isItPs4AuthUser=");
		_buf.appendUint(isItPs4AuthUser);
		_buf.append(',');
		_buf.append("maxCashinDaily=");
		_buf.appendInt(maxCashinDaily);
		_buf.append(',');
		_buf.append("maxCashinWeekly=");
		_buf.appendInt(maxCashinWeekly);
		_buf.append(',');
		_buf.append("maxCashinMonthly=");
		_buf.appendInt(maxCashinMonthly);
		_buf.append(',');
		_buf.append("paysystemFeeApplies=");
		_buf.appendUint(paysystemFeeApplies);
		_buf.append(',');
		_buf.append("cardNumLength=");
		_buf.appendInt(cardNumLength);
		_buf.append(',');
		_buf.append("depositAvailableCurrencies=");
		depositAvailableCurrencies.toTraceString(_buf);
		_buf.append(',');
		_buf.append(',');
		_buf.append("prepopulatedCodes=");
		prepopulatedCodes.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierPaysystemReply::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
		Atf::XmlElement::encodeAsXmlElement("isAvailable", isAvailable, _buf);
		Atf::XmlElement::encodeAsXmlElement("paysystemMessage", paysystemMessage, _buf);
		subTypes.toXmlString("subTypes", _buf);
		urlPairs.toXmlString("urlPairs", _buf);
		Atf::XmlElement::encodeAsXmlElement("ageVerifyNeeded", ageVerifyNeeded, _buf);
		ageVerifications.toXmlString("ageVerifications", _buf);
		Atf::XmlElement::encodeAsXmlElement("ageVerifyProcessorId", ageVerifyProcessorId, _buf);
		Atf::XmlElement::encodeAsXmlElement("daysToClear", daysToClear, _buf);
		availableCurrencies.toXmlString("availableCurrencies", _buf);
		Atf::XmlElement::encodeAsXmlElement("bonusWithCodeExists", bonusWithCodeExists, _buf);
		Atf::XmlElement::encodeAsXmlElement("validationFailuresThreshold", validationFailuresThreshold, _buf);
		Atf::XmlElement::encodeAsXmlElement("selfImposedLimit", selfImposedLimit, _buf);
		Atf::XmlElement::encodeAsXmlElement("allowedAmount", allowedAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("fastDepositIsOk", fastDepositIsOk, _buf);
		Atf::XmlElement::encodeAsXmlElement("isItPs4AuthUser", isItPs4AuthUser, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxCashinDaily", maxCashinDaily, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxCashinWeekly", maxCashinWeekly, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxCashinMonthly", maxCashinMonthly, _buf);
		Atf::XmlElement::encodeAsXmlElement("paysystemFeeApplies", paysystemFeeApplies, _buf);
		Atf::XmlElement::encodeAsXmlElement("cardNumLength", cardNumLength, _buf);
		depositAvailableCurrencies.toXmlString("depositAvailableCurrencies", _buf);
		prepopulatedCodes.toXmlString("prepopulatedCodes", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierPaysystemReply::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("errCode"))
		{
			errCode = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errDescr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
		}
		else if (_element.equals("paySystemByte"))
		{
			paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isAvailable"))
		{
			isAvailable = (*_value.ptr() == '1');
		}
		else if (_element.equals("paysystemMessage"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, paysystemMessage)) return false;
		}
		else if (_element.equals("subTypes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CashierSubType, 4 > >::FromXmlString(_value, subTypes)) return false;
		}
		else if (_element.equals("urlPairs"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CashierUrlPair, 4 > >::FromXmlString(_value, urlPairs)) return false;
		}
		else if (_element.equals("ageVerifyNeeded"))
		{
			ageVerifyNeeded = (*_value.ptr() == '1');
		}
		else if (_element.equals("ageVerifications"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CashierAgeVerifyOne, 4 > >::FromXmlString(_value, ageVerifications)) return false;
		}
		else if (_element.equals("ageVerifyProcessorId"))
		{
			ageVerifyProcessorId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("daysToClear"))
		{
			daysToClear = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("availableCurrencies"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CashierAvailableCurrency, 4 > >::FromXmlString(_value, availableCurrencies)) return false;
		}
		else if (_element.equals("bonusWithCodeExists"))
		{
			bonusWithCodeExists = (*_value.ptr() == '1');
		}
		else if (_element.equals("validationFailuresThreshold"))
		{
			validationFailuresThreshold = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("selfImposedLimit"))
		{
			selfImposedLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("allowedAmount"))
		{
			allowedAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fastDepositIsOk"))
		{
			fastDepositIsOk = (*_value.ptr() == '1');
		}
		else if (_element.equals("isItPs4AuthUser"))
		{
			isItPs4AuthUser = (*_value.ptr() == '1');
		}
		else if (_element.equals("maxCashinDaily"))
		{
			maxCashinDaily = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxCashinWeekly"))
		{
			maxCashinWeekly = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxCashinMonthly"))
		{
			maxCashinMonthly = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("paysystemFeeApplies"))
		{
			paysystemFeeApplies = (*_value.ptr() == '1');
		}
		else if (_element.equals("cardNumLength"))
		{
			cardNumLength = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("depositAvailableCurrencies"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CashierDepositCurrencyBody, 4 > >::FromXmlString(_value, depositAvailableCurrencies)) return false;
		}
		else if (_element.equals("prepopulatedCodes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CashierPrepopulatedCodeBody, 4 > >::FromXmlString(_value, prepopulatedCodes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierPaysystemReply::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBYTE(paySystemByte);
		_msg.composeBOOL(isAvailable);
		_msg.composeString(paysystemMessage);
		subTypes.composeMsg(_msg, _ignoreJSON);
		urlPairs.composeMsg(_msg, _ignoreJSON);
		_msg.composeBOOL(ageVerifyNeeded);
		ageVerifications.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT32(ageVerifyProcessorId);
		_msg.composeINT32(daysToClear);
		availableCurrencies.composeMsg(_msg, _ignoreJSON);
		_msg.composeBOOL(bonusWithCodeExists);
		_msg.composeUINT32(validationFailuresThreshold);
		_msg.composeINT32(selfImposedLimit);
		_msg.composeINT32(allowedAmount);
		_msg.composeBOOL(fastDepositIsOk);
		_msg.composeBOOL(isItPs4AuthUser);
		CommMsgBody _msg0;
		_msg0.composeINT32(maxCashinDaily);
		_msg0.composeINT32(maxCashinWeekly);
		_msg0.composeINT32(maxCashinMonthly);
		_msg.composeMsgBody(_msg0);
		_msg.composeBOOL(paysystemFeeApplies);
		_msg.composeINT32(cardNumLength);
		CommMsgBody _msg1;
		depositAvailableCurrencies.composeMsg(_msg1, _ignoreJSON);
		_msg.composeMsgBody(_msg1);
		CommMsgBody _msg2;
		_msg.composeMsgBody(_msg2);
		prepopulatedCodes.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::CashierPaysystemReply::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBYTE(paySystemByte);
		_parser.parseBOOL(isAvailable);
		_parser.parseStringP(paysystemMessage);
		subTypes.parseMsg(_parser);
		urlPairs.parseMsg(_parser);
		_parser.parseBOOL(ageVerifyNeeded);
		ageVerifications.parseMsg(_parser);
		_parser.parseUINT32(ageVerifyProcessorId);
		_parser.parseINT32(daysToClear);
		availableCurrencies.parseMsg(_parser);
		_parser.parseBOOL(bonusWithCodeExists);
		_parser.parseUINT32(validationFailuresThreshold);
		_parser.parseINT32(selfImposedLimit);
		_parser.parseINT32(allowedAmount);
		_parser.parseBOOL(fastDepositIsOk);
		_parser.parseBOOL(isItPs4AuthUser);
		parseAnonymousMsgBody0(_parser);
		_parser.parseBOOL(paysystemFeeApplies);
		_parser.parseINT32(cardNumLength);
		parseAnonymousMsgBody1(_parser);
		parseAnonymousMsgBody2(_parser);
		prepopulatedCodes.parseMsg(_parser);
	}
}

const char *CashierServer::cli::CashierPaysystemReply::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("paySystemByte", paySystemByte);
		_jsonstr.compose("isAvailable", isAvailable);
		_jsonstr.compose("paysystemMessage", paysystemMessage);
		_jsonstr.compose("subTypes", subTypes);
		_jsonstr.compose("urlPairs", urlPairs);
		_jsonstr.compose("ageVerifyNeeded", ageVerifyNeeded);
		_jsonstr.compose("ageVerifications", ageVerifications);
		_jsonstr.compose("ageVerifyProcessorId", ageVerifyProcessorId);
		_jsonstr.compose("daysToClear", daysToClear);
		_jsonstr.compose("availableCurrencies", availableCurrencies);
		_jsonstr.compose("bonusWithCodeExists", bonusWithCodeExists);
		_jsonstr.compose("validationFailuresThreshold", validationFailuresThreshold);
		_jsonstr.compose("selfImposedLimit", selfImposedLimit);
		_jsonstr.compose("allowedAmount", allowedAmount);
		_jsonstr.compose("fastDepositIsOk", fastDepositIsOk);
		_jsonstr.compose("isItPs4AuthUser", isItPs4AuthUser);
		_jsonstr.compose("maxCashinDaily", maxCashinDaily);
		_jsonstr.compose("maxCashinWeekly", maxCashinWeekly);
		_jsonstr.compose("maxCashinMonthly", maxCashinMonthly);
		_jsonstr.compose("paysystemFeeApplies", paysystemFeeApplies);
		_jsonstr.compose("cardNumLength", cardNumLength);
		_jsonstr.compose("depositAvailableCurrencies", depositAvailableCurrencies);
		_jsonstr.compose("prepopulatedCodes", prepopulatedCodes);
	}
	return _buf.c_str();
}

void CashierServer::cli::CashierPaysystemReply::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("paySystemByte", paySystemByte);
		_jparser.parseByNameThrow("isAvailable", isAvailable);
		_jparser.parseByNameThrow("paysystemMessage", paysystemMessage);
		_jparser.parseByNameThrow("subTypes", subTypes);
		_jparser.parseByNameThrow("urlPairs", urlPairs);
		_jparser.parseByNameThrow("ageVerifyNeeded", ageVerifyNeeded);
		_jparser.parseByNameThrow("ageVerifications", ageVerifications);
		_jparser.parseByNameThrow("ageVerifyProcessorId", ageVerifyProcessorId);
		_jparser.parseByNameThrow("daysToClear", daysToClear);
		_jparser.parseByNameThrow("availableCurrencies", availableCurrencies);
		_jparser.parseByNameThrow("bonusWithCodeExists", bonusWithCodeExists);
		_jparser.parseByNameThrow("validationFailuresThreshold", validationFailuresThreshold);
		_jparser.parseByNameThrow("selfImposedLimit", selfImposedLimit);
		_jparser.parseByNameThrow("allowedAmount", allowedAmount);
		_jparser.parseByNameThrow("fastDepositIsOk", fastDepositIsOk);
		_jparser.parseByNameThrow("isItPs4AuthUser", isItPs4AuthUser);
		_jparser.parseByNameThrow("maxCashinDaily", maxCashinDaily);
		_jparser.parseByNameThrow("maxCashinWeekly", maxCashinWeekly);
		_jparser.parseByNameThrow("maxCashinMonthly", maxCashinMonthly);
		_jparser.parseByNameThrow("paysystemFeeApplies", paysystemFeeApplies);
		_jparser.parseByNameThrow("cardNumLength", cardNumLength);
		_jparser.parseByNameThrow("depositAvailableCurrencies", depositAvailableCurrencies);
		_jparser.parseByNameThrow("prepopulatedCodes", prepopulatedCodes);
	}
}

/* static */ void CashierServer::cli::CashierPaysystemReply::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
		AtfValidator::validateInt(_descr, "paySystemByte", paySystemByte, _checker, __FILE__, __LINE__);
		bool isAvailable; _jparser.validateByNameThrow("isAvailable", isAvailable);
		AtfValidator::validateInt(_descr, "isAvailable", isAvailable, _checker, __FILE__, __LINE__);
		PString paysystemMessage; _jparser.validateByNameThrow("paysystemMessage", paysystemMessage);
		AtfValidator::validateInt(_descr, "paysystemMessage", paysystemMessage.length(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< CashierSubType > subTypes; _jparser.validateByNameThrow("subTypes", subTypes);
		AtfValidator::validateInt(_descr, "subTypes", subTypes.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< CashierUrlPair > urlPairs; _jparser.validateByNameThrow("urlPairs", urlPairs);
		AtfValidator::validateInt(_descr, "urlPairs", urlPairs.size(), _checker, __FILE__, __LINE__);
		bool ageVerifyNeeded; _jparser.validateByNameThrow("ageVerifyNeeded", ageVerifyNeeded);
		AtfValidator::validateInt(_descr, "ageVerifyNeeded", ageVerifyNeeded, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< CashierAgeVerifyOne > ageVerifications; _jparser.validateByNameThrow("ageVerifications", ageVerifications);
		AtfValidator::validateInt(_descr, "ageVerifications", ageVerifications.size(), _checker, __FILE__, __LINE__);
		UINT32 ageVerifyProcessorId; _jparser.validateByNameThrow("ageVerifyProcessorId", ageVerifyProcessorId);
		AtfValidator::validateInt(_descr, "ageVerifyProcessorId", ageVerifyProcessorId, _checker, __FILE__, __LINE__);
		INT32 daysToClear; _jparser.validateByNameThrow("daysToClear", daysToClear);
		AtfValidator::validateInt(_descr, "daysToClear", daysToClear, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< CashierAvailableCurrency > availableCurrencies; _jparser.validateByNameThrow("availableCurrencies", availableCurrencies);
		AtfValidator::validateInt(_descr, "availableCurrencies", availableCurrencies.size(), _checker, __FILE__, __LINE__);
		bool bonusWithCodeExists; _jparser.validateByNameThrow("bonusWithCodeExists", bonusWithCodeExists);
		AtfValidator::validateInt(_descr, "bonusWithCodeExists", bonusWithCodeExists, _checker, __FILE__, __LINE__);
		UINT32 validationFailuresThreshold; _jparser.validateByNameThrow("validationFailuresThreshold", validationFailuresThreshold);
		AtfValidator::validateInt(_descr, "validationFailuresThreshold", validationFailuresThreshold, _checker, __FILE__, __LINE__);
		INT32 selfImposedLimit; _jparser.validateByNameThrow("selfImposedLimit", selfImposedLimit);
		AtfValidator::validateInt(_descr, "selfImposedLimit", selfImposedLimit, _checker, __FILE__, __LINE__);
		INT32 allowedAmount; _jparser.validateByNameThrow("allowedAmount", allowedAmount);
		AtfValidator::validateInt(_descr, "allowedAmount", allowedAmount, _checker, __FILE__, __LINE__);
		bool fastDepositIsOk; _jparser.validateByNameThrow("fastDepositIsOk", fastDepositIsOk);
		AtfValidator::validateInt(_descr, "fastDepositIsOk", fastDepositIsOk, _checker, __FILE__, __LINE__);
		bool isItPs4AuthUser; _jparser.validateByNameThrow("isItPs4AuthUser", isItPs4AuthUser);
		AtfValidator::validateInt(_descr, "isItPs4AuthUser", isItPs4AuthUser, _checker, __FILE__, __LINE__);
		INT32 maxCashinDaily; _jparser.validateByNameThrow("maxCashinDaily", maxCashinDaily);
		AtfValidator::validateInt(_descr, "maxCashinDaily", maxCashinDaily, _checker, __FILE__, __LINE__);
		INT32 maxCashinWeekly; _jparser.validateByNameThrow("maxCashinWeekly", maxCashinWeekly);
		AtfValidator::validateInt(_descr, "maxCashinWeekly", maxCashinWeekly, _checker, __FILE__, __LINE__);
		INT32 maxCashinMonthly; _jparser.validateByNameThrow("maxCashinMonthly", maxCashinMonthly);
		AtfValidator::validateInt(_descr, "maxCashinMonthly", maxCashinMonthly, _checker, __FILE__, __LINE__);
		bool paysystemFeeApplies; _jparser.validateByNameThrow("paysystemFeeApplies", paysystemFeeApplies);
		AtfValidator::validateInt(_descr, "paysystemFeeApplies", paysystemFeeApplies, _checker, __FILE__, __LINE__);
		INT32 cardNumLength; _jparser.validateByNameThrow("cardNumLength", cardNumLength);
		AtfValidator::validateInt(_descr, "cardNumLength", cardNumLength, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< CashierDepositCurrencyBody > depositAvailableCurrencies; _jparser.validateByNameThrow("depositAvailableCurrencies", depositAvailableCurrencies);
		AtfValidator::validateInt(_descr, "depositAvailableCurrencies", depositAvailableCurrencies.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< CashierPrepopulatedCodeBody > prepopulatedCodes; _jparser.validateByNameThrow("prepopulatedCodes", prepopulatedCodes);
		AtfValidator::validateInt(_descr, "prepopulatedCodes", prepopulatedCodes.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::CashierPaysystemReply::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
		AtfValidator::validateInt(_descr, "paySystemByte", paySystemByte, _checker, __FILE__, __LINE__);
		bool isAvailable; _parser.parseBOOL(isAvailable);
		AtfValidator::validateInt(_descr, "isAvailable", isAvailable, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "paysystemMessage"); size_t szPaysystemMessage = strlen(_dummy);
		AtfValidator::validateInt(_descr, "paysystemMessage", szPaysystemMessage, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szSubTypes = Atf::LAtfVector< CashierSubType, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("subTypes"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "subTypes", szSubTypes, _checker, __FILE__, __LINE__);
		int szUrlPairs = Atf::LAtfVector< CashierUrlPair, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("urlPairs"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "urlPairs", szUrlPairs, _checker, __FILE__, __LINE__);
		bool ageVerifyNeeded; _parser.parseBOOL(ageVerifyNeeded);
		AtfValidator::validateInt(_descr, "ageVerifyNeeded", ageVerifyNeeded, _checker, __FILE__, __LINE__);
		int szAgeVerifications = Atf::LAtfVector< CashierAgeVerifyOne, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ageVerifications"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ageVerifications", szAgeVerifications, _checker, __FILE__, __LINE__);
		UINT32 ageVerifyProcessorId; _parser.parseUINT32(ageVerifyProcessorId);
		AtfValidator::validateInt(_descr, "ageVerifyProcessorId", ageVerifyProcessorId, _checker, __FILE__, __LINE__);
		INT32 daysToClear; _parser.parseINT32(daysToClear);
		AtfValidator::validateInt(_descr, "daysToClear", daysToClear, _checker, __FILE__, __LINE__);
		int szAvailableCurrencies = Atf::LAtfVector< CashierAvailableCurrency, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("availableCurrencies"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "availableCurrencies", szAvailableCurrencies, _checker, __FILE__, __LINE__);
		bool bonusWithCodeExists; _parser.parseBOOL(bonusWithCodeExists);
		AtfValidator::validateInt(_descr, "bonusWithCodeExists", bonusWithCodeExists, _checker, __FILE__, __LINE__);
		UINT32 validationFailuresThreshold; _parser.parseUINT32(validationFailuresThreshold);
		AtfValidator::validateInt(_descr, "validationFailuresThreshold", validationFailuresThreshold, _checker, __FILE__, __LINE__);
		INT32 selfImposedLimit; _parser.parseINT32(selfImposedLimit);
		AtfValidator::validateInt(_descr, "selfImposedLimit", selfImposedLimit, _checker, __FILE__, __LINE__);
		INT32 allowedAmount; _parser.parseINT32(allowedAmount);
		AtfValidator::validateInt(_descr, "allowedAmount", allowedAmount, _checker, __FILE__, __LINE__);
		bool fastDepositIsOk; _parser.parseBOOL(fastDepositIsOk);
		AtfValidator::validateInt(_descr, "fastDepositIsOk", fastDepositIsOk, _checker, __FILE__, __LINE__);
		bool isItPs4AuthUser; _parser.parseBOOL(isItPs4AuthUser);
		AtfValidator::validateInt(_descr, "isItPs4AuthUser", isItPs4AuthUser, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		bool paysystemFeeApplies; _parser.parseBOOL(paysystemFeeApplies);
		AtfValidator::validateInt(_descr, "paysystemFeeApplies", paysystemFeeApplies, _checker, __FILE__, __LINE__);
		INT32 cardNumLength; _parser.parseINT32(cardNumLength);
		AtfValidator::validateInt(_descr, "cardNumLength", cardNumLength, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		validateAnonymousMsgBody2(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		int szPrepopulatedCodes = Atf::LAtfVector< CashierPrepopulatedCodeBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prepopulatedCodes"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "prepopulatedCodes", szPrepopulatedCodes, _checker, __FILE__, __LINE__);
	}
}

void CashierServer::cli::CashierPaysystemReply::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(maxCashinDaily);
	_parser0.parseINT32(maxCashinWeekly);
	_parser0.parseINT32(maxCashinMonthly);
}

/*static*/ void CashierServer::cli::CashierPaysystemReply::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 maxCashinDaily; _parser0.parseINT32(maxCashinDaily);
	AtfValidator::validateInt(_descr, "maxCashinDaily", maxCashinDaily, _checker, __FILE__, __LINE__);
	INT32 maxCashinWeekly; _parser0.parseINT32(maxCashinWeekly);
	AtfValidator::validateInt(_descr, "maxCashinWeekly", maxCashinWeekly, _checker, __FILE__, __LINE__);
	INT32 maxCashinMonthly; _parser0.parseINT32(maxCashinMonthly);
	AtfValidator::validateInt(_descr, "maxCashinMonthly", maxCashinMonthly, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::CashierPaysystemReply::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	depositAvailableCurrencies.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::CashierPaysystemReply::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szDepositAvailableCurrencies = Atf::LAtfVector< CashierDepositCurrencyBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("depositAvailableCurrencies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "depositAvailableCurrencies", szDepositAvailableCurrencies, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::CashierPaysystemReply::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
}

/*static*/ void CashierServer::cli::CashierPaysystemReply::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::clear()
{
	reply.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::equals(const Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY& _o) const
{
	return reply.equals(_o.reply);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CHECK_PAYSYSTEM_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHECK_PAYSYSTEM_REPLY).append(")");
	_buf.append(',');
	_buf.append("reply=");
	reply.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CHECK_PAYSYSTEM_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	reply.toXmlString("reply", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reply"))
			{
				if(!Atf::AtfTempl< CashierPaysystemReply >::FromXmlString(_value, reply)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	reply.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::parseMsg(CommMsgParser& _parser)
{
	reply.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reply", reply);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reply", reply);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PAYSYSTEM_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	CashierPaysystemReply reply; _jparser.validateByNameThrow("reply", reply);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PAYSYSTEM_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	CashierPaysystemReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    FastDepositDataBody
//=================================================================

CashierServer::cli::FastDepositDataBody::FastDepositDataBody()
{
	clear();
}

void CashierServer::cli::FastDepositDataBody::clear()
{
	currency.clear();
	amount = 0;
}

bool CashierServer::cli::FastDepositDataBody::equals(const FastDepositDataBody& _o) const
{
	return Atf::atfPStringEquals(currency, _o.currency) &&
		amount == _o.amount;
}

const char *CashierServer::cli::FastDepositDataBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::FastDepositDataBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::FastDepositDataBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("amount"))
		{
			amount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::FastDepositDataBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FastDepositDataBody())) // not empty
	{
		_body.composeString(currency);
		_body.composeINT32(amount);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::FastDepositDataBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(currency);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(amount);
}

const char *CashierServer::cli::FastDepositDataBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("amount", amount);
	return _buf.c_str();
}

void CashierServer::cli::FastDepositDataBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("currency", currency);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("amount", amount);
}

/* static */ void CashierServer::cli::FastDepositDataBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), 8, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::FastDepositDataBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 8, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 amount; _parser0.parseINT32(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::clear()
{
	paySystemByte = 0;
	requestCurrency.clear();
	cardInfoId = 0;
	fastDepositData.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::equals(const Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		Atf::atfPStringEquals(requestCurrency, _o.requestCurrency) &&
		cardInfoId == _o.cardInfoId &&
		fastDepositData.equals(_o.fastDepositData);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CHECK_PAYSYSTEM2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHECK_PAYSYSTEM2).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("requestCurrency=");
	_buf.append(requestCurrency);
	_buf.append(',');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	_buf.append(',');
	_buf.append("fastDepositData=");
	fastDepositData.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CHECK_PAYSYSTEM2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("requestCurrency", requestCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardInfoId", cardInfoId, _buf);
	fastDepositData.toXmlString("fastDepositData", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("requestCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, requestCurrency)) return false;
			}
			else if (_element.equals("cardInfoId"))
			{
				cardInfoId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fastDepositData"))
			{
				if(!Atf::AtfTempl< FastDepositDataBody >::FromXmlString(_value, fastDepositData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeString(requestCurrency);
	_msg.composeUINT32(cardInfoId);
	fastDepositData.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseStringP(requestCurrency);
	_parser.parseUINT32(cardInfoId);
	if(_parser.parseEnded()) return;
	fastDepositData.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemByte", paySystemByte);
	_jsonstr.compose("requestCurrency", requestCurrency);
	_jsonstr.compose("cardInfoId", cardInfoId);
	_jsonstr.compose("fastDepositData", fastDepositData);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
	_jparser.parseByNameThrow("requestCurrency", requestCurrency);
	_jparser.parseByNameThrow("cardInfoId", cardInfoId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("fastDepositData", fastDepositData);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PAYSYSTEM2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	PString requestCurrency; _jparser.validateByNameThrow("requestCurrency", requestCurrency);
	AtfValidator::validateIntMax(_descr, "requestCurrency", requestCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _jparser.validateByNameThrow("cardInfoId", cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	FastDepositDataBody fastDepositData; _jparser.validateByNameThrow("fastDepositData", fastDepositData);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PAYSYSTEM2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "requestCurrency"); size_t szRequestCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "requestCurrency", szRequestCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	FastDepositDataBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("fastDepositData"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::clear()
{
	reply.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::equals(const Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY& _o) const
{
	return reply.equals(_o.reply);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY).append(")");
	_buf.append(',');
	_buf.append("reply=");
	reply.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	reply.toXmlString("reply", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reply"))
			{
				if(!Atf::AtfTempl< CashierPaysystemReply >::FromXmlString(_value, reply)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	reply.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::parseMsg(CommMsgParser& _parser)
{
	reply.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reply", reply);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reply", reply);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	CashierPaysystemReply reply; _jparser.validateByNameThrow("reply", reply);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	CashierPaysystemReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_HOSTED
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::Protocol_MSG_CASHIER_CASHIN_HOSTED()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::clear()
{
	userId.clear();
	amount = 0;
	currency.clear();
	converted = 0;
	paySystemByte = 0;
	productId.clear();
	bonusId = 0;
	bonusCode.clear();
	doNotCancelCashouts = 0;
	balanceCurrency.clear();
	clientBalance = 0;
	cardNum.clear();
	saveCardInfoRequested = false;
	fastDepositTransaction = false;
	saveInfoForFastDeposit = false;
	cardInfoId = 0;
	awardId = 0;
	clientDepositFlags = 0;
	encryptedCardNum.clear();
	paymentSpecificDataVec.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::equals(const Protocol_MSG_CASHIER_CASHIN_HOSTED& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		amount == _o.amount &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		converted == _o.converted &&
		paySystemByte == _o.paySystemByte &&
		Atf::atfPStringEquals(productId, _o.productId) &&
		bonusId == _o.bonusId &&
		Atf::atfPStringEquals(bonusCode, _o.bonusCode) &&
		doNotCancelCashouts == _o.doNotCancelCashouts &&
		Atf::atfPStringEquals(balanceCurrency, _o.balanceCurrency) &&
		clientBalance == _o.clientBalance &&
		Atf::atfPStringEquals(cardNum, _o.cardNum) &&
		saveCardInfoRequested == _o.saveCardInfoRequested &&
		fastDepositTransaction == _o.fastDepositTransaction &&
		saveInfoForFastDeposit == _o.saveInfoForFastDeposit &&
		cardInfoId == _o.cardInfoId &&
		awardId == _o.awardId &&
		clientDepositFlags == _o.clientDepositFlags &&
		encryptedCardNum.size() == _o.encryptedCardNum.size() && memcmp(encryptedCardNum.ptr(), _o.encryptedCardNum.ptr(), encryptedCardNum.size()) == 0 &&
		paymentSpecificDataVec.equals(_o.paymentSpecificDataVec);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CASHIN_HOSTED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CASHIN_HOSTED*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_HOSTED).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("converted=");
	_buf.appendInt(converted);
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("productId=");
	_buf.append(productId);
	_buf.append(',');
	_buf.append("bonusId=");
	_buf.appendUint(bonusId);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("doNotCancelCashouts=");
	_buf.appendUint(doNotCancelCashouts);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	_buf.append(',');
	_buf.append("clientBalance=");
	_buf.appendInt(clientBalance);
	_buf.append(',');
	_buf.append("cardNum=");
	_buf.append(cardNum);
	_buf.append(',');
	_buf.append("saveCardInfoRequested=");
	_buf.appendUint(saveCardInfoRequested);
	_buf.append(',');
	_buf.append("fastDepositTransaction=");
	_buf.appendUint(fastDepositTransaction);
	_buf.append(',');
	_buf.append("saveInfoForFastDeposit=");
	_buf.appendUint(saveInfoForFastDeposit);
	_buf.append(',');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	_buf.append(',');
	_buf.append("awardId=");
	_buf.appendUint(awardId);
	_buf.append(',');
	_buf.append("clientDepositFlags=");
	_buf.appendUint(clientDepositFlags);
	_buf.append(',');
	_buf.append("encryptedCardNum=");
	Atf::AtfTempl<PBlock>::ToTraceString(_buf, encryptedCardNum);
	_buf.append(',');
	_buf.append("paymentSpecificDataVec=");
	paymentSpecificDataVec.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CASHIN_HOSTED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("converted", converted, _buf);
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("productId", productId, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusId", bonusId, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusCode", bonusCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("doNotCancelCashouts", doNotCancelCashouts, _buf);
	Atf::XmlElement::encodeAsXmlElement("balanceCurrency", balanceCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientBalance", clientBalance, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardNum", cardNum, _buf);
	Atf::XmlElement::encodeAsXmlElement("saveCardInfoRequested", saveCardInfoRequested, _buf);
	Atf::XmlElement::encodeAsXmlElement("fastDepositTransaction", fastDepositTransaction, _buf);
	Atf::XmlElement::encodeAsXmlElement("saveInfoForFastDeposit", saveInfoForFastDeposit, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardInfoId", cardInfoId, _buf);
	Atf::XmlElement::encodeAsXmlElement("awardId", awardId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientDepositFlags", clientDepositFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("encryptedCardNum", encryptedCardNum, _buf);
	paymentSpecificDataVec.toXmlString("paymentSpecificDataVec", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("amount"))
			{
				amount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("converted"))
			{
				converted = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("productId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, productId)) return false;
			}
			else if (_element.equals("bonusId"))
			{
				bonusId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bonusCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bonusCode)) return false;
			}
			else if (_element.equals("doNotCancelCashouts"))
			{
				doNotCancelCashouts = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("balanceCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, balanceCurrency)) return false;
			}
			else if (_element.equals("clientBalance"))
			{
				clientBalance = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cardNum"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, cardNum)) return false;
			}
			else if (_element.equals("saveCardInfoRequested"))
			{
				saveCardInfoRequested = (*_value.ptr() == '1');
			}
			else if (_element.equals("fastDepositTransaction"))
			{
				fastDepositTransaction = (*_value.ptr() == '1');
			}
			else if (_element.equals("saveInfoForFastDeposit"))
			{
				saveInfoForFastDeposit = (*_value.ptr() == '1');
			}
			else if (_element.equals("cardInfoId"))
			{
				cardInfoId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("awardId"))
			{
				awardId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientDepositFlags"))
			{
				clientDepositFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("encryptedCardNum"))
			{
				Atf::XmlElement::_movePBlockWithNullStrip(_value, encryptedCardNum);
			}
			else if (_element.equals("paymentSpecificDataVec"))
			{
				if(!Atf::AtfTempl< PaymentSpecificDataVec >::FromXmlString(_value, paymentSpecificDataVec)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeINT32(amount);
	_msg.composeString(currency);
	_msg.composeINT32(converted);
	_msg.composeBYTE(paySystemByte);
	_msg.composeString(productId);
	_msg.composeUINT32(bonusId);
	_msg.composeString(bonusCode);
	_msg.composeBYTE(doNotCancelCashouts);
	_msg.composeString(balanceCurrency);
	_msg.composeINT32(clientBalance);
	_msg.composeString(cardNum);
	_msg.composeBOOL(saveCardInfoRequested);
	_msg.composeBOOL(fastDepositTransaction);
	_msg.composeBOOL(saveInfoForFastDeposit);
	_msg.composeUINT32(cardInfoId);
	_msg.composeUINT32(awardId);
	_msg.composeUINT32(clientDepositFlags);
	_msg._composeVarBlock(encryptedCardNum.ptr(), encryptedCardNum.size());
	paymentSpecificDataVec.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(amount);
	_parser.parseStringP(currency);
	_parser.parseINT32(converted);
	_parser.parseBYTE(paySystemByte);
	_parser.parseStringP(productId);
	_parser.parseUINT32(bonusId);
	_parser.parseStringP(bonusCode);
	_parser.parseBYTE(doNotCancelCashouts);
	_parser.parseStringP(balanceCurrency);
	_parser.parseINT32(clientBalance);
	_parser.parseStringP(cardNum);
	_parser.parseBOOL(saveCardInfoRequested);
	_parser.parseBOOL(fastDepositTransaction);
	_parser.parseBOOL(saveInfoForFastDeposit);
	_parser.parseUINT32(cardInfoId);
	_parser.parseUINT32(awardId);
	_parser.parseUINT32(clientDepositFlags);
	if(_parser.parseEnded()) return;
	_parser.parsePBlock(encryptedCardNum);
	if(_parser.parseEnded()) return;
	paymentSpecificDataVec.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("converted", converted);
	_jsonstr.compose("paySystemByte", paySystemByte);
	_jsonstr.compose("productId", productId);
	_jsonstr.compose("bonusId", bonusId);
	_jsonstr.compose("bonusCode", bonusCode);
	_jsonstr.compose("doNotCancelCashouts", doNotCancelCashouts);
	_jsonstr.compose("balanceCurrency", balanceCurrency);
	_jsonstr.compose("clientBalance", clientBalance);
	_jsonstr.compose("cardNum", cardNum);
	_jsonstr.compose("saveCardInfoRequested", saveCardInfoRequested);
	_jsonstr.compose("fastDepositTransaction", fastDepositTransaction);
	_jsonstr.compose("saveInfoForFastDeposit", saveInfoForFastDeposit);
	_jsonstr.compose("cardInfoId", cardInfoId);
	_jsonstr.compose("awardId", awardId);
	_jsonstr.compose("clientDepositFlags", clientDepositFlags);
	_jsonstr.compose("encryptedCardNum", encryptedCardNum);
	_jsonstr.compose("paymentSpecificDataVec", paymentSpecificDataVec);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("converted", converted);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
	_jparser.parseByNameThrow("productId", productId);
	_jparser.parseByNameThrow("bonusId", bonusId);
	_jparser.parseByNameThrow("bonusCode", bonusCode);
	_jparser.parseByNameThrow("doNotCancelCashouts", doNotCancelCashouts);
	_jparser.parseByNameThrow("balanceCurrency", balanceCurrency);
	_jparser.parseByNameThrow("clientBalance", clientBalance);
	_jparser.parseByNameThrow("cardNum", cardNum);
	_jparser.parseByNameThrow("saveCardInfoRequested", saveCardInfoRequested);
	_jparser.parseByNameThrow("fastDepositTransaction", fastDepositTransaction);
	_jparser.parseByNameThrow("saveInfoForFastDeposit", saveInfoForFastDeposit);
	_jparser.parseByNameThrow("cardInfoId", cardInfoId);
	_jparser.parseByNameThrow("awardId", awardId);
	_jparser.parseByNameThrow("clientDepositFlags", clientDepositFlags);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("encryptedCardNum", encryptedCardNum);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("paymentSpecificDataVec", paymentSpecificDataVec);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_HOSTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 converted; _jparser.validateByNameThrow("converted", converted);
	AtfValidator::validateIntRange(_descr, "converted", converted, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	PString productId; _jparser.validateByNameThrow("productId", productId);
	AtfValidator::validateIntMax(_descr, "productId", productId.length(), PRODUCT_ID_LEN, _checker, __FILE__, __LINE__);
	UINT32 bonusId; _jparser.validateByNameThrow("bonusId", bonusId);
	AtfValidator::validateInt(_descr, "bonusId", bonusId, _checker, __FILE__, __LINE__);
	PString bonusCode; _jparser.validateByNameThrow("bonusCode", bonusCode);
	AtfValidator::validateIntMax(_descr, "bonusCode", bonusCode.length(), BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	BYTE doNotCancelCashouts; _jparser.validateByNameThrow("doNotCancelCashouts", doNotCancelCashouts);
	AtfValidator::validateInt(_descr, "doNotCancelCashouts", doNotCancelCashouts, _checker, __FILE__, __LINE__);
	PString balanceCurrency; _jparser.validateByNameThrow("balanceCurrency", balanceCurrency);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", balanceCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 clientBalance; _jparser.validateByNameThrow("clientBalance", clientBalance);
	AtfValidator::validateIntRange(_descr, "clientBalance", clientBalance, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString cardNum; _jparser.validateByNameThrow("cardNum", cardNum);
	AtfValidator::validateIntMax(_descr, "cardNum", cardNum.length(), CARDNUM_LEN, _checker, __FILE__, __LINE__);
	bool saveCardInfoRequested; _jparser.validateByNameThrow("saveCardInfoRequested", saveCardInfoRequested);
	AtfValidator::validateInt(_descr, "saveCardInfoRequested", saveCardInfoRequested, _checker, __FILE__, __LINE__);
	bool fastDepositTransaction; _jparser.validateByNameThrow("fastDepositTransaction", fastDepositTransaction);
	AtfValidator::validateInt(_descr, "fastDepositTransaction", fastDepositTransaction, _checker, __FILE__, __LINE__);
	bool saveInfoForFastDeposit; _jparser.validateByNameThrow("saveInfoForFastDeposit", saveInfoForFastDeposit);
	AtfValidator::validateInt(_descr, "saveInfoForFastDeposit", saveInfoForFastDeposit, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _jparser.validateByNameThrow("cardInfoId", cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	UINT32 awardId; _jparser.validateByNameThrow("awardId", awardId);
	AtfValidator::validateInt(_descr, "awardId", awardId, _checker, __FILE__, __LINE__);
	UINT32 clientDepositFlags; _jparser.validateByNameThrow("clientDepositFlags", clientDepositFlags);
	AtfValidator::validateIntMax(_descr, "clientDepositFlags", clientDepositFlags, ((((UINT32)eClientDepositFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PBlock encryptedCardNum; _jparser.validateByNameThrow("encryptedCardNum", encryptedCardNum);
	AtfValidator::validateIntMax(_descr, "encryptedCardNum", encryptedCardNum.size(), 4000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PaymentSpecificDataVec paymentSpecificDataVec; _jparser.validateByNameThrow("paymentSpecificDataVec", paymentSpecificDataVec);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_HOSTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 converted; _parser.parseINT32(converted);
	AtfValidator::validateIntRange(_descr, "converted", converted, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "productId"); size_t szProductId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "productId", szProductId, PRODUCT_ID_LEN, _checker, __FILE__, __LINE__);
	UINT32 bonusId; _parser.parseUINT32(bonusId);
	AtfValidator::validateInt(_descr, "bonusId", bonusId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	BYTE doNotCancelCashouts; _parser.parseBYTE(doNotCancelCashouts);
	AtfValidator::validateInt(_descr, "doNotCancelCashouts", doNotCancelCashouts, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", szBalanceCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 clientBalance; _parser.parseINT32(clientBalance);
	AtfValidator::validateIntRange(_descr, "clientBalance", clientBalance, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cardNum"); size_t szCardNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cardNum", szCardNum, CARDNUM_LEN, _checker, __FILE__, __LINE__);
	bool saveCardInfoRequested; _parser.parseBOOL(saveCardInfoRequested);
	AtfValidator::validateInt(_descr, "saveCardInfoRequested", saveCardInfoRequested, _checker, __FILE__, __LINE__);
	bool fastDepositTransaction; _parser.parseBOOL(fastDepositTransaction);
	AtfValidator::validateInt(_descr, "fastDepositTransaction", fastDepositTransaction, _checker, __FILE__, __LINE__);
	bool saveInfoForFastDeposit; _parser.parseBOOL(saveInfoForFastDeposit);
	AtfValidator::validateInt(_descr, "saveInfoForFastDeposit", saveInfoForFastDeposit, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	UINT32 awardId; _parser.parseUINT32(awardId);
	AtfValidator::validateInt(_descr, "awardId", awardId, _checker, __FILE__, __LINE__);
	UINT32 clientDepositFlags; _parser.parseUINT32(clientDepositFlags);
	AtfValidator::validateIntMax(_descr, "clientDepositFlags", clientDepositFlags, ((((UINT32)eClientDepositFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	const BYTE* encryptedCardNum; size_t szEncryptedCardNum; _parser._parseVarBlock(encryptedCardNum, szEncryptedCardNum);  /*encryptedCardNum*/
	AtfValidator::validateIntMax(_descr, "encryptedCardNum", szEncryptedCardNum, 4000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	PaymentSpecificDataVec::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("paymentSpecificDataVec"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::clear()
{
	errCode = 0;
	errDescr.clear();
	formMethod.clear();
	formAction.clear();
	transId = 0;
	xTransStr.clear();
	cardTypeByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::equals(const Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(formMethod, _o.formMethod) &&
		Atf::atfPStringEquals(formAction, _o.formAction) &&
		transId == _o.transId &&
		Atf::atfPStringEquals(xTransStr, _o.xTransStr) &&
		cardTypeByte == _o.cardTypeByte;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CASHIN_HOSTED_REDIRECT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_HOSTED_REDIRECT).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("formMethod=");
		_buf.append(formMethod);
		_buf.append(',');
		_buf.append("formAction=");
		_buf.append(formAction);
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
		_buf.append(',');
		_buf.append("xTransStr=");
		_buf.append(xTransStr);
		_buf.append(',');
		_buf.append("cardTypeByte=");
		_buf.appendUint(cardTypeByte);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CASHIN_HOSTED_REDIRECT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("formMethod", formMethod, _buf);
		Atf::XmlElement::encodeAsXmlElement("formAction", formAction, _buf);
		Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
		Atf::XmlElement::encodeAsXmlElement("xTransStr", xTransStr, _buf);
		Atf::XmlElement::encodeAsXmlElement("cardTypeByte", cardTypeByte, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("formMethod"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, formMethod)) return false;
			}
			else if (_element.equals("formAction"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, formAction)) return false;
			}
			else if (_element.equals("transId"))
			{
				transId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("xTransStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, xTransStr)) return false;
			}
			else if (_element.equals("cardTypeByte"))
			{
				cardTypeByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(formMethod);
		_msg.composeString(formAction);
		_msg.composeUINT32(transId);
		_msg.composeString(xTransStr);
		_msg.composeBYTE(cardTypeByte);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(formMethod);
		_parser.parseStringP(formAction);
		_parser.parseUINT32(transId);
		_parser.parseStringP(xTransStr);
		_parser.parseBYTE(cardTypeByte);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("formMethod", formMethod);
		_jsonstr.compose("formAction", formAction);
		_jsonstr.compose("transId", transId);
		_jsonstr.compose("xTransStr", xTransStr);
		_jsonstr.compose("cardTypeByte", cardTypeByte);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("formMethod", formMethod);
		_jparser.parseByNameThrow("formAction", formAction);
		_jparser.parseByNameThrow("transId", transId);
		_jparser.parseByNameThrow("xTransStr", xTransStr);
		_jparser.parseByNameThrow("cardTypeByte", cardTypeByte);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_HOSTED_REDIRECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString formMethod; _jparser.validateByNameThrow("formMethod", formMethod);
		AtfValidator::validateInt(_descr, "formMethod", formMethod.length(), _checker, __FILE__, __LINE__);
		PString formAction; _jparser.validateByNameThrow("formAction", formAction);
		AtfValidator::validateInt(_descr, "formAction", formAction.length(), _checker, __FILE__, __LINE__);
		UINT32 transId; _jparser.validateByNameThrow("transId", transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		PString xTransStr; _jparser.validateByNameThrow("xTransStr", xTransStr);
		AtfValidator::validateInt(_descr, "xTransStr", xTransStr.length(), _checker, __FILE__, __LINE__);
		BYTE cardTypeByte; _jparser.validateByNameThrow("cardTypeByte", cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_HOSTED_REDIRECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "formMethod"); size_t szFormMethod = strlen(_dummy);
		AtfValidator::validateInt(_descr, "formMethod", szFormMethod, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "formAction"); size_t szFormAction = strlen(_dummy);
		AtfValidator::validateInt(_descr, "formAction", szFormAction, _checker, __FILE__, __LINE__);
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "xTransStr"); size_t szXTransStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "xTransStr", szXTransStr, _checker, __FILE__, __LINE__);
		BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_HOSTED_DONE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::Protocol_MSG_CASHIER_HOSTED_DONE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::clear()
{
	userId.clear();
	transId = 0;
	xTransStr.clear();
	isDone = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::equals(const Protocol_MSG_CASHIER_HOSTED_DONE& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		transId == _o.transId &&
		Atf::atfPStringEquals(xTransStr, _o.xTransStr) &&
		isDone == _o.isDone;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_HOSTED_DONE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_HOSTED_DONE*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_HOSTED_DONE).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("xTransStr=");
	_buf.append(xTransStr);
	_buf.append(',');
	_buf.append("isDone=");
	_buf.appendUint(isDone);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_HOSTED_DONE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
	Atf::XmlElement::encodeAsXmlElement("xTransStr", xTransStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("isDone", isDone, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("transId"))
			{
				transId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("xTransStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, xTransStr)) return false;
			}
			else if (_element.equals("isDone"))
			{
				isDone = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(transId);
	_msg.composeString(xTransStr);
	_msg.composeBOOL(isDone);
}

void CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(transId);
	_parser.parseStringP(xTransStr);
	_parser.parseBOOL(isDone);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("transId", transId);
	_jsonstr.compose("xTransStr", xTransStr);
	_jsonstr.compose("isDone", isDone);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("transId", transId);
	_jparser.parseByNameThrow("xTransStr", xTransStr);
	_jparser.parseByNameThrow("isDone", isDone);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_HOSTED_DONE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 transId; _jparser.validateByNameThrow("transId", transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	PString xTransStr; _jparser.validateByNameThrow("xTransStr", xTransStr);
	AtfValidator::validateIntMax(_descr, "xTransStr", xTransStr.length(), 1000, _checker, __FILE__, __LINE__);
	bool isDone; _jparser.validateByNameThrow("isDone", isDone);
	AtfValidator::validateInt(_descr, "isDone", isDone, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_HOSTED_DONE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 transId; _parser.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "xTransStr"); size_t szXTransStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "xTransStr", szXTransStr, 1000, _checker, __FILE__, __LINE__);
	bool isDone; _parser.parseBOOL(isDone);
	AtfValidator::validateInt(_descr, "isDone", isDone, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::clear()
{
	paysystemRejectedByte = 0;
	rejectedTransId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::equals(const Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS& _o) const
{
	return paysystemRejectedByte == _o.paysystemRejectedByte &&
		rejectedTransId == _o.rejectedTransId;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SUGGEST_PAYSYSTEMS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SUGGEST_PAYSYSTEMS).append(")");
	_buf.append(',');
	_buf.append("paysystemRejectedByte=");
	_buf.appendUint(paysystemRejectedByte);
	_buf.append(',');
	_buf.append("rejectedTransId=");
	_buf.appendUint(rejectedTransId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SUGGEST_PAYSYSTEMS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paysystemRejectedByte", paysystemRejectedByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("rejectedTransId", rejectedTransId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paysystemRejectedByte"))
			{
				paysystemRejectedByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rejectedTransId"))
			{
				rejectedTransId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paysystemRejectedByte);
	_msg.composeUINT32(rejectedTransId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paysystemRejectedByte);
	_parser.parseUINT32(rejectedTransId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paysystemRejectedByte", paysystemRejectedByte);
	_jsonstr.compose("rejectedTransId", rejectedTransId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paysystemRejectedByte", paysystemRejectedByte);
	_jparser.parseByNameThrow("rejectedTransId", rejectedTransId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SUGGEST_PAYSYSTEMS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paysystemRejectedByte; _jparser.validateByNameThrow("paysystemRejectedByte", paysystemRejectedByte);
	AtfValidator::validateIntRange(_descr, "paysystemRejectedByte", paysystemRejectedByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	UINT32 rejectedTransId; _jparser.validateByNameThrow("rejectedTransId", rejectedTransId);
	AtfValidator::validateInt(_descr, "rejectedTransId", rejectedTransId, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SUGGEST_PAYSYSTEMS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paysystemRejectedByte; _parser.parseBYTE(paysystemRejectedByte);
	AtfValidator::validateIntRange(_descr, "paysystemRejectedByte", paysystemRejectedByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	UINT32 rejectedTransId; _parser.parseUINT32(rejectedTransId);
	AtfValidator::validateInt(_descr, "rejectedTransId", rejectedTransId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierSuggestedPaysystem
//=================================================================

CashierServer::cli::CashierSuggestedPaysystem::CashierSuggestedPaysystem()
{
	clear();
}

void CashierServer::cli::CashierSuggestedPaysystem::clear()
{
	cardTypeByte = 0;
	usedDescription.clear();
}

bool CashierServer::cli::CashierSuggestedPaysystem::equals(const CashierSuggestedPaysystem& _o) const
{
	return cardTypeByte == _o.cardTypeByte &&
		Atf::atfPStringEquals(usedDescription, _o.usedDescription);
}

const char *CashierServer::cli::CashierSuggestedPaysystem::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	_buf.append(',');
	_buf.append("usedDescription=");
	_buf.append(usedDescription);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierSuggestedPaysystem::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("cardTypeByte", cardTypeByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("usedDescription", usedDescription, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierSuggestedPaysystem::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cardTypeByte"))
		{
			cardTypeByte = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("usedDescription"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, usedDescription)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierSuggestedPaysystem::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierSuggestedPaysystem())) // not empty
	{
		_body.composeBYTE(cardTypeByte);
		_body.composeString(usedDescription);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierSuggestedPaysystem::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(cardTypeByte);
	_parser0.parseStringP(usedDescription);
}

const char *CashierServer::cli::CashierSuggestedPaysystem::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cardTypeByte", cardTypeByte);
	_jsonstr.compose("usedDescription", usedDescription);
	return _buf.c_str();
}

void CashierServer::cli::CashierSuggestedPaysystem::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cardTypeByte", cardTypeByte);
	_jparser.parseByNameThrow("usedDescription", usedDescription);
}

/* static */ void CashierServer::cli::CashierSuggestedPaysystem::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE cardTypeByte; _jparser.validateByNameThrow("cardTypeByte", cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	PString usedDescription; _jparser.validateByNameThrow("usedDescription", usedDescription);
	AtfValidator::validateInt(_descr, "usedDescription", usedDescription.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierSuggestedPaysystem::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE cardTypeByte; _parser0.parseBYTE(cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "usedDescription"); size_t szUsedDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "usedDescription", szUsedDescription, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	suggestions.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::equals(const Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		suggestions.equals(_o.suggestions);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("suggestions=");
		suggestions.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		suggestions.toXmlString("suggestions", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("suggestions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierSuggestedPaysystem, 4 > >::FromXmlString(_value, suggestions)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		suggestions.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		suggestions.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("suggestions", suggestions);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("suggestions", suggestions);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CashierSuggestedPaysystem > suggestions; _jparser.validateByNameThrow("suggestions", suggestions);
		AtfValidator::validateInt(_descr, "suggestions", suggestions.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSuggestions = Atf::LAtfVector< CashierSuggestedPaysystem, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("suggestions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "suggestions", szSuggestions, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::equals(const Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierRecentDepositBody
//=================================================================

CashierServer::cli::CashierRecentDepositBody::CashierRecentDepositBody()
{
	clear();
}

void CashierServer::cli::CashierRecentDepositBody::clear()
{
	paysystemByte = 0;
	transId = 0;
	maskedCardNum.clear();
	started.setNull();
	completed.setNull();
	fxAmount = 0;
	fxCurrency.clear();
	converted = 0;
	currency.clear();
}

bool CashierServer::cli::CashierRecentDepositBody::equals(const CashierRecentDepositBody& _o) const
{
	return paysystemByte == _o.paysystemByte &&
		transId == _o.transId &&
		Atf::atfPStringEquals(maskedCardNum, _o.maskedCardNum) &&
		started.equals(_o.started) &&
		completed.equals(_o.completed) &&
		fxAmount == _o.fxAmount &&
		Atf::atfPStringEquals(fxCurrency, _o.fxCurrency) &&
		converted == _o.converted &&
		Atf::atfPStringEquals(currency, _o.currency);
}

const char *CashierServer::cli::CashierRecentDepositBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("paysystemByte=");
	_buf.appendUint(paysystemByte);
	_buf.append(',');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("maskedCardNum=");
	_buf.append(maskedCardNum);
	_buf.append(',');
	_buf.append("started=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, started);
	_buf.append(',');
	_buf.append("completed=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, completed);
	_buf.append(',');
	_buf.append("fxAmount=");
	_buf.appendInt(fxAmount);
	_buf.append(',');
	_buf.append("fxCurrency=");
	_buf.append(fxCurrency);
	_buf.append(',');
	_buf.append("converted=");
	_buf.appendInt(converted);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierRecentDepositBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("paysystemByte", paysystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
	Atf::XmlElement::encodeAsXmlElement("maskedCardNum", maskedCardNum, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "started", started);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "completed", completed);
	Atf::XmlElement::encodeAsXmlElement("fxAmount", fxAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("fxCurrency", fxCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("converted", converted, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierRecentDepositBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("paysystemByte"))
		{
			paysystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("transId"))
		{
			transId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maskedCardNum"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, maskedCardNum)) return false;
		}
		else if (_element.equals("started"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, started);
		}
		else if (_element.equals("completed"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, completed);
		}
		else if (_element.equals("fxAmount"))
		{
			fxAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fxCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, fxCurrency)) return false;
		}
		else if (_element.equals("converted"))
		{
			converted = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierRecentDepositBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierRecentDepositBody())) // not empty
	{
		_body.composeBYTE(paysystemByte);
		_body.composeUINT32(transId);
		_body.composeString(maskedCardNum);
		_body.composeSrvTime(started);
		_body.composeSrvTime(completed);
		_body.composeINT32(fxAmount);
		_body.composeString(fxCurrency);
		_body.composeINT32(converted);
		_body.composeString(currency);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierRecentDepositBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(paysystemByte);
	_parser0.parseUINT32(transId);
	_parser0.parseStringP(maskedCardNum);
	_parser0.parseSrvTime(started);
	_parser0.parseSrvTime(completed);
	_parser0.parseINT32(fxAmount);
	_parser0.parseStringP(fxCurrency);
	_parser0.parseINT32(converted);
	_parser0.parseStringP(currency);
}

const char *CashierServer::cli::CashierRecentDepositBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paysystemByte", paysystemByte);
	_jsonstr.compose("transId", transId);
	_jsonstr.compose("maskedCardNum", maskedCardNum);
	_jsonstr.compose("started", started);
	_jsonstr.compose("completed", completed);
	_jsonstr.compose("fxAmount", fxAmount);
	_jsonstr.compose("fxCurrency", fxCurrency);
	_jsonstr.compose("converted", converted);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void CashierServer::cli::CashierRecentDepositBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paysystemByte", paysystemByte);
	_jparser.parseByNameThrow("transId", transId);
	_jparser.parseByNameThrow("maskedCardNum", maskedCardNum);
	_jparser.parseByNameThrow("started", started);
	_jparser.parseByNameThrow("completed", completed);
	_jparser.parseByNameThrow("fxAmount", fxAmount);
	_jparser.parseByNameThrow("fxCurrency", fxCurrency);
	_jparser.parseByNameThrow("converted", converted);
	_jparser.parseByNameThrow("currency", currency);
}

/* static */ void CashierServer::cli::CashierRecentDepositBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paysystemByte; _jparser.validateByNameThrow("paysystemByte", paysystemByte);
	AtfValidator::validateInt(_descr, "paysystemByte", paysystemByte, _checker, __FILE__, __LINE__);
	UINT32 transId; _jparser.validateByNameThrow("transId", transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	PString maskedCardNum; _jparser.validateByNameThrow("maskedCardNum", maskedCardNum);
	AtfValidator::validateInt(_descr, "maskedCardNum", maskedCardNum.length(), _checker, __FILE__, __LINE__);
	SrvTime started; _jparser.validateByNameThrow("started", started);
	AtfValidator::validateSrvDateTime(_descr, "started", started, _checker, __FILE__, __LINE__);
	SrvTime completed; _jparser.validateByNameThrow("completed", completed);
	AtfValidator::validateSrvDateTime(_descr, "completed", completed, _checker, __FILE__, __LINE__);
	INT32 fxAmount; _jparser.validateByNameThrow("fxAmount", fxAmount);
	AtfValidator::validateInt(_descr, "fxAmount", fxAmount, _checker, __FILE__, __LINE__);
	PString fxCurrency; _jparser.validateByNameThrow("fxCurrency", fxCurrency);
	AtfValidator::validateInt(_descr, "fxCurrency", fxCurrency.length(), _checker, __FILE__, __LINE__);
	INT32 converted; _jparser.validateByNameThrow("converted", converted);
	AtfValidator::validateInt(_descr, "converted", converted, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierRecentDepositBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE paysystemByte; _parser0.parseBYTE(paysystemByte);
	AtfValidator::validateInt(_descr, "paysystemByte", paysystemByte, _checker, __FILE__, __LINE__);
	UINT32 transId; _parser0.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "maskedCardNum"); size_t szMaskedCardNum = strlen(_dummy);
	AtfValidator::validateInt(_descr, "maskedCardNum", szMaskedCardNum, _checker, __FILE__, __LINE__);
	SrvTime started; _parser0.parseSrvTime(started);
	AtfValidator::validateSrvDateTime(_descr, "started", started, _checker, __FILE__, __LINE__);
	SrvTime completed; _parser0.parseSrvTime(completed);
	AtfValidator::validateSrvDateTime(_descr, "completed", completed, _checker, __FILE__, __LINE__);
	INT32 fxAmount; _parser0.parseINT32(fxAmount);
	AtfValidator::validateInt(_descr, "fxAmount", fxAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "fxCurrency"); size_t szFxCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "fxCurrency", szFxCurrency, _checker, __FILE__, __LINE__);
	INT32 converted; _parser0.parseINT32(converted);
	AtfValidator::validateInt(_descr, "converted", converted, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	deposits.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::equals(const Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		deposits.equals(_o.deposits);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("deposits=");
		deposits.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		deposits.toXmlString("deposits", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("deposits"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierRecentDepositBody, 4 > >::FromXmlString(_value, deposits)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		deposits.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		deposits.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("deposits", deposits);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("deposits", deposits);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CashierRecentDepositBody > deposits; _jparser.validateByNameThrow("deposits", deposits);
		AtfValidator::validateInt(_descr, "deposits", deposits.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szDeposits = Atf::LAtfVector< CashierRecentDepositBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("deposits"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "deposits", szDeposits, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::equals(const Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_RESCUE_PAYSYSTEMS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_RESCUE_PAYSYSTEMS).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_RESCUE_PAYSYSTEMS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RESCUE_PAYSYSTEMS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RESCUE_PAYSYSTEMS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierRescuePaysystem
//=================================================================

CashierServer::cli::CashierRescuePaysystem::CashierRescuePaysystem()
{
	clear();
}

void CashierServer::cli::CashierRescuePaysystem::clear()
{
	paysystemByte = 0;
	flags = 0;
}

bool CashierServer::cli::CashierRescuePaysystem::equals(const CashierRescuePaysystem& _o) const
{
	return paysystemByte == _o.paysystemByte &&
		flags == _o.flags;
}

const char *CashierServer::cli::CashierRescuePaysystem::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("paysystemByte=");
	_buf.appendUint(paysystemByte);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierRescuePaysystem::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("paysystemByte", paysystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierRescuePaysystem::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("paysystemByte"))
		{
			paysystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierRescuePaysystem::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierRescuePaysystem())) // not empty
	{
		_body.composeBYTE(paysystemByte);
		_body.composeUINT32(flags);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierRescuePaysystem::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(paysystemByte);
	_parser0.parseUINT32(flags);
}

const char *CashierServer::cli::CashierRescuePaysystem::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paysystemByte", paysystemByte);
	_jsonstr.compose("flags", flags);
	return _buf.c_str();
}

void CashierServer::cli::CashierRescuePaysystem::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paysystemByte", paysystemByte);
	_jparser.parseByNameThrow("flags", flags);
}

/* static */ void CashierServer::cli::CashierRescuePaysystem::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paysystemByte; _jparser.validateByNameThrow("paysystemByte", paysystemByte);
	AtfValidator::validateInt(_descr, "paysystemByte", paysystemByte, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateIntMax(_descr, "flags", flags, ((((UINT32)eRescuePaysystemFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierRescuePaysystem::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE paysystemByte; _parser0.parseBYTE(paysystemByte);
	AtfValidator::validateInt(_descr, "paysystemByte", paysystemByte, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateIntMax(_descr, "flags", flags, ((((UINT32)eRescuePaysystemFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	paysystems.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::equals(const Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		paysystems.equals(_o.paysystems);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("paysystems=");
		paysystems.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		paysystems.toXmlString("paysystems", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("paysystems"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierRescuePaysystem, 4 > >::FromXmlString(_value, paysystems)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		paysystems.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		paysystems.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("paysystems", paysystems);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("paysystems", paysystems);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CashierRescuePaysystem > paysystems; _jparser.validateByNameThrow("paysystems", paysystems);
		AtfValidator::validateInt(_descr, "paysystems", paysystems.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szPaysystems = Atf::LAtfVector< CashierRescuePaysystem, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("paysystems"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "paysystems", szPaysystems, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VERIFY_AGE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::Protocol_MSG_CASHIER_VERIFY_AGE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::clear()
{
	clientReqId = 0;
	userId.clear();
	fullName.clear();
	gender.clear();
	dateOfBirth.setNull();
	phone.clear();
	address.clear();
	city.clear();
	zip.clear();
	county.clear();
	state.clear();
	country.clear();
	SSN4.clear();
	idType = 0;
	id.clear();
	contextAttemptNumber = 0;
	requestPurpose = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::equals(const Protocol_MSG_CASHIER_VERIFY_AGE& _o) const
{
	return clientReqId == _o.clientReqId &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(fullName, _o.fullName) &&
		Atf::atfPStringEquals(gender, _o.gender) &&
		dateOfBirth.equals(_o.dateOfBirth) &&
		Atf::atfPStringEquals(phone, _o.phone) &&
		Atf::atfPStringEquals(address, _o.address) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(zip, _o.zip) &&
		Atf::atfPStringEquals(county, _o.county) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(country, _o.country) &&
		Atf::atfPStringEquals(SSN4, _o.SSN4) &&
		idType == _o.idType &&
		Atf::atfPStringEquals(id, _o.id) &&
		contextAttemptNumber == _o.contextAttemptNumber &&
		requestPurpose == _o.requestPurpose;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_VERIFY_AGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_VERIFY_AGE*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VERIFY_AGE).append(")");
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("fullName=");
	_buf.append(fullName);
	_buf.append(',');
	_buf.append("gender=");
	_buf.append(gender);
	_buf.append(',');
	_buf.append("dateOfBirth=");
	Atf::AtfTempl<CommSrvDate>::ToTraceString(_buf, dateOfBirth);
	_buf.append(',');
	_buf.append("phone=");
	_buf.append(phone);
	_buf.append(',');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("zip=");
	_buf.append(zip);
	_buf.append(',');
	_buf.append("county=");
	_buf.append(county);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("SSN4=");
	_buf.append(SSN4);
	_buf.append(',');
	_buf.append("idType=");
	_buf.appendUint(idType);
	_buf.append(',');
	_buf.append("id=");
	_buf.append(id);
	_buf.append(',');
	_buf.append("contextAttemptNumber=");
	_buf.appendUint(contextAttemptNumber);
	_buf.append(',');
	_buf.append("requestPurpose=");
	_buf.appendUint(requestPurpose);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_VERIFY_AGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("fullName", fullName, _buf);
	Atf::XmlElement::encodeAsXmlElement("gender", gender, _buf);
	Atf::AtfTempl<CommSrvDate>::ToXmlString(_buf, "dateOfBirth", dateOfBirth);
	Atf::XmlElement::encodeAsXmlElement("phone", phone, _buf);
	Atf::XmlElement::encodeAsXmlElement("address", address, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::encodeAsXmlElement("zip", zip, _buf);
	Atf::XmlElement::encodeAsXmlElement("county", county, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("SSN4", SSN4, _buf);
	Atf::XmlElement::encodeAsXmlElement("idType", idType, _buf);
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("contextAttemptNumber", contextAttemptNumber, _buf);
	Atf::XmlElement::encodeAsXmlElement("requestPurpose", requestPurpose, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clientReqId"))
			{
				clientReqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("fullName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fullName)) return false;
			}
			else if (_element.equals("gender"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, gender)) return false;
			}
			else if (_element.equals("dateOfBirth"))
			{
				Atf::AtfTempl<CommSrvDate>::FromXmlString(_value, dateOfBirth);
			}
			else if (_element.equals("phone"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, phone)) return false;
			}
			else if (_element.equals("address"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, address)) return false;
			}
			else if (_element.equals("city"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
			}
			else if (_element.equals("zip"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, zip)) return false;
			}
			else if (_element.equals("county"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, county)) return false;
			}
			else if (_element.equals("state"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("SSN4"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, SSN4)) return false;
			}
			else if (_element.equals("idType"))
			{
				idType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("id"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, id)) return false;
			}
			else if (_element.equals("contextAttemptNumber"))
			{
				contextAttemptNumber = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("requestPurpose"))
			{
				requestPurpose = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clientReqId);
	_msg.composeString(userId);
	_msg.composeString(fullName);
	_msg.composeString(gender);
	_msg.composeSrvDate(dateOfBirth);
	_msg.composeString(phone);
	_msg.composeString(address);
	_msg.composeString(city);
	_msg.composeString(zip);
	_msg.composeString(county);
	_msg.composeString(state);
	_msg.composeString(country);
	_msg.composeString(SSN4);
	_msg.composeUINT32(idType);
	_msg.composeString(id);
	_msg.composeUINT32(contextAttemptNumber);
	_msg.composeUINT32(requestPurpose);
}

void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clientReqId);
	_parser.parseStringP(userId);
	_parser.parseStringP(fullName);
	_parser.parseStringP(gender);
	_parser.parseSrvDate(dateOfBirth);
	_parser.parseStringP(phone);
	_parser.parseStringP(address);
	_parser.parseStringP(city);
	_parser.parseStringP(zip);
	_parser.parseStringP(county);
	_parser.parseStringP(state);
	_parser.parseStringP(country);
	_parser.parseStringP(SSN4);
	_parser.parseUINT32(idType);
	_parser.parseStringP(id);
	_parser.parseUINT32(contextAttemptNumber);
	_parser.parseUINT32(requestPurpose);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clientReqId", clientReqId);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("fullName", fullName);
	_jsonstr.compose("gender", gender);
	_jsonstr.compose("dateOfBirth", dateOfBirth);
	_jsonstr.compose("phone", phone);
	_jsonstr.compose("address", address);
	_jsonstr.compose("city", city);
	_jsonstr.compose("zip", zip);
	_jsonstr.compose("county", county);
	_jsonstr.compose("state", state);
	_jsonstr.compose("country", country);
	_jsonstr.compose("SSN4", SSN4);
	_jsonstr.compose("idType", idType);
	_jsonstr.compose("id", id);
	_jsonstr.compose("contextAttemptNumber", contextAttemptNumber);
	_jsonstr.compose("requestPurpose", requestPurpose);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clientReqId", clientReqId);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("fullName", fullName);
	_jparser.parseByNameThrow("gender", gender);
	_jparser.parseByNameThrow("dateOfBirth", dateOfBirth);
	_jparser.parseByNameThrow("phone", phone);
	_jparser.parseByNameThrow("address", address);
	_jparser.parseByNameThrow("city", city);
	_jparser.parseByNameThrow("zip", zip);
	_jparser.parseByNameThrow("county", county);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("SSN4", SSN4);
	_jparser.parseByNameThrow("idType", idType);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("contextAttemptNumber", contextAttemptNumber);
	_jparser.parseByNameThrow("requestPurpose", requestPurpose);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VERIFY_AGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString fullName; _jparser.validateByNameThrow("fullName", fullName);
	AtfValidator::validateIntMax(_descr, "fullName", fullName.length(), USER_FULLNAME_LEN, _checker, __FILE__, __LINE__);
	PString gender; _jparser.validateByNameThrow("gender", gender);
	AtfValidator::validateIntMax(_descr, "gender", gender.length(), GENDER_LEN, _checker, __FILE__, __LINE__);
	CommSrvDate dateOfBirth; _jparser.validateByNameThrow("dateOfBirth", dateOfBirth);
	AtfValidator::validateSrvDateTime(_descr, "dateOfBirth", dateOfBirth, _checker, __FILE__, __LINE__);
	PString phone; _jparser.validateByNameThrow("phone", phone);
	AtfValidator::validateIntMax(_descr, "phone", phone.length(), 100, _checker, __FILE__, __LINE__);
	PString address; _jparser.validateByNameThrow("address", address);
	AtfValidator::validateIntMax(_descr, "address", address.length(), USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateIntMax(_descr, "city", city.length(), USER_CITY_LEN, _checker, __FILE__, __LINE__);
	PString zip; _jparser.validateByNameThrow("zip", zip);
	AtfValidator::validateIntMax(_descr, "zip", zip.length(), USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	PString county; _jparser.validateByNameThrow("county", county);
	AtfValidator::validateIntMax(_descr, "county", county.length(), COUNTY_LEN, _checker, __FILE__, __LINE__);
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateIntMax(_descr, "state", state.length(), USER_STATE_LEN, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	PString SSN4; _jparser.validateByNameThrow("SSN4", SSN4);
	AtfValidator::validateIntMax(_descr, "SSN4", SSN4.length(), SSN_4_LEN, _checker, __FILE__, __LINE__);
	UINT32 idType; _jparser.validateByNameThrow("idType", idType);
	AtfValidator::validateIntRange(_descr, "idType", idType, eAgeVerificationPersonalIdTypeNone, eAgeVerificationPersonalIdTypeTravelDocument, _checker, __FILE__, __LINE__);
	PString id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateIntMax(_descr, "id", id.length(), 100, _checker, __FILE__, __LINE__);
	UINT32 contextAttemptNumber; _jparser.validateByNameThrow("contextAttemptNumber", contextAttemptNumber);
	AtfValidator::validateIntMax(_descr, "contextAttemptNumber", contextAttemptNumber, 1000, _checker, __FILE__, __LINE__);
	UINT32 requestPurpose; _jparser.validateByNameThrow("requestPurpose", requestPurpose);
	{ const UINT32 requestPurpose_enum[] = { eAristotleRequestForAgeVerification, eAristotleRequestForAuthentication, eAristotleRequestForScreening }; AtfValidator::validateEnum(_descr, "requestPurpose", requestPurpose, requestPurpose_enum, _checker, __FILE__, __LINE__); }
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VERIFY_AGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "fullName"); size_t szFullName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fullName", szFullName, USER_FULLNAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "gender"); size_t szGender = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "gender", szGender, GENDER_LEN, _checker, __FILE__, __LINE__);
	CommSrvDate dateOfBirth; _parser.parseSrvDate(dateOfBirth);
	AtfValidator::validateSrvDateTime(_descr, "dateOfBirth", dateOfBirth, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phone", szPhone, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "address", szAddress, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "zip"); size_t szZip = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zip", szZip, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "county"); size_t szCounty = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "county", szCounty, COUNTY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "SSN4"); size_t szSSN4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "SSN4", szSSN4, SSN_4_LEN, _checker, __FILE__, __LINE__);
	UINT32 idType; _parser.parseUINT32(idType);
	AtfValidator::validateIntRange(_descr, "idType", idType, eAgeVerificationPersonalIdTypeNone, eAgeVerificationPersonalIdTypeTravelDocument, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "id"); size_t szId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "id", szId, 100, _checker, __FILE__, __LINE__);
	UINT32 contextAttemptNumber; _parser.parseUINT32(contextAttemptNumber);
	AtfValidator::validateIntMax(_descr, "contextAttemptNumber", contextAttemptNumber, 1000, _checker, __FILE__, __LINE__);
	UINT32 requestPurpose; _parser.parseUINT32(requestPurpose);
	{ const UINT32 requestPurpose_enum[] = { eAristotleRequestForAgeVerification, eAristotleRequestForAuthentication, eAristotleRequestForScreening }; AtfValidator::validateEnum(_descr, "requestPurpose", requestPurpose, requestPurpose_enum, _checker, __FILE__, __LINE__); }
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VERIFY_AGE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	resultId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::equals(const Protocol_MSG_CASHIER_VERIFY_AGE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		resultId == _o.resultId;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_VERIFY_AGE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_VERIFY_AGE_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VERIFY_AGE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	_buf.append(',');
	_buf.append("resultId=");
	_buf.appendUint(resultId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_VERIFY_AGE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	Atf::XmlElement::encodeAsXmlElement("resultId", resultId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("resultId"))
			{
				resultId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
	_msg.composeUINT32(resultId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
	_parser.parseUINT32(resultId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errDescr", errDescr);
	_jsonstr.compose("resultId", resultId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errDescr", errDescr);
	_jparser.parseByNameThrow("resultId", resultId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VERIFY_AGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
	AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	UINT32 resultId; _jparser.validateByNameThrow("resultId", resultId);
	AtfValidator::validateInt(_descr, "resultId", resultId, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VERIFY_AGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	UINT32 resultId; _parser.parseUINT32(resultId);
	AtfValidator::validateInt(_descr, "resultId", resultId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::clear()
{
	currency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::equals(const Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL& _o) const
{
	return Atf::atfPStringEquals(currency, _o.currency);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PAYSYSTEMS_AVAIL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL).append(")");
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(currency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(currency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currency", currency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PaysystemLimitBody
//=================================================================

CashierServer::cli::PaysystemLimitBody::PaysystemLimitBody()
{
	clear();
}

void CashierServer::cli::PaysystemLimitBody::clear()
{
	limit.clear();
}

bool CashierServer::cli::PaysystemLimitBody::equals(const PaysystemLimitBody& _o) const
{
	return limit.equals(_o.limit);
}

const char *CashierServer::cli::PaysystemLimitBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limit=");
	limit.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::PaysystemLimitBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	limit.toXmlString("limit", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::PaysystemLimitBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("limit"))
		{
			if(!Atf::AtfTempl< common_structs::PaysystemLimit >::FromXmlString(_value, limit)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::PaysystemLimitBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PaysystemLimitBody())) // not empty
	{
		limit.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::PaysystemLimitBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	limit.parseMsg(_parser0);
}

const char *CashierServer::cli::PaysystemLimitBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limit", limit);
	return _buf.c_str();
}

void CashierServer::cli::PaysystemLimitBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("limit", limit);
}

/* static */ void CashierServer::cli::PaysystemLimitBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::PaysystemLimit limit; _jparser.validateByNameThrow("limit", limit);
}

/*static*/ void CashierServer::cli::PaysystemLimitBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	common_structs::PaysystemLimit::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("limit"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	limits.clear();
	dadPreDepositAvailable = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::equals(const Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		limits.equals(_o.limits) &&
		dadPreDepositAvailable == _o.dadPreDepositAvailable;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limits=");
		limits.toTraceString(_buf);
		_buf.append(',');
		_buf.append("dadPreDepositAvailable=");
		_buf.appendUint(dadPreDepositAvailable);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		limits.toXmlString("limits", _buf);
		Atf::XmlElement::encodeAsXmlElement("dadPreDepositAvailable", dadPreDepositAvailable, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("limits"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PaysystemLimitBody, 4 > >::FromXmlString(_value, limits)) return false;
			}
			else if (_element.equals("dadPreDepositAvailable"))
			{
				dadPreDepositAvailable = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		limits.composeMsg(_msg, _ignoreJSON);
		_msg.composeBOOL(dadPreDepositAvailable);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		limits.parseMsg(_parser);
		_parser.parseBOOL(dadPreDepositAvailable);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("limits", limits);
		_jsonstr.compose("dadPreDepositAvailable", dadPreDepositAvailable);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("limits", limits);
		_jparser.parseByNameThrow("dadPreDepositAvailable", dadPreDepositAvailable);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< PaysystemLimitBody > limits; _jparser.validateByNameThrow("limits", limits);
		AtfValidator::validateInt(_descr, "limits", limits.size(), _checker, __FILE__, __LINE__);
		bool dadPreDepositAvailable; _jparser.validateByNameThrow("dadPreDepositAvailable", dadPreDepositAvailable);
		AtfValidator::validateInt(_descr, "dadPreDepositAvailable", dadPreDepositAvailable, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szLimits = Atf::LAtfVector< PaysystemLimitBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limits", szLimits, _checker, __FILE__, __LINE__);
		bool dadPreDepositAvailable; _parser.parseBOOL(dadPreDepositAvailable);
		AtfValidator::validateInt(_descr, "dadPreDepositAvailable", dadPreDepositAvailable, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::equals(const Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PAYSYSTEMS_AVAIL_PM != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL_PM).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL_PM).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL_PM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL_PM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierPaySystemLimitExBody
//=================================================================

CashierServer::cli::CashierPaySystemLimitExBody::CashierPaySystemLimitExBody()
{
	clear();
}

void CashierServer::cli::CashierPaySystemLimitExBody::clear()
{
	paySystemByte = 0;
	cashinLimit.clear();
	fastDepositIsOk = false;
	psAvailFlagToClient = 0;
}

bool CashierServer::cli::CashierPaySystemLimitExBody::equals(const CashierPaySystemLimitExBody& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		cashinLimit.equals(_o.cashinLimit) &&
		fastDepositIsOk == _o.fastDepositIsOk &&
		psAvailFlagToClient == _o.psAvailFlagToClient;
}

const char *CashierServer::cli::CashierPaySystemLimitExBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("cashinLimit=");
	cashinLimit.toTraceString(_buf);
	_buf.append(',');
	_buf.append("fastDepositIsOk=");
	_buf.appendUint(fastDepositIsOk);
	_buf.append(',');
	_buf.append("psAvailFlagToClient=");
	_buf.appendUint(psAvailFlagToClient);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierPaySystemLimitExBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	cashinLimit.toXmlString("cashinLimit", _buf);
	Atf::XmlElement::encodeAsXmlElement("fastDepositIsOk", fastDepositIsOk, _buf);
	Atf::XmlElement::encodeAsXmlElement("psAvailFlagToClient", psAvailFlagToClient, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierPaySystemLimitExBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("paySystemByte"))
		{
			paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cashinLimit"))
		{
			if(!Atf::AtfTempl< PaysystemLimitBody >::FromXmlString(_value, cashinLimit)) return false;
		}
		else if (_element.equals("fastDepositIsOk"))
		{
			fastDepositIsOk = (*_value.ptr() == '1');
		}
		else if (_element.equals("psAvailFlagToClient"))
		{
			psAvailFlagToClient = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierPaySystemLimitExBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierPaySystemLimitExBody())) // not empty
	{
		_body.composeBYTE(paySystemByte);
		cashinLimit.composeMsg(_body, _ignoreJSON);
		_body.composeBOOL(fastDepositIsOk);
		_body.composeUINT32(psAvailFlagToClient);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierPaySystemLimitExBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(paySystemByte);
	cashinLimit.parseMsg(_parser0);
	_parser0.parseBOOL(fastDepositIsOk);
	_parser0.parseUINT32(psAvailFlagToClient);
}

const char *CashierServer::cli::CashierPaySystemLimitExBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemByte", paySystemByte);
	_jsonstr.compose("cashinLimit", cashinLimit);
	_jsonstr.compose("fastDepositIsOk", fastDepositIsOk);
	_jsonstr.compose("psAvailFlagToClient", psAvailFlagToClient);
	return _buf.c_str();
}

void CashierServer::cli::CashierPaySystemLimitExBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
	_jparser.parseByNameThrow("cashinLimit", cashinLimit);
	_jparser.parseByNameThrow("fastDepositIsOk", fastDepositIsOk);
	_jparser.parseByNameThrow("psAvailFlagToClient", psAvailFlagToClient);
}

/* static */ void CashierServer::cli::CashierPaySystemLimitExBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateInt(_descr, "paySystemByte", paySystemByte, _checker, __FILE__, __LINE__);
	PaysystemLimitBody cashinLimit; _jparser.validateByNameThrow("cashinLimit", cashinLimit);
	bool fastDepositIsOk; _jparser.validateByNameThrow("fastDepositIsOk", fastDepositIsOk);
	AtfValidator::validateInt(_descr, "fastDepositIsOk", fastDepositIsOk, _checker, __FILE__, __LINE__);
	UINT32 psAvailFlagToClient; _jparser.validateByNameThrow("psAvailFlagToClient", psAvailFlagToClient);
	AtfValidator::validateInt(_descr, "psAvailFlagToClient", psAvailFlagToClient, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierPaySystemLimitExBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE paySystemByte; _parser0.parseBYTE(paySystemByte);
	AtfValidator::validateInt(_descr, "paySystemByte", paySystemByte, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PaysystemLimitBody::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("cashinLimit"), _fieldsWithUnparsedContent);
	bool fastDepositIsOk; _parser0.parseBOOL(fastDepositIsOk);
	AtfValidator::validateInt(_descr, "fastDepositIsOk", fastDepositIsOk, _checker, __FILE__, __LINE__);
	UINT32 psAvailFlagToClient; _parser0.parseUINT32(psAvailFlagToClient);
	AtfValidator::validateInt(_descr, "psAvailFlagToClient", psAvailFlagToClient, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	limits.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::equals(const Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		limits.equals(_o.limits);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limits=");
		limits.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		limits.toXmlString("limits", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("limits"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierPaySystemLimitExBody, 4 > >::FromXmlString(_value, limits)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		limits.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		limits.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("limits", limits);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("limits", limits);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CashierPaySystemLimitExBody > limits; _jparser.validateByNameThrow("limits", limits);
		AtfValidator::validateInt(_descr, "limits", limits.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szLimits = Atf::LAtfVector< CashierPaySystemLimitExBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limits", szLimits, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::clear()
{
	currency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::equals(const Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO& _o) const
{
	return Atf::atfPStringEquals(currency, _o.currency);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO).append(")");
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(currency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(currency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currency", currency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::clear()
{
	pssNum = 0;
	header.clear();
	body.clear();
	footer.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::equals(const Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY& _o) const
{
	return pssNum == _o.pssNum &&
		Atf::atfPStringEquals(header, _o.header) &&
		Atf::atfPStringEquals(body, _o.body) &&
		Atf::atfPStringEquals(footer, _o.footer);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY).append(")");
	_buf.append(',');
	_buf.append("pssNum=");
	_buf.appendUint(pssNum);
	_buf.append(',');
	_buf.append("header=");
	_buf.append(header);
	_buf.append(',');
	_buf.append("body=");
	_buf.append(body);
	_buf.append(',');
	_buf.append("footer=");
	_buf.append(footer);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pssNum", pssNum, _buf);
	Atf::XmlElement::encodeAsXmlElement("header", header, _buf);
	Atf::XmlElement::encodeAsXmlElement("body", body, _buf);
	Atf::XmlElement::encodeAsXmlElement("footer", footer, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pssNum"))
			{
				pssNum = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("header"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, header)) return false;
			}
			else if (_element.equals("body"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, body)) return false;
			}
			else if (_element.equals("footer"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, footer)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(pssNum);
	_msg.composeString(header);
	_msg.composeString(body);
	_msg.composeString(footer);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(pssNum);
	_parser.parseStringP(header);
	_parser.parseStringP(body);
	_parser.parseStringP(footer);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pssNum", pssNum);
	_jsonstr.compose("header", header);
	_jsonstr.compose("body", body);
	_jsonstr.compose("footer", footer);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("pssNum", pssNum);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("body", body);
	_jparser.parseByNameThrow("footer", footer);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE pssNum; _jparser.validateByNameThrow("pssNum", pssNum);
	AtfValidator::validateInt(_descr, "pssNum", pssNum, _checker, __FILE__, __LINE__);
	PString header; _jparser.validateByNameThrow("header", header);
	AtfValidator::validateInt(_descr, "header", header.length(), _checker, __FILE__, __LINE__);
	PString body; _jparser.validateByNameThrow("body", body);
	AtfValidator::validateInt(_descr, "body", body.length(), _checker, __FILE__, __LINE__);
	PString footer; _jparser.validateByNameThrow("footer", footer);
	AtfValidator::validateInt(_descr, "footer", footer.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE pssNum; _parser.parseBYTE(pssNum);
	AtfValidator::validateInt(_descr, "pssNum", pssNum, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "header"); size_t szHeader = strlen(_dummy);
	AtfValidator::validateInt(_descr, "header", szHeader, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "body"); size_t szBody = strlen(_dummy);
	AtfValidator::validateInt(_descr, "body", szBody, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "footer"); size_t szFooter = strlen(_dummy);
	AtfValidator::validateInt(_descr, "footer", szFooter, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    WireHolderBody
//=================================================================

CashierServer::cli::WireHolderBody::WireHolderBody()
{
	clear();
}

void CashierServer::cli::WireHolderBody::clear()
{
	fullName.clear();
	phone.clear();
	address.clear();
	city.clear();
	state.clear();
	zip.clear();
	countryCode.clear();
}

bool CashierServer::cli::WireHolderBody::equals(const WireHolderBody& _o) const
{
	return Atf::atfPStringEquals(fullName, _o.fullName) &&
		Atf::atfPStringEquals(phone, _o.phone) &&
		Atf::atfPStringEquals(address, _o.address) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(zip, _o.zip) &&
		Atf::atfPStringEquals(countryCode, _o.countryCode);
}

const char *CashierServer::cli::WireHolderBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fullName=");
	_buf.append(fullName);
	_buf.append(',');
	_buf.append("phone=");
	_buf.append(phone);
	_buf.append(',');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("zip=");
	_buf.append(zip);
	_buf.append(',');
	_buf.append("countryCode=");
	_buf.append(countryCode);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::WireHolderBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("fullName", fullName, _buf);
	Atf::XmlElement::encodeAsXmlElement("phone", phone, _buf);
	Atf::XmlElement::encodeAsXmlElement("address", address, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("zip", zip, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryCode", countryCode, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::WireHolderBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("fullName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, fullName)) return false;
		}
		else if (_element.equals("phone"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, phone)) return false;
		}
		else if (_element.equals("address"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, address)) return false;
		}
		else if (_element.equals("city"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
		}
		else if (_element.equals("state"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
		}
		else if (_element.equals("zip"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, zip)) return false;
		}
		else if (_element.equals("countryCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, countryCode)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::WireHolderBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(WireHolderBody())) // not empty
	{
		_body.composeString(fullName);
		_body.composeString(phone);
		_body.composeString(address);
		_body.composeString(city);
		_body.composeString(state);
		_body.composeString(zip);
		_body.composeString(countryCode);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::WireHolderBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(fullName);
	_parser0.parseStringP(phone);
	_parser0.parseStringP(address);
	_parser0.parseStringP(city);
	_parser0.parseStringP(state);
	_parser0.parseStringP(zip);
	_parser0.parseStringP(countryCode);
}

const char *CashierServer::cli::WireHolderBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("fullName", fullName);
	_jsonstr.compose("phone", phone);
	_jsonstr.compose("address", address);
	_jsonstr.compose("city", city);
	_jsonstr.compose("state", state);
	_jsonstr.compose("zip", zip);
	_jsonstr.compose("countryCode", countryCode);
	return _buf.c_str();
}

void CashierServer::cli::WireHolderBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("fullName", fullName);
	_jparser.parseByNameThrow("phone", phone);
	_jparser.parseByNameThrow("address", address);
	_jparser.parseByNameThrow("city", city);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("zip", zip);
	_jparser.parseByNameThrow("countryCode", countryCode);
}

/* static */ void CashierServer::cli::WireHolderBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString fullName; _jparser.validateByNameThrow("fullName", fullName);
	AtfValidator::validateIntMax(_descr, "fullName", fullName.length(), WIREACCOUNTS_HOLDERNAME_LEN, _checker, __FILE__, __LINE__);
	PString phone; _jparser.validateByNameThrow("phone", phone);
	AtfValidator::validateIntMax(_descr, "phone", phone.length(), WIREACCOUNTS_PHONE_LEN, _checker, __FILE__, __LINE__);
	PString address; _jparser.validateByNameThrow("address", address);
	AtfValidator::validateIntMax(_descr, "address", address.length(), WIREACCOUNTS_ADDR_LEN, _checker, __FILE__, __LINE__);
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateIntMax(_descr, "city", city.length(), WIREACCOUNTS_CITY_LEN, _checker, __FILE__, __LINE__);
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateIntMax(_descr, "state", state.length(), WIREACCOUNTS_STATE_LEN, _checker, __FILE__, __LINE__);
	PString zip; _jparser.validateByNameThrow("zip", zip);
	AtfValidator::validateIntMax(_descr, "zip", zip.length(), WIREACCOUNTS_ZIPCODE_LEN, _checker, __FILE__, __LINE__);
	PString countryCode; _jparser.validateByNameThrow("countryCode", countryCode);
	AtfValidator::validateIntMax(_descr, "countryCode", countryCode.length(), WIREACCOUNTS_COUNTRY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::WireHolderBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "fullName"); size_t szFullName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fullName", szFullName, WIREACCOUNTS_HOLDERNAME_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phone", szPhone, WIREACCOUNTS_PHONE_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "address", szAddress, WIREACCOUNTS_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, WIREACCOUNTS_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, WIREACCOUNTS_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "zip"); size_t szZip = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zip", szZip, WIREACCOUNTS_ZIPCODE_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "countryCode"); size_t szCountryCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "countryCode", szCountryCode, WIREACCOUNTS_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    WireBankInfoBody
//=================================================================

CashierServer::cli::WireBankInfoBody::WireBankInfoBody()
{
	clear();
}

void CashierServer::cli::WireBankInfoBody::clear()
{
	userAccount.clear();
	currencyCode.clear();
	iban.clear();
	swiftCode.clear();
	bankName.clear();
	bankAddr.clear();
	comments.clear();
}

bool CashierServer::cli::WireBankInfoBody::equals(const WireBankInfoBody& _o) const
{
	return Atf::atfPStringEquals(userAccount, _o.userAccount) &&
		Atf::atfPStringEquals(currencyCode, _o.currencyCode) &&
		Atf::atfPStringEquals(iban, _o.iban) &&
		Atf::atfPStringEquals(swiftCode, _o.swiftCode) &&
		Atf::atfPStringEquals(bankName, _o.bankName) &&
		Atf::atfPStringEquals(bankAddr, _o.bankAddr) &&
		Atf::atfPStringEquals(comments, _o.comments);
}

const char *CashierServer::cli::WireBankInfoBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userAccount=");
	_buf.append(userAccount);
	_buf.append(',');
	_buf.append("currencyCode=");
	_buf.append(currencyCode);
	_buf.append(',');
	_buf.append("iban=");
	_buf.append(iban);
	_buf.append(',');
	_buf.append("swiftCode=");
	_buf.append(swiftCode);
	_buf.append(',');
	_buf.append("bankName=");
	_buf.append(bankName);
	_buf.append(',');
	_buf.append("bankAddr=");
	_buf.append(bankAddr);
	_buf.append(',');
	_buf.append("comments=");
	_buf.append(comments);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::WireBankInfoBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userAccount", userAccount, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyCode", currencyCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("iban", iban, _buf);
	Atf::XmlElement::encodeAsXmlElement("swiftCode", swiftCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("bankName", bankName, _buf);
	Atf::XmlElement::encodeAsXmlElement("bankAddr", bankAddr, _buf);
	Atf::XmlElement::encodeAsXmlElement("comments", comments, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::WireBankInfoBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userAccount"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userAccount)) return false;
		}
		else if (_element.equals("currencyCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currencyCode)) return false;
		}
		else if (_element.equals("iban"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, iban)) return false;
		}
		else if (_element.equals("swiftCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, swiftCode)) return false;
		}
		else if (_element.equals("bankName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, bankName)) return false;
		}
		else if (_element.equals("bankAddr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, bankAddr)) return false;
		}
		else if (_element.equals("comments"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, comments)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::WireBankInfoBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(WireBankInfoBody())) // not empty
	{
		_body.composeString(userAccount);
		_body.composeString(currencyCode);
		_body.composeString(iban);
		_body.composeString(swiftCode);
		_body.composeString(bankName);
		_body.composeString(bankAddr);
		_body.composeString(comments);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::WireBankInfoBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(userAccount);
	_parser0.parseStringP(currencyCode);
	_parser0.parseStringP(iban);
	_parser0.parseStringP(swiftCode);
	_parser0.parseStringP(bankName);
	_parser0.parseStringP(bankAddr);
	_parser0.parseStringP(comments);
}

const char *CashierServer::cli::WireBankInfoBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userAccount", userAccount);
	_jsonstr.compose("currencyCode", currencyCode);
	_jsonstr.compose("iban", iban);
	_jsonstr.compose("swiftCode", swiftCode);
	_jsonstr.compose("bankName", bankName);
	_jsonstr.compose("bankAddr", bankAddr);
	_jsonstr.compose("comments", comments);
	return _buf.c_str();
}

void CashierServer::cli::WireBankInfoBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userAccount", userAccount);
	_jparser.parseByNameThrow("currencyCode", currencyCode);
	_jparser.parseByNameThrow("iban", iban);
	_jparser.parseByNameThrow("swiftCode", swiftCode);
	_jparser.parseByNameThrow("bankName", bankName);
	_jparser.parseByNameThrow("bankAddr", bankAddr);
	_jparser.parseByNameThrow("comments", comments);
}

/* static */ void CashierServer::cli::WireBankInfoBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userAccount; _jparser.validateByNameThrow("userAccount", userAccount);
	AtfValidator::validateIntMax(_descr, "userAccount", userAccount.length(), 100, _checker, __FILE__, __LINE__);
	PString currencyCode; _jparser.validateByNameThrow("currencyCode", currencyCode);
	AtfValidator::validateIntMax(_descr, "currencyCode", currencyCode.length(), WIREACCOUNTS_CURRENCY_LEN, _checker, __FILE__, __LINE__);
	PString iban; _jparser.validateByNameThrow("iban", iban);
	AtfValidator::validateIntMax(_descr, "iban", iban.length(), WIREACCOUNTS_IBAN_LEN, _checker, __FILE__, __LINE__);
	PString swiftCode; _jparser.validateByNameThrow("swiftCode", swiftCode);
	AtfValidator::validateIntMax(_descr, "swiftCode", swiftCode.length(), WIREACCOUNTS_SWIFTCODE_LEN, _checker, __FILE__, __LINE__);
	PString bankName; _jparser.validateByNameThrow("bankName", bankName);
	AtfValidator::validateIntMax(_descr, "bankName", bankName.length(), WIREACCOUNTS_BANKNAME_LEN, _checker, __FILE__, __LINE__);
	PString bankAddr; _jparser.validateByNameThrow("bankAddr", bankAddr);
	AtfValidator::validateIntMax(_descr, "bankAddr", bankAddr.length(), WIREACCOUNTS_BANKADDR_LEN, _checker, __FILE__, __LINE__);
	PString comments; _jparser.validateByNameThrow("comments", comments);
	AtfValidator::validateIntMax(_descr, "comments", comments.length(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::WireBankInfoBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "userAccount"); size_t szUserAccount = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userAccount", szUserAccount, 100, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currencyCode"); size_t szCurrencyCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currencyCode", szCurrencyCode, WIREACCOUNTS_CURRENCY_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "iban"); size_t szIban = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "iban", szIban, WIREACCOUNTS_IBAN_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "swiftCode"); size_t szSwiftCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "swiftCode", szSwiftCode, WIREACCOUNTS_SWIFTCODE_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "bankName"); size_t szBankName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankName", szBankName, WIREACCOUNTS_BANKNAME_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "bankAddr"); size_t szBankAddr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankAddr", szBankAddr, WIREACCOUNTS_BANKADDR_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "comments"); size_t szComments = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "comments", szComments, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::clear()
{
	holder.clear();
	bankinfo.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::equals(const Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO& _o) const
{
	return holder.equals(_o.holder) &&
		bankinfo.equals(_o.bankinfo);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO).append(")");
	_buf.append(',');
	_buf.append("holder=");
	holder.toTraceString(_buf);
	_buf.append(',');
	_buf.append("bankinfo=");
	bankinfo.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	holder.toXmlString("holder", _buf);
	bankinfo.toXmlString("bankinfo", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("holder"))
			{
				if(!Atf::AtfTempl< WireHolderBody >::FromXmlString(_value, holder)) return false;
			}
			else if (_element.equals("bankinfo"))
			{
				if(!Atf::AtfTempl< WireBankInfoBody >::FromXmlString(_value, bankinfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	holder.composeMsg(_msg, _ignoreJSON);
	bankinfo.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::parseMsg(CommMsgParser& _parser)
{
	holder.parseMsg(_parser);
	bankinfo.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("holder", holder);
	_jsonstr.compose("bankinfo", bankinfo);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("holder", holder);
	_jparser.parseByNameThrow("bankinfo", bankinfo);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	WireHolderBody holder; _jparser.validateByNameThrow("holder", holder);
	WireBankInfoBody bankinfo; _jparser.validateByNameThrow("bankinfo", bankinfo);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	WireHolderBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("holder"), _fieldsWithUnparsedContent);
	WireBankInfoBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("bankinfo"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::clear()
{
	errCode = 0;
	errReplyInfo.clear();
	eDbtWireBankValNoError = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::equals(const Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errReplyInfo, _o.errReplyInfo) &&
		eDbtWireBankValNoError == _o.eDbtWireBankValNoError;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errReplyInfo=");
	_buf.append(errReplyInfo);
	_buf.append(',');
	_buf.append("eDbtWireBankValNoError=");
	_buf.appendInt(eDbtWireBankValNoError);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errReplyInfo", errReplyInfo, _buf);
	Atf::XmlElement::encodeAsXmlElement("eDbtWireBankValNoError", eDbtWireBankValNoError, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errReplyInfo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errReplyInfo)) return false;
			}
			else if (_element.equals("eDbtWireBankValNoError"))
			{
				eDbtWireBankValNoError = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errReplyInfo);
	_msg.composeINT16(eDbtWireBankValNoError);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errReplyInfo);
	_parser.parseINT16(eDbtWireBankValNoError);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errReplyInfo", errReplyInfo);
	_jsonstr.compose("eDbtWireBankValNoError", eDbtWireBankValNoError);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errReplyInfo", errReplyInfo);
	_jparser.parseByNameThrow("eDbtWireBankValNoError", eDbtWireBankValNoError);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errReplyInfo; _jparser.validateByNameThrow("errReplyInfo", errReplyInfo);
	AtfValidator::validateInt(_descr, "errReplyInfo", errReplyInfo.length(), _checker, __FILE__, __LINE__);
	INT16 eDbtWireBankValNoError; _jparser.validateByNameThrow("eDbtWireBankValNoError", eDbtWireBankValNoError);
	AtfValidator::validateInt(_descr, "eDbtWireBankValNoError", eDbtWireBankValNoError, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errReplyInfo"); size_t szErrReplyInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errReplyInfo", szErrReplyInfo, _checker, __FILE__, __LINE__);
	INT16 eDbtWireBankValNoError; _parser.parseINT16(eDbtWireBankValNoError);
	AtfValidator::validateInt(_descr, "eDbtWireBankValNoError", eDbtWireBankValNoError, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_LIMIT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::Protocol_MSG_CASHIER_GET_USER_LIMIT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::clear()
{
	userId.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::equals(const Protocol_MSG_CASHIER_GET_USER_LIMIT& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_USER_LIMIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_USER_LIMIT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_LIMIT).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_USER_LIMIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(userId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("userId", userId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	weeklyLimit = 0;
	enforcedUntil.setNull();
	maxUserLimit = 0;
	minUserLimitInCur = 0;
	selfLimitCurrency.clear();
	rateToUsd_x100M = 0;
	regulatoryWeeklyLimit = -1;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::equals(const Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		weeklyLimit == _o.weeklyLimit &&
		enforcedUntil.equals(_o.enforcedUntil) &&
		maxUserLimit == _o.maxUserLimit &&
		minUserLimitInCur == _o.minUserLimitInCur &&
		Atf::atfPStringEquals(selfLimitCurrency, _o.selfLimitCurrency) &&
		rateToUsd_x100M == _o.rateToUsd_x100M &&
		regulatoryWeeklyLimit == _o.regulatoryWeeklyLimit;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_USER_LIMIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("weeklyLimit=");
		_buf.appendInt(weeklyLimit);
		_buf.append(',');
		_buf.append("enforcedUntil=");
		Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, enforcedUntil);
		_buf.append(',');
		_buf.append("maxUserLimit=");
		_buf.appendInt(maxUserLimit);
		_buf.append(',');
		_buf.append("minUserLimitInCur=");
		_buf.appendInt(minUserLimitInCur);
		_buf.append(',');
		_buf.append("selfLimitCurrency=");
		_buf.append(selfLimitCurrency);
		_buf.append(',');
		_buf.append("rateToUsd_x100M=");
		_buf.appendInt64(rateToUsd_x100M);
		_buf.append(',');
		_buf.append("regulatoryWeeklyLimit=");
		_buf.appendInt(regulatoryWeeklyLimit);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_USER_LIMIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("weeklyLimit", weeklyLimit, _buf);
		Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "enforcedUntil", enforcedUntil);
		Atf::XmlElement::encodeAsXmlElement("maxUserLimit", maxUserLimit, _buf);
		Atf::XmlElement::encodeAsXmlElement("minUserLimitInCur", minUserLimitInCur, _buf);
		Atf::XmlElement::encodeAsXmlElement("selfLimitCurrency", selfLimitCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("rateToUsd_x100M", rateToUsd_x100M, _buf);
		Atf::XmlElement::encodeAsXmlElement("regulatoryWeeklyLimit", regulatoryWeeklyLimit, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("weeklyLimit"))
			{
				weeklyLimit = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("enforcedUntil"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, enforcedUntil);
			}
			else if (_element.equals("maxUserLimit"))
			{
				maxUserLimit = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minUserLimitInCur"))
			{
				minUserLimitInCur = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("selfLimitCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, selfLimitCurrency)) return false;
			}
			else if (_element.equals("rateToUsd_x100M"))
			{
				rateToUsd_x100M = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("regulatoryWeeklyLimit"))
			{
				regulatoryWeeklyLimit = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(weeklyLimit);
		_msg.composeSrvTime(enforcedUntil);
		_msg.composeINT32(maxUserLimit);
		_msg.composeINT32(minUserLimitInCur);
		_msg.composeString(selfLimitCurrency);
		_msg.composeINT64(rateToUsd_x100M);
		_msg.composeINT32(regulatoryWeeklyLimit);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(weeklyLimit);
		_parser.parseSrvTime(enforcedUntil);
		_parser.parseINT32(maxUserLimit);
		_parser.parseINT32(minUserLimitInCur);
		_parser.parseStringP(selfLimitCurrency);
		_parser.parseINT64(rateToUsd_x100M);
		if(_parser.parseEnded()) return;
		_parser.parseINT32(regulatoryWeeklyLimit);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("weeklyLimit", weeklyLimit);
		_jsonstr.compose("enforcedUntil", enforcedUntil);
		_jsonstr.compose("maxUserLimit", maxUserLimit);
		_jsonstr.compose("minUserLimitInCur", minUserLimitInCur);
		_jsonstr.compose("selfLimitCurrency", selfLimitCurrency);
		_jsonstr.compose("rateToUsd_x100M", rateToUsd_x100M);
		_jsonstr.compose("regulatoryWeeklyLimit", regulatoryWeeklyLimit);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("weeklyLimit", weeklyLimit);
		_jparser.parseByNameThrow("enforcedUntil", enforcedUntil);
		_jparser.parseByNameThrow("maxUserLimit", maxUserLimit);
		_jparser.parseByNameThrow("minUserLimitInCur", minUserLimitInCur);
		_jparser.parseByNameThrow("selfLimitCurrency", selfLimitCurrency);
		_jparser.parseByNameThrow("rateToUsd_x100M", rateToUsd_x100M);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("regulatoryWeeklyLimit", regulatoryWeeklyLimit);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 weeklyLimit; _jparser.validateByNameThrow("weeklyLimit", weeklyLimit);
		AtfValidator::validateInt(_descr, "weeklyLimit", weeklyLimit, _checker, __FILE__, __LINE__);
		CommSrvTime enforcedUntil; _jparser.validateByNameThrow("enforcedUntil", enforcedUntil);
		AtfValidator::validateSrvDateTime(_descr, "enforcedUntil", enforcedUntil, _checker, __FILE__, __LINE__);
		INT32 maxUserLimit; _jparser.validateByNameThrow("maxUserLimit", maxUserLimit);
		AtfValidator::validateInt(_descr, "maxUserLimit", maxUserLimit, _checker, __FILE__, __LINE__);
		INT32 minUserLimitInCur; _jparser.validateByNameThrow("minUserLimitInCur", minUserLimitInCur);
		AtfValidator::validateInt(_descr, "minUserLimitInCur", minUserLimitInCur, _checker, __FILE__, __LINE__);
		PString selfLimitCurrency; _jparser.validateByNameThrow("selfLimitCurrency", selfLimitCurrency);
		AtfValidator::validateInt(_descr, "selfLimitCurrency", selfLimitCurrency.length(), _checker, __FILE__, __LINE__);
		INT64 rateToUsd_x100M; _jparser.validateByNameThrow("rateToUsd_x100M", rateToUsd_x100M);
		AtfValidator::validateInt(_descr, "rateToUsd_x100M", rateToUsd_x100M, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		INT32 regulatoryWeeklyLimit; _jparser.validateByNameThrow("regulatoryWeeklyLimit", regulatoryWeeklyLimit);
		AtfValidator::validateInt(_descr, "regulatoryWeeklyLimit", regulatoryWeeklyLimit, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 weeklyLimit; _parser.parseINT32(weeklyLimit);
		AtfValidator::validateInt(_descr, "weeklyLimit", weeklyLimit, _checker, __FILE__, __LINE__);
		CommSrvTime enforcedUntil; _parser.parseSrvTime(enforcedUntil);
		AtfValidator::validateSrvDateTime(_descr, "enforcedUntil", enforcedUntil, _checker, __FILE__, __LINE__);
		INT32 maxUserLimit; _parser.parseINT32(maxUserLimit);
		AtfValidator::validateInt(_descr, "maxUserLimit", maxUserLimit, _checker, __FILE__, __LINE__);
		INT32 minUserLimitInCur; _parser.parseINT32(minUserLimitInCur);
		AtfValidator::validateInt(_descr, "minUserLimitInCur", minUserLimitInCur, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "selfLimitCurrency"); size_t szSelfLimitCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "selfLimitCurrency", szSelfLimitCurrency, _checker, __FILE__, __LINE__);
		INT64 rateToUsd_x100M; _parser.parseINT64(rateToUsd_x100M);
		AtfValidator::validateInt(_descr, "rateToUsd_x100M", rateToUsd_x100M, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		INT32 regulatoryWeeklyLimit; _parser.parseINT32(regulatoryWeeklyLimit);
		AtfValidator::validateInt(_descr, "regulatoryWeeklyLimit", regulatoryWeeklyLimit, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USER_LIMIT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::Protocol_MSG_CASHIER_SET_USER_LIMIT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::clear()
{
	userId.clear();
	weeklyLimit = 0;
	flags_ignored = 0;
	flags2_ignored = 0;
	groupDepositLimit = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::equals(const Protocol_MSG_CASHIER_SET_USER_LIMIT& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		weeklyLimit == _o.weeklyLimit &&
		flags_ignored == _o.flags_ignored &&
		flags2_ignored == _o.flags2_ignored &&
		groupDepositLimit == _o.groupDepositLimit;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_USER_LIMIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_USER_LIMIT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USER_LIMIT).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("weeklyLimit=");
	_buf.appendInt(weeklyLimit);
	_buf.append(',');
	_buf.append("flags_ignored=");
	_buf.appendUint(flags_ignored);
	_buf.append(',');
	_buf.append("flags2_ignored=");
	_buf.appendUint64(flags2_ignored);
	_buf.append(',');
	_buf.append("groupDepositLimit=");
	_buf.appendUint(groupDepositLimit);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_USER_LIMIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("weeklyLimit", weeklyLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags_ignored", flags_ignored, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags2_ignored", flags2_ignored, _buf);
	Atf::XmlElement::encodeAsXmlElement("groupDepositLimit", groupDepositLimit, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("weeklyLimit"))
			{
				weeklyLimit = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags_ignored"))
			{
				flags_ignored = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags2_ignored"))
			{
				flags2_ignored = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("groupDepositLimit"))
			{
				groupDepositLimit = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeINT32(weeklyLimit);
	_msg.composeUINT32(flags_ignored);
	_msg.composeUINT64(flags2_ignored);
	_msg.composeBOOL(groupDepositLimit);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(weeklyLimit);
	_parser.parseUINT32(flags_ignored);
	_parser.parseUINT64(flags2_ignored);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(groupDepositLimit);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("weeklyLimit", weeklyLimit);
	_jsonstr.compose("flags_ignored", flags_ignored);
	_jsonstr.compose("flags2_ignored", flags2_ignored);
	_jsonstr.compose("groupDepositLimit", groupDepositLimit);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("weeklyLimit", weeklyLimit);
	_jparser.parseByNameThrow("flags_ignored", flags_ignored);
	_jparser.parseByNameThrow("flags2_ignored", flags2_ignored);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("groupDepositLimit", groupDepositLimit);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 weeklyLimit; _jparser.validateByNameThrow("weeklyLimit", weeklyLimit);
	AtfValidator::validateIntRange(_descr, "weeklyLimit", weeklyLimit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	UINT32 flags_ignored; _jparser.validateByNameThrow("flags_ignored", flags_ignored);
	AtfValidator::validateInt(_descr, "flags_ignored", flags_ignored, _checker, __FILE__, __LINE__);
	UINT64 flags2_ignored; _jparser.validateByNameThrow("flags2_ignored", flags2_ignored);
	AtfValidator::validateUint(_descr, "flags2_ignored", flags2_ignored, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool groupDepositLimit; _jparser.validateByNameThrow("groupDepositLimit", groupDepositLimit);
	AtfValidator::validateInt(_descr, "groupDepositLimit", groupDepositLimit, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 weeklyLimit; _parser.parseINT32(weeklyLimit);
	AtfValidator::validateIntRange(_descr, "weeklyLimit", weeklyLimit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	UINT32 flags_ignored; _parser.parseUINT32(flags_ignored);
	AtfValidator::validateInt(_descr, "flags_ignored", flags_ignored, _checker, __FILE__, __LINE__);
	UINT64 flags2_ignored; _parser.parseUINT64(flags2_ignored);
	AtfValidator::validateUint(_descr, "flags2_ignored", flags2_ignored, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool groupDepositLimit; _parser.parseBOOL(groupDepositLimit);
	AtfValidator::validateInt(_descr, "groupDepositLimit", groupDepositLimit, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	status = 0;
	weeklyLimit = 0;
	enforcedUntil.setNull();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::equals(const Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		status == _o.status &&
		weeklyLimit == _o.weeklyLimit &&
		enforcedUntil.equals(_o.enforcedUntil);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_USER_LIMIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USER_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("status=");
		_buf.appendUint(status);
		_buf.append(',');
		_buf.append("weeklyLimit=");
		_buf.appendInt(weeklyLimit);
		_buf.append(',');
		_buf.append("enforcedUntil=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, enforcedUntil);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_USER_LIMIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
		Atf::XmlElement::encodeAsXmlElement("weeklyLimit", weeklyLimit, _buf);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "enforcedUntil", enforcedUntil);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("status"))
			{
				status = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("weeklyLimit"))
			{
				weeklyLimit = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("enforcedUntil"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, enforcedUntil);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBYTE(status);
		_msg.composeINT32(weeklyLimit);
		_msg.composeSrvTime(enforcedUntil);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBYTE(status);
		_parser.parseINT32(weeklyLimit);
		_parser.parseSrvTime(enforcedUntil);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("status", status);
		_jsonstr.compose("weeklyLimit", weeklyLimit);
		_jsonstr.compose("enforcedUntil", enforcedUntil);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("status", status);
		_jparser.parseByNameThrow("weeklyLimit", weeklyLimit);
		_jparser.parseByNameThrow("enforcedUntil", enforcedUntil);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE status; _jparser.validateByNameThrow("status", status);
		AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
		INT32 weeklyLimit; _jparser.validateByNameThrow("weeklyLimit", weeklyLimit);
		AtfValidator::validateInt(_descr, "weeklyLimit", weeklyLimit, _checker, __FILE__, __LINE__);
		SrvTime enforcedUntil; _jparser.validateByNameThrow("enforcedUntil", enforcedUntil);
		AtfValidator::validateSrvDateTime(_descr, "enforcedUntil", enforcedUntil, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE status; _parser.parseBYTE(status);
		AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
		INT32 weeklyLimit; _parser.parseINT32(weeklyLimit);
		AtfValidator::validateInt(_descr, "weeklyLimit", weeklyLimit, _checker, __FILE__, __LINE__);
		SrvTime enforcedUntil; _parser.parseSrvTime(enforcedUntil);
		AtfValidator::validateSrvDateTime(_descr, "enforcedUntil", enforcedUntil, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_LIMIT_EX
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::clear()
{
	userId.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::equals(const Protocol_MSG_CASHIER_GET_USER_LIMIT_EX& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_USER_LIMIT_EX != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_USER_LIMIT_EX*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_LIMIT_EX).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_USER_LIMIT_EX).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_LIMIT_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_LIMIT_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserLimitReplyBody
//=================================================================

CashierServer::cli::UserLimitReplyBody::UserLimitReplyBody()
{
	clear();
}

void CashierServer::cli::UserLimitReplyBody::clear()
{
	type = 0;
	value = 0;
	enforcedUntil.setNull();
	maxL = 0;
	minL = 0;
	maxValuePropInt = 0;
	regulatoryLimit = -1;
}

bool CashierServer::cli::UserLimitReplyBody::equals(const UserLimitReplyBody& _o) const
{
	return type == _o.type &&
		value == _o.value &&
		enforcedUntil.equals(_o.enforcedUntil) &&
		maxL == _o.maxL &&
		minL == _o.minL &&
		maxValuePropInt == _o.maxValuePropInt &&
		regulatoryLimit == _o.regulatoryLimit;
}

const char *CashierServer::cli::UserLimitReplyBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("value=");
	_buf.appendInt(value);
	_buf.append(',');
	_buf.append("enforcedUntil=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, enforcedUntil);
	_buf.append(',');
	_buf.append("maxL=");
	_buf.appendInt(maxL);
	_buf.append(',');
	_buf.append("minL=");
	_buf.appendInt(minL);
	_buf.append(',');
	_buf.append("maxValuePropInt=");
	_buf.appendInt(maxValuePropInt);
	_buf.append(',');
	_buf.append("regulatoryLimit=");
	_buf.appendInt(regulatoryLimit);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::UserLimitReplyBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("value", value, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "enforcedUntil", enforcedUntil);
	Atf::XmlElement::encodeAsXmlElement("maxL", maxL, _buf);
	Atf::XmlElement::encodeAsXmlElement("minL", minL, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxValuePropInt", maxValuePropInt, _buf);
	Atf::XmlElement::encodeAsXmlElement("regulatoryLimit", regulatoryLimit, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::UserLimitReplyBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("type"))
		{
			type = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("value"))
		{
			value = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("enforcedUntil"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, enforcedUntil);
		}
		else if (_element.equals("maxL"))
		{
			maxL = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minL"))
		{
			minL = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxValuePropInt"))
		{
			maxValuePropInt = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("regulatoryLimit"))
		{
			regulatoryLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::UserLimitReplyBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(UserLimitReplyBody())) // not empty
	{
		_body.composeUINT32(type);
		_body.composeINT32(value);
		_body.composeSrvTime(enforcedUntil);
		_body.composeINT32(maxL);
		_body.composeINT32(minL);
		_body.composeINT32(maxValuePropInt);
		_body.composeINT32(regulatoryLimit);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::UserLimitReplyBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(type);
	_parser0.parseINT32(value);
	_parser0.parseSrvTime(enforcedUntil);
	_parser0.parseINT32(maxL);
	_parser0.parseINT32(minL);
	_parser0.parseINT32(maxValuePropInt);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(regulatoryLimit);
}

const char *CashierServer::cli::UserLimitReplyBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("type", type);
	_jsonstr.compose("value", value);
	_jsonstr.compose("enforcedUntil", enforcedUntil);
	_jsonstr.compose("maxL", maxL);
	_jsonstr.compose("minL", minL);
	_jsonstr.compose("maxValuePropInt", maxValuePropInt);
	_jsonstr.compose("regulatoryLimit", regulatoryLimit);
	return _buf.c_str();
}

void CashierServer::cli::UserLimitReplyBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("value", value);
	_jparser.parseByNameThrow("enforcedUntil", enforcedUntil);
	_jparser.parseByNameThrow("maxL", maxL);
	_jparser.parseByNameThrow("minL", minL);
	_jparser.parseByNameThrow("maxValuePropInt", maxValuePropInt);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("regulatoryLimit", regulatoryLimit);
}

/* static */ void CashierServer::cli::UserLimitReplyBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	INT32 value; _jparser.validateByNameThrow("value", value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	CommSrvTime enforcedUntil; _jparser.validateByNameThrow("enforcedUntil", enforcedUntil);
	AtfValidator::validateSrvDateTime(_descr, "enforcedUntil", enforcedUntil, _checker, __FILE__, __LINE__);
	INT32 maxL; _jparser.validateByNameThrow("maxL", maxL);
	AtfValidator::validateInt(_descr, "maxL", maxL, _checker, __FILE__, __LINE__);
	INT32 minL; _jparser.validateByNameThrow("minL", minL);
	AtfValidator::validateInt(_descr, "minL", minL, _checker, __FILE__, __LINE__);
	INT32 maxValuePropInt; _jparser.validateByNameThrow("maxValuePropInt", maxValuePropInt);
	AtfValidator::validateInt(_descr, "maxValuePropInt", maxValuePropInt, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 regulatoryLimit; _jparser.validateByNameThrow("regulatoryLimit", regulatoryLimit);
	AtfValidator::validateInt(_descr, "regulatoryLimit", regulatoryLimit, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::UserLimitReplyBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 type; _parser0.parseUINT32(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	INT32 value; _parser0.parseINT32(value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	CommSrvTime enforcedUntil; _parser0.parseSrvTime(enforcedUntil);
	AtfValidator::validateSrvDateTime(_descr, "enforcedUntil", enforcedUntil, _checker, __FILE__, __LINE__);
	INT32 maxL; _parser0.parseINT32(maxL);
	AtfValidator::validateInt(_descr, "maxL", maxL, _checker, __FILE__, __LINE__);
	INT32 minL; _parser0.parseINT32(minL);
	AtfValidator::validateInt(_descr, "minL", minL, _checker, __FILE__, __LINE__);
	INT32 maxValuePropInt; _parser0.parseINT32(maxValuePropInt);
	AtfValidator::validateInt(_descr, "maxValuePropInt", maxValuePropInt, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 regulatoryLimit; _parser0.parseINT32(regulatoryLimit);
	AtfValidator::validateInt(_descr, "regulatoryLimit", regulatoryLimit, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	quizPropInt = 0;
	quizPropWhen.setNull();
	size = 0;
	limitDaily.clear();
	limitWeekly.clear();
	limitMonthly.clear();
	selfLimitCurrency.clear();
	rateToUsd_x100M = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::equals(const Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		quizPropInt == _o.quizPropInt &&
		quizPropWhen.equals(_o.quizPropWhen) &&
		size == _o.size &&
		limitDaily.equals(_o.limitDaily) &&
		limitWeekly.equals(_o.limitWeekly) &&
		limitMonthly.equals(_o.limitMonthly) &&
		Atf::atfPStringEquals(selfLimitCurrency, _o.selfLimitCurrency) &&
		rateToUsd_x100M == _o.rateToUsd_x100M;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_USER_LIMIT_EX_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_LIMIT_EX_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("quizPropInt=");
		_buf.appendUint(quizPropInt);
		_buf.append(',');
		_buf.append("quizPropWhen=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, quizPropWhen);
		_buf.append(',');
		_buf.append("size=");
		_buf.appendUint(size);
		_buf.append(',');
		_buf.append("limitDaily=");
		limitDaily.toTraceString(_buf);
		_buf.append(',');
		_buf.append("limitWeekly=");
		limitWeekly.toTraceString(_buf);
		_buf.append(',');
		_buf.append("limitMonthly=");
		limitMonthly.toTraceString(_buf);
		_buf.append(',');
		_buf.append("selfLimitCurrency=");
		_buf.append(selfLimitCurrency);
		_buf.append(',');
		_buf.append("rateToUsd_x100M=");
		_buf.appendInt64(rateToUsd_x100M);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_USER_LIMIT_EX_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("quizPropInt", quizPropInt, _buf);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "quizPropWhen", quizPropWhen);
		Atf::XmlElement::encodeAsXmlElement("size", size, _buf);
		limitDaily.toXmlString("limitDaily", _buf);
		limitWeekly.toXmlString("limitWeekly", _buf);
		limitMonthly.toXmlString("limitMonthly", _buf);
		Atf::XmlElement::encodeAsXmlElement("selfLimitCurrency", selfLimitCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("rateToUsd_x100M", rateToUsd_x100M, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("quizPropInt"))
			{
				quizPropInt = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("quizPropWhen"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, quizPropWhen);
			}
			else if (_element.equals("size"))
			{
				size = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("limitDaily"))
			{
				if(!Atf::AtfTempl< UserLimitReplyBody >::FromXmlString(_value, limitDaily)) return false;
			}
			else if (_element.equals("limitWeekly"))
			{
				if(!Atf::AtfTempl< UserLimitReplyBody >::FromXmlString(_value, limitWeekly)) return false;
			}
			else if (_element.equals("limitMonthly"))
			{
				if(!Atf::AtfTempl< UserLimitReplyBody >::FromXmlString(_value, limitMonthly)) return false;
			}
			else if (_element.equals("selfLimitCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, selfLimitCurrency)) return false;
			}
			else if (_element.equals("rateToUsd_x100M"))
			{
				rateToUsd_x100M = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		CommMsgBody _msg0;
		_msg0.composeUINT32(quizPropInt);
		_msg0.composeSrvTime(quizPropWhen);
		_msg.composeMsgBody(_msg0);
		_msg.composeUINT32(size);
		limitDaily.composeMsg(_msg, _ignoreJSON);
		limitWeekly.composeMsg(_msg, _ignoreJSON);
		limitMonthly.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(selfLimitCurrency);
		_msg.composeINT64(rateToUsd_x100M);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		parseAnonymousMsgBody0(_parser);
		_parser.parseUINT32(size);
		limitDaily.parseMsg(_parser);
		limitWeekly.parseMsg(_parser);
		limitMonthly.parseMsg(_parser);
		_parser.parseStringP(selfLimitCurrency);
		_parser.parseINT64(rateToUsd_x100M);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("quizPropInt", quizPropInt);
		_jsonstr.compose("quizPropWhen", quizPropWhen);
		_jsonstr.compose("size", size);
		_jsonstr.compose("limitDaily", limitDaily);
		_jsonstr.compose("limitWeekly", limitWeekly);
		_jsonstr.compose("limitMonthly", limitMonthly);
		_jsonstr.compose("selfLimitCurrency", selfLimitCurrency);
		_jsonstr.compose("rateToUsd_x100M", rateToUsd_x100M);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("quizPropInt", quizPropInt);
		_jparser.parseByNameThrow("quizPropWhen", quizPropWhen);
		_jparser.parseByNameThrow("size", size);
		_jparser.parseByNameThrow("limitDaily", limitDaily);
		_jparser.parseByNameThrow("limitWeekly", limitWeekly);
		_jparser.parseByNameThrow("limitMonthly", limitMonthly);
		_jparser.parseByNameThrow("selfLimitCurrency", selfLimitCurrency);
		_jparser.parseByNameThrow("rateToUsd_x100M", rateToUsd_x100M);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_LIMIT_EX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 quizPropInt; _jparser.validateByNameThrow("quizPropInt", quizPropInt);
		AtfValidator::validateInt(_descr, "quizPropInt", quizPropInt, _checker, __FILE__, __LINE__);
		SrvTime quizPropWhen; _jparser.validateByNameThrow("quizPropWhen", quizPropWhen);
		AtfValidator::validateSrvDateTime(_descr, "quizPropWhen", quizPropWhen, _checker, __FILE__, __LINE__);
		UINT32 size; _jparser.validateByNameThrow("size", size);
		AtfValidator::validateIntRange(_descr, "size", size, 3, 3, _checker, __FILE__, __LINE__);
		UserLimitReplyBody limitDaily; _jparser.validateByNameThrow("limitDaily", limitDaily);
		UserLimitReplyBody limitWeekly; _jparser.validateByNameThrow("limitWeekly", limitWeekly);
		UserLimitReplyBody limitMonthly; _jparser.validateByNameThrow("limitMonthly", limitMonthly);
		PString selfLimitCurrency; _jparser.validateByNameThrow("selfLimitCurrency", selfLimitCurrency);
		AtfValidator::validateInt(_descr, "selfLimitCurrency", selfLimitCurrency.length(), _checker, __FILE__, __LINE__);
		INT64 rateToUsd_x100M; _jparser.validateByNameThrow("rateToUsd_x100M", rateToUsd_x100M);
		AtfValidator::validateInt(_descr, "rateToUsd_x100M", rateToUsd_x100M, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_LIMIT_EX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		UINT32 size; _parser.parseUINT32(size);
		AtfValidator::validateIntRange(_descr, "size", size, 3, 3, _checker, __FILE__, __LINE__);
		PString _descbuf;
		UserLimitReplyBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limitDaily"), _fieldsWithUnparsedContent);
		UserLimitReplyBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limitWeekly"), _fieldsWithUnparsedContent);
		UserLimitReplyBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limitMonthly"), _fieldsWithUnparsedContent);
		_parser.parseStringN(_dummy, 0, "selfLimitCurrency"); size_t szSelfLimitCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "selfLimitCurrency", szSelfLimitCurrency, _checker, __FILE__, __LINE__);
		INT64 rateToUsd_x100M; _parser.parseINT64(rateToUsd_x100M);
		AtfValidator::validateInt(_descr, "rateToUsd_x100M", rateToUsd_x100M, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(quizPropInt);
	_parser0.parseSrvTime(quizPropWhen);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 quizPropInt; _parser0.parseUINT32(quizPropInt);
	AtfValidator::validateInt(_descr, "quizPropInt", quizPropInt, _checker, __FILE__, __LINE__);
	SrvTime quizPropWhen; _parser0.parseSrvTime(quizPropWhen);
	AtfValidator::validateSrvDateTime(_descr, "quizPropWhen", quizPropWhen, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierUserLimit
//=================================================================

CashierServer::cli::CashierUserLimit::CashierUserLimit()
{
	clear();
}

void CashierServer::cli::CashierUserLimit::clear()
{
	type = 0;
	value = 0;
}

bool CashierServer::cli::CashierUserLimit::equals(const CashierUserLimit& _o) const
{
	return type == _o.type &&
		value == _o.value;
}

const char *CashierServer::cli::CashierUserLimit::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("value=");
	_buf.appendInt(value);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierUserLimit::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("value", value, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierUserLimit::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("type"))
		{
			type = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("value"))
		{
			value = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierUserLimit::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(type);
	_msg.composeINT32(value);
}

void CashierServer::cli::CashierUserLimit::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(type);
	_parser.parseINT32(value);
}

const char *CashierServer::cli::CashierUserLimit::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("type", type);
	_jsonstr.compose("value", value);
	return _buf.c_str();
}

void CashierServer::cli::CashierUserLimit::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("value", value);
}

/* static */ void CashierServer::cli::CashierUserLimit::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 type; _jparser.validateByNameThrow("type", type);
	{ const UINT32 type_enum[] = {eDailyDepositLimit, eWeeklyDepositLimit, eMonthlyDepositLimit}; AtfValidator::validateEnum(_descr, "type", type, type_enum, _checker, __FILE__, __LINE__); }
	INT32 value; _jparser.validateByNameThrow("value", value);
	AtfValidator::validateIntRange(_descr, "value", value, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierUserLimit::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 type; _parser.parseUINT32(type);
	{ const UINT32 type_enum[] = {eDailyDepositLimit, eWeeklyDepositLimit, eMonthlyDepositLimit}; AtfValidator::validateEnum(_descr, "type", type, type_enum, _checker, __FILE__, __LINE__); }
	INT32 value; _parser.parseINT32(value);
	AtfValidator::validateIntRange(_descr, "value", value, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USER_LIMIT_EX
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::clear()
{
	quiz = 0;
	ignoreFlags1 = 0;
	ignoreFlags2 = 0;
	answers = 0;
	sz = 0;
	daily.clear();
	weekly.clear();
	monthly.clear();
	groupDepositLimit = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::equals(const Protocol_MSG_CASHIER_SET_USER_LIMIT_EX& _o) const
{
	return quiz == _o.quiz &&
		ignoreFlags1 == _o.ignoreFlags1 &&
		ignoreFlags2 == _o.ignoreFlags2 &&
		answers == _o.answers &&
		sz == _o.sz &&
		daily.equals(_o.daily) &&
		weekly.equals(_o.weekly) &&
		monthly.equals(_o.monthly) &&
		groupDepositLimit == _o.groupDepositLimit;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_USER_LIMIT_EX != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_USER_LIMIT_EX*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USER_LIMIT_EX).append(")");
	_buf.append(',');
	_buf.append("quiz=");
	_buf.appendUint(quiz);
	_buf.append(',');
	_buf.append("ignoreFlags1=");
	_buf.appendUint(ignoreFlags1);
	_buf.append(',');
	_buf.append("ignoreFlags2=");
	_buf.appendUint64(ignoreFlags2);
	_buf.append(',');
	_buf.append("answers=");
	_buf.appendUint(answers);
	_buf.append(',');
	_buf.append("sz=");
	_buf.appendUint(sz);
	_buf.append(',');
	_buf.append("daily=");
	daily.toTraceString(_buf);
	_buf.append(',');
	_buf.append("weekly=");
	weekly.toTraceString(_buf);
	_buf.append(',');
	_buf.append("monthly=");
	monthly.toTraceString(_buf);
	_buf.append(',');
	_buf.append("groupDepositLimit=");
	_buf.appendUint(groupDepositLimit);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_USER_LIMIT_EX).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("quiz", quiz, _buf);
	Atf::XmlElement::encodeAsXmlElement("ignoreFlags1", ignoreFlags1, _buf);
	Atf::XmlElement::encodeAsXmlElement("ignoreFlags2", ignoreFlags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("answers", answers, _buf);
	Atf::XmlElement::encodeAsXmlElement("sz", sz, _buf);
	daily.toXmlString("daily", _buf);
	weekly.toXmlString("weekly", _buf);
	monthly.toXmlString("monthly", _buf);
	Atf::XmlElement::encodeAsXmlElement("groupDepositLimit", groupDepositLimit, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("quiz"))
			{
				quiz = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ignoreFlags1"))
			{
				ignoreFlags1 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ignoreFlags2"))
			{
				ignoreFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("answers"))
			{
				answers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sz"))
			{
				sz = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("daily"))
			{
				if(!Atf::AtfTempl< CashierUserLimit >::FromXmlString(_value, daily)) return false;
			}
			else if (_element.equals("weekly"))
			{
				if(!Atf::AtfTempl< CashierUserLimit >::FromXmlString(_value, weekly)) return false;
			}
			else if (_element.equals("monthly"))
			{
				if(!Atf::AtfTempl< CashierUserLimit >::FromXmlString(_value, monthly)) return false;
			}
			else if (_element.equals("groupDepositLimit"))
			{
				groupDepositLimit = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg0.composeUINT32(quiz);
	_msg0.composeUINT32(ignoreFlags1);
	_msg0.composeUINT64(ignoreFlags2);
	_msg0.composeUINT32(answers);
	_msg.composeMsgBody(_msg0);
	_msg.composeUINT32(sz);
	CommMsgBody _msg1;
	daily.composeMsg(_msg1, _ignoreJSON);
	_msg.composeMsgBody(_msg1);
	CommMsgBody _msg2;
	weekly.composeMsg(_msg2, _ignoreJSON);
	_msg.composeMsgBody(_msg2);
	CommMsgBody _msg3;
	monthly.composeMsg(_msg3, _ignoreJSON);
	_msg.composeMsgBody(_msg3);
	_msg.composeBOOL(groupDepositLimit);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::parseMsg(CommMsgParser& _parser)
{
	parseAnonymousMsgBody0(_parser);
	_parser.parseUINT32(sz);
	parseAnonymousMsgBody1(_parser);
	parseAnonymousMsgBody2(_parser);
	parseAnonymousMsgBody3(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(groupDepositLimit);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("quiz", quiz);
	_jsonstr.compose("ignoreFlags1", ignoreFlags1);
	_jsonstr.compose("ignoreFlags2", ignoreFlags2);
	_jsonstr.compose("answers", answers);
	_jsonstr.compose("sz", sz);
	_jsonstr.compose("daily", daily);
	_jsonstr.compose("weekly", weekly);
	_jsonstr.compose("monthly", monthly);
	_jsonstr.compose("groupDepositLimit", groupDepositLimit);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("quiz", quiz);
	_jparser.parseByNameThrow("ignoreFlags1", ignoreFlags1);
	_jparser.parseByNameThrow("ignoreFlags2", ignoreFlags2);
	_jparser.parseByNameThrow("answers", answers);
	_jparser.parseByNameThrow("sz", sz);
	_jparser.parseByNameThrow("daily", daily);
	_jparser.parseByNameThrow("weekly", weekly);
	_jparser.parseByNameThrow("monthly", monthly);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("groupDepositLimit", groupDepositLimit);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_LIMIT_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 quiz; _jparser.validateByNameThrow("quiz", quiz);
	AtfValidator::validateInt(_descr, "quiz", quiz, _checker, __FILE__, __LINE__);
	UINT32 ignoreFlags1; _jparser.validateByNameThrow("ignoreFlags1", ignoreFlags1);
	AtfValidator::validateInt(_descr, "ignoreFlags1", ignoreFlags1, _checker, __FILE__, __LINE__);
	UINT64 ignoreFlags2; _jparser.validateByNameThrow("ignoreFlags2", ignoreFlags2);
	AtfValidator::validateUint(_descr, "ignoreFlags2", ignoreFlags2, _checker, __FILE__, __LINE__);
	UINT32 answers; _jparser.validateByNameThrow("answers", answers);
	AtfValidator::validateInt(_descr, "answers", answers, _checker, __FILE__, __LINE__);
	UINT32 sz; _jparser.validateByNameThrow("sz", sz);
	AtfValidator::validateIntRange(_descr, "sz", sz, 3, 3, _checker, __FILE__, __LINE__);
	CashierUserLimit daily; _jparser.validateByNameThrow("daily", daily);
	CashierUserLimit weekly; _jparser.validateByNameThrow("weekly", weekly);
	CashierUserLimit monthly; _jparser.validateByNameThrow("monthly", monthly);
	if(_jparser.parseEnded()) return;
	bool groupDepositLimit; _jparser.validateByNameThrow("groupDepositLimit", groupDepositLimit);
	AtfValidator::validateInt(_descr, "groupDepositLimit", groupDepositLimit, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_LIMIT_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 sz; _parser.parseUINT32(sz);
	AtfValidator::validateIntRange(_descr, "sz", sz, 3, 3, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	validateAnonymousMsgBody2(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	validateAnonymousMsgBody3(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	bool groupDepositLimit; _parser.parseBOOL(groupDepositLimit);
	AtfValidator::validateInt(_descr, "groupDepositLimit", groupDepositLimit, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(quiz);
	_parser0.parseUINT32(ignoreFlags1);
	_parser0.parseUINT64(ignoreFlags2);
	_parser0.parseUINT32(answers);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 quiz; _parser0.parseUINT32(quiz);
	AtfValidator::validateInt(_descr, "quiz", quiz, _checker, __FILE__, __LINE__);
	UINT32 ignoreFlags1; _parser0.parseUINT32(ignoreFlags1);
	AtfValidator::validateInt(_descr, "ignoreFlags1", ignoreFlags1, _checker, __FILE__, __LINE__);
	UINT64 ignoreFlags2; _parser0.parseUINT64(ignoreFlags2);
	AtfValidator::validateUint(_descr, "ignoreFlags2", ignoreFlags2, _checker, __FILE__, __LINE__);
	UINT32 answers; _parser0.parseUINT32(answers);
	AtfValidator::validateInt(_descr, "answers", answers, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	daily.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	CashierUserLimit::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("daily"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	weekly.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	CashierUserLimit::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("weekly"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::parseAnonymousMsgBody3(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	monthly.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::validateAnonymousMsgBody3(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	CashierUserLimit::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("monthly"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SelfDepositLimitReplyInfo
//=================================================================

CashierServer::cli::SelfDepositLimitReplyInfo::SelfDepositLimitReplyInfo()
{
	clear();
}

void CashierServer::cli::SelfDepositLimitReplyInfo::clear()
{
	type = 0;
	code = 0;
	info.clear();
	curValue = 0;
	enforcedUntil.setNull();
	newValue = 0;
}

bool CashierServer::cli::SelfDepositLimitReplyInfo::equals(const SelfDepositLimitReplyInfo& _o) const
{
	return type == _o.type &&
		code == _o.code &&
		Atf::atfPStringEquals(info, _o.info) &&
		curValue == _o.curValue &&
		enforcedUntil.equals(_o.enforcedUntil) &&
		newValue == _o.newValue;
}

const char *CashierServer::cli::SelfDepositLimitReplyInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("code=");
	_buf.appendInt(code);
	_buf.append(',');
	_buf.append("info=");
	_buf.append(info);
	_buf.append(',');
	_buf.append("curValue=");
	_buf.appendInt(curValue);
	_buf.append(',');
	_buf.append("enforcedUntil=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, enforcedUntil);
	_buf.append(',');
	_buf.append("newValue=");
	_buf.appendInt(newValue);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::SelfDepositLimitReplyInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("code", code, _buf);
	Atf::XmlElement::encodeAsXmlElement("info", info, _buf);
	Atf::XmlElement::encodeAsXmlElement("curValue", curValue, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "enforcedUntil", enforcedUntil);
	Atf::XmlElement::encodeAsXmlElement("newValue", newValue, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::SelfDepositLimitReplyInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("type"))
		{
			type = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("code"))
		{
			code = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("info"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, info)) return false;
		}
		else if (_element.equals("curValue"))
		{
			curValue = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("enforcedUntil"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, enforcedUntil);
		}
		else if (_element.equals("newValue"))
		{
			newValue = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::SelfDepositLimitReplyInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(type);
	_msg.composeINT16(code);
	_msg.composeString(info);
	_msg.composeINT32(curValue);
	_msg.composeSrvTime(enforcedUntil);
	_msg.composeINT32(newValue);
}

void CashierServer::cli::SelfDepositLimitReplyInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(type);
	_parser.parseINT16(code);
	_parser.parseStringP(info);
	_parser.parseINT32(curValue);
	_parser.parseSrvTime(enforcedUntil);
	_parser.parseINT32(newValue);
}

const char *CashierServer::cli::SelfDepositLimitReplyInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("type", type);
	_jsonstr.compose("code", code);
	_jsonstr.compose("info", info);
	_jsonstr.compose("curValue", curValue);
	_jsonstr.compose("enforcedUntil", enforcedUntil);
	_jsonstr.compose("newValue", newValue);
	return _buf.c_str();
}

void CashierServer::cli::SelfDepositLimitReplyInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("code", code);
	_jparser.parseByNameThrow("info", info);
	_jparser.parseByNameThrow("curValue", curValue);
	_jparser.parseByNameThrow("enforcedUntil", enforcedUntil);
	_jparser.parseByNameThrow("newValue", newValue);
}

/* static */ void CashierServer::cli::SelfDepositLimitReplyInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	INT16 code; _jparser.validateByNameThrow("code", code);
	AtfValidator::validateInt(_descr, "code", code, _checker, __FILE__, __LINE__);
	PString info; _jparser.validateByNameThrow("info", info);
	AtfValidator::validateInt(_descr, "info", info.length(), _checker, __FILE__, __LINE__);
	INT32 curValue; _jparser.validateByNameThrow("curValue", curValue);
	AtfValidator::validateInt(_descr, "curValue", curValue, _checker, __FILE__, __LINE__);
	SrvTime enforcedUntil; _jparser.validateByNameThrow("enforcedUntil", enforcedUntil);
	AtfValidator::validateSrvDateTime(_descr, "enforcedUntil", enforcedUntil, _checker, __FILE__, __LINE__);
	INT32 newValue; _jparser.validateByNameThrow("newValue", newValue);
	AtfValidator::validateInt(_descr, "newValue", newValue, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::SelfDepositLimitReplyInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 type; _parser.parseUINT32(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	INT16 code; _parser.parseINT16(code);
	AtfValidator::validateInt(_descr, "code", code, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "info"); size_t szInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "info", szInfo, _checker, __FILE__, __LINE__);
	INT32 curValue; _parser.parseINT32(curValue);
	AtfValidator::validateInt(_descr, "curValue", curValue, _checker, __FILE__, __LINE__);
	SrvTime enforcedUntil; _parser.parseSrvTime(enforcedUntil);
	AtfValidator::validateSrvDateTime(_descr, "enforcedUntil", enforcedUntil, _checker, __FILE__, __LINE__);
	INT32 newValue; _parser.parseINT32(newValue);
	AtfValidator::validateInt(_descr, "newValue", newValue, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	sz = 0;
	daily.clear();
	weekly.clear();
	monthly.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::equals(const Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		sz == _o.sz &&
		daily.equals(_o.daily) &&
		weekly.equals(_o.weekly) &&
		monthly.equals(_o.monthly);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_USER_LIMIT_EX_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USER_LIMIT_EX_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("sz=");
		_buf.appendUint(sz);
		_buf.append(',');
		_buf.append("daily=");
		daily.toTraceString(_buf);
		_buf.append(',');
		_buf.append("weekly=");
		weekly.toTraceString(_buf);
		_buf.append(',');
		_buf.append("monthly=");
		monthly.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_USER_LIMIT_EX_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("sz", sz, _buf);
		daily.toXmlString("daily", _buf);
		weekly.toXmlString("weekly", _buf);
		monthly.toXmlString("monthly", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("sz"))
			{
				sz = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("daily"))
			{
				if(!Atf::AtfTempl< SelfDepositLimitReplyInfo >::FromXmlString(_value, daily)) return false;
			}
			else if (_element.equals("weekly"))
			{
				if(!Atf::AtfTempl< SelfDepositLimitReplyInfo >::FromXmlString(_value, weekly)) return false;
			}
			else if (_element.equals("monthly"))
			{
				if(!Atf::AtfTempl< SelfDepositLimitReplyInfo >::FromXmlString(_value, monthly)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(sz);
		CommMsgBody _msg0;
		daily.composeMsg(_msg0, _ignoreJSON);
		_msg.composeMsgBody(_msg0);
		CommMsgBody _msg1;
		weekly.composeMsg(_msg1, _ignoreJSON);
		_msg.composeMsgBody(_msg1);
		CommMsgBody _msg2;
		monthly.composeMsg(_msg2, _ignoreJSON);
		_msg.composeMsgBody(_msg2);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(sz);
		parseAnonymousMsgBody0(_parser);
		parseAnonymousMsgBody1(_parser);
		parseAnonymousMsgBody2(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("sz", sz);
		_jsonstr.compose("daily", daily);
		_jsonstr.compose("weekly", weekly);
		_jsonstr.compose("monthly", monthly);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("sz", sz);
		_jparser.parseByNameThrow("daily", daily);
		_jparser.parseByNameThrow("weekly", weekly);
		_jparser.parseByNameThrow("monthly", monthly);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_LIMIT_EX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 sz; _jparser.validateByNameThrow("sz", sz);
		AtfValidator::validateInt(_descr, "sz", sz, _checker, __FILE__, __LINE__);
		SelfDepositLimitReplyInfo daily; _jparser.validateByNameThrow("daily", daily);
		SelfDepositLimitReplyInfo weekly; _jparser.validateByNameThrow("weekly", weekly);
		SelfDepositLimitReplyInfo monthly; _jparser.validateByNameThrow("monthly", monthly);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_LIMIT_EX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 sz; _parser.parseUINT32(sz);
		AtfValidator::validateInt(_descr, "sz", sz, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		validateAnonymousMsgBody2(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	daily.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	SelfDepositLimitReplyInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("daily"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	weekly.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	SelfDepositLimitReplyInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("weekly"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	monthly.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	SelfDepositLimitReplyInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("monthly"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::equals(const Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_UNCLEARED_DEPOSITS2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_UNCLEARED_DEPOSITS2).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_UNCLEARED_DEPOSITS2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_UNCLEARED_DEPOSITS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_UNCLEARED_DEPOSITS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierUnclearedDepositBody
//=================================================================

CashierServer::cli::CashierUnclearedDepositBody::CashierUnclearedDepositBody()
{
	clear();
}

void CashierServer::cli::CashierUnclearedDepositBody::clear()
{
	transId = 0;
	psNameTranslated.clear();
	amountUsd = 0;
	whenClear.setNull();
	fppLeftToClear = 0;
	balanceCurrency.clear();
	balanceAmount = 0;
	processorCurrency.clear();
	processorAmount = 0;
}

bool CashierServer::cli::CashierUnclearedDepositBody::equals(const CashierUnclearedDepositBody& _o) const
{
	return transId == _o.transId &&
		Atf::atfPStringEquals(psNameTranslated, _o.psNameTranslated) &&
		amountUsd == _o.amountUsd &&
		whenClear.equals(_o.whenClear) &&
		fppLeftToClear == _o.fppLeftToClear &&
		Atf::atfPStringEquals(balanceCurrency, _o.balanceCurrency) &&
		balanceAmount == _o.balanceAmount &&
		Atf::atfPStringEquals(processorCurrency, _o.processorCurrency) &&
		processorAmount == _o.processorAmount;
}

const char *CashierServer::cli::CashierUnclearedDepositBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("psNameTranslated=");
	_buf.append(psNameTranslated);
	_buf.append(',');
	_buf.append("amountUsd=");
	_buf.appendInt(amountUsd);
	_buf.append(',');
	_buf.append("whenClear=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenClear);
	_buf.append(',');
	_buf.append("fppLeftToClear=");
	_buf.appendInt(fppLeftToClear);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	_buf.append(',');
	_buf.append("balanceAmount=");
	_buf.appendInt(balanceAmount);
	_buf.append(',');
	_buf.append("processorCurrency=");
	_buf.append(processorCurrency);
	_buf.append(',');
	_buf.append("processorAmount=");
	_buf.appendInt(processorAmount);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierUnclearedDepositBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
	Atf::XmlElement::encodeAsXmlElement("psNameTranslated", psNameTranslated, _buf);
	Atf::XmlElement::encodeAsXmlElement("amountUsd", amountUsd, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenClear", whenClear);
	Atf::XmlElement::encodeAsXmlElement("fppLeftToClear", fppLeftToClear, _buf);
	Atf::XmlElement::encodeAsXmlElement("balanceCurrency", balanceCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("balanceAmount", balanceAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("processorCurrency", processorCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("processorAmount", processorAmount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierUnclearedDepositBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("transId"))
		{
			transId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("psNameTranslated"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, psNameTranslated)) return false;
		}
		else if (_element.equals("amountUsd"))
		{
			amountUsd = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenClear"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenClear);
		}
		else if (_element.equals("fppLeftToClear"))
		{
			fppLeftToClear = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("balanceCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, balanceCurrency)) return false;
		}
		else if (_element.equals("balanceAmount"))
		{
			balanceAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("processorCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, processorCurrency)) return false;
		}
		else if (_element.equals("processorAmount"))
		{
			processorAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierUnclearedDepositBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierUnclearedDepositBody())) // not empty
	{
		_body.composeUINT32(transId);
		_body.composeString(psNameTranslated);
		_body.composeINT32(amountUsd);
		_body.composeSrvTime(whenClear);
		_body.composeINT32(fppLeftToClear);
		_body.composeString(balanceCurrency);
		_body.composeINT32(balanceAmount);
		_body.composeString(processorCurrency);
		_body.composeINT32(processorAmount);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierUnclearedDepositBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(transId);
	_parser0.parseStringP(psNameTranslated);
	_parser0.parseINT32(amountUsd);
	_parser0.parseSrvTime(whenClear);
	_parser0.parseINT32(fppLeftToClear);
	_parser0.parseStringP(balanceCurrency);
	_parser0.parseINT32(balanceAmount);
	_parser0.parseStringP(processorCurrency);
	_parser0.parseINT32(processorAmount);
}

const char *CashierServer::cli::CashierUnclearedDepositBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("transId", transId);
	_jsonstr.compose("psNameTranslated", psNameTranslated);
	_jsonstr.compose("amountUsd", amountUsd);
	_jsonstr.compose("whenClear", whenClear);
	_jsonstr.compose("fppLeftToClear", fppLeftToClear);
	_jsonstr.compose("balanceCurrency", balanceCurrency);
	_jsonstr.compose("balanceAmount", balanceAmount);
	_jsonstr.compose("processorCurrency", processorCurrency);
	_jsonstr.compose("processorAmount", processorAmount);
	return _buf.c_str();
}

void CashierServer::cli::CashierUnclearedDepositBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("transId", transId);
	_jparser.parseByNameThrow("psNameTranslated", psNameTranslated);
	_jparser.parseByNameThrow("amountUsd", amountUsd);
	_jparser.parseByNameThrow("whenClear", whenClear);
	_jparser.parseByNameThrow("fppLeftToClear", fppLeftToClear);
	_jparser.parseByNameThrow("balanceCurrency", balanceCurrency);
	_jparser.parseByNameThrow("balanceAmount", balanceAmount);
	_jparser.parseByNameThrow("processorCurrency", processorCurrency);
	_jparser.parseByNameThrow("processorAmount", processorAmount);
}

/* static */ void CashierServer::cli::CashierUnclearedDepositBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 transId; _jparser.validateByNameThrow("transId", transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	PString psNameTranslated; _jparser.validateByNameThrow("psNameTranslated", psNameTranslated);
	AtfValidator::validateInt(_descr, "psNameTranslated", psNameTranslated.length(), _checker, __FILE__, __LINE__);
	INT32 amountUsd; _jparser.validateByNameThrow("amountUsd", amountUsd);
	AtfValidator::validateInt(_descr, "amountUsd", amountUsd, _checker, __FILE__, __LINE__);
	CommSrvTime whenClear; _jparser.validateByNameThrow("whenClear", whenClear);
	AtfValidator::validateSrvDateTime(_descr, "whenClear", whenClear, _checker, __FILE__, __LINE__);
	INT32 fppLeftToClear; _jparser.validateByNameThrow("fppLeftToClear", fppLeftToClear);
	AtfValidator::validateInt(_descr, "fppLeftToClear", fppLeftToClear, _checker, __FILE__, __LINE__);
	PString balanceCurrency; _jparser.validateByNameThrow("balanceCurrency", balanceCurrency);
	AtfValidator::validateInt(_descr, "balanceCurrency", balanceCurrency.length(), _checker, __FILE__, __LINE__);
	INT32 balanceAmount; _jparser.validateByNameThrow("balanceAmount", balanceAmount);
	AtfValidator::validateInt(_descr, "balanceAmount", balanceAmount, _checker, __FILE__, __LINE__);
	PString processorCurrency; _jparser.validateByNameThrow("processorCurrency", processorCurrency);
	AtfValidator::validateInt(_descr, "processorCurrency", processorCurrency.length(), _checker, __FILE__, __LINE__);
	INT32 processorAmount; _jparser.validateByNameThrow("processorAmount", processorAmount);
	AtfValidator::validateInt(_descr, "processorAmount", processorAmount, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierUnclearedDepositBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 transId; _parser0.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "psNameTranslated"); size_t szPsNameTranslated = strlen(_dummy);
	AtfValidator::validateInt(_descr, "psNameTranslated", szPsNameTranslated, _checker, __FILE__, __LINE__);
	INT32 amountUsd; _parser0.parseINT32(amountUsd);
	AtfValidator::validateInt(_descr, "amountUsd", amountUsd, _checker, __FILE__, __LINE__);
	CommSrvTime whenClear; _parser0.parseSrvTime(whenClear);
	AtfValidator::validateSrvDateTime(_descr, "whenClear", whenClear, _checker, __FILE__, __LINE__);
	INT32 fppLeftToClear; _parser0.parseINT32(fppLeftToClear);
	AtfValidator::validateInt(_descr, "fppLeftToClear", fppLeftToClear, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "balanceCurrency", szBalanceCurrency, _checker, __FILE__, __LINE__);
	INT32 balanceAmount; _parser0.parseINT32(balanceAmount);
	AtfValidator::validateInt(_descr, "balanceAmount", balanceAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "processorCurrency"); size_t szProcessorCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "processorCurrency", szProcessorCurrency, _checker, __FILE__, __LINE__);
	INT32 processorAmount; _parser0.parseINT32(processorAmount);
	AtfValidator::validateInt(_descr, "processorAmount", processorAmount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	unclearedDeposits.clear();
	maxNum = 0;
	maxSum = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::equals(const Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		unclearedDeposits.equals(_o.unclearedDeposits) &&
		maxNum == _o.maxNum &&
		maxSum == _o.maxSum;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("unclearedDeposits=");
		unclearedDeposits.toTraceString(_buf);
		_buf.append(',');
		_buf.append("maxNum=");
		_buf.appendUint(maxNum);
		_buf.append(',');
		_buf.append("maxSum=");
		_buf.appendUint(maxSum);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		unclearedDeposits.toXmlString("unclearedDeposits", _buf);
		Atf::XmlElement::encodeAsXmlElement("maxNum", maxNum, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxSum", maxSum, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("unclearedDeposits"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierUnclearedDepositBody, 4 > >::FromXmlString(_value, unclearedDeposits)) return false;
			}
			else if (_element.equals("maxNum"))
			{
				maxNum = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxSum"))
			{
				maxSum = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		unclearedDeposits.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT32(maxNum);
		_msg.composeUINT32(maxSum);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		unclearedDeposits.parseMsg(_parser);
		_parser.parseUINT32(maxNum);
		_parser.parseUINT32(maxSum);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("unclearedDeposits", unclearedDeposits);
		_jsonstr.compose("maxNum", maxNum);
		_jsonstr.compose("maxSum", maxSum);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("unclearedDeposits", unclearedDeposits);
		_jparser.parseByNameThrow("maxNum", maxNum);
		_jparser.parseByNameThrow("maxSum", maxSum);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CashierUnclearedDepositBody > unclearedDeposits; _jparser.validateByNameThrow("unclearedDeposits", unclearedDeposits);
		AtfValidator::validateInt(_descr, "unclearedDeposits", unclearedDeposits.size(), _checker, __FILE__, __LINE__);
		UINT32 maxNum; _jparser.validateByNameThrow("maxNum", maxNum);
		AtfValidator::validateInt(_descr, "maxNum", maxNum, _checker, __FILE__, __LINE__);
		UINT32 maxSum; _jparser.validateByNameThrow("maxSum", maxSum);
		AtfValidator::validateInt(_descr, "maxSum", maxSum, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szUnclearedDeposits = Atf::LAtfVector< CashierUnclearedDepositBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("unclearedDeposits"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "unclearedDeposits", szUnclearedDeposits, _checker, __FILE__, __LINE__);
		UINT32 maxNum; _parser.parseUINT32(maxNum);
		AtfValidator::validateInt(_descr, "maxNum", maxNum, _checker, __FILE__, __LINE__);
		UINT32 maxSum; _parser.parseUINT32(maxSum);
		AtfValidator::validateInt(_descr, "maxSum", maxSum, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_DBT_FIELDS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::Protocol_MSG_CASHIER_GET_DBT_FIELDS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::clear()
{
	userId.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::equals(const Protocol_MSG_CASHIER_GET_DBT_FIELDS& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_DBT_FIELDS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_DBT_FIELDS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_DBT_FIELDS).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_DBT_FIELDS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_DBT_FIELDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_DBT_FIELDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    OneDbtFieldBody
//=================================================================

CashierServer::cli::OneDbtFieldBody::OneDbtFieldBody()
{
	clear();
}

void CashierServer::cli::OneDbtFieldBody::clear()
{
	fieldName.clear();
	localizedDescription.clear();
	fieldValue.clear();
	maxLen = 0;
	flag = 0;
	extra.clear();
	minLen = 0;
}

bool CashierServer::cli::OneDbtFieldBody::equals(const OneDbtFieldBody& _o) const
{
	return Atf::atfPStringEquals(fieldName, _o.fieldName) &&
		Atf::atfPStringEquals(localizedDescription, _o.localizedDescription) &&
		Atf::atfPStringEquals(fieldValue, _o.fieldValue) &&
		maxLen == _o.maxLen &&
		flag == _o.flag &&
		Atf::atfPStringEquals(extra, _o.extra) &&
		minLen == _o.minLen;
}

const char *CashierServer::cli::OneDbtFieldBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fieldName=");
	_buf.append(fieldName);
	_buf.append(',');
	_buf.append("localizedDescription=");
	_buf.append(localizedDescription);
	_buf.append(',');
	_buf.append("fieldValue=");
	_buf.append(fieldValue);
	_buf.append(',');
	_buf.append("maxLen=");
	_buf.appendUint(maxLen);
	_buf.append(',');
	_buf.append("flag=");
	_buf.appendUint(flag);
	_buf.append(',');
	_buf.append("extra=");
	_buf.append(extra);
	_buf.append(',');
	_buf.append("minLen=");
	_buf.appendUint(minLen);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::OneDbtFieldBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("fieldName", fieldName, _buf);
	Atf::XmlElement::encodeAsXmlElement("localizedDescription", localizedDescription, _buf);
	Atf::XmlElement::encodeAsXmlElement("fieldValue", fieldValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxLen", maxLen, _buf);
	Atf::XmlElement::encodeAsXmlElement("flag", flag, _buf);
	Atf::XmlElement::encodeAsXmlElement("extra", extra, _buf);
	Atf::XmlElement::encodeAsXmlElement("minLen", minLen, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::OneDbtFieldBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("fieldName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, fieldName)) return false;
		}
		else if (_element.equals("localizedDescription"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, localizedDescription)) return false;
		}
		else if (_element.equals("fieldValue"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, fieldValue)) return false;
		}
		else if (_element.equals("maxLen"))
		{
			maxLen = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flag"))
		{
			flag = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("extra"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, extra)) return false;
		}
		else if (_element.equals("minLen"))
		{
			minLen = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::OneDbtFieldBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(OneDbtFieldBody())) // not empty
	{
		_body.composeString(fieldName);
		_body.composeString(localizedDescription);
		_body.composeString(fieldValue);
		_body.composeUINT32(maxLen);
		_body.composeUINT32(flag);
		_body.composeString(extra);
		_body.composeUINT32(minLen);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::OneDbtFieldBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(fieldName);
	_parser0.parseStringP(localizedDescription);
	_parser0.parseStringP(fieldValue);
	_parser0.parseUINT32(maxLen);
	_parser0.parseUINT32(flag);
	_parser0.parseStringP(extra);
	_parser0.parseUINT32(minLen);
}

const char *CashierServer::cli::OneDbtFieldBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("fieldName", fieldName);
	_jsonstr.compose("localizedDescription", localizedDescription);
	_jsonstr.compose("fieldValue", fieldValue);
	_jsonstr.compose("maxLen", maxLen);
	_jsonstr.compose("flag", flag);
	_jsonstr.compose("extra", extra);
	_jsonstr.compose("minLen", minLen);
	return _buf.c_str();
}

void CashierServer::cli::OneDbtFieldBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("fieldName", fieldName);
	_jparser.parseByNameThrow("localizedDescription", localizedDescription);
	_jparser.parseByNameThrow("fieldValue", fieldValue);
	_jparser.parseByNameThrow("maxLen", maxLen);
	_jparser.parseByNameThrow("flag", flag);
	_jparser.parseByNameThrow("extra", extra);
	_jparser.parseByNameThrow("minLen", minLen);
}

/* static */ void CashierServer::cli::OneDbtFieldBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString fieldName; _jparser.validateByNameThrow("fieldName", fieldName);
	AtfValidator::validateInt(_descr, "fieldName", fieldName.length(), _checker, __FILE__, __LINE__);
	PString localizedDescription; _jparser.validateByNameThrow("localizedDescription", localizedDescription);
	AtfValidator::validateInt(_descr, "localizedDescription", localizedDescription.length(), _checker, __FILE__, __LINE__);
	PString fieldValue; _jparser.validateByNameThrow("fieldValue", fieldValue);
	AtfValidator::validateInt(_descr, "fieldValue", fieldValue.length(), _checker, __FILE__, __LINE__);
	UINT32 maxLen; _jparser.validateByNameThrow("maxLen", maxLen);
	AtfValidator::validateInt(_descr, "maxLen", maxLen, _checker, __FILE__, __LINE__);
	UINT32 flag; _jparser.validateByNameThrow("flag", flag);
	AtfValidator::validateInt(_descr, "flag", flag, _checker, __FILE__, __LINE__);
	PString extra; _jparser.validateByNameThrow("extra", extra);
	AtfValidator::validateInt(_descr, "extra", extra.length(), _checker, __FILE__, __LINE__);
	UINT32 minLen; _jparser.validateByNameThrow("minLen", minLen);
	AtfValidator::validateInt(_descr, "minLen", minLen, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::OneDbtFieldBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "fieldName"); size_t szFieldName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "fieldName", szFieldName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "localizedDescription"); size_t szLocalizedDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "localizedDescription", szLocalizedDescription, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "fieldValue"); size_t szFieldValue = strlen(_dummy);
	AtfValidator::validateInt(_descr, "fieldValue", szFieldValue, _checker, __FILE__, __LINE__);
	UINT32 maxLen; _parser0.parseUINT32(maxLen);
	AtfValidator::validateInt(_descr, "maxLen", maxLen, _checker, __FILE__, __LINE__);
	UINT32 flag; _parser0.parseUINT32(flag);
	AtfValidator::validateInt(_descr, "flag", flag, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "extra"); size_t szExtra = strlen(_dummy);
	AtfValidator::validateInt(_descr, "extra", szExtra, _checker, __FILE__, __LINE__);
	UINT32 minLen; _parser0.parseUINT32(minLen);
	AtfValidator::validateInt(_descr, "minLen", minLen, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	dbtFields.clear();
	currencies.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::equals(const Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		dbtFields.equals(_o.dbtFields) &&
		currencies.equals(_o.currencies);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_DBT_FIELDS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_DBT_FIELDS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("dbtFields=");
		dbtFields.toTraceString(_buf);
		_buf.append(',');
		_buf.append("currencies=");
		currencies.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_DBT_FIELDS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		dbtFields.toXmlString("dbtFields", _buf);
		currencies.toXmlString("currencies", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("dbtFields"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< OneDbtFieldBody, 4 > >::FromXmlString(_value, dbtFields)) return false;
			}
			else if (_element.equals("currencies"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, currencies)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		dbtFields.composeMsg(_msg, _ignoreJSON);
		currencies.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		dbtFields.parseMsg(_parser);
		currencies.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("dbtFields", dbtFields);
		_jsonstr.compose("currencies", currencies);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("dbtFields", dbtFields);
		_jparser.parseByNameThrow("currencies", currencies);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_DBT_FIELDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< OneDbtFieldBody > dbtFields; _jparser.validateByNameThrow("dbtFields", dbtFields);
		AtfValidator::validateInt(_descr, "dbtFields", dbtFields.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< PString > currencies; _jparser.validateByNameThrow("currencies", currencies);
		AtfValidator::validateInt(_descr, "currencies", currencies.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_DBT_FIELDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szDbtFields = Atf::LAtfVector< OneDbtFieldBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("dbtFields"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "dbtFields", szDbtFields, _checker, __FILE__, __LINE__);
		int szCurrencies = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("currencies"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "currencies", szCurrencies, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    DbtValidateFieldBody
//=================================================================

CashierServer::cli::DbtValidateFieldBody::DbtValidateFieldBody()
{
	clear();
}

void CashierServer::cli::DbtValidateFieldBody::clear()
{
	fieldName.clear();
	fieldValue.clear();
}

bool CashierServer::cli::DbtValidateFieldBody::equals(const DbtValidateFieldBody& _o) const
{
	return Atf::atfPStringEquals(fieldName, _o.fieldName) &&
		Atf::atfPStringEquals(fieldValue, _o.fieldValue);
}

const char *CashierServer::cli::DbtValidateFieldBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fieldName=");
	_buf.append(fieldName);
	_buf.append(',');
	_buf.append("fieldValue=");
	_buf.append(fieldValue);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::DbtValidateFieldBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("fieldName", fieldName, _buf);
	Atf::XmlElement::encodeAsXmlElement("fieldValue", fieldValue, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::DbtValidateFieldBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("fieldName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, fieldName)) return false;
		}
		else if (_element.equals("fieldValue"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, fieldValue)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::DbtValidateFieldBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(DbtValidateFieldBody())) // not empty
	{
		_body.composeString(fieldName);
		_body.composeString(fieldValue);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::DbtValidateFieldBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(fieldName);
	_parser0.parseStringP(fieldValue);
}

const char *CashierServer::cli::DbtValidateFieldBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("fieldName", fieldName);
	_jsonstr.compose("fieldValue", fieldValue);
	return _buf.c_str();
}

void CashierServer::cli::DbtValidateFieldBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("fieldName", fieldName);
	_jparser.parseByNameThrow("fieldValue", fieldValue);
}

/* static */ void CashierServer::cli::DbtValidateFieldBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString fieldName; _jparser.validateByNameThrow("fieldName", fieldName);
	AtfValidator::validateIntMax(_descr, "fieldName", fieldName.length(), 100, _checker, __FILE__, __LINE__);
	PString fieldValue; _jparser.validateByNameThrow("fieldValue", fieldValue);
	AtfValidator::validateIntMax(_descr, "fieldValue", fieldValue.length(), 300, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::DbtValidateFieldBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "fieldName"); size_t szFieldName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fieldName", szFieldName, 100, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "fieldValue"); size_t szFieldValue = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fieldValue", szFieldValue, 300, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_DBT_VALIDATE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::Protocol_MSG_CASHIER_DBT_VALIDATE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::clear()
{
	userId.clear();
	currency.clear();
	fields.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::equals(const Protocol_MSG_CASHIER_DBT_VALIDATE& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		fields.equals(_o.fields);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_DBT_VALIDATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_DBT_VALIDATE*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DBT_VALIDATE).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("fields=");
	fields.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_DBT_VALIDATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	fields.toXmlString("fields", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("fields"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< DbtValidateFieldBody, 4 > >::FromXmlString(_value, fields)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeString(currency);
	fields.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseStringP(currency);
	fields.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("fields", fields);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("fields", fields);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DBT_VALIDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< DbtValidateFieldBody > fields; _jparser.validateByNameThrow("fields", fields);
	AtfValidator::validateIntMax(_descr, "fields", fields.size(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DBT_VALIDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szFields = Atf::LAtfVector< DbtValidateFieldBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("fields"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "fields", szFields, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::clear()
{
	errCode = 0;
	errReplyInfo.clear();
	eDbtWireBankValNoError = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::equals(const Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errReplyInfo, _o.errReplyInfo) &&
		eDbtWireBankValNoError == _o.eDbtWireBankValNoError;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_DBT_VALIDATE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DBT_VALIDATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errReplyInfo=");
	_buf.append(errReplyInfo);
	_buf.append(',');
	_buf.append("eDbtWireBankValNoError=");
	_buf.appendInt(eDbtWireBankValNoError);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_DBT_VALIDATE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errReplyInfo", errReplyInfo, _buf);
	Atf::XmlElement::encodeAsXmlElement("eDbtWireBankValNoError", eDbtWireBankValNoError, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errReplyInfo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errReplyInfo)) return false;
			}
			else if (_element.equals("eDbtWireBankValNoError"))
			{
				eDbtWireBankValNoError = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errReplyInfo);
	_msg.composeINT16(eDbtWireBankValNoError);
}

void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errReplyInfo);
	_parser.parseINT16(eDbtWireBankValNoError);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errReplyInfo", errReplyInfo);
	_jsonstr.compose("eDbtWireBankValNoError", eDbtWireBankValNoError);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errReplyInfo", errReplyInfo);
	_jparser.parseByNameThrow("eDbtWireBankValNoError", eDbtWireBankValNoError);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DBT_VALIDATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errReplyInfo; _jparser.validateByNameThrow("errReplyInfo", errReplyInfo);
	AtfValidator::validateInt(_descr, "errReplyInfo", errReplyInfo.length(), _checker, __FILE__, __LINE__);
	INT16 eDbtWireBankValNoError; _jparser.validateByNameThrow("eDbtWireBankValNoError", eDbtWireBankValNoError);
	AtfValidator::validateInt(_descr, "eDbtWireBankValNoError", eDbtWireBankValNoError, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DBT_VALIDATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errReplyInfo"); size_t szErrReplyInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errReplyInfo", szErrReplyInfo, _checker, __FILE__, __LINE__);
	INT16 eDbtWireBankValNoError; _parser.parseINT16(eDbtWireBankValNoError);
	AtfValidator::validateInt(_descr, "eDbtWireBankValNoError", eDbtWireBankValNoError, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_AVLS_REQUEST
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::Protocol_MSG_CASHIER_AVLS_REQUEST()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::clear()
{
	requestType = 0;
	userId.clear();
	phoneToContact.clear();
	timeToContact.clear();
	avSystem = 0;
	resultId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::equals(const Protocol_MSG_CASHIER_AVLS_REQUEST& _o) const
{
	return requestType == _o.requestType &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(phoneToContact, _o.phoneToContact) &&
		Atf::atfPStringEquals(timeToContact, _o.timeToContact) &&
		avSystem == _o.avSystem &&
		resultId == _o.resultId;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_AVLS_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_AVLS_REQUEST*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_AVLS_REQUEST).append(")");
	_buf.append(',');
	_buf.append("requestType=");
	_buf.appendUint(requestType);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("phoneToContact=");
	_buf.append(phoneToContact);
	_buf.append(',');
	_buf.append("timeToContact=");
	_buf.append(timeToContact);
	_buf.append(',');
	_buf.append("avSystem=");
	_buf.appendUint(avSystem);
	_buf.append(',');
	_buf.append("resultId=");
	_buf.appendUint(resultId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_AVLS_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestType", requestType, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("phoneToContact", phoneToContact, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeToContact", timeToContact, _buf);
	Atf::XmlElement::encodeAsXmlElement("avSystem", avSystem, _buf);
	Atf::XmlElement::encodeAsXmlElement("resultId", resultId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestType"))
			{
				requestType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("phoneToContact"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, phoneToContact)) return false;
			}
			else if (_element.equals("timeToContact"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, timeToContact)) return false;
			}
			else if (_element.equals("avSystem"))
			{
				avSystem = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("resultId"))
			{
				resultId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(requestType);
	_msg.composeString(userId);
	_msg.composeString(phoneToContact);
	_msg.composeString(timeToContact);
	_msg.composeUINT32(avSystem);
	_msg.composeUINT32(resultId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(requestType);
	_parser.parseStringP(userId);
	_parser.parseStringP(phoneToContact);
	_parser.parseStringP(timeToContact);
	_parser.parseUINT32(avSystem);
	_parser.parseUINT32(resultId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestType", requestType);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("phoneToContact", phoneToContact);
	_jsonstr.compose("timeToContact", timeToContact);
	_jsonstr.compose("avSystem", avSystem);
	_jsonstr.compose("resultId", resultId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestType", requestType);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("phoneToContact", phoneToContact);
	_jparser.parseByNameThrow("timeToContact", timeToContact);
	_jparser.parseByNameThrow("avSystem", avSystem);
	_jparser.parseByNameThrow("resultId", resultId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AVLS_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 requestType; _jparser.validateByNameThrow("requestType", requestType);
	{ const UINT32 requestType_enum[] = { eLiveSupportRequestChat, eLiveSupportRequestPhone, eLiveSupportRequestNone, eLiveSupportRequestEmail, eLiveSupportRequestIndirect }; AtfValidator::validateEnum(_descr, "requestType", requestType, requestType_enum, _checker, __FILE__, __LINE__); }
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString phoneToContact; _jparser.validateByNameThrow("phoneToContact", phoneToContact);
	AtfValidator::validateIntMax(_descr, "phoneToContact", phoneToContact.length(), 100, _checker, __FILE__, __LINE__);
	PString timeToContact; _jparser.validateByNameThrow("timeToContact", timeToContact);
	AtfValidator::validateIntMax(_descr, "timeToContact", timeToContact.length(), 1000, _checker, __FILE__, __LINE__);
	UINT32 avSystem; _jparser.validateByNameThrow("avSystem", avSystem);
	{ const UINT32 avSystem_enum[] = { eAgeVerificationSystemAristotle, eAgeVerificationSystemURU }; AtfValidator::validateEnum(_descr, "avSystem", avSystem, avSystem_enum, _checker, __FILE__, __LINE__); }
	UINT32 resultId; _jparser.validateByNameThrow("resultId", resultId);
	AtfValidator::validateInt(_descr, "resultId", resultId, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AVLS_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 requestType; _parser.parseUINT32(requestType);
	{ const UINT32 requestType_enum[] = { eLiveSupportRequestChat, eLiveSupportRequestPhone, eLiveSupportRequestNone, eLiveSupportRequestEmail, eLiveSupportRequestIndirect }; AtfValidator::validateEnum(_descr, "requestType", requestType, requestType_enum, _checker, __FILE__, __LINE__); }
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "phoneToContact"); size_t szPhoneToContact = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phoneToContact", szPhoneToContact, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "timeToContact"); size_t szTimeToContact = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "timeToContact", szTimeToContact, 1000, _checker, __FILE__, __LINE__);
	UINT32 avSystem; _parser.parseUINT32(avSystem);
	{ const UINT32 avSystem_enum[] = { eAgeVerificationSystemAristotle, eAgeVerificationSystemURU }; AtfValidator::validateEnum(_descr, "avSystem", avSystem, avSystem_enum, _checker, __FILE__, __LINE__); }
	UINT32 resultId; _parser.parseUINT32(resultId);
	AtfValidator::validateInt(_descr, "resultId", resultId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	requestType = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::equals(const Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		requestType == _o.requestType;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_AVLS_REQUEST_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_AVLS_REQUEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("requestType=");
		_buf.appendUint(requestType);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_AVLS_REQUEST_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("requestType", requestType, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("requestType"))
			{
				requestType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(requestType);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(requestType);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("requestType", requestType);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("requestType", requestType);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AVLS_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 requestType; _jparser.validateByNameThrow("requestType", requestType);
		AtfValidator::validateInt(_descr, "requestType", requestType, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AVLS_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 requestType; _parser.parseUINT32(requestType);
		AtfValidator::validateInt(_descr, "requestType", requestType, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::clear()
{
	includeHoldStatus_obsolete = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::equals(const Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS& _o) const
{
	return includeHoldStatus_obsolete == _o.includeHoldStatus_obsolete;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_PENDING_CASHOUTS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_PENDING_CASHOUTS).append(")");
	_buf.append(',');
	_buf.append("includeHoldStatus_obsolete=");
	_buf.appendUint(includeHoldStatus_obsolete);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_PENDING_CASHOUTS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("includeHoldStatus_obsolete", includeHoldStatus_obsolete, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("includeHoldStatus_obsolete"))
			{
				includeHoldStatus_obsolete = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(includeHoldStatus_obsolete);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(includeHoldStatus_obsolete);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("includeHoldStatus_obsolete", includeHoldStatus_obsolete);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("includeHoldStatus_obsolete", includeHoldStatus_obsolete);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PENDING_CASHOUTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool includeHoldStatus_obsolete; _jparser.validateByNameThrow("includeHoldStatus_obsolete", includeHoldStatus_obsolete);
	AtfValidator::validateInt(_descr, "includeHoldStatus_obsolete", includeHoldStatus_obsolete, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PENDING_CASHOUTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool includeHoldStatus_obsolete; _parser.parseBOOL(includeHoldStatus_obsolete);
	AtfValidator::validateInt(_descr, "includeHoldStatus_obsolete", includeHoldStatus_obsolete, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    OneTransBody
//=================================================================

CashierServer::cli::OneTransBody::OneTransBody()
{
	clear();
}

void CashierServer::cli::OneTransBody::clear()
{
	transId = 0;
	psForCashout.clear();
	returnedAmount = 0;
	currency.clear();
	converted = 0;
	started.setNull();
	status.clear();
	balanceCurrency.clear();
	canBeCancelled = false;
	cardTypeByte = 0;
	maskedReference.clear();
}

bool CashierServer::cli::OneTransBody::equals(const OneTransBody& _o) const
{
	return transId == _o.transId &&
		Atf::atfPStringEquals(psForCashout, _o.psForCashout) &&
		returnedAmount == _o.returnedAmount &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		converted == _o.converted &&
		started.equals(_o.started) &&
		Atf::atfPStringEquals(status, _o.status) &&
		Atf::atfPStringEquals(balanceCurrency, _o.balanceCurrency) &&
		canBeCancelled == _o.canBeCancelled &&
		cardTypeByte == _o.cardTypeByte &&
		Atf::atfPStringEquals(maskedReference, _o.maskedReference);
}

const char *CashierServer::cli::OneTransBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("psForCashout=");
	_buf.append(psForCashout);
	_buf.append(',');
	_buf.append("returnedAmount=");
	_buf.appendInt(returnedAmount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("converted=");
	_buf.appendInt(converted);
	_buf.append(',');
	_buf.append("started=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, started);
	_buf.append(',');
	_buf.append("status=");
	_buf.append(status);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	_buf.append(',');
	_buf.append("canBeCancelled=");
	_buf.appendUint(canBeCancelled);
	_buf.append(',');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	_buf.append(',');
	_buf.append("maskedReference=");
	_buf.append(maskedReference);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::OneTransBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
	Atf::XmlElement::encodeAsXmlElement("psForCashout", psForCashout, _buf);
	Atf::XmlElement::encodeAsXmlElement("returnedAmount", returnedAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("converted", converted, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "started", started);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("balanceCurrency", balanceCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("canBeCancelled", canBeCancelled, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardTypeByte", cardTypeByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("maskedReference", maskedReference, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::OneTransBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("transId"))
		{
			transId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("psForCashout"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, psForCashout)) return false;
		}
		else if (_element.equals("returnedAmount"))
		{
			returnedAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("converted"))
		{
			converted = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("started"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, started);
		}
		else if (_element.equals("status"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, status)) return false;
		}
		else if (_element.equals("balanceCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, balanceCurrency)) return false;
		}
		else if (_element.equals("canBeCancelled"))
		{
			canBeCancelled = (*_value.ptr() == '1');
		}
		else if (_element.equals("cardTypeByte"))
		{
			cardTypeByte = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maskedReference"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, maskedReference)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::OneTransBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(OneTransBody())) // not empty
	{
		_body.composeUINT32(transId);
		_body.composeString(psForCashout);
		_body.composeINT32(returnedAmount);
		_body.composeString(currency);
		_body.composeINT32(converted);
		_body.composeSrvTime(started);
		_body.composeString(status);
		_body.composeString(balanceCurrency);
		_body.composeBOOL(canBeCancelled);
		_body.composeBYTE(cardTypeByte);
		_body.composeString(maskedReference);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::OneTransBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(transId);
	_parser0.parseStringP(psForCashout);
	_parser0.parseINT32(returnedAmount);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(converted);
	_parser0.parseSrvTime(started);
	_parser0.parseStringP(status);
	_parser0.parseStringP(balanceCurrency);
	_parser0.parseBOOL(canBeCancelled);
	_parser0.parseBYTE(cardTypeByte);
	_parser0.parseStringP(maskedReference);
}

const char *CashierServer::cli::OneTransBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("transId", transId);
	_jsonstr.compose("psForCashout", psForCashout);
	_jsonstr.compose("returnedAmount", returnedAmount);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("converted", converted);
	_jsonstr.compose("started", started);
	_jsonstr.compose("status", status);
	_jsonstr.compose("balanceCurrency", balanceCurrency);
	_jsonstr.compose("canBeCancelled", canBeCancelled);
	_jsonstr.compose("cardTypeByte", cardTypeByte);
	_jsonstr.compose("maskedReference", maskedReference);
	return _buf.c_str();
}

void CashierServer::cli::OneTransBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("transId", transId);
	_jparser.parseByNameThrow("psForCashout", psForCashout);
	_jparser.parseByNameThrow("returnedAmount", returnedAmount);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("converted", converted);
	_jparser.parseByNameThrow("started", started);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("balanceCurrency", balanceCurrency);
	_jparser.parseByNameThrow("canBeCancelled", canBeCancelled);
	_jparser.parseByNameThrow("cardTypeByte", cardTypeByte);
	_jparser.parseByNameThrow("maskedReference", maskedReference);
}

/* static */ void CashierServer::cli::OneTransBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 transId; _jparser.validateByNameThrow("transId", transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	PString psForCashout; _jparser.validateByNameThrow("psForCashout", psForCashout);
	AtfValidator::validateInt(_descr, "psForCashout", psForCashout.length(), _checker, __FILE__, __LINE__);
	INT32 returnedAmount; _jparser.validateByNameThrow("returnedAmount", returnedAmount);
	AtfValidator::validateInt(_descr, "returnedAmount", returnedAmount, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 converted; _jparser.validateByNameThrow("converted", converted);
	AtfValidator::validateInt(_descr, "converted", converted, _checker, __FILE__, __LINE__);
	CommSrvTime started; _jparser.validateByNameThrow("started", started);
	AtfValidator::validateSrvDateTime(_descr, "started", started, _checker, __FILE__, __LINE__);
	PString status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status.length(), _checker, __FILE__, __LINE__);
	PString balanceCurrency; _jparser.validateByNameThrow("balanceCurrency", balanceCurrency);
	AtfValidator::validateInt(_descr, "balanceCurrency", balanceCurrency.length(), _checker, __FILE__, __LINE__);
	bool canBeCancelled; _jparser.validateByNameThrow("canBeCancelled", canBeCancelled);
	AtfValidator::validateInt(_descr, "canBeCancelled", canBeCancelled, _checker, __FILE__, __LINE__);
	BYTE cardTypeByte; _jparser.validateByNameThrow("cardTypeByte", cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	PString maskedReference; _jparser.validateByNameThrow("maskedReference", maskedReference);
	AtfValidator::validateInt(_descr, "maskedReference", maskedReference.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::OneTransBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 transId; _parser0.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "psForCashout"); size_t szPsForCashout = strlen(_dummy);
	AtfValidator::validateInt(_descr, "psForCashout", szPsForCashout, _checker, __FILE__, __LINE__);
	INT32 returnedAmount; _parser0.parseINT32(returnedAmount);
	AtfValidator::validateInt(_descr, "returnedAmount", returnedAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 converted; _parser0.parseINT32(converted);
	AtfValidator::validateInt(_descr, "converted", converted, _checker, __FILE__, __LINE__);
	CommSrvTime started; _parser0.parseSrvTime(started);
	AtfValidator::validateSrvDateTime(_descr, "started", started, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "status"); size_t szStatus = strlen(_dummy);
	AtfValidator::validateInt(_descr, "status", szStatus, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "balanceCurrency", szBalanceCurrency, _checker, __FILE__, __LINE__);
	bool canBeCancelled; _parser0.parseBOOL(canBeCancelled);
	AtfValidator::validateInt(_descr, "canBeCancelled", canBeCancelled, _checker, __FILE__, __LINE__);
	BYTE cardTypeByte; _parser0.parseBYTE(cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "maskedReference"); size_t szMaskedReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "maskedReference", szMaskedReference, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::clear()
{
	cashoutTransactions.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::equals(const Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY& _o) const
{
	return cashoutTransactions.equals(_o.cashoutTransactions);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("cashoutTransactions=");
	cashoutTransactions.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	cashoutTransactions.toXmlString("cashoutTransactions", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("cashoutTransactions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< OneTransBody, 4 > >::FromXmlString(_value, cashoutTransactions)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	cashoutTransactions.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	cashoutTransactions.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cashoutTransactions", cashoutTransactions);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cashoutTransactions", cashoutTransactions);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< OneTransBody > cashoutTransactions; _jparser.validateByNameThrow("cashoutTransactions", cashoutTransactions);
	AtfValidator::validateInt(_descr, "cashoutTransactions", cashoutTransactions.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szCashoutTransactions = Atf::LAtfVector< OneTransBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cashoutTransactions"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cashoutTransactions", szCashoutTransactions, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::clear()
{
	idsToCancel.clear();
	bonusCode.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::equals(const Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS& _o) const
{
	return idsToCancel.equals(_o.idsToCancel) &&
		Atf::atfPStringEquals(bonusCode, _o.bonusCode);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CANCEL_PENDING_CASHOUTS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CANCEL_PENDING_CASHOUTS).append(")");
	_buf.append(',');
	_buf.append("idsToCancel=");
	idsToCancel.toTraceString(_buf);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CANCEL_PENDING_CASHOUTS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	idsToCancel.toXmlString("idsToCancel", _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusCode", bonusCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("idsToCancel"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, idsToCancel)) return false;
			}
			else if (_element.equals("bonusCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bonusCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	idsToCancel.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(bonusCode);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::parseMsg(CommMsgParser& _parser)
{
	idsToCancel.parseMsg(_parser);
	_parser.parseStringP(bonusCode);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("idsToCancel", idsToCancel);
	_jsonstr.compose("bonusCode", bonusCode);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("idsToCancel", idsToCancel);
	_jparser.parseByNameThrow("bonusCode", bonusCode);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CANCEL_PENDING_CASHOUTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< UINT32 > idsToCancel; _jparser.validateByNameThrow("idsToCancel", idsToCancel);
	AtfValidator::validateIntMax(_descr, "idsToCancel", idsToCancel.size(), 10000, _checker, __FILE__, __LINE__);
	PString bonusCode; _jparser.validateByNameThrow("bonusCode", bonusCode);
	AtfValidator::validateIntMax(_descr, "bonusCode", bonusCode.length(), BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CANCEL_PENDING_CASHOUTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	PString _descbuf;
	int szIdsToCancel = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("idsToCancel"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "idsToCancel", szIdsToCancel, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PendingCashoutStatus
//=================================================================

CashierServer::cli::PendingCashoutStatus::PendingCashoutStatus()
{
	clear();
}

void CashierServer::cli::PendingCashoutStatus::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::PendingCashoutStatus::equals(const PendingCashoutStatus& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

const char *CashierServer::cli::PendingCashoutStatus::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::PendingCashoutStatus::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::PendingCashoutStatus::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("errCode"))
		{
			errCode = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errDescr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::PendingCashoutStatus::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
}

void CashierServer::cli::PendingCashoutStatus::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
}

const char *CashierServer::cli::PendingCashoutStatus::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errDescr", errDescr);
	return _buf.c_str();
}

void CashierServer::cli::PendingCashoutStatus::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errDescr", errDescr);
}

/* static */ void CashierServer::cli::PendingCashoutStatus::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
	AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::PendingCashoutStatus::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	cashoutStatuses.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::equals(const Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		cashoutStatuses.equals(_o.cashoutStatuses);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("cashoutStatuses=");
		cashoutStatuses.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		cashoutStatuses.toXmlString("cashoutStatuses", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("cashoutStatuses"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PendingCashoutStatus, 4 > >::FromXmlString(_value, cashoutStatuses)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		cashoutStatuses.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		cashoutStatuses.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("cashoutStatuses", cashoutStatuses);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("cashoutStatuses", cashoutStatuses);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< PendingCashoutStatus > cashoutStatuses; _jparser.validateByNameThrow("cashoutStatuses", cashoutStatuses);
		AtfValidator::validateInt(_descr, "cashoutStatuses", cashoutStatuses.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szCashoutStatuses = Atf::LAtfVector< PendingCashoutStatus, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cashoutStatuses"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "cashoutStatuses", szCashoutStatuses, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::clear()
{
	procCurrency.clear();
	forAllCurrencies = false;
	paysystemByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::equals(const Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS& _o) const
{
	return Atf::atfPStringEquals(procCurrency, _o.procCurrency) &&
		forAllCurrencies == _o.forAllCurrencies &&
		paysystemByte == _o.paysystemByte;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_ENVOY_LBT_GET_BANKS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ENVOY_LBT_GET_BANKS).append(")");
	_buf.append(',');
	_buf.append("procCurrency=");
	_buf.append(procCurrency);
	_buf.append(',');
	_buf.append("forAllCurrencies=");
	_buf.appendUint(forAllCurrencies);
	_buf.append(',');
	_buf.append("paysystemByte=");
	_buf.appendUint(paysystemByte);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_ENVOY_LBT_GET_BANKS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("procCurrency", procCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("forAllCurrencies", forAllCurrencies, _buf);
	Atf::XmlElement::encodeAsXmlElement("paysystemByte", paysystemByte, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("procCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, procCurrency)) return false;
			}
			else if (_element.equals("forAllCurrencies"))
			{
				forAllCurrencies = (*_value.ptr() == '1');
			}
			else if (_element.equals("paysystemByte"))
			{
				paysystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(procCurrency);
	_msg.composeBOOL(forAllCurrencies);
	_msg.composeBYTE(paysystemByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(procCurrency);
	_parser.parseBOOL(forAllCurrencies);
	_parser.parseBYTE(paysystemByte);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("procCurrency", procCurrency);
	_jsonstr.compose("forAllCurrencies", forAllCurrencies);
	_jsonstr.compose("paysystemByte", paysystemByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("procCurrency", procCurrency);
	_jparser.parseByNameThrow("forAllCurrencies", forAllCurrencies);
	_jparser.parseByNameThrow("paysystemByte", paysystemByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ENVOY_LBT_GET_BANKS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString procCurrency; _jparser.validateByNameThrow("procCurrency", procCurrency);
	AtfValidator::validateIntMax(_descr, "procCurrency", procCurrency.length(), 100, _checker, __FILE__, __LINE__);
	bool forAllCurrencies; _jparser.validateByNameThrow("forAllCurrencies", forAllCurrencies);
	AtfValidator::validateInt(_descr, "forAllCurrencies", forAllCurrencies, _checker, __FILE__, __LINE__);
	BYTE paysystemByte; _jparser.validateByNameThrow("paysystemByte", paysystemByte);
	AtfValidator::validateIntRange(_descr, "paysystemByte", paysystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ENVOY_LBT_GET_BANKS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "procCurrency"); size_t szProcCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "procCurrency", szProcCurrency, 100, _checker, __FILE__, __LINE__);
	bool forAllCurrencies; _parser.parseBOOL(forAllCurrencies);
	AtfValidator::validateInt(_descr, "forAllCurrencies", forAllCurrencies, _checker, __FILE__, __LINE__);
	BYTE paysystemByte; _parser.parseBYTE(paysystemByte);
	AtfValidator::validateIntRange(_descr, "paysystemByte", paysystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    EnvoyBankInfoBody
//=================================================================

CashierServer::cli::EnvoyBankInfoBody::EnvoyBankInfoBody()
{
	clear();
}

void CashierServer::cli::EnvoyBankInfoBody::clear()
{
	bankrefId = 0;
	currency.clear();
	name.clear();
	city.clear();
	address.clear();
	swift.clear();
	url.clear();
	accountNum.clear();
	iban.clear();
	benficiary.clear();
	extraInfo.clear();
	preferred = false;
	paysystem.clear();
	bankId.clear();
	comment.clear();
	flags = 0;
	country.clear();
}

bool CashierServer::cli::EnvoyBankInfoBody::equals(const EnvoyBankInfoBody& _o) const
{
	return bankrefId == _o.bankrefId &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(address, _o.address) &&
		Atf::atfPStringEquals(swift, _o.swift) &&
		Atf::atfPStringEquals(url, _o.url) &&
		Atf::atfPStringEquals(accountNum, _o.accountNum) &&
		Atf::atfPStringEquals(iban, _o.iban) &&
		Atf::atfPStringEquals(benficiary, _o.benficiary) &&
		Atf::atfPStringEquals(extraInfo, _o.extraInfo) &&
		preferred == _o.preferred &&
		Atf::atfPStringEquals(paysystem, _o.paysystem) &&
		Atf::atfPStringEquals(bankId, _o.bankId) &&
		Atf::atfPStringEquals(comment, _o.comment) &&
		flags == _o.flags &&
		Atf::atfPStringEquals(country, _o.country);
}

const char *CashierServer::cli::EnvoyBankInfoBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("bankrefId=");
	_buf.appendUint(bankrefId);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("swift=");
	_buf.append(swift);
	_buf.append(',');
	_buf.append("url=");
	_buf.append(url);
	_buf.append(',');
	_buf.append("accountNum=");
	_buf.append(accountNum);
	_buf.append(',');
	_buf.append("iban=");
	_buf.append(iban);
	_buf.append(',');
	_buf.append("benficiary=");
	_buf.append(benficiary);
	_buf.append(',');
	_buf.append("extraInfo=");
	_buf.append(extraInfo);
	_buf.append(',');
	_buf.append("preferred=");
	_buf.appendUint(preferred);
	_buf.append(',');
	_buf.append("paysystem=");
	_buf.append(paysystem);
	_buf.append(',');
	_buf.append("bankId=");
	_buf.append(bankId);
	_buf.append(',');
	_buf.append("comment=");
	_buf.append(comment);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::EnvoyBankInfoBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("bankrefId", bankrefId, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::encodeAsXmlElement("address", address, _buf);
	Atf::XmlElement::encodeAsXmlElement("swift", swift, _buf);
	Atf::XmlElement::encodeAsXmlElement("url", url, _buf);
	Atf::XmlElement::encodeAsXmlElement("accountNum", accountNum, _buf);
	Atf::XmlElement::encodeAsXmlElement("iban", iban, _buf);
	Atf::XmlElement::encodeAsXmlElement("benficiary", benficiary, _buf);
	Atf::XmlElement::encodeAsXmlElement("extraInfo", extraInfo, _buf);
	Atf::XmlElement::encodeAsXmlElement("preferred", preferred, _buf);
	Atf::XmlElement::encodeAsXmlElement("paysystem", paysystem, _buf);
	Atf::XmlElement::encodeAsXmlElement("bankId", bankId, _buf);
	Atf::XmlElement::encodeAsXmlElement("comment", comment, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::EnvoyBankInfoBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("bankrefId"))
		{
			bankrefId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("city"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
		}
		else if (_element.equals("address"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, address)) return false;
		}
		else if (_element.equals("swift"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, swift)) return false;
		}
		else if (_element.equals("url"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, url)) return false;
		}
		else if (_element.equals("accountNum"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, accountNum)) return false;
		}
		else if (_element.equals("iban"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, iban)) return false;
		}
		else if (_element.equals("benficiary"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, benficiary)) return false;
		}
		else if (_element.equals("extraInfo"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, extraInfo)) return false;
		}
		else if (_element.equals("preferred"))
		{
			preferred = (*_value.ptr() == '1');
		}
		else if (_element.equals("paysystem"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, paysystem)) return false;
		}
		else if (_element.equals("bankId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, bankId)) return false;
		}
		else if (_element.equals("comment"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, comment)) return false;
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::EnvoyBankInfoBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(EnvoyBankInfoBody())) // not empty
	{
		_body.composeUINT32(bankrefId);
		_body.composeString(currency);
		_body.composeString(name);
		_body.composeString(city);
		_body.composeString(address);
		_body.composeString(swift);
		_body.composeString(url);
		_body.composeString(accountNum);
		_body.composeString(iban);
		_body.composeString(benficiary);
		_body.composeString(extraInfo);
		_body.composeBOOL(preferred);
		_body.composeString(paysystem);
		_body.composeString(bankId);
		_body.composeString(comment);
		_body.composeUINT32(flags);
		_body.composeString(country);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::EnvoyBankInfoBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(bankrefId);
	_parser0.parseStringP(currency);
	_parser0.parseStringP(name);
	_parser0.parseStringP(city);
	_parser0.parseStringP(address);
	_parser0.parseStringP(swift);
	_parser0.parseStringP(url);
	_parser0.parseStringP(accountNum);
	_parser0.parseStringP(iban);
	_parser0.parseStringP(benficiary);
	_parser0.parseStringP(extraInfo);
	_parser0.parseBOOL(preferred);
	_parser0.parseStringP(paysystem);
	_parser0.parseStringP(bankId);
	_parser0.parseStringP(comment);
	_parser0.parseUINT32(flags);
	_parser0.parseStringP(country);
}

const char *CashierServer::cli::EnvoyBankInfoBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("bankrefId", bankrefId);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("name", name);
	_jsonstr.compose("city", city);
	_jsonstr.compose("address", address);
	_jsonstr.compose("swift", swift);
	_jsonstr.compose("url", url);
	_jsonstr.compose("accountNum", accountNum);
	_jsonstr.compose("iban", iban);
	_jsonstr.compose("benficiary", benficiary);
	_jsonstr.compose("extraInfo", extraInfo);
	_jsonstr.compose("preferred", preferred);
	_jsonstr.compose("paysystem", paysystem);
	_jsonstr.compose("bankId", bankId);
	_jsonstr.compose("comment", comment);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("country", country);
	return _buf.c_str();
}

void CashierServer::cli::EnvoyBankInfoBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("bankrefId", bankrefId);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("city", city);
	_jparser.parseByNameThrow("address", address);
	_jparser.parseByNameThrow("swift", swift);
	_jparser.parseByNameThrow("url", url);
	_jparser.parseByNameThrow("accountNum", accountNum);
	_jparser.parseByNameThrow("iban", iban);
	_jparser.parseByNameThrow("benficiary", benficiary);
	_jparser.parseByNameThrow("extraInfo", extraInfo);
	_jparser.parseByNameThrow("preferred", preferred);
	_jparser.parseByNameThrow("paysystem", paysystem);
	_jparser.parseByNameThrow("bankId", bankId);
	_jparser.parseByNameThrow("comment", comment);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("country", country);
}

/* static */ void CashierServer::cli::EnvoyBankInfoBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 bankrefId; _jparser.validateByNameThrow("bankrefId", bankrefId);
	AtfValidator::validateInt(_descr, "bankrefId", bankrefId, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateInt(_descr, "city", city.length(), _checker, __FILE__, __LINE__);
	PString address; _jparser.validateByNameThrow("address", address);
	AtfValidator::validateInt(_descr, "address", address.length(), _checker, __FILE__, __LINE__);
	PString swift; _jparser.validateByNameThrow("swift", swift);
	AtfValidator::validateInt(_descr, "swift", swift.length(), _checker, __FILE__, __LINE__);
	PString url; _jparser.validateByNameThrow("url", url);
	AtfValidator::validateInt(_descr, "url", url.length(), _checker, __FILE__, __LINE__);
	PString accountNum; _jparser.validateByNameThrow("accountNum", accountNum);
	AtfValidator::validateInt(_descr, "accountNum", accountNum.length(), _checker, __FILE__, __LINE__);
	PString iban; _jparser.validateByNameThrow("iban", iban);
	AtfValidator::validateInt(_descr, "iban", iban.length(), _checker, __FILE__, __LINE__);
	PString benficiary; _jparser.validateByNameThrow("benficiary", benficiary);
	AtfValidator::validateInt(_descr, "benficiary", benficiary.length(), _checker, __FILE__, __LINE__);
	PString extraInfo; _jparser.validateByNameThrow("extraInfo", extraInfo);
	AtfValidator::validateInt(_descr, "extraInfo", extraInfo.length(), _checker, __FILE__, __LINE__);
	bool preferred; _jparser.validateByNameThrow("preferred", preferred);
	AtfValidator::validateInt(_descr, "preferred", preferred, _checker, __FILE__, __LINE__);
	PString paysystem; _jparser.validateByNameThrow("paysystem", paysystem);
	AtfValidator::validateInt(_descr, "paysystem", paysystem.length(), _checker, __FILE__, __LINE__);
	PString bankId; _jparser.validateByNameThrow("bankId", bankId);
	AtfValidator::validateInt(_descr, "bankId", bankId.length(), _checker, __FILE__, __LINE__);
	PString comment; _jparser.validateByNameThrow("comment", comment);
	AtfValidator::validateInt(_descr, "comment", comment.length(), _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::EnvoyBankInfoBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 bankrefId; _parser0.parseUINT32(bankrefId);
	AtfValidator::validateInt(_descr, "bankrefId", bankrefId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "address", szAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "swift"); size_t szSwift = strlen(_dummy);
	AtfValidator::validateInt(_descr, "swift", szSwift, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
	AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "accountNum"); size_t szAccountNum = strlen(_dummy);
	AtfValidator::validateInt(_descr, "accountNum", szAccountNum, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "iban"); size_t szIban = strlen(_dummy);
	AtfValidator::validateInt(_descr, "iban", szIban, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "benficiary"); size_t szBenficiary = strlen(_dummy);
	AtfValidator::validateInt(_descr, "benficiary", szBenficiary, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "extraInfo"); size_t szExtraInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "extraInfo", szExtraInfo, _checker, __FILE__, __LINE__);
	bool preferred; _parser0.parseBOOL(preferred);
	AtfValidator::validateInt(_descr, "preferred", preferred, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "paysystem"); size_t szPaysystem = strlen(_dummy);
	AtfValidator::validateInt(_descr, "paysystem", szPaysystem, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "bankId"); size_t szBankId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "bankId", szBankId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateInt(_descr, "comment", szComment, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	banksForClient.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::equals(const Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		banksForClient.equals(_o.banksForClient);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("banksForClient=");
		banksForClient.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		banksForClient.toXmlString("banksForClient", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("banksForClient"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< EnvoyBankInfoBody, 4 > >::FromXmlString(_value, banksForClient)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		banksForClient.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		banksForClient.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("banksForClient", banksForClient);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("banksForClient", banksForClient);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< EnvoyBankInfoBody > banksForClient; _jparser.validateByNameThrow("banksForClient", banksForClient);
		AtfValidator::validateInt(_descr, "banksForClient", banksForClient.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szBanksForClient = Atf::LAtfVector< EnvoyBankInfoBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("banksForClient"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "banksForClient", szBanksForClient, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::clear()
{
	bonusCode.clear();
	bankrefId = 0;
	currency.clear();
	name.clear();
	city.clear();
	address.clear();
	swift.clear();
	url.clear();
	accountNum.clear();
	iban.clear();
	benficiary.clear();
	extraInfo.clear();
	preferred = false;
	intendedProcAmount = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::equals(const Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED& _o) const
{
	return Atf::atfPStringEquals(bonusCode, _o.bonusCode) &&
		bankrefId == _o.bankrefId &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(address, _o.address) &&
		Atf::atfPStringEquals(swift, _o.swift) &&
		Atf::atfPStringEquals(url, _o.url) &&
		Atf::atfPStringEquals(accountNum, _o.accountNum) &&
		Atf::atfPStringEquals(iban, _o.iban) &&
		Atf::atfPStringEquals(benficiary, _o.benficiary) &&
		Atf::atfPStringEquals(extraInfo, _o.extraInfo) &&
		preferred == _o.preferred &&
		intendedProcAmount == _o.intendedProcAmount;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_ENVOY_LBT_BANK_SELECTED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ENVOY_LBT_BANK_SELECTED).append(")");
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("bankrefId=");
	_buf.appendUint(bankrefId);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("swift=");
	_buf.append(swift);
	_buf.append(',');
	_buf.append("url=");
	_buf.append(url);
	_buf.append(',');
	_buf.append("accountNum=");
	_buf.append(accountNum);
	_buf.append(',');
	_buf.append("iban=");
	_buf.append(iban);
	_buf.append(',');
	_buf.append("benficiary=");
	_buf.append(benficiary);
	_buf.append(',');
	_buf.append("extraInfo=");
	_buf.append(extraInfo);
	_buf.append(',');
	_buf.append("preferred=");
	_buf.appendUint(preferred);
	_buf.append(',');
	_buf.append("intendedProcAmount=");
	_buf.appendInt(intendedProcAmount);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_ENVOY_LBT_BANK_SELECTED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("bonusCode", bonusCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("bankrefId", bankrefId, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::encodeAsXmlElement("address", address, _buf);
	Atf::XmlElement::encodeAsXmlElement("swift", swift, _buf);
	Atf::XmlElement::encodeAsXmlElement("url", url, _buf);
	Atf::XmlElement::encodeAsXmlElement("accountNum", accountNum, _buf);
	Atf::XmlElement::encodeAsXmlElement("iban", iban, _buf);
	Atf::XmlElement::encodeAsXmlElement("benficiary", benficiary, _buf);
	Atf::XmlElement::encodeAsXmlElement("extraInfo", extraInfo, _buf);
	Atf::XmlElement::encodeAsXmlElement("preferred", preferred, _buf);
	Atf::XmlElement::encodeAsXmlElement("intendedProcAmount", intendedProcAmount, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("bonusCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bonusCode)) return false;
			}
			else if (_element.equals("bankrefId"))
			{
				bankrefId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("name"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
			}
			else if (_element.equals("city"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
			}
			else if (_element.equals("address"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, address)) return false;
			}
			else if (_element.equals("swift"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, swift)) return false;
			}
			else if (_element.equals("url"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, url)) return false;
			}
			else if (_element.equals("accountNum"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, accountNum)) return false;
			}
			else if (_element.equals("iban"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, iban)) return false;
			}
			else if (_element.equals("benficiary"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, benficiary)) return false;
			}
			else if (_element.equals("extraInfo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, extraInfo)) return false;
			}
			else if (_element.equals("preferred"))
			{
				preferred = (*_value.ptr() == '1');
			}
			else if (_element.equals("intendedProcAmount"))
			{
				intendedProcAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(bonusCode);
	_msg.composeUINT32(bankrefId);
	_msg.composeString(currency);
	_msg.composeString(name);
	_msg.composeString(city);
	_msg.composeString(address);
	_msg.composeString(swift);
	_msg.composeString(url);
	_msg.composeString(accountNum);
	_msg.composeString(iban);
	_msg.composeString(benficiary);
	_msg.composeString(extraInfo);
	_msg.composeBOOL(preferred);
	_msg.composeINT32(intendedProcAmount);
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(bonusCode);
	_parser.parseUINT32(bankrefId);
	_parser.parseStringP(currency);
	_parser.parseStringP(name);
	_parser.parseStringP(city);
	_parser.parseStringP(address);
	_parser.parseStringP(swift);
	_parser.parseStringP(url);
	_parser.parseStringP(accountNum);
	_parser.parseStringP(iban);
	_parser.parseStringP(benficiary);
	_parser.parseStringP(extraInfo);
	_parser.parseBOOL(preferred);
	_parser.parseINT32(intendedProcAmount);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("bonusCode", bonusCode);
	_jsonstr.compose("bankrefId", bankrefId);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("name", name);
	_jsonstr.compose("city", city);
	_jsonstr.compose("address", address);
	_jsonstr.compose("swift", swift);
	_jsonstr.compose("url", url);
	_jsonstr.compose("accountNum", accountNum);
	_jsonstr.compose("iban", iban);
	_jsonstr.compose("benficiary", benficiary);
	_jsonstr.compose("extraInfo", extraInfo);
	_jsonstr.compose("preferred", preferred);
	_jsonstr.compose("intendedProcAmount", intendedProcAmount);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("bonusCode", bonusCode);
	_jparser.parseByNameThrow("bankrefId", bankrefId);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("city", city);
	_jparser.parseByNameThrow("address", address);
	_jparser.parseByNameThrow("swift", swift);
	_jparser.parseByNameThrow("url", url);
	_jparser.parseByNameThrow("accountNum", accountNum);
	_jparser.parseByNameThrow("iban", iban);
	_jparser.parseByNameThrow("benficiary", benficiary);
	_jparser.parseByNameThrow("extraInfo", extraInfo);
	_jparser.parseByNameThrow("preferred", preferred);
	_jparser.parseByNameThrow("intendedProcAmount", intendedProcAmount);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ENVOY_LBT_BANK_SELECTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString bonusCode; _jparser.validateByNameThrow("bonusCode", bonusCode);
	AtfValidator::validateIntMax(_descr, "bonusCode", bonusCode.length(), BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	UINT32 bankrefId; _jparser.validateByNameThrow("bankrefId", bankrefId);
	AtfValidator::validateInt(_descr, "bankrefId", bankrefId, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateIntMax(_descr, "name", name.length(), WIREACCOUNTS_HOLDERNAME_LEN, _checker, __FILE__, __LINE__);
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateIntMax(_descr, "city", city.length(), WIREACCOUNTS_CITY_LEN, _checker, __FILE__, __LINE__);
	PString address; _jparser.validateByNameThrow("address", address);
	AtfValidator::validateIntMax(_descr, "address", address.length(), WIREACCOUNTS_ADDR_LEN, _checker, __FILE__, __LINE__);
	PString swift; _jparser.validateByNameThrow("swift", swift);
	AtfValidator::validateIntMax(_descr, "swift", swift.length(), WIREACCOUNTS_SWIFTCODE_LEN, _checker, __FILE__, __LINE__);
	PString url; _jparser.validateByNameThrow("url", url);
	AtfValidator::validateIntMax(_descr, "url", url.length(), 1000, _checker, __FILE__, __LINE__);
	PString accountNum; _jparser.validateByNameThrow("accountNum", accountNum);
	AtfValidator::validateIntMax(_descr, "accountNum", accountNum.length(), 100, _checker, __FILE__, __LINE__);
	PString iban; _jparser.validateByNameThrow("iban", iban);
	AtfValidator::validateIntMax(_descr, "iban", iban.length(), WIREACCOUNTS_IBAN_LEN, _checker, __FILE__, __LINE__);
	PString benficiary; _jparser.validateByNameThrow("benficiary", benficiary);
	AtfValidator::validateIntMax(_descr, "benficiary", benficiary.length(), WIREACCOUNTS_HOLDERNAME_LEN, _checker, __FILE__, __LINE__);
	PString extraInfo; _jparser.validateByNameThrow("extraInfo", extraInfo);
	AtfValidator::validateIntMax(_descr, "extraInfo", extraInfo.length(), 4000, _checker, __FILE__, __LINE__);
	bool preferred; _jparser.validateByNameThrow("preferred", preferred);
	AtfValidator::validateInt(_descr, "preferred", preferred, _checker, __FILE__, __LINE__);
	INT32 intendedProcAmount; _jparser.validateByNameThrow("intendedProcAmount", intendedProcAmount);
	AtfValidator::validateIntRange(_descr, "intendedProcAmount", intendedProcAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ENVOY_LBT_BANK_SELECTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	UINT32 bankrefId; _parser.parseUINT32(bankrefId);
	AtfValidator::validateInt(_descr, "bankrefId", bankrefId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, WIREACCOUNTS_HOLDERNAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, WIREACCOUNTS_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "address", szAddress, WIREACCOUNTS_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "swift"); size_t szSwift = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "swift", szSwift, WIREACCOUNTS_SWIFTCODE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "url", szUrl, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "accountNum"); size_t szAccountNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "accountNum", szAccountNum, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "iban"); size_t szIban = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "iban", szIban, WIREACCOUNTS_IBAN_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "benficiary"); size_t szBenficiary = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "benficiary", szBenficiary, WIREACCOUNTS_HOLDERNAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "extraInfo"); size_t szExtraInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "extraInfo", szExtraInfo, 4000, _checker, __FILE__, __LINE__);
	bool preferred; _parser.parseBOOL(preferred);
	AtfValidator::validateInt(_descr, "preferred", preferred, _checker, __FILE__, __LINE__);
	INT32 intendedProcAmount; _parser.parseINT32(intendedProcAmount);
	AtfValidator::validateIntRange(_descr, "intendedProcAmount", intendedProcAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	retStr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::equals(const Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(retStr, _o.retStr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("retStr=");
		_buf.append(retStr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("retStr", retStr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("retStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, retStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(retStr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(retStr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("retStr", retStr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("retStr", retStr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString retStr; _jparser.validateByNameThrow("retStr", retStr);
		AtfValidator::validateInt(_descr, "retStr", retStr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "retStr"); size_t szRetStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "retStr", szRetStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::clear()
{
	bonusCode.clear();
	bankRefId = 0;
	intendedProcAmount = 0;
	processorCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::equals(const Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED& _o) const
{
	return Atf::atfPStringEquals(bonusCode, _o.bonusCode) &&
		bankRefId == _o.bankRefId &&
		intendedProcAmount == _o.intendedProcAmount &&
		Atf::atfPStringEquals(processorCurrency, _o.processorCurrency);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PSTARSPAY_BANK_SELECTED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PSTARSPAY_BANK_SELECTED).append(")");
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("bankRefId=");
	_buf.appendUint(bankRefId);
	_buf.append(',');
	_buf.append("intendedProcAmount=");
	_buf.appendInt(intendedProcAmount);
	_buf.append(',');
	_buf.append("processorCurrency=");
	_buf.append(processorCurrency);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PSTARSPAY_BANK_SELECTED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("bonusCode", bonusCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("bankRefId", bankRefId, _buf);
	Atf::XmlElement::encodeAsXmlElement("intendedProcAmount", intendedProcAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("processorCurrency", processorCurrency, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("bonusCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bonusCode)) return false;
			}
			else if (_element.equals("bankRefId"))
			{
				bankRefId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("intendedProcAmount"))
			{
				intendedProcAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("processorCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, processorCurrency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(bonusCode);
	_msg.composeUINT32(bankRefId);
	_msg.composeINT32(intendedProcAmount);
	_msg.composeString(processorCurrency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(bonusCode);
	_parser.parseUINT32(bankRefId);
	_parser.parseINT32(intendedProcAmount);
	_parser.parseStringP(processorCurrency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("bonusCode", bonusCode);
	_jsonstr.compose("bankRefId", bankRefId);
	_jsonstr.compose("intendedProcAmount", intendedProcAmount);
	_jsonstr.compose("processorCurrency", processorCurrency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("bonusCode", bonusCode);
	_jparser.parseByNameThrow("bankRefId", bankRefId);
	_jparser.parseByNameThrow("intendedProcAmount", intendedProcAmount);
	_jparser.parseByNameThrow("processorCurrency", processorCurrency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PSTARSPAY_BANK_SELECTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString bonusCode; _jparser.validateByNameThrow("bonusCode", bonusCode);
	AtfValidator::validateIntMax(_descr, "bonusCode", bonusCode.length(), BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	UINT32 bankRefId; _jparser.validateByNameThrow("bankRefId", bankRefId);
	AtfValidator::validateInt(_descr, "bankRefId", bankRefId, _checker, __FILE__, __LINE__);
	INT32 intendedProcAmount; _jparser.validateByNameThrow("intendedProcAmount", intendedProcAmount);
	AtfValidator::validateIntRange(_descr, "intendedProcAmount", intendedProcAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString processorCurrency; _jparser.validateByNameThrow("processorCurrency", processorCurrency);
	AtfValidator::validateIntMax(_descr, "processorCurrency", processorCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PSTARSPAY_BANK_SELECTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	UINT32 bankRefId; _parser.parseUINT32(bankRefId);
	AtfValidator::validateInt(_descr, "bankRefId", bankRefId, _checker, __FILE__, __LINE__);
	INT32 intendedProcAmount; _parser.parseINT32(intendedProcAmount);
	AtfValidator::validateIntRange(_descr, "intendedProcAmount", intendedProcAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "processorCurrency"); size_t szProcessorCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "processorCurrency", szProcessorCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	name.clear();
	benficiary.clear();
	sccountNum.clear();
	useReference = false;
	processorExtras.clear();
	currency.clear();
	intendedProcAmount = 0;
	amount = 0;
	comment.clear();
	empty.clear();
	extraInfo.clear();
	url.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::equals(const Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(benficiary, _o.benficiary) &&
		Atf::atfPStringEquals(sccountNum, _o.sccountNum) &&
		useReference == _o.useReference &&
		Atf::atfPStringEquals(processorExtras, _o.processorExtras) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		intendedProcAmount == _o.intendedProcAmount &&
		amount == _o.amount &&
		Atf::atfPStringEquals(comment, _o.comment) &&
		Atf::atfPStringEquals(empty, _o.empty) &&
		Atf::atfPStringEquals(extraInfo, _o.extraInfo) &&
		Atf::atfPStringEquals(url, _o.url);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("name=");
		_buf.append(name);
		_buf.append(',');
		_buf.append("benficiary=");
		_buf.append(benficiary);
		_buf.append(',');
		_buf.append("sccountNum=");
		_buf.append(sccountNum);
		_buf.append(',');
		_buf.append("useReference=");
		_buf.appendUint(useReference);
		_buf.append(',');
		_buf.append("processorExtras=");
		_buf.append(processorExtras);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("intendedProcAmount=");
		_buf.appendInt(intendedProcAmount);
		_buf.append(',');
		_buf.append("amount=");
		_buf.appendInt(amount);
		_buf.append(',');
		_buf.append("comment=");
		_buf.append(comment);
		_buf.append(',');
		_buf.append("empty=");
		_buf.append(empty);
		_buf.append(',');
		_buf.append("extraInfo=");
		_buf.append(extraInfo);
		_buf.append(',');
		_buf.append("url=");
		_buf.append(url);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
		Atf::XmlElement::encodeAsXmlElement("benficiary", benficiary, _buf);
		Atf::XmlElement::encodeAsXmlElement("sccountNum", sccountNum, _buf);
		Atf::XmlElement::encodeAsXmlElement("useReference", useReference, _buf);
		Atf::XmlElement::encodeAsXmlElement("processorExtras", processorExtras, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("intendedProcAmount", intendedProcAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
		Atf::XmlElement::encodeAsXmlElement("comment", comment, _buf);
		Atf::XmlElement::encodeAsXmlElement("empty", empty, _buf);
		Atf::XmlElement::encodeAsXmlElement("extraInfo", extraInfo, _buf);
		Atf::XmlElement::encodeAsXmlElement("url", url, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("name"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
			}
			else if (_element.equals("benficiary"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, benficiary)) return false;
			}
			else if (_element.equals("sccountNum"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, sccountNum)) return false;
			}
			else if (_element.equals("useReference"))
			{
				useReference = (*_value.ptr() == '1');
			}
			else if (_element.equals("processorExtras"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, processorExtras)) return false;
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("intendedProcAmount"))
			{
				intendedProcAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("amount"))
			{
				amount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("comment"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, comment)) return false;
			}
			else if (_element.equals("empty"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, empty)) return false;
			}
			else if (_element.equals("extraInfo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, extraInfo)) return false;
			}
			else if (_element.equals("url"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, url)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(name);
		_msg.composeString(benficiary);
		_msg.composeString(sccountNum);
		_msg.composeBOOL(useReference);
		_msg.composeString(processorExtras);
		_msg.composeString(currency);
		_msg.composeINT32(intendedProcAmount);
		_msg.composeINT32(amount);
		_msg.composeString(comment);
		_msg.composeString(empty);
		_msg.composeString(extraInfo);
		_msg.composeString(url);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(name);
		_parser.parseStringP(benficiary);
		_parser.parseStringP(sccountNum);
		_parser.parseBOOL(useReference);
		_parser.parseStringP(processorExtras);
		_parser.parseStringP(currency);
		_parser.parseINT32(intendedProcAmount);
		_parser.parseINT32(amount);
		_parser.parseStringP(comment);
		_parser.parseStringP(empty);
		_parser.parseStringP(extraInfo);
		_parser.parseStringP(url);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("name", name);
		_jsonstr.compose("benficiary", benficiary);
		_jsonstr.compose("sccountNum", sccountNum);
		_jsonstr.compose("useReference", useReference);
		_jsonstr.compose("processorExtras", processorExtras);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("intendedProcAmount", intendedProcAmount);
		_jsonstr.compose("amount", amount);
		_jsonstr.compose("comment", comment);
		_jsonstr.compose("empty", empty);
		_jsonstr.compose("extraInfo", extraInfo);
		_jsonstr.compose("url", url);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("name", name);
		_jparser.parseByNameThrow("benficiary", benficiary);
		_jparser.parseByNameThrow("sccountNum", sccountNum);
		_jparser.parseByNameThrow("useReference", useReference);
		_jparser.parseByNameThrow("processorExtras", processorExtras);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("intendedProcAmount", intendedProcAmount);
		_jparser.parseByNameThrow("amount", amount);
		_jparser.parseByNameThrow("comment", comment);
		_jparser.parseByNameThrow("empty", empty);
		_jparser.parseByNameThrow("extraInfo", extraInfo);
		_jparser.parseByNameThrow("url", url);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString name; _jparser.validateByNameThrow("name", name);
		AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
		PString benficiary; _jparser.validateByNameThrow("benficiary", benficiary);
		AtfValidator::validateInt(_descr, "benficiary", benficiary.length(), _checker, __FILE__, __LINE__);
		PString sccountNum; _jparser.validateByNameThrow("sccountNum", sccountNum);
		AtfValidator::validateInt(_descr, "sccountNum", sccountNum.length(), _checker, __FILE__, __LINE__);
		bool useReference; _jparser.validateByNameThrow("useReference", useReference);
		AtfValidator::validateInt(_descr, "useReference", useReference, _checker, __FILE__, __LINE__);
		PString processorExtras; _jparser.validateByNameThrow("processorExtras", processorExtras);
		AtfValidator::validateInt(_descr, "processorExtras", processorExtras.length(), _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		INT32 intendedProcAmount; _jparser.validateByNameThrow("intendedProcAmount", intendedProcAmount);
		AtfValidator::validateInt(_descr, "intendedProcAmount", intendedProcAmount, _checker, __FILE__, __LINE__);
		INT32 amount; _jparser.validateByNameThrow("amount", amount);
		AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
		PString comment; _jparser.validateByNameThrow("comment", comment);
		AtfValidator::validateInt(_descr, "comment", comment.length(), _checker, __FILE__, __LINE__);
		PString empty; _jparser.validateByNameThrow("empty", empty);
		AtfValidator::validateInt(_descr, "empty", empty.length(), _checker, __FILE__, __LINE__);
		PString extraInfo; _jparser.validateByNameThrow("extraInfo", extraInfo);
		AtfValidator::validateInt(_descr, "extraInfo", extraInfo.length(), _checker, __FILE__, __LINE__);
		PString url; _jparser.validateByNameThrow("url", url);
		AtfValidator::validateInt(_descr, "url", url.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "benficiary"); size_t szBenficiary = strlen(_dummy);
		AtfValidator::validateInt(_descr, "benficiary", szBenficiary, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "sccountNum"); size_t szSccountNum = strlen(_dummy);
		AtfValidator::validateInt(_descr, "sccountNum", szSccountNum, _checker, __FILE__, __LINE__);
		bool useReference; _parser.parseBOOL(useReference);
		AtfValidator::validateInt(_descr, "useReference", useReference, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "processorExtras"); size_t szProcessorExtras = strlen(_dummy);
		AtfValidator::validateInt(_descr, "processorExtras", szProcessorExtras, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		INT32 intendedProcAmount; _parser.parseINT32(intendedProcAmount);
		AtfValidator::validateInt(_descr, "intendedProcAmount", intendedProcAmount, _checker, __FILE__, __LINE__);
		INT32 amount; _parser.parseINT32(amount);
		AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
		AtfValidator::validateInt(_descr, "comment", szComment, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "empty"); size_t szEmpty = strlen(_dummy);
		AtfValidator::validateInt(_descr, "empty", szEmpty, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "extraInfo"); size_t szExtraInfo = strlen(_dummy);
		AtfValidator::validateInt(_descr, "extraInfo", szExtraInfo, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CONVRATES_SUBSET
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::Protocol_MSG_CASHIER_CONVRATES_SUBSET()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::clear()
{
	intActionType = 0;
	incomingCur.clear();
	curIsSrcNotDst = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::equals(const Protocol_MSG_CASHIER_CONVRATES_SUBSET& _o) const
{
	return intActionType == _o.intActionType &&
		Atf::atfPStringEquals(incomingCur, _o.incomingCur) &&
		curIsSrcNotDst == _o.curIsSrcNotDst;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CONVRATES_SUBSET != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CONVRATES_SUBSET*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CONVRATES_SUBSET).append(")");
	_buf.append(',');
	_buf.append("intActionType=");
	_buf.appendUint(intActionType);
	_buf.append(',');
	_buf.append("incomingCur=");
	_buf.append(incomingCur);
	_buf.append(',');
	_buf.append("curIsSrcNotDst=");
	_buf.appendUint(curIsSrcNotDst);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CONVRATES_SUBSET).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("intActionType", intActionType, _buf);
	Atf::XmlElement::encodeAsXmlElement("incomingCur", incomingCur, _buf);
	Atf::XmlElement::encodeAsXmlElement("curIsSrcNotDst", curIsSrcNotDst, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("intActionType"))
			{
				intActionType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("incomingCur"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, incomingCur)) return false;
			}
			else if (_element.equals("curIsSrcNotDst"))
			{
				curIsSrcNotDst = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(intActionType);
	_msg.composeString(incomingCur);
	_msg.composeBOOL(curIsSrcNotDst);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(intActionType);
	_parser.parseStringP(incomingCur);
	_parser.parseBOOL(curIsSrcNotDst);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("intActionType", intActionType);
	_jsonstr.compose("incomingCur", incomingCur);
	_jsonstr.compose("curIsSrcNotDst", curIsSrcNotDst);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("intActionType", intActionType);
	_jparser.parseByNameThrow("incomingCur", incomingCur);
	_jparser.parseByNameThrow("curIsSrcNotDst", curIsSrcNotDst);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVRATES_SUBSET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 intActionType; _jparser.validateByNameThrow("intActionType", intActionType);
	AtfValidator::validateIntRange(_descr, "intActionType", intActionType, eConvActionDefault, eConvActionPoolBettingLast, _checker, __FILE__, __LINE__);
	PString incomingCur; _jparser.validateByNameThrow("incomingCur", incomingCur);
	AtfValidator::validateIntMax(_descr, "incomingCur", incomingCur.length(), 100, _checker, __FILE__, __LINE__);
	bool curIsSrcNotDst; _jparser.validateByNameThrow("curIsSrcNotDst", curIsSrcNotDst);
	AtfValidator::validateInt(_descr, "curIsSrcNotDst", curIsSrcNotDst, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVRATES_SUBSET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 intActionType; _parser.parseUINT32(intActionType);
	AtfValidator::validateIntRange(_descr, "intActionType", intActionType, eConvActionDefault, eConvActionPoolBettingLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "incomingCur"); size_t szIncomingCur = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "incomingCur", szIncomingCur, 100, _checker, __FILE__, __LINE__);
	bool curIsSrcNotDst; _parser.parseBOOL(curIsSrcNotDst);
	AtfValidator::validateInt(_descr, "curIsSrcNotDst", curIsSrcNotDst, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierConvRateBody
//=================================================================

CashierServer::cli::CashierConvRateBody::CashierConvRateBody()
{
	clear();
}

void CashierServer::cli::CashierConvRateBody::clear()
{
	outgoingCur.clear();
	rateFin = 0;
	inverseRateFin = 0;
}

bool CashierServer::cli::CashierConvRateBody::equals(const CashierConvRateBody& _o) const
{
	return Atf::atfPStringEquals(outgoingCur, _o.outgoingCur) &&
		rateFin == _o.rateFin &&
		inverseRateFin == _o.inverseRateFin;
}

const char *CashierServer::cli::CashierConvRateBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("outgoingCur=");
	_buf.append(outgoingCur);
	_buf.append(',');
	_buf.append("rateFin=");
	_buf.appendUint64(rateFin);
	_buf.append(',');
	_buf.append("inverseRateFin=");
	_buf.appendUint64(inverseRateFin);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierConvRateBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("outgoingCur", outgoingCur, _buf);
	Atf::XmlElement::encodeAsXmlElement("rateFin", rateFin, _buf);
	Atf::XmlElement::encodeAsXmlElement("inverseRateFin", inverseRateFin, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierConvRateBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("outgoingCur"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, outgoingCur)) return false;
		}
		else if (_element.equals("rateFin"))
		{
			rateFin = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("inverseRateFin"))
		{
			inverseRateFin = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierConvRateBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierConvRateBody())) // not empty
	{
		_body.composeString(outgoingCur);
		_body.composeUINT64(rateFin);
		_body.composeUINT64(inverseRateFin);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierConvRateBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(outgoingCur);
	_parser0.parseUINT64(rateFin);
	_parser0.parseUINT64(inverseRateFin);
}

const char *CashierServer::cli::CashierConvRateBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("outgoingCur", outgoingCur);
	_jsonstr.compose("rateFin", rateFin);
	_jsonstr.compose("inverseRateFin", inverseRateFin);
	return _buf.c_str();
}

void CashierServer::cli::CashierConvRateBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("outgoingCur", outgoingCur);
	_jparser.parseByNameThrow("rateFin", rateFin);
	_jparser.parseByNameThrow("inverseRateFin", inverseRateFin);
}

/* static */ void CashierServer::cli::CashierConvRateBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString outgoingCur; _jparser.validateByNameThrow("outgoingCur", outgoingCur);
	AtfValidator::validateInt(_descr, "outgoingCur", outgoingCur.length(), _checker, __FILE__, __LINE__);
	UINT64 rateFin; _jparser.validateByNameThrow("rateFin", rateFin);
	AtfValidator::validateUint(_descr, "rateFin", rateFin, _checker, __FILE__, __LINE__);
	UINT64 inverseRateFin; _jparser.validateByNameThrow("inverseRateFin", inverseRateFin);
	AtfValidator::validateUint(_descr, "inverseRateFin", inverseRateFin, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierConvRateBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "outgoingCur"); size_t szOutgoingCur = strlen(_dummy);
	AtfValidator::validateInt(_descr, "outgoingCur", szOutgoingCur, _checker, __FILE__, __LINE__);
	UINT64 rateFin; _parser0.parseUINT64(rateFin);
	AtfValidator::validateUint(_descr, "rateFin", rateFin, _checker, __FILE__, __LINE__);
	UINT64 inverseRateFin; _parser0.parseUINT64(inverseRateFin);
	AtfValidator::validateUint(_descr, "inverseRateFin", inverseRateFin, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	convRates.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::equals(const Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		convRates.equals(_o.convRates);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CONVRATES_SUBSET_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CONVRATES_SUBSET_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("convRates=");
		convRates.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CONVRATES_SUBSET_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		convRates.toXmlString("convRates", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("convRates"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierConvRateBody, 4 > >::FromXmlString(_value, convRates)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		convRates.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		convRates.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("convRates", convRates);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("convRates", convRates);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVRATES_SUBSET_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CashierConvRateBody > convRates; _jparser.validateByNameThrow("convRates", convRates);
		AtfValidator::validateInt(_descr, "convRates", convRates.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVRATES_SUBSET_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szConvRates = Atf::LAtfVector< CashierConvRateBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("convRates"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "convRates", szConvRates, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::clear()
{
	newDefaultCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::equals(const Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT& _o) const
{
	return Atf::atfPStringEquals(newDefaultCurrency, _o.newDefaultCurrency);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_DEFAULT_ACCOUNT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_DEFAULT_ACCOUNT).append(")");
	_buf.append(',');
	_buf.append("newDefaultCurrency=");
	_buf.append(newDefaultCurrency);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_DEFAULT_ACCOUNT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("newDefaultCurrency", newDefaultCurrency, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("newDefaultCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, newDefaultCurrency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(newDefaultCurrency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(newDefaultCurrency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("newDefaultCurrency", newDefaultCurrency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("newDefaultCurrency", newDefaultCurrency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_DEFAULT_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString newDefaultCurrency; _jparser.validateByNameThrow("newDefaultCurrency", newDefaultCurrency);
	AtfValidator::validateIntMax(_descr, "newDefaultCurrency", newDefaultCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_DEFAULT_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "newDefaultCurrency"); size_t szNewDefaultCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "newDefaultCurrency", szNewDefaultCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::equals(const Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::clear()
{
	newCurrencyToAdd.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::equals(const Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT& _o) const
{
	return Atf::atfPStringEquals(newCurrencyToAdd, _o.newCurrencyToAdd);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_NEW_CURRENCY_ACCOUNT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_NEW_CURRENCY_ACCOUNT).append(")");
	_buf.append(',');
	_buf.append("newCurrencyToAdd=");
	_buf.append(newCurrencyToAdd);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_NEW_CURRENCY_ACCOUNT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("newCurrencyToAdd", newCurrencyToAdd, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("newCurrencyToAdd"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, newCurrencyToAdd)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(newCurrencyToAdd);
}

void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(newCurrencyToAdd);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("newCurrencyToAdd", newCurrencyToAdd);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("newCurrencyToAdd", newCurrencyToAdd);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_NEW_CURRENCY_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString newCurrencyToAdd; _jparser.validateByNameThrow("newCurrencyToAdd", newCurrencyToAdd);
	AtfValidator::validateIntMax(_descr, "newCurrencyToAdd", newCurrencyToAdd.length(), 100, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_NEW_CURRENCY_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "newCurrencyToAdd"); size_t szNewCurrencyToAdd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "newCurrencyToAdd", szNewCurrencyToAdd, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::equals(const Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::clear()
{
	currencyToDelete.clear();
	disregradBonuses = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::equals(const Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT& _o) const
{
	return Atf::atfPStringEquals(currencyToDelete, _o.currencyToDelete) &&
		disregradBonuses == _o.disregradBonuses;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_DELETE_CURRENCY_ACCOUNT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DELETE_CURRENCY_ACCOUNT).append(")");
	_buf.append(',');
	_buf.append("currencyToDelete=");
	_buf.append(currencyToDelete);
	_buf.append(',');
	_buf.append("disregradBonuses=");
	_buf.appendUint(disregradBonuses);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_DELETE_CURRENCY_ACCOUNT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("currencyToDelete", currencyToDelete, _buf);
	Atf::XmlElement::encodeAsXmlElement("disregradBonuses", disregradBonuses, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("currencyToDelete"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currencyToDelete)) return false;
			}
			else if (_element.equals("disregradBonuses"))
			{
				disregradBonuses = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(currencyToDelete);
	_msg.composeBOOL(disregradBonuses);
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(currencyToDelete);
	_parser.parseBOOL(disregradBonuses);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currencyToDelete", currencyToDelete);
	_jsonstr.compose("disregradBonuses", disregradBonuses);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currencyToDelete", currencyToDelete);
	_jparser.parseByNameThrow("disregradBonuses", disregradBonuses);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_CURRENCY_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currencyToDelete; _jparser.validateByNameThrow("currencyToDelete", currencyToDelete);
	AtfValidator::validateIntMax(_descr, "currencyToDelete", currencyToDelete.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	bool disregradBonuses; _jparser.validateByNameThrow("disregradBonuses", disregradBonuses);
	AtfValidator::validateInt(_descr, "disregradBonuses", disregradBonuses, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_CURRENCY_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "currencyToDelete"); size_t szCurrencyToDelete = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currencyToDelete", szCurrencyToDelete, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	bool disregradBonuses; _parser.parseBOOL(disregradBonuses);
	AtfValidator::validateInt(_descr, "disregradBonuses", disregradBonuses, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::equals(const Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    AccountTransferInfo
//=================================================================

CashierServer::cli::AccountTransferInfo::AccountTransferInfo()
{
	clear();
}

void CashierServer::cli::AccountTransferInfo::clear()
{
	amountSrc = 0;
	currencySrc.clear();
	amountDst = 0;
	currencyDst.clear();
	chipsType = 0;
}

bool CashierServer::cli::AccountTransferInfo::equals(const AccountTransferInfo& _o) const
{
	return amountSrc == _o.amountSrc &&
		Atf::atfPStringEquals(currencySrc, _o.currencySrc) &&
		amountDst == _o.amountDst &&
		Atf::atfPStringEquals(currencyDst, _o.currencyDst) &&
		chipsType == _o.chipsType;
}

const char *CashierServer::cli::AccountTransferInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("amountSrc=");
	_buf.appendInt(amountSrc);
	_buf.append(',');
	_buf.append("currencySrc=");
	_buf.append(currencySrc);
	_buf.append(',');
	_buf.append("amountDst=");
	_buf.appendInt(amountDst);
	_buf.append(',');
	_buf.append("currencyDst=");
	_buf.append(currencyDst);
	_buf.append(',');
	_buf.append("chipsType=");
	_buf.appendInt(chipsType);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::AccountTransferInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("amountSrc", amountSrc, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencySrc", currencySrc, _buf);
	Atf::XmlElement::encodeAsXmlElement("amountDst", amountDst, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyDst", currencyDst, _buf);
	Atf::XmlElement::encodeAsXmlElement("chipsType", chipsType, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::AccountTransferInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("amountSrc"))
		{
			amountSrc = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currencySrc"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currencySrc)) return false;
		}
		else if (_element.equals("amountDst"))
		{
			amountDst = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currencyDst"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currencyDst)) return false;
		}
		else if (_element.equals("chipsType"))
		{
			chipsType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::AccountTransferInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(amountSrc);
	_msg.composeString(currencySrc);
	_msg.composeINT32(amountDst);
	_msg.composeString(currencyDst);
	_msg.composeINT32(chipsType);
}

void CashierServer::cli::AccountTransferInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(amountSrc);
	_parser.parseStringP(currencySrc);
	_parser.parseINT32(amountDst);
	_parser.parseStringP(currencyDst);
	_parser.parseINT32(chipsType);
}

const char *CashierServer::cli::AccountTransferInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("amountSrc", amountSrc);
	_jsonstr.compose("currencySrc", currencySrc);
	_jsonstr.compose("amountDst", amountDst);
	_jsonstr.compose("currencyDst", currencyDst);
	_jsonstr.compose("chipsType", chipsType);
	return _buf.c_str();
}

void CashierServer::cli::AccountTransferInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("amountSrc", amountSrc);
	_jparser.parseByNameThrow("currencySrc", currencySrc);
	_jparser.parseByNameThrow("amountDst", amountDst);
	_jparser.parseByNameThrow("currencyDst", currencyDst);
	_jparser.parseByNameThrow("chipsType", chipsType);
}

/* static */ void CashierServer::cli::AccountTransferInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 amountSrc; _jparser.validateByNameThrow("amountSrc", amountSrc);
	AtfValidator::validateIntRange(_descr, "amountSrc", amountSrc, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString currencySrc; _jparser.validateByNameThrow("currencySrc", currencySrc);
	AtfValidator::validateIntMax(_descr, "currencySrc", currencySrc.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 amountDst; _jparser.validateByNameThrow("amountDst", amountDst);
	AtfValidator::validateIntRange(_descr, "amountDst", amountDst, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString currencyDst; _jparser.validateByNameThrow("currencyDst", currencyDst);
	AtfValidator::validateIntMax(_descr, "currencyDst", currencyDst.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 chipsType; _jparser.validateByNameThrow("chipsType", chipsType);
	{ const INT32 chipsType_enum[] = { REAL_CHIPS, PLAY_CHIPS, TOURN_CHIPS, BLITZ_REAL_CHIPS, BLITZ_PLAY_CHIPS, POKER_DUEL_CHIPS }; AtfValidator::validateEnum(_descr, "chipsType", chipsType, chipsType_enum, _checker, __FILE__, __LINE__); }
}

/*static*/ void CashierServer::cli::AccountTransferInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 amountSrc; _parser.parseINT32(amountSrc);
	AtfValidator::validateIntRange(_descr, "amountSrc", amountSrc, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currencySrc"); size_t szCurrencySrc = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currencySrc", szCurrencySrc, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 amountDst; _parser.parseINT32(amountDst);
	AtfValidator::validateIntRange(_descr, "amountDst", amountDst, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currencyDst"); size_t szCurrencyDst = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currencyDst", szCurrencyDst, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 chipsType; _parser.parseINT32(chipsType);
	{ const INT32 chipsType_enum[] = { REAL_CHIPS, PLAY_CHIPS, TOURN_CHIPS, BLITZ_REAL_CHIPS, BLITZ_PLAY_CHIPS, POKER_DUEL_CHIPS }; AtfValidator::validateEnum(_descr, "chipsType", chipsType, chipsType_enum, _checker, __FILE__, __LINE__); }
}

//=================================================================
//                Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::clear()
{
	transfers.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::equals(const Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER& _o) const
{
	return transfers.equals(_o.transfers);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER).append(")");
	_buf.append(',');
	_buf.append("transfers=");
	transfers.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	transfers.toXmlString("transfers", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("transfers"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< AccountTransferInfo, 4 > >::FromXmlString(_value, transfers)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	transfers.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::parseMsg(CommMsgParser& _parser)
{
	transfers.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("transfers", transfers);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("transfers", transfers);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< AccountTransferInfo > transfers; _jparser.validateByNameThrow("transfers", transfers);
	AtfValidator::validateIntMax(_descr, "transfers", transfers.size(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTransfers = Atf::LAtfVector< AccountTransferInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("transfers"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "transfers", szTransfers, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::equals(const Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_PRIVS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::Protocol_MSG_CASHIER_GET_USER_PRIVS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::clear()
{
	unusedStr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::equals(const Protocol_MSG_CASHIER_GET_USER_PRIVS& _o) const
{
	return Atf::atfPStringEquals(unusedStr, _o.unusedStr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_USER_PRIVS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_USER_PRIVS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_PRIVS).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_USER_PRIVS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("unusedStr", unusedStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("unusedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, unusedStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(unusedStr);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(unusedStr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("unusedStr", unusedStr);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("unusedStr", unusedStr);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_PRIVS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString unusedStr; _jparser.validateByNameThrow("unusedStr", unusedStr);
	AtfValidator::validateIntMax(_descr, "unusedStr", unusedStr.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_PRIVS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierUserPrivs
//=================================================================

CashierServer::cli::CashierUserPrivs::CashierUserPrivs()
{
	clear();
}

void CashierServer::cli::CashierUserPrivs::clear()
{
	privs = 0;
	privs2 = 0;
	modelessCashierAllowedForUser = false;
	forceCashout = false;
	dummy = false;
	privs3 = 0;
}

bool CashierServer::cli::CashierUserPrivs::equals(const CashierUserPrivs& _o) const
{
	return privs == _o.privs &&
		privs2 == _o.privs2 &&
		modelessCashierAllowedForUser == _o.modelessCashierAllowedForUser &&
		forceCashout == _o.forceCashout &&
		dummy == _o.dummy &&
		privs3 == _o.privs3;
}

const char *CashierServer::cli::CashierUserPrivs::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("privs=");
	_buf.appendUint(privs);
	_buf.append(',');
	_buf.append("privs2=");
	_buf.appendUint64(privs2);
	_buf.append(',');
	_buf.append("modelessCashierAllowedForUser=");
	_buf.appendUint(modelessCashierAllowedForUser);
	_buf.append(',');
	_buf.append("forceCashout=");
	_buf.appendUint(forceCashout);
	_buf.append(',');
	_buf.append("dummy=");
	_buf.appendUint(dummy);
	_buf.append(',');
	_buf.append("privs3=");
	_buf.appendUint64(privs3);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierUserPrivs::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("privs", privs, _buf);
	Atf::XmlElement::encodeAsXmlElement("privs2", privs2, _buf);
	Atf::XmlElement::encodeAsXmlElement("modelessCashierAllowedForUser", modelessCashierAllowedForUser, _buf);
	Atf::XmlElement::encodeAsXmlElement("forceCashout", forceCashout, _buf);
	Atf::XmlElement::encodeAsXmlElement("dummy", dummy, _buf);
	Atf::XmlElement::encodeAsXmlElement("privs3", privs3, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierUserPrivs::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("privs"))
		{
			privs = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("privs2"))
		{
			privs2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("modelessCashierAllowedForUser"))
		{
			modelessCashierAllowedForUser = (*_value.ptr() == '1');
		}
		else if (_element.equals("forceCashout"))
		{
			forceCashout = (*_value.ptr() == '1');
		}
		else if (_element.equals("dummy"))
		{
			dummy = (*_value.ptr() == '1');
		}
		else if (_element.equals("privs3"))
		{
			privs3 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierUserPrivs::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(privs);
	_msg.composeUINT64(privs2);
	_msg.composeBOOL(modelessCashierAllowedForUser);
	_msg.composeBOOL(forceCashout);
	_msg.composeBOOL(dummy);
	_msg.composeUINT64(privs3);
}

void CashierServer::cli::CashierUserPrivs::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(privs);
	_parser.parseUINT64(privs2);
	_parser.parseBOOL(modelessCashierAllowedForUser);
	_parser.parseBOOL(forceCashout);
	_parser.parseBOOL(dummy);
	_parser.parseUINT64(privs3);
}

const char *CashierServer::cli::CashierUserPrivs::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("privs", privs);
	_jsonstr.compose("privs2", privs2);
	_jsonstr.compose("modelessCashierAllowedForUser", modelessCashierAllowedForUser);
	_jsonstr.compose("forceCashout", forceCashout);
	_jsonstr.compose("dummy", dummy);
	_jsonstr.compose("privs3", privs3);
	return _buf.c_str();
}

void CashierServer::cli::CashierUserPrivs::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("privs", privs);
	_jparser.parseByNameThrow("privs2", privs2);
	_jparser.parseByNameThrow("modelessCashierAllowedForUser", modelessCashierAllowedForUser);
	_jparser.parseByNameThrow("forceCashout", forceCashout);
	_jparser.parseByNameThrow("dummy", dummy);
	_jparser.parseByNameThrow("privs3", privs3);
}

/* static */ void CashierServer::cli::CashierUserPrivs::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 privs; _jparser.validateByNameThrow("privs", privs);
	AtfValidator::validateInt(_descr, "privs", privs, _checker, __FILE__, __LINE__);
	UINT64 privs2; _jparser.validateByNameThrow("privs2", privs2);
	AtfValidator::validateUint(_descr, "privs2", privs2, _checker, __FILE__, __LINE__);
	bool modelessCashierAllowedForUser; _jparser.validateByNameThrow("modelessCashierAllowedForUser", modelessCashierAllowedForUser);
	AtfValidator::validateInt(_descr, "modelessCashierAllowedForUser", modelessCashierAllowedForUser, _checker, __FILE__, __LINE__);
	bool forceCashout; _jparser.validateByNameThrow("forceCashout", forceCashout);
	AtfValidator::validateInt(_descr, "forceCashout", forceCashout, _checker, __FILE__, __LINE__);
	bool dummy; _jparser.validateByNameThrow("dummy", dummy);
	AtfValidator::validateInt(_descr, "dummy", dummy, _checker, __FILE__, __LINE__);
	UINT64 privs3; _jparser.validateByNameThrow("privs3", privs3);
	AtfValidator::validateUint(_descr, "privs3", privs3, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierUserPrivs::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 privs; _parser.parseUINT32(privs);
	AtfValidator::validateInt(_descr, "privs", privs, _checker, __FILE__, __LINE__);
	UINT64 privs2; _parser.parseUINT64(privs2);
	AtfValidator::validateUint(_descr, "privs2", privs2, _checker, __FILE__, __LINE__);
	bool modelessCashierAllowedForUser; _parser.parseBOOL(modelessCashierAllowedForUser);
	AtfValidator::validateInt(_descr, "modelessCashierAllowedForUser", modelessCashierAllowedForUser, _checker, __FILE__, __LINE__);
	bool forceCashout; _parser.parseBOOL(forceCashout);
	AtfValidator::validateInt(_descr, "forceCashout", forceCashout, _checker, __FILE__, __LINE__);
	bool dummy; _parser.parseBOOL(dummy);
	AtfValidator::validateInt(_descr, "dummy", dummy, _checker, __FILE__, __LINE__);
	UINT64 privs3; _parser.parseUINT64(privs3);
	AtfValidator::validateUint(_descr, "privs3", privs3, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::clear()
{
	privs.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::equals(const Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY& _o) const
{
	return privs.equals(_o.privs);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_USER_PRIVS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_PRIVS_REPLY).append(")");
	_buf.append(',');
	_buf.append("privs=");
	privs.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_USER_PRIVS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	privs.toXmlString("privs", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("privs"))
			{
				if(!Atf::AtfTempl< CashierUserPrivs >::FromXmlString(_value, privs)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	privs.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::parseMsg(CommMsgParser& _parser)
{
	privs.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("privs", privs);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("privs", privs);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_PRIVS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	CashierUserPrivs privs; _jparser.validateByNameThrow("privs", privs);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_PRIVS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	CashierUserPrivs::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privs"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_PRIVS_2
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::Protocol_MSG_CASHIER_GET_USER_PRIVS_2()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::clear()
{
	unusedStr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::equals(const Protocol_MSG_CASHIER_GET_USER_PRIVS_2& _o) const
{
	return Atf::atfPStringEquals(unusedStr, _o.unusedStr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_USER_PRIVS_2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_USER_PRIVS_2*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_PRIVS_2).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_USER_PRIVS_2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("unusedStr", unusedStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("unusedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, unusedStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(unusedStr);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(unusedStr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("unusedStr", unusedStr);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("unusedStr", unusedStr);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_PRIVS_2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString unusedStr; _jparser.validateByNameThrow("unusedStr", unusedStr);
	AtfValidator::validateIntMax(_descr, "unusedStr", unusedStr.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_PRIVS_2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	privs.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::equals(const Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		privs.equals(_o.privs);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_USER_PRIVS_2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_PRIVS_2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("privs=");
		privs.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_USER_PRIVS_2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		privs.toXmlString("privs", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("privs"))
			{
				if(!Atf::AtfTempl< CashierUserPrivs >::FromXmlString(_value, privs)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		privs.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		privs.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("privs", privs);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("privs", privs);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_PRIVS_2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		CashierUserPrivs privs; _jparser.validateByNameThrow("privs", privs);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_PRIVS_2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		CashierUserPrivs::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privs"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_REAL_PRE_TRANSFER
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::clear()
{
	userFrom.clear();
	userTo.clear();
	amountFrom = 0;
	currencyFrom.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::equals(const Protocol_MSG_CASHIER_REAL_PRE_TRANSFER& _o) const
{
	return Atf::atfPStringEquals(userFrom, _o.userFrom) &&
		Atf::atfPStringEquals(userTo, _o.userTo) &&
		amountFrom == _o.amountFrom &&
		Atf::atfPStringEquals(currencyFrom, _o.currencyFrom);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_REAL_PRE_TRANSFER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_REAL_PRE_TRANSFER*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_REAL_PRE_TRANSFER).append(")");
	_buf.append(',');
	_buf.append("userFrom=");
	_buf.append(userFrom);
	_buf.append(',');
	_buf.append("userTo=");
	_buf.append(userTo);
	_buf.append(',');
	_buf.append("amountFrom=");
	_buf.appendInt(amountFrom);
	_buf.append(',');
	_buf.append("currencyFrom=");
	_buf.append(currencyFrom);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_REAL_PRE_TRANSFER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userFrom", userFrom, _buf);
	Atf::XmlElement::encodeAsXmlElement("userTo", userTo, _buf);
	Atf::XmlElement::encodeAsXmlElement("amountFrom", amountFrom, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyFrom", currencyFrom, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userFrom"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userFrom)) return false;
			}
			else if (_element.equals("userTo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userTo)) return false;
			}
			else if (_element.equals("amountFrom"))
			{
				amountFrom = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currencyFrom"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currencyFrom)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userFrom);
	_msg.composeString(userTo);
	_msg.composeINT32(amountFrom);
	_msg.composeString(currencyFrom);
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userFrom);
	_parser.parseStringP(userTo);
	_parser.parseINT32(amountFrom);
	_parser.parseStringP(currencyFrom);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userFrom", userFrom);
	_jsonstr.compose("userTo", userTo);
	_jsonstr.compose("amountFrom", amountFrom);
	_jsonstr.compose("currencyFrom", currencyFrom);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userFrom", userFrom);
	_jparser.parseByNameThrow("userTo", userTo);
	_jparser.parseByNameThrow("amountFrom", amountFrom);
	_jparser.parseByNameThrow("currencyFrom", currencyFrom);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REAL_PRE_TRANSFER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userFrom; _jparser.validateByNameThrow("userFrom", userFrom);
	AtfValidator::validateIntMax(_descr, "userFrom", userFrom.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString userTo; _jparser.validateByNameThrow("userTo", userTo);
	AtfValidator::validateIntMax(_descr, "userTo", userTo.length(), 1000, _checker, __FILE__, __LINE__);
	INT32 amountFrom; _jparser.validateByNameThrow("amountFrom", amountFrom);
	AtfValidator::validateIntRange(_descr, "amountFrom", amountFrom, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString currencyFrom; _jparser.validateByNameThrow("currencyFrom", currencyFrom);
	AtfValidator::validateIntMax(_descr, "currencyFrom", currencyFrom.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REAL_PRE_TRANSFER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userFrom"); size_t szUserFrom = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userFrom", szUserFrom, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userTo"); size_t szUserTo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userTo", szUserTo, 1000, _checker, __FILE__, __LINE__);
	INT32 amountFrom; _parser.parseINT32(amountFrom);
	AtfValidator::validateIntRange(_descr, "amountFrom", amountFrom, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currencyFrom"); size_t szCurrencyFrom = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currencyFrom", szCurrencyFrom, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	userId.clear();
	city.clear();
	country.clear();
	showCity = 0;
	imageId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::equals(const Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(country, _o.country) &&
		showCity == _o.showCity &&
		imageId == _o.imageId;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_REAL_PRE_TRANSFER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_REAL_PRE_TRANSFER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
		_buf.append(',');
		_buf.append("city=");
		_buf.append(city);
		_buf.append(',');
		_buf.append("country=");
		_buf.append(country);
		_buf.append(',');
		_buf.append("showCity=");
		_buf.appendUint(showCity);
		_buf.append(',');
		_buf.append("imageId=");
		_buf.appendUint(imageId);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_REAL_PRE_TRANSFER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
		Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
		Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
		Atf::XmlElement::encodeAsXmlElement("showCity", showCity, _buf);
		Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("city"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("showCity"))
			{
				showCity = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("imageId"))
			{
				imageId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(userId);
		_msg.composeString(city);
		_msg.composeString(country);
		_msg.composeBYTE(showCity);
		_msg.composeUINT32(imageId);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(userId);
		_parser.parseStringP(city);
		_parser.parseStringP(country);
		_parser.parseBYTE(showCity);
		_parser.parseUINT32(imageId);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("userId", userId);
		_jsonstr.compose("city", city);
		_jsonstr.compose("country", country);
		_jsonstr.compose("showCity", showCity);
		_jsonstr.compose("imageId", imageId);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("userId", userId);
		_jparser.parseByNameThrow("city", city);
		_jparser.parseByNameThrow("country", country);
		_jparser.parseByNameThrow("showCity", showCity);
		_jparser.parseByNameThrow("imageId", imageId);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REAL_PRE_TRANSFER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString userId; _jparser.validateByNameThrow("userId", userId);
		AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
		PString city; _jparser.validateByNameThrow("city", city);
		AtfValidator::validateInt(_descr, "city", city.length(), _checker, __FILE__, __LINE__);
		PString country; _jparser.validateByNameThrow("country", country);
		AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
		BYTE showCity; _jparser.validateByNameThrow("showCity", showCity);
		AtfValidator::validateIntRange(_descr, "showCity", showCity, 0, 1, _checker, __FILE__, __LINE__);
		UINT32 imageId; _jparser.validateByNameThrow("imageId", imageId);
		AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REAL_PRE_TRANSFER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
		AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
		AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
		BYTE showCity; _parser.parseBYTE(showCity);
		AtfValidator::validateIntRange(_descr, "showCity", showCity, 0, 1, _checker, __FILE__, __LINE__);
		UINT32 imageId; _parser.parseUINT32(imageId);
		AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_REAL_TRANSFER
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::Protocol_MSG_CASHIER_REAL_TRANSFER()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::clear()
{
	userFrom.clear();
	userTo.clear();
	amountFrom = 0;
	userComment.clear();
	currencyFrom.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::equals(const Protocol_MSG_CASHIER_REAL_TRANSFER& _o) const
{
	return Atf::atfPStringEquals(userFrom, _o.userFrom) &&
		Atf::atfPStringEquals(userTo, _o.userTo) &&
		amountFrom == _o.amountFrom &&
		Atf::atfPStringEquals(userComment, _o.userComment) &&
		Atf::atfPStringEquals(currencyFrom, _o.currencyFrom);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_REAL_TRANSFER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_REAL_TRANSFER*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_REAL_TRANSFER).append(")");
	_buf.append(',');
	_buf.append("userFrom=");
	_buf.append(userFrom);
	_buf.append(',');
	_buf.append("userTo=");
	_buf.append(userTo);
	_buf.append(',');
	_buf.append("amountFrom=");
	_buf.appendInt(amountFrom);
	_buf.append(',');
	_buf.append("userComment=");
	_buf.append(userComment);
	_buf.append(',');
	_buf.append("currencyFrom=");
	_buf.append(currencyFrom);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_REAL_TRANSFER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userFrom", userFrom, _buf);
	Atf::XmlElement::encodeAsXmlElement("userTo", userTo, _buf);
	Atf::XmlElement::encodeAsXmlElement("amountFrom", amountFrom, _buf);
	Atf::XmlElement::encodeAsXmlElement("userComment", userComment, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyFrom", currencyFrom, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userFrom"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userFrom)) return false;
			}
			else if (_element.equals("userTo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userTo)) return false;
			}
			else if (_element.equals("amountFrom"))
			{
				amountFrom = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userComment"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userComment)) return false;
			}
			else if (_element.equals("currencyFrom"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currencyFrom)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userFrom);
	_msg.composeString(userTo);
	_msg.composeINT32(amountFrom);
	_msg.composeString(userComment);
	_msg.composeString(currencyFrom);
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userFrom);
	_parser.parseStringP(userTo);
	_parser.parseINT32(amountFrom);
	_parser.parseStringP(userComment);
	_parser.parseStringP(currencyFrom);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userFrom", userFrom);
	_jsonstr.compose("userTo", userTo);
	_jsonstr.compose("amountFrom", amountFrom);
	_jsonstr.compose("userComment", userComment);
	_jsonstr.compose("currencyFrom", currencyFrom);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userFrom", userFrom);
	_jparser.parseByNameThrow("userTo", userTo);
	_jparser.parseByNameThrow("amountFrom", amountFrom);
	_jparser.parseByNameThrow("userComment", userComment);
	_jparser.parseByNameThrow("currencyFrom", currencyFrom);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REAL_TRANSFER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userFrom; _jparser.validateByNameThrow("userFrom", userFrom);
	AtfValidator::validateIntMax(_descr, "userFrom", userFrom.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString userTo; _jparser.validateByNameThrow("userTo", userTo);
	AtfValidator::validateIntMax(_descr, "userTo", userTo.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 amountFrom; _jparser.validateByNameThrow("amountFrom", amountFrom);
	AtfValidator::validateIntRange(_descr, "amountFrom", amountFrom, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString userComment; _jparser.validateByNameThrow("userComment", userComment);
	AtfValidator::validateIntMax(_descr, "userComment", userComment.length(), 4000, _checker, __FILE__, __LINE__);
	PString currencyFrom; _jparser.validateByNameThrow("currencyFrom", currencyFrom);
	AtfValidator::validateIntMax(_descr, "currencyFrom", currencyFrom.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REAL_TRANSFER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userFrom"); size_t szUserFrom = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userFrom", szUserFrom, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userTo"); size_t szUserTo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userTo", szUserTo, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 amountFrom; _parser.parseINT32(amountFrom);
	AtfValidator::validateIntRange(_descr, "amountFrom", amountFrom, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userComment"); size_t szUserComment = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userComment", szUserComment, 4000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currencyFrom"); size_t szCurrencyFrom = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currencyFrom", szCurrencyFrom, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::equals(const Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_REAL_TRANSFER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_REAL_TRANSFER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_REAL_TRANSFER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REAL_TRANSFER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REAL_TRANSFER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierRedeemAccountData
//=================================================================

CashierServer::cli::CashierRedeemAccountData::CashierRedeemAccountData()
{
	clear();
}

void CashierServer::cli::CashierRedeemAccountData::clear()
{
	name.clear();
	acct.clear();
}

bool CashierServer::cli::CashierRedeemAccountData::equals(const CashierRedeemAccountData& _o) const
{
	return Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(acct, _o.acct);
}

const char *CashierServer::cli::CashierRedeemAccountData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("acct=");
	_buf.append(acct);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierRedeemAccountData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("acct", acct, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierRedeemAccountData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("acct"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, acct)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierRedeemAccountData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(name);
	_msg.composeString(acct);
}

void CashierServer::cli::CashierRedeemAccountData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
	_parser.parseStringP(acct);
}

const char *CashierServer::cli::CashierRedeemAccountData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	_jsonstr.compose("acct", acct);
	return _buf.c_str();
}

void CashierServer::cli::CashierRedeemAccountData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("acct", acct);
}

/* static */ void CashierServer::cli::CashierRedeemAccountData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateIntMax(_descr, "name", name.length(), 100, _checker, __FILE__, __LINE__);
	PString acct; _jparser.validateByNameThrow("acct", acct);
	AtfValidator::validateIntMax(_descr, "acct", acct.length(), 100, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierRedeemAccountData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "acct"); size_t szAcct = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "acct", szAcct, 100, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::clear()
{
	paysystemByte = 0;
	accounts.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::equals(const Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT& _o) const
{
	return paysystemByte == _o.paysystemByte &&
		accounts.equals(_o.accounts);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CREATE_REDEEM_ACCOUNT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CREATE_REDEEM_ACCOUNT).append(")");
	_buf.append(',');
	_buf.append("paysystemByte=");
	_buf.appendUint(paysystemByte);
	_buf.append(',');
	_buf.append("accounts=");
	accounts.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CREATE_REDEEM_ACCOUNT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paysystemByte", paysystemByte, _buf);
	accounts.toXmlString("accounts", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paysystemByte"))
			{
				paysystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("accounts"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierRedeemAccountData, 4 > >::FromXmlString(_value, accounts)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paysystemByte);
	accounts.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paysystemByte);
	accounts.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paysystemByte", paysystemByte);
	_jsonstr.compose("accounts", accounts);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paysystemByte", paysystemByte);
	_jparser.parseByNameThrow("accounts", accounts);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CREATE_REDEEM_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paysystemByte; _jparser.validateByNameThrow("paysystemByte", paysystemByte);
	AtfValidator::validateIntRange(_descr, "paysystemByte", paysystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< CashierRedeemAccountData > accounts; _jparser.validateByNameThrow("accounts", accounts);
	AtfValidator::validateIntMax(_descr, "accounts", accounts.size(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CREATE_REDEEM_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paysystemByte; _parser.parseBYTE(paysystemByte);
	AtfValidator::validateIntRange(_descr, "paysystemByte", paysystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAccounts = Atf::LAtfVector< CashierRedeemAccountData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("accounts"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "accounts", szAccounts, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::equals(const Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::clear()
{
	userId.clear();
	paysystemByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::equals(const Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		paysystemByte == _o.paysystemByte;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_USER_ACCT_PROC_REGISTRATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_USER_ACCT_PROC_REGISTRATION).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("paysystemByte=");
	_buf.appendUint(paysystemByte);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_USER_ACCT_PROC_REGISTRATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("paysystemByte", paysystemByte, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("paysystemByte"))
			{
				paysystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeBYTE(paysystemByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseBYTE(paysystemByte);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("paysystemByte", paysystemByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("paysystemByte", paysystemByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_ACCT_PROC_REGISTRATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	BYTE paysystemByte; _jparser.validateByNameThrow("paysystemByte", paysystemByte);
	AtfValidator::validateIntRange(_descr, "paysystemByte", paysystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_ACCT_PROC_REGISTRATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	BYTE paysystemByte; _parser.parseBYTE(paysystemByte);
	AtfValidator::validateIntRange(_descr, "paysystemByte", paysystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::equals(const Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHECK_PLI
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::Protocol_MSG_CASHIER_CHECK_PLI()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::clear()
{
	paySystemByte = 0;
	accountCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::equals(const Protocol_MSG_CASHIER_CHECK_PLI& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		Atf::atfPStringEquals(accountCurrency, _o.accountCurrency);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CHECK_PLI != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CHECK_PLI*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHECK_PLI).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("accountCurrency=");
	_buf.append(accountCurrency);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CHECK_PLI).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("accountCurrency", accountCurrency, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("accountCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, accountCurrency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeString(accountCurrency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseStringP(accountCurrency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemByte", paySystemByte);
	_jsonstr.compose("accountCurrency", accountCurrency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
	_jparser.parseByNameThrow("accountCurrency", accountCurrency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PLI";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	PString accountCurrency; _jparser.validateByNameThrow("accountCurrency", accountCurrency);
	AtfValidator::validateIntMax(_descr, "accountCurrency", accountCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PLI";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "accountCurrency"); size_t szAccountCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "accountCurrency", szAccountCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHECK_PLI_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::Protocol_MSG_CASHIER_CHECK_PLI_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	cardTypeByte = 0;
	minDepositInCur = 0;
	maxCashinDaily = 0;
	maxCashinWeekly = 0;
	maxCashinMonthly = 0;
	levelId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::equals(const Protocol_MSG_CASHIER_CHECK_PLI_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		cardTypeByte == _o.cardTypeByte &&
		minDepositInCur == _o.minDepositInCur &&
		maxCashinDaily == _o.maxCashinDaily &&
		maxCashinWeekly == _o.maxCashinWeekly &&
		maxCashinMonthly == _o.maxCashinMonthly &&
		levelId == _o.levelId;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CHECK_PLI_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CHECK_PLI_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHECK_PLI_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("cardTypeByte=");
		_buf.appendUint(cardTypeByte);
		_buf.append(',');
		_buf.append("minDepositInCur=");
		_buf.appendInt(minDepositInCur);
		_buf.append(',');
		_buf.append("maxCashinDaily=");
		_buf.appendInt(maxCashinDaily);
		_buf.append(',');
		_buf.append("maxCashinWeekly=");
		_buf.appendInt(maxCashinWeekly);
		_buf.append(',');
		_buf.append("maxCashinMonthly=");
		_buf.appendInt(maxCashinMonthly);
		_buf.append(',');
		_buf.append("levelId=");
		_buf.appendUint(levelId);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CHECK_PLI_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("cardTypeByte", cardTypeByte, _buf);
		Atf::XmlElement::encodeAsXmlElement("minDepositInCur", minDepositInCur, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxCashinDaily", maxCashinDaily, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxCashinWeekly", maxCashinWeekly, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxCashinMonthly", maxCashinMonthly, _buf);
		Atf::XmlElement::encodeAsXmlElement("levelId", levelId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("cardTypeByte"))
			{
				cardTypeByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minDepositInCur"))
			{
				minDepositInCur = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxCashinDaily"))
			{
				maxCashinDaily = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxCashinWeekly"))
			{
				maxCashinWeekly = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxCashinMonthly"))
			{
				maxCashinMonthly = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("levelId"))
			{
				levelId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBYTE(cardTypeByte);
		_msg.composeINT32(minDepositInCur);
		_msg.composeINT32(maxCashinDaily);
		_msg.composeINT32(maxCashinWeekly);
		_msg.composeINT32(maxCashinMonthly);
		_msg.composeUINT32(levelId);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBYTE(cardTypeByte);
		_parser.parseINT32(minDepositInCur);
		_parser.parseINT32(maxCashinDaily);
		_parser.parseINT32(maxCashinWeekly);
		_parser.parseINT32(maxCashinMonthly);
		_parser.parseUINT32(levelId);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("cardTypeByte", cardTypeByte);
		_jsonstr.compose("minDepositInCur", minDepositInCur);
		_jsonstr.compose("maxCashinDaily", maxCashinDaily);
		_jsonstr.compose("maxCashinWeekly", maxCashinWeekly);
		_jsonstr.compose("maxCashinMonthly", maxCashinMonthly);
		_jsonstr.compose("levelId", levelId);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("cardTypeByte", cardTypeByte);
		_jparser.parseByNameThrow("minDepositInCur", minDepositInCur);
		_jparser.parseByNameThrow("maxCashinDaily", maxCashinDaily);
		_jparser.parseByNameThrow("maxCashinWeekly", maxCashinWeekly);
		_jparser.parseByNameThrow("maxCashinMonthly", maxCashinMonthly);
		_jparser.parseByNameThrow("levelId", levelId);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PLI_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE cardTypeByte; _jparser.validateByNameThrow("cardTypeByte", cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
		INT32 minDepositInCur; _jparser.validateByNameThrow("minDepositInCur", minDepositInCur);
		AtfValidator::validateInt(_descr, "minDepositInCur", minDepositInCur, _checker, __FILE__, __LINE__);
		INT32 maxCashinDaily; _jparser.validateByNameThrow("maxCashinDaily", maxCashinDaily);
		AtfValidator::validateInt(_descr, "maxCashinDaily", maxCashinDaily, _checker, __FILE__, __LINE__);
		INT32 maxCashinWeekly; _jparser.validateByNameThrow("maxCashinWeekly", maxCashinWeekly);
		AtfValidator::validateInt(_descr, "maxCashinWeekly", maxCashinWeekly, _checker, __FILE__, __LINE__);
		INT32 maxCashinMonthly; _jparser.validateByNameThrow("maxCashinMonthly", maxCashinMonthly);
		AtfValidator::validateInt(_descr, "maxCashinMonthly", maxCashinMonthly, _checker, __FILE__, __LINE__);
		UINT32 levelId; _jparser.validateByNameThrow("levelId", levelId);
		AtfValidator::validateInt(_descr, "levelId", levelId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PLI_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
		INT32 minDepositInCur; _parser.parseINT32(minDepositInCur);
		AtfValidator::validateInt(_descr, "minDepositInCur", minDepositInCur, _checker, __FILE__, __LINE__);
		INT32 maxCashinDaily; _parser.parseINT32(maxCashinDaily);
		AtfValidator::validateInt(_descr, "maxCashinDaily", maxCashinDaily, _checker, __FILE__, __LINE__);
		INT32 maxCashinWeekly; _parser.parseINT32(maxCashinWeekly);
		AtfValidator::validateInt(_descr, "maxCashinWeekly", maxCashinWeekly, _checker, __FILE__, __LINE__);
		INT32 maxCashinMonthly; _parser.parseINT32(maxCashinMonthly);
		AtfValidator::validateInt(_descr, "maxCashinMonthly", maxCashinMonthly, _checker, __FILE__, __LINE__);
		UINT32 levelId; _parser.parseUINT32(levelId);
		AtfValidator::validateInt(_descr, "levelId", levelId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_INCREASE_PLI
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::Protocol_MSG_CASHIER_INCREASE_PLI()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::clear()
{
	paySystemByte = 0;
	nextLevelId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::equals(const Protocol_MSG_CASHIER_INCREASE_PLI& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		nextLevelId == _o.nextLevelId;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_INCREASE_PLI != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_INCREASE_PLI*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_INCREASE_PLI).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("nextLevelId=");
	_buf.appendUint(nextLevelId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_INCREASE_PLI).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("nextLevelId", nextLevelId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("nextLevelId"))
			{
				nextLevelId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeUINT32(nextLevelId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseUINT32(nextLevelId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemByte", paySystemByte);
	_jsonstr.compose("nextLevelId", nextLevelId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
	_jparser.parseByNameThrow("nextLevelId", nextLevelId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_INCREASE_PLI";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	UINT32 nextLevelId; _jparser.validateByNameThrow("nextLevelId", nextLevelId);
	AtfValidator::validateInt(_descr, "nextLevelId", nextLevelId, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_INCREASE_PLI";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	UINT32 nextLevelId; _parser.parseUINT32(nextLevelId);
	AtfValidator::validateInt(_descr, "nextLevelId", nextLevelId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_INCREASE_PLI_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::equals(const Protocol_MSG_CASHIER_INCREASE_PLI_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_INCREASE_PLI_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_INCREASE_PLI_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_INCREASE_PLI_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_INCREASE_PLI_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_INCREASE_PLI_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_INCREASE_PLI_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SEND_USER_DOCS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::Protocol_MSG_CASHIER_SEND_USER_DOCS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::clear()
{
	paySystemByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::equals(const Protocol_MSG_CASHIER_SEND_USER_DOCS& _o) const
{
	return paySystemByte == _o.paySystemByte;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SEND_USER_DOCS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SEND_USER_DOCS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SEND_USER_DOCS).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SEND_USER_DOCS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paySystemByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemByte", paySystemByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SEND_USER_DOCS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SEND_USER_DOCS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	data.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::equals(const Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		data.size() == _o.data.size() && memcmp(data.ptr(), _o.data.ptr(), data.size()) == 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SEND_USER_DOCS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SEND_USER_DOCS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("data=");
		Atf::AtfTempl<PBlock>::ToTraceString(_buf, data);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SEND_USER_DOCS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("data", data, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("data"))
			{
				Atf::XmlElement::_movePBlockWithNullStrip(_value, data);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg._composeVarBlock(data.ptr(), data.size());
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parsePBlock(data);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("data", data);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("data", data);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SEND_USER_DOCS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PBlock data; _jparser.validateByNameThrow("data", data);
		AtfValidator::validateInt(_descr, "data", data.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SEND_USER_DOCS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		const BYTE* data; size_t szData; _parser._parseVarBlock(data, szData);  /*data*/
		AtfValidator::validateInt(_descr, "data", szData, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::clear()
{
	paySystemBytes.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::equals(const Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS& _o) const
{
	return paySystemBytes.equals(_o.paySystemBytes);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PAYSYSTEMS_LIMITS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PAYSYSTEMS_LIMITS).append(")");
	_buf.append(',');
	_buf.append("paySystemBytes=");
	paySystemBytes.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PAYSYSTEMS_LIMITS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	paySystemBytes.toXmlString("paySystemBytes", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paySystemBytes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< BYTE, 4 > >::FromXmlString(_value, paySystemBytes)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	paySystemBytes.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::parseMsg(CommMsgParser& _parser)
{
	paySystemBytes.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemBytes", paySystemBytes);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemBytes", paySystemBytes);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< BYTE > paySystemBytes; _jparser.validateByNameThrow("paySystemBytes", paySystemBytes);
	AtfValidator::validateIntMax(_descr, "paySystemBytes", paySystemBytes.size(), 2000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szPaySystemBytes = Atf::LAtfVector< BYTE, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("paySystemBytes"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "paySystemBytes", szPaySystemBytes, 2000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PaysystemLimit2Body
//=================================================================

CashierServer::cli::PaysystemLimit2Body::PaysystemLimit2Body()
{
	clear();
}

void CashierServer::cli::PaysystemLimit2Body::clear()
{
	currency.clear();
	limit.clear();
}

bool CashierServer::cli::PaysystemLimit2Body::equals(const PaysystemLimit2Body& _o) const
{
	return Atf::atfPStringEquals(currency, _o.currency) &&
		limit.equals(_o.limit);
}

const char *CashierServer::cli::PaysystemLimit2Body::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("limit=");
	limit.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::PaysystemLimit2Body::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	limit.toXmlString("limit", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::PaysystemLimit2Body::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("limit"))
		{
			if(!Atf::AtfTempl< common_structs::PaysystemLimit >::FromXmlString(_value, limit)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::PaysystemLimit2Body::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PaysystemLimit2Body())) // not empty
	{
		_body.composeString(currency);
		limit.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::PaysystemLimit2Body::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	limit.parseMsg(_parser0);
}

const char *CashierServer::cli::PaysystemLimit2Body::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("limit", limit);
	return _buf.c_str();
}

void CashierServer::cli::PaysystemLimit2Body::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("limit", limit);
}

/* static */ void CashierServer::cli::PaysystemLimit2Body::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	common_structs::PaysystemLimit limit; _jparser.validateByNameThrow("limit", limit);
}

/*static*/ void CashierServer::cli::PaysystemLimit2Body::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	PString _descbuf;
	common_structs::PaysystemLimit::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("limit"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	limits.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::equals(const Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		limits.equals(_o.limits);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limits=");
		limits.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		limits.toXmlString("limits", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("limits"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PaysystemLimit2Body, 4 > >::FromXmlString(_value, limits)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		limits.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		limits.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("limits", limits);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("limits", limits);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< PaysystemLimit2Body > limits; _jparser.validateByNameThrow("limits", limits);
		AtfValidator::validateInt(_descr, "limits", limits.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szLimits = Atf::LAtfVector< PaysystemLimit2Body, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limits", szLimits, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::equals(const Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CONVERT_ALL_ASSETS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CONVERT_ALL_ASSETS).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CONVERT_ALL_ASSETS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_ALL_ASSETS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_ALL_ASSETS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserAllAssetsOneBody
//=================================================================

CashierServer::cli::UserAllAssetsOneBody::UserAllAssetsOneBody()
{
	clear();
}

void CashierServer::cli::UserAllAssetsOneBody::clear()
{
	assetType = 0;
	typedAmount = 0;
	currency.clear();
	chipsDst = 0;
	convRate = 0;
}

bool CashierServer::cli::UserAllAssetsOneBody::equals(const UserAllAssetsOneBody& _o) const
{
	return assetType == _o.assetType &&
		typedAmount == _o.typedAmount &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		chipsDst == _o.chipsDst &&
		convRate == _o.convRate;
}

const char *CashierServer::cli::UserAllAssetsOneBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("assetType=");
	_buf.appendInt(assetType);
	_buf.append(',');
	_buf.append("typedAmount=");
	_buf.appendInt(typedAmount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("chipsDst=");
	_buf.appendInt(chipsDst);
	_buf.append(',');
	_buf.append("convRate=");
	_buf.appendUint64(convRate);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::UserAllAssetsOneBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("assetType", assetType, _buf);
	Atf::XmlElement::encodeAsXmlElement("typedAmount", typedAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("chipsDst", chipsDst, _buf);
	Atf::XmlElement::encodeAsXmlElement("convRate", convRate, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::UserAllAssetsOneBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("assetType"))
		{
			assetType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("typedAmount"))
		{
			typedAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("chipsDst"))
		{
			chipsDst = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("convRate"))
		{
			convRate = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::UserAllAssetsOneBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(UserAllAssetsOneBody())) // not empty
	{
		_body.composeINT32(assetType);
		_body.composeINT32(typedAmount);
		_body.composeString(currency);
		_body.composeINT32(chipsDst);
		_body.composeUINT64(convRate);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::UserAllAssetsOneBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(assetType);
	_parser0.parseINT32(typedAmount);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(chipsDst);
	_parser0.parseUINT64(convRate);
}

const char *CashierServer::cli::UserAllAssetsOneBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("assetType", assetType);
	_jsonstr.compose("typedAmount", typedAmount);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("chipsDst", chipsDst);
	_jsonstr.compose("convRate", convRate);
	return _buf.c_str();
}

void CashierServer::cli::UserAllAssetsOneBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("assetType", assetType);
	_jparser.parseByNameThrow("typedAmount", typedAmount);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("chipsDst", chipsDst);
	_jparser.parseByNameThrow("convRate", convRate);
}

/* static */ void CashierServer::cli::UserAllAssetsOneBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 assetType; _jparser.validateByNameThrow("assetType", assetType);
	AtfValidator::validateInt(_descr, "assetType", assetType, _checker, __FILE__, __LINE__);
	INT32 typedAmount; _jparser.validateByNameThrow("typedAmount", typedAmount);
	AtfValidator::validateInt(_descr, "typedAmount", typedAmount, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 chipsDst; _jparser.validateByNameThrow("chipsDst", chipsDst);
	AtfValidator::validateInt(_descr, "chipsDst", chipsDst, _checker, __FILE__, __LINE__);
	UINT64 convRate; _jparser.validateByNameThrow("convRate", convRate);
	AtfValidator::validateUint(_descr, "convRate", convRate, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::UserAllAssetsOneBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 assetType; _parser0.parseINT32(assetType);
	AtfValidator::validateInt(_descr, "assetType", assetType, _checker, __FILE__, __LINE__);
	INT32 typedAmount; _parser0.parseINT32(typedAmount);
	AtfValidator::validateInt(_descr, "typedAmount", typedAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 chipsDst; _parser0.parseINT32(chipsDst);
	AtfValidator::validateInt(_descr, "chipsDst", chipsDst, _checker, __FILE__, __LINE__);
	UINT64 convRate; _parser0.parseUINT64(convRate);
	AtfValidator::validateUint(_descr, "convRate", convRate, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserAllAssets
//=================================================================

CashierServer::cli::UserAllAssets::UserAllAssets()
{
	clear();
}

void CashierServer::cli::UserAllAssets::clear()
{
	availDst = 0;
	currencyDst.clear();
	assets.clear();
}

bool CashierServer::cli::UserAllAssets::equals(const UserAllAssets& _o) const
{
	return availDst == _o.availDst &&
		Atf::atfPStringEquals(currencyDst, _o.currencyDst) &&
		assets.equals(_o.assets);
}

const char *CashierServer::cli::UserAllAssets::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("availDst=");
	_buf.appendInt(availDst);
	_buf.append(',');
	_buf.append("currencyDst=");
	_buf.append(currencyDst);
	_buf.append(',');
	_buf.append("assets=");
	assets.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::UserAllAssets::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("availDst", availDst, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyDst", currencyDst, _buf);
	assets.toXmlString("assets", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::UserAllAssets::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("availDst"))
		{
			availDst = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currencyDst"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currencyDst)) return false;
		}
		else if (_element.equals("assets"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UserAllAssetsOneBody, 4 > >::FromXmlString(_value, assets)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::UserAllAssets::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(availDst);
	_msg.composeString(currencyDst);
	assets.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::UserAllAssets::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(availDst);
	_parser.parseStringP(currencyDst);
	assets.parseMsg(_parser);
}

const char *CashierServer::cli::UserAllAssets::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("availDst", availDst);
	_jsonstr.compose("currencyDst", currencyDst);
	_jsonstr.compose("assets", assets);
	return _buf.c_str();
}

void CashierServer::cli::UserAllAssets::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("availDst", availDst);
	_jparser.parseByNameThrow("currencyDst", currencyDst);
	_jparser.parseByNameThrow("assets", assets);
}

/* static */ void CashierServer::cli::UserAllAssets::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 availDst; _jparser.validateByNameThrow("availDst", availDst);
	AtfValidator::validateInt(_descr, "availDst", availDst, _checker, __FILE__, __LINE__);
	PString currencyDst; _jparser.validateByNameThrow("currencyDst", currencyDst);
	AtfValidator::validateInt(_descr, "currencyDst", currencyDst.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UserAllAssetsOneBody > assets; _jparser.validateByNameThrow("assets", assets);
	AtfValidator::validateInt(_descr, "assets", assets.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::UserAllAssets::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 availDst; _parser.parseINT32(availDst);
	AtfValidator::validateInt(_descr, "availDst", availDst, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currencyDst"); size_t szCurrencyDst = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currencyDst", szCurrencyDst, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAssets = Atf::LAtfVector< UserAllAssetsOneBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("assets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "assets", szAssets, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	allAssets.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::equals(const Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		allAssets.equals(_o.allAssets);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("allAssets=");
		allAssets.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		allAssets.toXmlString("allAssets", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("allAssets"))
			{
				if(!Atf::AtfTempl< UserAllAssets >::FromXmlString(_value, allAssets)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		allAssets.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		allAssets.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("allAssets", allAssets);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("allAssets", allAssets);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UserAllAssets allAssets; _jparser.validateByNameThrow("allAssets", allAssets);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserAllAssets::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("allAssets"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::clear()
{
	unusedStr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::equals(const Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT& _o) const
{
	return Atf::atfPStringEquals(unusedStr, _o.unusedStr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_RMF_BANKACCOUNT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_RMF_BANKACCOUNT).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_RMF_BANKACCOUNT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("unusedStr", unusedStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("unusedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, unusedStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(unusedStr);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(unusedStr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("unusedStr", unusedStr);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("unusedStr", unusedStr);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RMF_BANKACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString unusedStr; _jparser.validateByNameThrow("unusedStr", unusedStr);
	AtfValidator::validateIntMax(_descr, "unusedStr", unusedStr.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RMF_BANKACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	bankName.clear();
	accountNumberDecrypted.clear();
	isValid = false;
	bankCountry.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::equals(const Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(bankName, _o.bankName) &&
		Atf::atfPStringEquals(accountNumberDecrypted, _o.accountNumberDecrypted) &&
		isValid == _o.isValid &&
		Atf::atfPStringEquals(bankCountry, _o.bankCountry);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("bankName=");
		_buf.append(bankName);
		_buf.append(',');
		_buf.append("accountNumberDecrypted=");
		_buf.append(accountNumberDecrypted);
		_buf.append(',');
		_buf.append("isValid=");
		_buf.appendUint(isValid);
		_buf.append(',');
		_buf.append("bankCountry=");
		_buf.append(bankCountry);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("bankName", bankName, _buf);
		Atf::XmlElement::encodeAsXmlElement("accountNumberDecrypted", accountNumberDecrypted, _buf);
		Atf::XmlElement::encodeAsXmlElement("isValid", isValid, _buf);
		Atf::XmlElement::encodeAsXmlElement("bankCountry", bankCountry, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("bankName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bankName)) return false;
			}
			else if (_element.equals("accountNumberDecrypted"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, accountNumberDecrypted)) return false;
			}
			else if (_element.equals("isValid"))
			{
				isValid = (*_value.ptr() == '1');
			}
			else if (_element.equals("bankCountry"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bankCountry)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(bankName);
		_msg.composeString(accountNumberDecrypted);
		_msg.composeBOOL(isValid);
		_msg.composeString(bankCountry);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(bankName);
		_parser.parseStringP(accountNumberDecrypted);
		_parser.parseBOOL(isValid);
		_parser.parseStringP(bankCountry);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("bankName", bankName);
		_jsonstr.compose("accountNumberDecrypted", accountNumberDecrypted);
		_jsonstr.compose("isValid", isValid);
		_jsonstr.compose("bankCountry", bankCountry);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("bankName", bankName);
		_jparser.parseByNameThrow("accountNumberDecrypted", accountNumberDecrypted);
		_jparser.parseByNameThrow("isValid", isValid);
		_jparser.parseByNameThrow("bankCountry", bankCountry);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString bankName; _jparser.validateByNameThrow("bankName", bankName);
		AtfValidator::validateInt(_descr, "bankName", bankName.length(), _checker, __FILE__, __LINE__);
		PString accountNumberDecrypted; _jparser.validateByNameThrow("accountNumberDecrypted", accountNumberDecrypted);
		AtfValidator::validateInt(_descr, "accountNumberDecrypted", accountNumberDecrypted.length(), _checker, __FILE__, __LINE__);
		bool isValid; _jparser.validateByNameThrow("isValid", isValid);
		AtfValidator::validateInt(_descr, "isValid", isValid, _checker, __FILE__, __LINE__);
		PString bankCountry; _jparser.validateByNameThrow("bankCountry", bankCountry);
		AtfValidator::validateInt(_descr, "bankCountry", bankCountry.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "bankName"); size_t szBankName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bankName", szBankName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "accountNumberDecrypted"); size_t szAccountNumberDecrypted = strlen(_dummy);
		AtfValidator::validateInt(_descr, "accountNumberDecrypted", szAccountNumberDecrypted, _checker, __FILE__, __LINE__);
		bool isValid; _parser.parseBOOL(isValid);
		AtfValidator::validateInt(_descr, "isValid", isValid, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bankCountry"); size_t szBankCountry = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bankCountry", szBankCountry, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::clear()
{
	bankName.clear();
	accountNumberDecrypted.clear();
	bankCountry.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::equals(const Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT& _o) const
{
	return Atf::atfPStringEquals(bankName, _o.bankName) &&
		Atf::atfPStringEquals(accountNumberDecrypted, _o.accountNumberDecrypted) &&
		Atf::atfPStringEquals(bankCountry, _o.bankCountry);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_RMF_BANKACCOUNT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_RMF_BANKACCOUNT).append(")");
	_buf.append(',');
	_buf.append("bankName=");
	_buf.append(bankName);
	_buf.append(',');
	_buf.append("accountNumberDecrypted=");
	_buf.append(accountNumberDecrypted);
	_buf.append(',');
	_buf.append("bankCountry=");
	_buf.append(bankCountry);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_RMF_BANKACCOUNT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("bankName", bankName, _buf);
	Atf::XmlElement::encodeAsXmlElement("accountNumberDecrypted", accountNumberDecrypted, _buf);
	Atf::XmlElement::encodeAsXmlElement("bankCountry", bankCountry, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("bankName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bankName)) return false;
			}
			else if (_element.equals("accountNumberDecrypted"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, accountNumberDecrypted)) return false;
			}
			else if (_element.equals("bankCountry"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bankCountry)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(bankName);
	_msg.composeString(accountNumberDecrypted);
	_msg.composeString(bankCountry);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(bankName);
	_parser.parseStringP(accountNumberDecrypted);
	_parser.parseStringP(bankCountry);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("bankName", bankName);
	_jsonstr.compose("accountNumberDecrypted", accountNumberDecrypted);
	_jsonstr.compose("bankCountry", bankCountry);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("bankName", bankName);
	_jparser.parseByNameThrow("accountNumberDecrypted", accountNumberDecrypted);
	_jparser.parseByNameThrow("bankCountry", bankCountry);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_RMF_BANKACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString bankName; _jparser.validateByNameThrow("bankName", bankName);
	AtfValidator::validateIntMax(_descr, "bankName", bankName.length(), 1000, _checker, __FILE__, __LINE__);
	PString accountNumberDecrypted; _jparser.validateByNameThrow("accountNumberDecrypted", accountNumberDecrypted);
	AtfValidator::validateIntMax(_descr, "accountNumberDecrypted", accountNumberDecrypted.length(), 1000, _checker, __FILE__, __LINE__);
	PString bankCountry; _jparser.validateByNameThrow("bankCountry", bankCountry);
	AtfValidator::validateIntMax(_descr, "bankCountry", bankCountry.length(), 100, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_RMF_BANKACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "bankName"); size_t szBankName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankName", szBankName, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "accountNumberDecrypted"); size_t szAccountNumberDecrypted = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "accountNumberDecrypted", szAccountNumberDecrypted, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bankCountry"); size_t szBankCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankCountry", szBankCountry, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	reference.clear();
	isValid = false;
	realMoneyOk = 0;
	accountNumberDecrypted.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::equals(const Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(reference, _o.reference) &&
		isValid == _o.isValid &&
		realMoneyOk == _o.realMoneyOk &&
		Atf::atfPStringEquals(accountNumberDecrypted, _o.accountNumberDecrypted);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("reference=");
		_buf.append(reference);
		_buf.append(',');
		_buf.append("isValid=");
		_buf.appendUint(isValid);
		_buf.append(',');
		_buf.append("realMoneyOk=");
		_buf.appendUint(realMoneyOk);
		_buf.append(',');
		_buf.append("accountNumberDecrypted=");
		_buf.append(accountNumberDecrypted);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("reference", reference, _buf);
		Atf::XmlElement::encodeAsXmlElement("isValid", isValid, _buf);
		Atf::XmlElement::encodeAsXmlElement("realMoneyOk", realMoneyOk, _buf);
		Atf::XmlElement::encodeAsXmlElement("accountNumberDecrypted", accountNumberDecrypted, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("reference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, reference)) return false;
			}
			else if (_element.equals("isValid"))
			{
				isValid = (*_value.ptr() == '1');
			}
			else if (_element.equals("realMoneyOk"))
			{
				realMoneyOk = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("accountNumberDecrypted"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, accountNumberDecrypted)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(reference);
		_msg.composeBOOL(isValid);
		CommMsgBody _msg0;
		_msg0.composeBYTE(realMoneyOk);
		_msg0.composeString(accountNumberDecrypted);
		_msg.composeMsgBody(_msg0);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(reference);
		_parser.parseBOOL(isValid);
		parseAnonymousMsgBody0(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("reference", reference);
		_jsonstr.compose("isValid", isValid);
		_jsonstr.compose("realMoneyOk", realMoneyOk);
		_jsonstr.compose("accountNumberDecrypted", accountNumberDecrypted);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("reference", reference);
		_jparser.parseByNameThrow("isValid", isValid);
		_jparser.parseByNameThrow("realMoneyOk", realMoneyOk);
		_jparser.parseByNameThrow("accountNumberDecrypted", accountNumberDecrypted);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString reference; _jparser.validateByNameThrow("reference", reference);
		AtfValidator::validateInt(_descr, "reference", reference.length(), _checker, __FILE__, __LINE__);
		bool isValid; _jparser.validateByNameThrow("isValid", isValid);
		AtfValidator::validateInt(_descr, "isValid", isValid, _checker, __FILE__, __LINE__);
		BYTE realMoneyOk; _jparser.validateByNameThrow("realMoneyOk", realMoneyOk);
		AtfValidator::validateIntRange(_descr, "realMoneyOk", realMoneyOk, 0, 1, _checker, __FILE__, __LINE__);
		PString accountNumberDecrypted; _jparser.validateByNameThrow("accountNumberDecrypted", accountNumberDecrypted);
		AtfValidator::validateInt(_descr, "accountNumberDecrypted", accountNumberDecrypted.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "reference"); size_t szReference = strlen(_dummy);
		AtfValidator::validateInt(_descr, "reference", szReference, _checker, __FILE__, __LINE__);
		bool isValid; _parser.parseBOOL(isValid);
		AtfValidator::validateInt(_descr, "isValid", isValid, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(realMoneyOk);
	_parser0.parseStringP(accountNumberDecrypted);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE realMoneyOk; _parser0.parseBYTE(realMoneyOk);
	AtfValidator::validateIntRange(_descr, "realMoneyOk", realMoneyOk, 0, 1, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "accountNumberDecrypted"); size_t szAccountNumberDecrypted = strlen(_dummy);
	AtfValidator::validateInt(_descr, "accountNumberDecrypted", szAccountNumberDecrypted, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_SPENDING_LIMIT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::equals(const Protocol_MSG_CASHIER_GET_SPENDING_LIMIT& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_SPENDING_LIMIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_SPENDING_LIMIT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_SPENDING_LIMIT).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_SPENDING_LIMIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_SPENDING_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_SPENDING_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	spendingLimitOUT = 0;
	availForSpending = 0;
	totalBalance = 0;
	limitsArray.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::equals(const Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		spendingLimitOUT == _o.spendingLimitOUT &&
		availForSpending == _o.availForSpending &&
		totalBalance == _o.totalBalance &&
		limitsArray.equals(_o.limitsArray);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_SPENDING_LIMIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_SPENDING_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("spendingLimitOUT=");
		_buf.appendInt(spendingLimitOUT);
		_buf.append(',');
		_buf.append("availForSpending=");
		_buf.appendInt(availForSpending);
		_buf.append(',');
		_buf.append("totalBalance=");
		_buf.appendInt(totalBalance);
		_buf.append(',');
		_buf.append("limitsArray=");
		limitsArray.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_SPENDING_LIMIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("spendingLimitOUT", spendingLimitOUT, _buf);
		Atf::XmlElement::encodeAsXmlElement("availForSpending", availForSpending, _buf);
		Atf::XmlElement::encodeAsXmlElement("totalBalance", totalBalance, _buf);
		limitsArray.toXmlString("limitsArray", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("spendingLimitOUT"))
			{
				spendingLimitOUT = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("availForSpending"))
			{
				availForSpending = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("totalBalance"))
			{
				totalBalance = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("limitsArray"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, limitsArray)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(spendingLimitOUT);
		_msg.composeINT32(availForSpending);
		_msg.composeINT32(totalBalance);
		limitsArray.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(spendingLimitOUT);
		_parser.parseINT32(availForSpending);
		_parser.parseINT32(totalBalance);
		limitsArray.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("spendingLimitOUT", spendingLimitOUT);
		_jsonstr.compose("availForSpending", availForSpending);
		_jsonstr.compose("totalBalance", totalBalance);
		_jsonstr.compose("limitsArray", limitsArray);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("spendingLimitOUT", spendingLimitOUT);
		_jparser.parseByNameThrow("availForSpending", availForSpending);
		_jparser.parseByNameThrow("totalBalance", totalBalance);
		_jparser.parseByNameThrow("limitsArray", limitsArray);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_SPENDING_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 spendingLimitOUT; _jparser.validateByNameThrow("spendingLimitOUT", spendingLimitOUT);
		AtfValidator::validateInt(_descr, "spendingLimitOUT", spendingLimitOUT, _checker, __FILE__, __LINE__);
		INT32 availForSpending; _jparser.validateByNameThrow("availForSpending", availForSpending);
		AtfValidator::validateInt(_descr, "availForSpending", availForSpending, _checker, __FILE__, __LINE__);
		INT32 totalBalance; _jparser.validateByNameThrow("totalBalance", totalBalance);
		AtfValidator::validateInt(_descr, "totalBalance", totalBalance, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< INT32 > limitsArray; _jparser.validateByNameThrow("limitsArray", limitsArray);
		AtfValidator::validateInt(_descr, "limitsArray", limitsArray.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_SPENDING_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 spendingLimitOUT; _parser.parseINT32(spendingLimitOUT);
		AtfValidator::validateInt(_descr, "spendingLimitOUT", spendingLimitOUT, _checker, __FILE__, __LINE__);
		INT32 availForSpending; _parser.parseINT32(availForSpending);
		AtfValidator::validateInt(_descr, "availForSpending", availForSpending, _checker, __FILE__, __LINE__);
		INT32 totalBalance; _parser.parseINT32(totalBalance);
		AtfValidator::validateInt(_descr, "totalBalance", totalBalance, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szLimitsArray = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limitsArray"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limitsArray", szLimitsArray, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_SPENDING_LIMIT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::clear()
{
	spendingLimit = 0;
	flags_ignored = 0;
	flags2_ignored = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::equals(const Protocol_MSG_CASHIER_SET_SPENDING_LIMIT& _o) const
{
	return spendingLimit == _o.spendingLimit &&
		flags_ignored == _o.flags_ignored &&
		flags2_ignored == _o.flags2_ignored;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_SPENDING_LIMIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_SPENDING_LIMIT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_SPENDING_LIMIT).append(")");
	_buf.append(',');
	_buf.append("spendingLimit=");
	_buf.appendInt(spendingLimit);
	_buf.append(',');
	_buf.append("flags_ignored=");
	_buf.appendUint(flags_ignored);
	_buf.append(',');
	_buf.append("flags2_ignored=");
	_buf.appendUint64(flags2_ignored);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_SPENDING_LIMIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("spendingLimit", spendingLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags_ignored", flags_ignored, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags2_ignored", flags2_ignored, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("spendingLimit"))
			{
				spendingLimit = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags_ignored"))
			{
				flags_ignored = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags2_ignored"))
			{
				flags2_ignored = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(spendingLimit);
	_msg.composeUINT32(flags_ignored);
	_msg.composeUINT64(flags2_ignored);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(spendingLimit);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(flags_ignored);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(flags2_ignored);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("spendingLimit", spendingLimit);
	_jsonstr.compose("flags_ignored", flags_ignored);
	_jsonstr.compose("flags2_ignored", flags2_ignored);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("spendingLimit", spendingLimit);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("flags_ignored", flags_ignored);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("flags2_ignored", flags2_ignored);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_SPENDING_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 spendingLimit; _jparser.validateByNameThrow("spendingLimit", spendingLimit);
	AtfValidator::validateIntRange(_descr, "spendingLimit", spendingLimit, 1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 flags_ignored; _jparser.validateByNameThrow("flags_ignored", flags_ignored);
	AtfValidator::validateInt(_descr, "flags_ignored", flags_ignored, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 flags2_ignored; _jparser.validateByNameThrow("flags2_ignored", flags2_ignored);
	AtfValidator::validateUint(_descr, "flags2_ignored", flags2_ignored, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_SPENDING_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 spendingLimit; _parser.parseINT32(spendingLimit);
	AtfValidator::validateIntRange(_descr, "spendingLimit", spendingLimit, 1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 flags_ignored; _parser.parseUINT32(flags_ignored);
	AtfValidator::validateInt(_descr, "flags_ignored", flags_ignored, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 flags2_ignored; _parser.parseUINT64(flags2_ignored);
	AtfValidator::validateUint(_descr, "flags2_ignored", flags2_ignored, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::equals(const Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_SPENDING_LIMIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_SPENDING_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_SPENDING_LIMIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_SPENDING_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_SPENDING_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_CANCEL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::clear()
{
	cancelCode = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::equals(const Protocol_MSG_CASHIER_FRMIGRATION_CANCEL& _o) const
{
	return cancelCode == _o.cancelCode;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_FRMIGRATION_CANCEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_FRMIGRATION_CANCEL*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_CANCEL).append(")");
	_buf.append(',');
	_buf.append("cancelCode=");
	_buf.appendUint(cancelCode);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_FRMIGRATION_CANCEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("cancelCode", cancelCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("cancelCode"))
			{
				cancelCode = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(cancelCode);
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(cancelCode);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cancelCode", cancelCode);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cancelCode", cancelCode);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 cancelCode; _jparser.validateByNameThrow("cancelCode", cancelCode);
	AtfValidator::validateIntRange(_descr, "cancelCode", cancelCode, eFrMigrationCancelCode1, eFrMigrationCancelCodeLast, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 cancelCode; _parser.parseUINT32(cancelCode);
	AtfValidator::validateIntRange(_descr, "cancelCode", cancelCode, eFrMigrationCancelCode1, eFrMigrationCancelCodeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::equals(const Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_FRMIGRATION_CANCEL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_CANCEL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_FRMIGRATION_CANCEL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_CANCEL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_CANCEL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::clear()
{
	migrTypeInt = 0;
	linkedUserId.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::equals(const Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO& _o) const
{
	return migrTypeInt == _o.migrTypeInt &&
		Atf::atfPStringEquals(linkedUserId, _o.linkedUserId);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_FRMIGRATION_GET_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_GET_INFO).append(")");
	_buf.append(',');
	_buf.append("migrTypeInt=");
	_buf.appendUint(migrTypeInt);
	_buf.append(',');
	_buf.append("linkedUserId=");
	_buf.append(linkedUserId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_FRMIGRATION_GET_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("migrTypeInt", migrTypeInt, _buf);
	Atf::XmlElement::encodeAsXmlElement("linkedUserId", linkedUserId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("migrTypeInt"))
			{
				migrTypeInt = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("linkedUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, linkedUserId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(migrTypeInt);
	_msg.composeString(linkedUserId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(migrTypeInt);
	_parser.parseStringP(linkedUserId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("migrTypeInt", migrTypeInt);
	_jsonstr.compose("linkedUserId", linkedUserId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("migrTypeInt", migrTypeInt);
	_jparser.parseByNameThrow("linkedUserId", linkedUserId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 migrTypeInt; _jparser.validateByNameThrow("migrTypeInt", migrTypeInt);
	AtfValidator::validateIntRange(_descr, "migrTypeInt", migrTypeInt, eMigrationTypeTransfer, eMigrationTypeLast, _checker, __FILE__, __LINE__);
	PString linkedUserId; _jparser.validateByNameThrow("linkedUserId", linkedUserId);
	AtfValidator::validateIntMax(_descr, "linkedUserId", linkedUserId.length(), 200, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 migrTypeInt; _parser.parseUINT32(migrTypeInt);
	AtfValidator::validateIntRange(_descr, "migrTypeInt", migrTypeInt, eMigrationTypeTransfer, eMigrationTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "linkedUserId"); size_t szLinkedUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "linkedUserId", szLinkedUserId, 200, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	cashAssets.clear();
	tChipsAssets.clear();
	fppBalance = 0;
	vipRewardBonusFpp = 0;
	monthlyVpp = 0;
	yearlyVpp = 0;
	totalCashAmount = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::equals(const Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		cashAssets.equals(_o.cashAssets) &&
		tChipsAssets.equals(_o.tChipsAssets) &&
		fppBalance == _o.fppBalance &&
		vipRewardBonusFpp == _o.vipRewardBonusFpp &&
		monthlyVpp == _o.monthlyVpp &&
		yearlyVpp == _o.yearlyVpp &&
		totalCashAmount == _o.totalCashAmount;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("cashAssets=");
		cashAssets.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tChipsAssets=");
		tChipsAssets.toTraceString(_buf);
		_buf.append(',');
		_buf.append("fppBalance=");
		_buf.appendUint(fppBalance);
		_buf.append(',');
		_buf.append("vipRewardBonusFpp=");
		_buf.appendUint(vipRewardBonusFpp);
		_buf.append(',');
		_buf.append("monthlyVpp=");
		_buf.appendUint(monthlyVpp);
		_buf.append(',');
		_buf.append("yearlyVpp=");
		_buf.appendUint(yearlyVpp);
		_buf.append(',');
		_buf.append("totalCashAmount=");
		_buf.appendUint(totalCashAmount);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		cashAssets.toXmlString("cashAssets", _buf);
		tChipsAssets.toXmlString("tChipsAssets", _buf);
		Atf::XmlElement::encodeAsXmlElement("fppBalance", fppBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("vipRewardBonusFpp", vipRewardBonusFpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("monthlyVpp", monthlyVpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("yearlyVpp", yearlyVpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("totalCashAmount", totalCashAmount, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("cashAssets"))
			{
				if(!Atf::AtfTempl< UserAllAssets >::FromXmlString(_value, cashAssets)) return false;
			}
			else if (_element.equals("tChipsAssets"))
			{
				if(!Atf::AtfTempl< UserAllAssets >::FromXmlString(_value, tChipsAssets)) return false;
			}
			else if (_element.equals("fppBalance"))
			{
				fppBalance = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vipRewardBonusFpp"))
			{
				vipRewardBonusFpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("monthlyVpp"))
			{
				monthlyVpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("yearlyVpp"))
			{
				yearlyVpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("totalCashAmount"))
			{
				totalCashAmount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		cashAssets.composeMsg(_msg, _ignoreJSON);
		tChipsAssets.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT32(fppBalance);
		_msg.composeUINT32(vipRewardBonusFpp);
		_msg.composeUINT32(monthlyVpp);
		_msg.composeUINT32(yearlyVpp);
		_msg.composeUINT32(totalCashAmount);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		cashAssets.parseMsg(_parser);
		tChipsAssets.parseMsg(_parser);
		_parser.parseUINT32(fppBalance);
		_parser.parseUINT32(vipRewardBonusFpp);
		_parser.parseUINT32(monthlyVpp);
		_parser.parseUINT32(yearlyVpp);
		_parser.parseUINT32(totalCashAmount);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("cashAssets", cashAssets);
		_jsonstr.compose("tChipsAssets", tChipsAssets);
		_jsonstr.compose("fppBalance", fppBalance);
		_jsonstr.compose("vipRewardBonusFpp", vipRewardBonusFpp);
		_jsonstr.compose("monthlyVpp", monthlyVpp);
		_jsonstr.compose("yearlyVpp", yearlyVpp);
		_jsonstr.compose("totalCashAmount", totalCashAmount);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("cashAssets", cashAssets);
		_jparser.parseByNameThrow("tChipsAssets", tChipsAssets);
		_jparser.parseByNameThrow("fppBalance", fppBalance);
		_jparser.parseByNameThrow("vipRewardBonusFpp", vipRewardBonusFpp);
		_jparser.parseByNameThrow("monthlyVpp", monthlyVpp);
		_jparser.parseByNameThrow("yearlyVpp", yearlyVpp);
		_jparser.parseByNameThrow("totalCashAmount", totalCashAmount);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UserAllAssets cashAssets; _jparser.validateByNameThrow("cashAssets", cashAssets);
		UserAllAssets tChipsAssets; _jparser.validateByNameThrow("tChipsAssets", tChipsAssets);
		UINT32 fppBalance; _jparser.validateByNameThrow("fppBalance", fppBalance);
		AtfValidator::validateInt(_descr, "fppBalance", fppBalance, _checker, __FILE__, __LINE__);
		UINT32 vipRewardBonusFpp; _jparser.validateByNameThrow("vipRewardBonusFpp", vipRewardBonusFpp);
		AtfValidator::validateInt(_descr, "vipRewardBonusFpp", vipRewardBonusFpp, _checker, __FILE__, __LINE__);
		UINT32 monthlyVpp; _jparser.validateByNameThrow("monthlyVpp", monthlyVpp);
		AtfValidator::validateInt(_descr, "monthlyVpp", monthlyVpp, _checker, __FILE__, __LINE__);
		UINT32 yearlyVpp; _jparser.validateByNameThrow("yearlyVpp", yearlyVpp);
		AtfValidator::validateInt(_descr, "yearlyVpp", yearlyVpp, _checker, __FILE__, __LINE__);
		UINT32 totalCashAmount; _jparser.validateByNameThrow("totalCashAmount", totalCashAmount);
		AtfValidator::validateInt(_descr, "totalCashAmount", totalCashAmount, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserAllAssets::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cashAssets"), _fieldsWithUnparsedContent);
		UserAllAssets::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tChipsAssets"), _fieldsWithUnparsedContent);
		UINT32 fppBalance; _parser.parseUINT32(fppBalance);
		AtfValidator::validateInt(_descr, "fppBalance", fppBalance, _checker, __FILE__, __LINE__);
		UINT32 vipRewardBonusFpp; _parser.parseUINT32(vipRewardBonusFpp);
		AtfValidator::validateInt(_descr, "vipRewardBonusFpp", vipRewardBonusFpp, _checker, __FILE__, __LINE__);
		UINT32 monthlyVpp; _parser.parseUINT32(monthlyVpp);
		AtfValidator::validateInt(_descr, "monthlyVpp", monthlyVpp, _checker, __FILE__, __LINE__);
		UINT32 yearlyVpp; _parser.parseUINT32(yearlyVpp);
		AtfValidator::validateInt(_descr, "yearlyVpp", yearlyVpp, _checker, __FILE__, __LINE__);
		UINT32 totalCashAmount; _parser.parseUINT32(totalCashAmount);
		AtfValidator::validateInt(_descr, "totalCashAmount", totalCashAmount, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::Protocol_MSG_CASHIER_FRMIGRATION()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::equals(const Protocol_MSG_CASHIER_FRMIGRATION& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_FRMIGRATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_FRMIGRATION*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_FRMIGRATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::Protocol_MSG_CASHIER_FRMIGRATION_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	overcreditTransId = 0;
	migrationId = 0;
	overcreditAmount = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::equals(const Protocol_MSG_CASHIER_FRMIGRATION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		overcreditTransId == _o.overcreditTransId &&
		migrationId == _o.migrationId &&
		overcreditAmount == _o.overcreditAmount;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_FRMIGRATION_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_FRMIGRATION_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("overcreditTransId=");
		_buf.appendUint(overcreditTransId);
		_buf.append(',');
		_buf.append("migrationId=");
		_buf.appendUint(migrationId);
		_buf.append(',');
		_buf.append("overcreditAmount=");
		_buf.appendInt(overcreditAmount);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_FRMIGRATION_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("overcreditTransId", overcreditTransId, _buf);
		Atf::XmlElement::encodeAsXmlElement("migrationId", migrationId, _buf);
		Atf::XmlElement::encodeAsXmlElement("overcreditAmount", overcreditAmount, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("overcreditTransId"))
			{
				overcreditTransId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("migrationId"))
			{
				migrationId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("overcreditAmount"))
			{
				overcreditAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(overcreditTransId);
		_msg.composeUINT32(migrationId);
		_msg.composeINT32(overcreditAmount);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(overcreditTransId);
		_parser.parseUINT32(migrationId);
		_parser.parseINT32(overcreditAmount);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("overcreditTransId", overcreditTransId);
		_jsonstr.compose("migrationId", migrationId);
		_jsonstr.compose("overcreditAmount", overcreditAmount);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("overcreditTransId", overcreditTransId);
		_jparser.parseByNameThrow("migrationId", migrationId);
		_jparser.parseByNameThrow("overcreditAmount", overcreditAmount);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 overcreditTransId; _jparser.validateByNameThrow("overcreditTransId", overcreditTransId);
		AtfValidator::validateInt(_descr, "overcreditTransId", overcreditTransId, _checker, __FILE__, __LINE__);
		UINT32 migrationId; _jparser.validateByNameThrow("migrationId", migrationId);
		AtfValidator::validateInt(_descr, "migrationId", migrationId, _checker, __FILE__, __LINE__);
		INT32 overcreditAmount; _jparser.validateByNameThrow("overcreditAmount", overcreditAmount);
		AtfValidator::validateInt(_descr, "overcreditAmount", overcreditAmount, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 overcreditTransId; _parser.parseUINT32(overcreditTransId);
		AtfValidator::validateInt(_descr, "overcreditTransId", overcreditTransId, _checker, __FILE__, __LINE__);
		UINT32 migrationId; _parser.parseUINT32(migrationId);
		AtfValidator::validateInt(_descr, "migrationId", migrationId, _checker, __FILE__, __LINE__);
		INT32 overcreditAmount; _parser.parseINT32(overcreditAmount);
		AtfValidator::validateInt(_descr, "overcreditAmount", overcreditAmount, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::clear()
{
	doDeposit = false;
	overcreditTransId = 0;
	migrationId = 0;
	amount = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::equals(const Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT& _o) const
{
	return doDeposit == _o.doDeposit &&
		overcreditTransId == _o.overcreditTransId &&
		migrationId == _o.migrationId &&
		amount == _o.amount;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_FRMIGRATION_DEPOSIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_DEPOSIT).append(")");
	_buf.append(',');
	_buf.append("doDeposit=");
	_buf.appendUint(doDeposit);
	_buf.append(',');
	_buf.append("overcreditTransId=");
	_buf.appendUint(overcreditTransId);
	_buf.append(',');
	_buf.append("migrationId=");
	_buf.appendUint(migrationId);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_FRMIGRATION_DEPOSIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("doDeposit", doDeposit, _buf);
	Atf::XmlElement::encodeAsXmlElement("overcreditTransId", overcreditTransId, _buf);
	Atf::XmlElement::encodeAsXmlElement("migrationId", migrationId, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("doDeposit"))
			{
				doDeposit = (*_value.ptr() == '1');
			}
			else if (_element.equals("overcreditTransId"))
			{
				overcreditTransId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("migrationId"))
			{
				migrationId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("amount"))
			{
				amount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(doDeposit);
	_msg.composeUINT32(overcreditTransId);
	_msg.composeUINT32(migrationId);
	_msg.composeINT32(amount);
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(doDeposit);
	_parser.parseUINT32(overcreditTransId);
	_parser.parseUINT32(migrationId);
	_parser.parseINT32(amount);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("doDeposit", doDeposit);
	_jsonstr.compose("overcreditTransId", overcreditTransId);
	_jsonstr.compose("migrationId", migrationId);
	_jsonstr.compose("amount", amount);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("doDeposit", doDeposit);
	_jparser.parseByNameThrow("overcreditTransId", overcreditTransId);
	_jparser.parseByNameThrow("migrationId", migrationId);
	_jparser.parseByNameThrow("amount", amount);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_DEPOSIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool doDeposit; _jparser.validateByNameThrow("doDeposit", doDeposit);
	AtfValidator::validateInt(_descr, "doDeposit", doDeposit, _checker, __FILE__, __LINE__);
	UINT32 overcreditTransId; _jparser.validateByNameThrow("overcreditTransId", overcreditTransId);
	AtfValidator::validateInt(_descr, "overcreditTransId", overcreditTransId, _checker, __FILE__, __LINE__);
	UINT32 migrationId; _jparser.validateByNameThrow("migrationId", migrationId);
	AtfValidator::validateInt(_descr, "migrationId", migrationId, _checker, __FILE__, __LINE__);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_DEPOSIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool doDeposit; _parser.parseBOOL(doDeposit);
	AtfValidator::validateInt(_descr, "doDeposit", doDeposit, _checker, __FILE__, __LINE__);
	UINT32 overcreditTransId; _parser.parseUINT32(overcreditTransId);
	AtfValidator::validateInt(_descr, "overcreditTransId", overcreditTransId, _checker, __FILE__, __LINE__);
	UINT32 migrationId; _parser.parseUINT32(migrationId);
	AtfValidator::validateInt(_descr, "migrationId", migrationId, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::equals(const Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::clear()
{
	cancelCode = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::equals(const Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL& _o) const
{
	return cancelCode == _o.cancelCode;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_ESMIGRATION2_CANCEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ESMIGRATION2_CANCEL).append(")");
	_buf.append(',');
	_buf.append("cancelCode=");
	_buf.appendUint(cancelCode);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_ESMIGRATION2_CANCEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("cancelCode", cancelCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("cancelCode"))
			{
				cancelCode = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(cancelCode);
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(cancelCode);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cancelCode", cancelCode);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cancelCode", cancelCode);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 cancelCode; _jparser.validateByNameThrow("cancelCode", cancelCode);
	AtfValidator::validateIntRange(_descr, "cancelCode", cancelCode, eEsMigrationCancelCode1, eEsMigrationCancelCodeLast, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 cancelCode; _parser.parseUINT32(cancelCode);
	AtfValidator::validateIntRange(_descr, "cancelCode", cancelCode, eEsMigrationCancelCode1, eEsMigrationCancelCodeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::equals(const Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::equals(const Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_ESMIGRATION2_GET_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ESMIGRATION2_GET_INFO).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_ESMIGRATION2_GET_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	cashAssets.clear();
	tChipsAssets.clear();
	fppBalance = 0;
	vipRewardBonusFpp = 0;
	monthlyVpp = 0;
	yearlyVpp = 0;
	totalCashAmount = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::equals(const Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		cashAssets.equals(_o.cashAssets) &&
		tChipsAssets.equals(_o.tChipsAssets) &&
		fppBalance == _o.fppBalance &&
		vipRewardBonusFpp == _o.vipRewardBonusFpp &&
		monthlyVpp == _o.monthlyVpp &&
		yearlyVpp == _o.yearlyVpp &&
		totalCashAmount == _o.totalCashAmount;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("cashAssets=");
		cashAssets.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tChipsAssets=");
		tChipsAssets.toTraceString(_buf);
		_buf.append(',');
		_buf.append("fppBalance=");
		_buf.appendUint(fppBalance);
		_buf.append(',');
		_buf.append("vipRewardBonusFpp=");
		_buf.appendUint(vipRewardBonusFpp);
		_buf.append(',');
		_buf.append("monthlyVpp=");
		_buf.appendUint(monthlyVpp);
		_buf.append(',');
		_buf.append("yearlyVpp=");
		_buf.appendUint(yearlyVpp);
		_buf.append(',');
		_buf.append("totalCashAmount=");
		_buf.appendUint(totalCashAmount);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		cashAssets.toXmlString("cashAssets", _buf);
		tChipsAssets.toXmlString("tChipsAssets", _buf);
		Atf::XmlElement::encodeAsXmlElement("fppBalance", fppBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("vipRewardBonusFpp", vipRewardBonusFpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("monthlyVpp", monthlyVpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("yearlyVpp", yearlyVpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("totalCashAmount", totalCashAmount, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("cashAssets"))
			{
				if(!Atf::AtfTempl< UserAllAssets >::FromXmlString(_value, cashAssets)) return false;
			}
			else if (_element.equals("tChipsAssets"))
			{
				if(!Atf::AtfTempl< UserAllAssets >::FromXmlString(_value, tChipsAssets)) return false;
			}
			else if (_element.equals("fppBalance"))
			{
				fppBalance = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vipRewardBonusFpp"))
			{
				vipRewardBonusFpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("monthlyVpp"))
			{
				monthlyVpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("yearlyVpp"))
			{
				yearlyVpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("totalCashAmount"))
			{
				totalCashAmount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		cashAssets.composeMsg(_msg, _ignoreJSON);
		tChipsAssets.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT32(fppBalance);
		_msg.composeUINT32(vipRewardBonusFpp);
		_msg.composeUINT32(monthlyVpp);
		_msg.composeUINT32(yearlyVpp);
		_msg.composeUINT32(totalCashAmount);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		cashAssets.parseMsg(_parser);
		tChipsAssets.parseMsg(_parser);
		_parser.parseUINT32(fppBalance);
		_parser.parseUINT32(vipRewardBonusFpp);
		_parser.parseUINT32(monthlyVpp);
		_parser.parseUINT32(yearlyVpp);
		_parser.parseUINT32(totalCashAmount);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("cashAssets", cashAssets);
		_jsonstr.compose("tChipsAssets", tChipsAssets);
		_jsonstr.compose("fppBalance", fppBalance);
		_jsonstr.compose("vipRewardBonusFpp", vipRewardBonusFpp);
		_jsonstr.compose("monthlyVpp", monthlyVpp);
		_jsonstr.compose("yearlyVpp", yearlyVpp);
		_jsonstr.compose("totalCashAmount", totalCashAmount);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("cashAssets", cashAssets);
		_jparser.parseByNameThrow("tChipsAssets", tChipsAssets);
		_jparser.parseByNameThrow("fppBalance", fppBalance);
		_jparser.parseByNameThrow("vipRewardBonusFpp", vipRewardBonusFpp);
		_jparser.parseByNameThrow("monthlyVpp", monthlyVpp);
		_jparser.parseByNameThrow("yearlyVpp", yearlyVpp);
		_jparser.parseByNameThrow("totalCashAmount", totalCashAmount);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UserAllAssets cashAssets; _jparser.validateByNameThrow("cashAssets", cashAssets);
		UserAllAssets tChipsAssets; _jparser.validateByNameThrow("tChipsAssets", tChipsAssets);
		UINT32 fppBalance; _jparser.validateByNameThrow("fppBalance", fppBalance);
		AtfValidator::validateInt(_descr, "fppBalance", fppBalance, _checker, __FILE__, __LINE__);
		UINT32 vipRewardBonusFpp; _jparser.validateByNameThrow("vipRewardBonusFpp", vipRewardBonusFpp);
		AtfValidator::validateInt(_descr, "vipRewardBonusFpp", vipRewardBonusFpp, _checker, __FILE__, __LINE__);
		UINT32 monthlyVpp; _jparser.validateByNameThrow("monthlyVpp", monthlyVpp);
		AtfValidator::validateInt(_descr, "monthlyVpp", monthlyVpp, _checker, __FILE__, __LINE__);
		UINT32 yearlyVpp; _jparser.validateByNameThrow("yearlyVpp", yearlyVpp);
		AtfValidator::validateInt(_descr, "yearlyVpp", yearlyVpp, _checker, __FILE__, __LINE__);
		UINT32 totalCashAmount; _jparser.validateByNameThrow("totalCashAmount", totalCashAmount);
		AtfValidator::validateInt(_descr, "totalCashAmount", totalCashAmount, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserAllAssets::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cashAssets"), _fieldsWithUnparsedContent);
		UserAllAssets::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tChipsAssets"), _fieldsWithUnparsedContent);
		UINT32 fppBalance; _parser.parseUINT32(fppBalance);
		AtfValidator::validateInt(_descr, "fppBalance", fppBalance, _checker, __FILE__, __LINE__);
		UINT32 vipRewardBonusFpp; _parser.parseUINT32(vipRewardBonusFpp);
		AtfValidator::validateInt(_descr, "vipRewardBonusFpp", vipRewardBonusFpp, _checker, __FILE__, __LINE__);
		UINT32 monthlyVpp; _parser.parseUINT32(monthlyVpp);
		AtfValidator::validateInt(_descr, "monthlyVpp", monthlyVpp, _checker, __FILE__, __LINE__);
		UINT32 yearlyVpp; _parser.parseUINT32(yearlyVpp);
		AtfValidator::validateInt(_descr, "yearlyVpp", yearlyVpp, _checker, __FILE__, __LINE__);
		UINT32 totalCashAmount; _parser.parseUINT32(totalCashAmount);
		AtfValidator::validateInt(_descr, "totalCashAmount", totalCashAmount, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ESMIGRATION2
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::Protocol_MSG_CASHIER_ESMIGRATION2()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::equals(const Protocol_MSG_CASHIER_ESMIGRATION2& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_ESMIGRATION2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_ESMIGRATION2*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ESMIGRATION2).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_ESMIGRATION2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ESMIGRATION2_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	overcreditTransId = 0;
	migrationId = 0;
	overcreditAmount = 0;
	voucher.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::equals(const Protocol_MSG_CASHIER_ESMIGRATION2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		overcreditTransId == _o.overcreditTransId &&
		migrationId == _o.migrationId &&
		overcreditAmount == _o.overcreditAmount &&
		Atf::atfPStringEquals(voucher, _o.voucher);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_ESMIGRATION2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_ESMIGRATION2_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ESMIGRATION2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("overcreditTransId=");
		_buf.appendUint(overcreditTransId);
		_buf.append(',');
		_buf.append("migrationId=");
		_buf.appendUint(migrationId);
		_buf.append(',');
		_buf.append("overcreditAmount=");
		_buf.appendUint(overcreditAmount);
		_buf.append(',');
		_buf.append("voucher=");
		_buf.append(voucher);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_ESMIGRATION2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("overcreditTransId", overcreditTransId, _buf);
		Atf::XmlElement::encodeAsXmlElement("migrationId", migrationId, _buf);
		Atf::XmlElement::encodeAsXmlElement("overcreditAmount", overcreditAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("voucher", voucher, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("overcreditTransId"))
			{
				overcreditTransId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("migrationId"))
			{
				migrationId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("overcreditAmount"))
			{
				overcreditAmount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("voucher"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, voucher)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(overcreditTransId);
		_msg.composeUINT32(migrationId);
		_msg.composeUINT32(overcreditAmount);
		_msg.composeString(voucher);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(overcreditTransId);
		_parser.parseUINT32(migrationId);
		_parser.parseUINT32(overcreditAmount);
		_parser.parseStringP(voucher);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("overcreditTransId", overcreditTransId);
		_jsonstr.compose("migrationId", migrationId);
		_jsonstr.compose("overcreditAmount", overcreditAmount);
		_jsonstr.compose("voucher", voucher);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("overcreditTransId", overcreditTransId);
		_jparser.parseByNameThrow("migrationId", migrationId);
		_jparser.parseByNameThrow("overcreditAmount", overcreditAmount);
		_jparser.parseByNameThrow("voucher", voucher);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 overcreditTransId; _jparser.validateByNameThrow("overcreditTransId", overcreditTransId);
		AtfValidator::validateInt(_descr, "overcreditTransId", overcreditTransId, _checker, __FILE__, __LINE__);
		UINT32 migrationId; _jparser.validateByNameThrow("migrationId", migrationId);
		AtfValidator::validateInt(_descr, "migrationId", migrationId, _checker, __FILE__, __LINE__);
		UINT32 overcreditAmount; _jparser.validateByNameThrow("overcreditAmount", overcreditAmount);
		AtfValidator::validateInt(_descr, "overcreditAmount", overcreditAmount, _checker, __FILE__, __LINE__);
		PString voucher; _jparser.validateByNameThrow("voucher", voucher);
		AtfValidator::validateInt(_descr, "voucher", voucher.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 overcreditTransId; _parser.parseUINT32(overcreditTransId);
		AtfValidator::validateInt(_descr, "overcreditTransId", overcreditTransId, _checker, __FILE__, __LINE__);
		UINT32 migrationId; _parser.parseUINT32(migrationId);
		AtfValidator::validateInt(_descr, "migrationId", migrationId, _checker, __FILE__, __LINE__);
		UINT32 overcreditAmount; _parser.parseUINT32(overcreditAmount);
		AtfValidator::validateInt(_descr, "overcreditAmount", overcreditAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "voucher"); size_t szVoucher = strlen(_dummy);
		AtfValidator::validateInt(_descr, "voucher", szVoucher, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::clear()
{
	doDeposit = false;
	overcreditTransId = 0;
	migrationId = 0;
	amountEur = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::equals(const Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT& _o) const
{
	return doDeposit == _o.doDeposit &&
		overcreditTransId == _o.overcreditTransId &&
		migrationId == _o.migrationId &&
		amountEur == _o.amountEur;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_ESMIGRATION2_DEPOSIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ESMIGRATION2_DEPOSIT).append(")");
	_buf.append(',');
	_buf.append("doDeposit=");
	_buf.appendUint(doDeposit);
	_buf.append(',');
	_buf.append("overcreditTransId=");
	_buf.appendUint(overcreditTransId);
	_buf.append(',');
	_buf.append("migrationId=");
	_buf.appendUint(migrationId);
	_buf.append(',');
	_buf.append("amountEur=");
	_buf.appendInt(amountEur);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_ESMIGRATION2_DEPOSIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("doDeposit", doDeposit, _buf);
	Atf::XmlElement::encodeAsXmlElement("overcreditTransId", overcreditTransId, _buf);
	Atf::XmlElement::encodeAsXmlElement("migrationId", migrationId, _buf);
	Atf::XmlElement::encodeAsXmlElement("amountEur", amountEur, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("doDeposit"))
			{
				doDeposit = (*_value.ptr() == '1');
			}
			else if (_element.equals("overcreditTransId"))
			{
				overcreditTransId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("migrationId"))
			{
				migrationId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("amountEur"))
			{
				amountEur = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(doDeposit);
	_msg.composeUINT32(overcreditTransId);
	_msg.composeUINT32(migrationId);
	_msg.composeINT32(amountEur);
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(doDeposit);
	_parser.parseUINT32(overcreditTransId);
	_parser.parseUINT32(migrationId);
	_parser.parseINT32(amountEur);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("doDeposit", doDeposit);
	_jsonstr.compose("overcreditTransId", overcreditTransId);
	_jsonstr.compose("migrationId", migrationId);
	_jsonstr.compose("amountEur", amountEur);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("doDeposit", doDeposit);
	_jparser.parseByNameThrow("overcreditTransId", overcreditTransId);
	_jparser.parseByNameThrow("migrationId", migrationId);
	_jparser.parseByNameThrow("amountEur", amountEur);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_DEPOSIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool doDeposit; _jparser.validateByNameThrow("doDeposit", doDeposit);
	AtfValidator::validateInt(_descr, "doDeposit", doDeposit, _checker, __FILE__, __LINE__);
	UINT32 overcreditTransId; _jparser.validateByNameThrow("overcreditTransId", overcreditTransId);
	AtfValidator::validateInt(_descr, "overcreditTransId", overcreditTransId, _checker, __FILE__, __LINE__);
	UINT32 migrationId; _jparser.validateByNameThrow("migrationId", migrationId);
	AtfValidator::validateInt(_descr, "migrationId", migrationId, _checker, __FILE__, __LINE__);
	INT32 amountEur; _jparser.validateByNameThrow("amountEur", amountEur);
	AtfValidator::validateIntRange(_descr, "amountEur", amountEur, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_DEPOSIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool doDeposit; _parser.parseBOOL(doDeposit);
	AtfValidator::validateInt(_descr, "doDeposit", doDeposit, _checker, __FILE__, __LINE__);
	UINT32 overcreditTransId; _parser.parseUINT32(overcreditTransId);
	AtfValidator::validateInt(_descr, "overcreditTransId", overcreditTransId, _checker, __FILE__, __LINE__);
	UINT32 migrationId; _parser.parseUINT32(migrationId);
	AtfValidator::validateInt(_descr, "migrationId", migrationId, _checker, __FILE__, __LINE__);
	INT32 amountEur; _parser.parseINT32(amountEur);
	AtfValidator::validateIntRange(_descr, "amountEur", amountEur, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	descrForUser.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::equals(const Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(descrForUser, _o.descrForUser);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("descrForUser=");
		_buf.append(descrForUser);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("descrForUser", descrForUser, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("descrForUser"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, descrForUser)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(descrForUser);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(descrForUser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("descrForUser", descrForUser);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("descrForUser", descrForUser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString descrForUser; _jparser.validateByNameThrow("descrForUser", descrForUser);
		AtfValidator::validateInt(_descr, "descrForUser", descrForUser.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "descrForUser"); size_t szDescrForUser = strlen(_dummy);
		AtfValidator::validateInt(_descr, "descrForUser", szDescrForUser, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VALIDATION_CANCEL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::Protocol_MSG_CASHIER_VALIDATION_CANCEL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::clear()
{
	paySystemByte = 0;
	digits = 0;
	attempts = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::equals(const Protocol_MSG_CASHIER_VALIDATION_CANCEL& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		digits == _o.digits &&
		attempts == _o.attempts;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_VALIDATION_CANCEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_VALIDATION_CANCEL*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VALIDATION_CANCEL).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("digits=");
	_buf.appendUint(digits);
	_buf.append(',');
	_buf.append("attempts=");
	_buf.appendUint(attempts);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_VALIDATION_CANCEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("digits", digits, _buf);
	Atf::XmlElement::encodeAsXmlElement("attempts", attempts, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("digits"))
			{
				digits = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("attempts"))
			{
				attempts = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeUINT32(digits);
	_msg.composeUINT32(attempts);
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseUINT32(digits);
	_parser.parseUINT32(attempts);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemByte", paySystemByte);
	_jsonstr.compose("digits", digits);
	_jsonstr.compose("attempts", attempts);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
	_jparser.parseByNameThrow("digits", digits);
	_jparser.parseByNameThrow("attempts", attempts);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALIDATION_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	UINT32 digits; _jparser.validateByNameThrow("digits", digits);
	AtfValidator::validateInt(_descr, "digits", digits, _checker, __FILE__, __LINE__);
	UINT32 attempts; _jparser.validateByNameThrow("attempts", attempts);
	AtfValidator::validateIntMax(_descr, "attempts", attempts, 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALIDATION_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	UINT32 digits; _parser.parseUINT32(digits);
	AtfValidator::validateInt(_descr, "digits", digits, _checker, __FILE__, __LINE__);
	UINT32 attempts; _parser.parseUINT32(attempts);
	AtfValidator::validateIntMax(_descr, "attempts", attempts, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::clear()
{
	errCode = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::equals(const Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY& _o) const
{
	return errCode == _o.errCode;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_VALIDATION_CANCEL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VALIDATION_CANCEL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_VALIDATION_CANCEL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALIDATION_CANCEL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALIDATION_CANCEL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_PRESALE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::Protocol_MSG_CASHIER_TCHIPS_PRESALE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::clear()
{
	anotherUserId.clear();
	isBuyer = false;
	tChips = 0;
	cash = 0;
	currency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::equals(const Protocol_MSG_CASHIER_TCHIPS_PRESALE& _o) const
{
	return Atf::atfPStringEquals(anotherUserId, _o.anotherUserId) &&
		isBuyer == _o.isBuyer &&
		tChips == _o.tChips &&
		cash == _o.cash &&
		Atf::atfPStringEquals(currency, _o.currency);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_TCHIPS_PRESALE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_TCHIPS_PRESALE*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_PRESALE).append(")");
	_buf.append(',');
	_buf.append("anotherUserId=");
	_buf.append(anotherUserId);
	_buf.append(',');
	_buf.append("isBuyer=");
	_buf.appendUint(isBuyer);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("cash=");
	_buf.appendInt(cash);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_TCHIPS_PRESALE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("anotherUserId", anotherUserId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isBuyer", isBuyer, _buf);
	Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("cash", cash, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("anotherUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, anotherUserId)) return false;
			}
			else if (_element.equals("isBuyer"))
			{
				isBuyer = (*_value.ptr() == '1');
			}
			else if (_element.equals("tChips"))
			{
				tChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cash"))
			{
				cash = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(anotherUserId);
	_msg.composeBOOL(isBuyer);
	_msg.composeINT32(tChips);
	_msg.composeINT32(cash);
	_msg.composeString(currency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(anotherUserId);
	_parser.parseBOOL(isBuyer);
	_parser.parseINT32(tChips);
	_parser.parseINT32(cash);
	_parser.parseStringP(currency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("anotherUserId", anotherUserId);
	_jsonstr.compose("isBuyer", isBuyer);
	_jsonstr.compose("tChips", tChips);
	_jsonstr.compose("cash", cash);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("anotherUserId", anotherUserId);
	_jparser.parseByNameThrow("isBuyer", isBuyer);
	_jparser.parseByNameThrow("tChips", tChips);
	_jparser.parseByNameThrow("cash", cash);
	_jparser.parseByNameThrow("currency", currency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_PRESALE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString anotherUserId; _jparser.validateByNameThrow("anotherUserId", anotherUserId);
	AtfValidator::validateIntMax(_descr, "anotherUserId", anotherUserId.length(), 200, _checker, __FILE__, __LINE__);
	bool isBuyer; _jparser.validateByNameThrow("isBuyer", isBuyer);
	AtfValidator::validateInt(_descr, "isBuyer", isBuyer, _checker, __FILE__, __LINE__);
	INT32 tChips; _jparser.validateByNameThrow("tChips", tChips);
	AtfValidator::validateIntRange(_descr, "tChips", tChips, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 cash; _jparser.validateByNameThrow("cash", cash);
	AtfValidator::validateIntRange(_descr, "cash", cash, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_PRESALE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "anotherUserId"); size_t szAnotherUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "anotherUserId", szAnotherUserId, 200, _checker, __FILE__, __LINE__);
	bool isBuyer; _parser.parseBOOL(isBuyer);
	AtfValidator::validateInt(_descr, "isBuyer", isBuyer, _checker, __FILE__, __LINE__);
	INT32 tChips; _parser.parseINT32(tChips);
	AtfValidator::validateIntRange(_descr, "tChips", tChips, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 cash; _parser.parseINT32(cash);
	AtfValidator::validateIntRange(_descr, "cash", cash, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	seller.clear();
	buyer.clear();
	isBuyer = false;
	tChips = 0;
	cash = 0;
	userId.clear();
	city.clear();
	country.clear();
	showCity = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::equals(const Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(seller, _o.seller) &&
		Atf::atfPStringEquals(buyer, _o.buyer) &&
		isBuyer == _o.isBuyer &&
		tChips == _o.tChips &&
		cash == _o.cash &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(country, _o.country) &&
		showCity == _o.showCity;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_TCHIPS_PRESALE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_PRESALE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("seller=");
		_buf.append(seller);
		_buf.append(',');
		_buf.append("buyer=");
		_buf.append(buyer);
		_buf.append(',');
		_buf.append("isBuyer=");
		_buf.appendUint(isBuyer);
		_buf.append(',');
		_buf.append("tChips=");
		_buf.appendInt(tChips);
		_buf.append(',');
		_buf.append("cash=");
		_buf.appendInt(cash);
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
		_buf.append(',');
		_buf.append("city=");
		_buf.append(city);
		_buf.append(',');
		_buf.append("country=");
		_buf.append(country);
		_buf.append(',');
		_buf.append("showCity=");
		_buf.appendUint(showCity);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_TCHIPS_PRESALE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("seller", seller, _buf);
		Atf::XmlElement::encodeAsXmlElement("buyer", buyer, _buf);
		Atf::XmlElement::encodeAsXmlElement("isBuyer", isBuyer, _buf);
		Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("cash", cash, _buf);
		Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
		Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
		Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
		Atf::XmlElement::encodeAsXmlElement("showCity", showCity, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("seller"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, seller)) return false;
			}
			else if (_element.equals("buyer"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, buyer)) return false;
			}
			else if (_element.equals("isBuyer"))
			{
				isBuyer = (*_value.ptr() == '1');
			}
			else if (_element.equals("tChips"))
			{
				tChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cash"))
			{
				cash = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("city"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("showCity"))
			{
				showCity = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(seller);
		_msg.composeString(buyer);
		_msg.composeBOOL(isBuyer);
		_msg.composeINT32(tChips);
		_msg.composeINT32(cash);
		_msg.composeString(userId);
		_msg.composeString(city);
		_msg.composeString(country);
		_msg.composeBYTE(showCity);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(seller);
		_parser.parseStringP(buyer);
		_parser.parseBOOL(isBuyer);
		_parser.parseINT32(tChips);
		_parser.parseINT32(cash);
		_parser.parseStringP(userId);
		_parser.parseStringP(city);
		_parser.parseStringP(country);
		_parser.parseBYTE(showCity);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("seller", seller);
		_jsonstr.compose("buyer", buyer);
		_jsonstr.compose("isBuyer", isBuyer);
		_jsonstr.compose("tChips", tChips);
		_jsonstr.compose("cash", cash);
		_jsonstr.compose("userId", userId);
		_jsonstr.compose("city", city);
		_jsonstr.compose("country", country);
		_jsonstr.compose("showCity", showCity);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("seller", seller);
		_jparser.parseByNameThrow("buyer", buyer);
		_jparser.parseByNameThrow("isBuyer", isBuyer);
		_jparser.parseByNameThrow("tChips", tChips);
		_jparser.parseByNameThrow("cash", cash);
		_jparser.parseByNameThrow("userId", userId);
		_jparser.parseByNameThrow("city", city);
		_jparser.parseByNameThrow("country", country);
		_jparser.parseByNameThrow("showCity", showCity);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_PRESALE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString seller; _jparser.validateByNameThrow("seller", seller);
		AtfValidator::validateInt(_descr, "seller", seller.length(), _checker, __FILE__, __LINE__);
		PString buyer; _jparser.validateByNameThrow("buyer", buyer);
		AtfValidator::validateInt(_descr, "buyer", buyer.length(), _checker, __FILE__, __LINE__);
		bool isBuyer; _jparser.validateByNameThrow("isBuyer", isBuyer);
		AtfValidator::validateInt(_descr, "isBuyer", isBuyer, _checker, __FILE__, __LINE__);
		INT32 tChips; _jparser.validateByNameThrow("tChips", tChips);
		AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
		INT32 cash; _jparser.validateByNameThrow("cash", cash);
		AtfValidator::validateInt(_descr, "cash", cash, _checker, __FILE__, __LINE__);
		PString userId; _jparser.validateByNameThrow("userId", userId);
		AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
		PString city; _jparser.validateByNameThrow("city", city);
		AtfValidator::validateInt(_descr, "city", city.length(), _checker, __FILE__, __LINE__);
		PString country; _jparser.validateByNameThrow("country", country);
		AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
		BYTE showCity; _jparser.validateByNameThrow("showCity", showCity);
		AtfValidator::validateIntRange(_descr, "showCity", showCity, 0, 1, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_PRESALE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "seller"); size_t szSeller = strlen(_dummy);
		AtfValidator::validateInt(_descr, "seller", szSeller, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "buyer"); size_t szBuyer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "buyer", szBuyer, _checker, __FILE__, __LINE__);
		bool isBuyer; _parser.parseBOOL(isBuyer);
		AtfValidator::validateInt(_descr, "isBuyer", isBuyer, _checker, __FILE__, __LINE__);
		INT32 tChips; _parser.parseINT32(tChips);
		AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
		INT32 cash; _parser.parseINT32(cash);
		AtfValidator::validateInt(_descr, "cash", cash, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
		AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
		AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
		BYTE showCity; _parser.parseBYTE(showCity);
		AtfValidator::validateIntRange(_descr, "showCity", showCity, 0, 1, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_SALE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::Protocol_MSG_CASHIER_TCHIPS_SALE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::clear()
{
	anotherUserId.clear();
	isBuyer = false;
	tChips = 0;
	cash = 0;
	currency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::equals(const Protocol_MSG_CASHIER_TCHIPS_SALE& _o) const
{
	return Atf::atfPStringEquals(anotherUserId, _o.anotherUserId) &&
		isBuyer == _o.isBuyer &&
		tChips == _o.tChips &&
		cash == _o.cash &&
		Atf::atfPStringEquals(currency, _o.currency);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_TCHIPS_SALE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_TCHIPS_SALE*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_SALE).append(")");
	_buf.append(',');
	_buf.append("anotherUserId=");
	_buf.append(anotherUserId);
	_buf.append(',');
	_buf.append("isBuyer=");
	_buf.appendUint(isBuyer);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("cash=");
	_buf.appendInt(cash);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_TCHIPS_SALE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("anotherUserId", anotherUserId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isBuyer", isBuyer, _buf);
	Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("cash", cash, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("anotherUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, anotherUserId)) return false;
			}
			else if (_element.equals("isBuyer"))
			{
				isBuyer = (*_value.ptr() == '1');
			}
			else if (_element.equals("tChips"))
			{
				tChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cash"))
			{
				cash = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(anotherUserId);
	_msg.composeBOOL(isBuyer);
	_msg.composeINT32(tChips);
	_msg.composeINT32(cash);
	_msg.composeString(currency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(anotherUserId);
	_parser.parseBOOL(isBuyer);
	_parser.parseINT32(tChips);
	_parser.parseINT32(cash);
	_parser.parseStringP(currency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("anotherUserId", anotherUserId);
	_jsonstr.compose("isBuyer", isBuyer);
	_jsonstr.compose("tChips", tChips);
	_jsonstr.compose("cash", cash);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("anotherUserId", anotherUserId);
	_jparser.parseByNameThrow("isBuyer", isBuyer);
	_jparser.parseByNameThrow("tChips", tChips);
	_jparser.parseByNameThrow("cash", cash);
	_jparser.parseByNameThrow("currency", currency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_SALE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString anotherUserId; _jparser.validateByNameThrow("anotherUserId", anotherUserId);
	AtfValidator::validateIntMax(_descr, "anotherUserId", anotherUserId.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	bool isBuyer; _jparser.validateByNameThrow("isBuyer", isBuyer);
	AtfValidator::validateInt(_descr, "isBuyer", isBuyer, _checker, __FILE__, __LINE__);
	INT32 tChips; _jparser.validateByNameThrow("tChips", tChips);
	AtfValidator::validateIntRange(_descr, "tChips", tChips, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 cash; _jparser.validateByNameThrow("cash", cash);
	AtfValidator::validateIntRange(_descr, "cash", cash, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_SALE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "anotherUserId"); size_t szAnotherUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "anotherUserId", szAnotherUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	bool isBuyer; _parser.parseBOOL(isBuyer);
	AtfValidator::validateInt(_descr, "isBuyer", isBuyer, _checker, __FILE__, __LINE__);
	INT32 tChips; _parser.parseINT32(tChips);
	AtfValidator::validateIntRange(_descr, "tChips", tChips, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 cash; _parser.parseINT32(cash);
	AtfValidator::validateIntRange(_descr, "cash", cash, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	expirationIntervalSec = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::equals(const Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		expirationIntervalSec == _o.expirationIntervalSec;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_TCHIPS_SALE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_SALE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("expirationIntervalSec=");
		_buf.appendInt(expirationIntervalSec);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_TCHIPS_SALE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("expirationIntervalSec", expirationIntervalSec, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("expirationIntervalSec"))
			{
				expirationIntervalSec = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(expirationIntervalSec);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(expirationIntervalSec);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("expirationIntervalSec", expirationIntervalSec);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("expirationIntervalSec", expirationIntervalSec);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_SALE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 expirationIntervalSec; _jparser.validateByNameThrow("expirationIntervalSec", expirationIntervalSec);
		AtfValidator::validateInt(_descr, "expirationIntervalSec", expirationIntervalSec, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_SALE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 expirationIntervalSec; _parser.parseINT32(expirationIntervalSec);
		AtfValidator::validateInt(_descr, "expirationIntervalSec", expirationIntervalSec, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_PRECANCEL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::equals(const Protocol_MSG_CASHIER_TCHIPS_PRECANCEL& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_TCHIPS_PRECANCEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_TCHIPS_PRECANCEL*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_PRECANCEL).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_TCHIPS_PRECANCEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_PRECANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_PRECANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierTChipsPrecancelOneBody
//=================================================================

CashierServer::cli::CashierTChipsPrecancelOneBody::CashierTChipsPrecancelOneBody()
{
	clear();
}

void CashierServer::cli::CashierTChipsPrecancelOneBody::clear()
{
	saleId = 0;
	anotherUserId.clear();
	tChips = 0;
	cash = 0;
	isStartedByBuyer = false;
	validUntil.setNull();
	currency.clear();
}

bool CashierServer::cli::CashierTChipsPrecancelOneBody::equals(const CashierTChipsPrecancelOneBody& _o) const
{
	return saleId == _o.saleId &&
		Atf::atfPStringEquals(anotherUserId, _o.anotherUserId) &&
		tChips == _o.tChips &&
		cash == _o.cash &&
		isStartedByBuyer == _o.isStartedByBuyer &&
		validUntil.equals(_o.validUntil) &&
		Atf::atfPStringEquals(currency, _o.currency);
}

const char *CashierServer::cli::CashierTChipsPrecancelOneBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("saleId=");
	_buf.appendUint(saleId);
	_buf.append(',');
	_buf.append("anotherUserId=");
	_buf.append(anotherUserId);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("cash=");
	_buf.appendInt(cash);
	_buf.append(',');
	_buf.append("isStartedByBuyer=");
	_buf.appendUint(isStartedByBuyer);
	_buf.append(',');
	_buf.append("validUntil=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, validUntil);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierTChipsPrecancelOneBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("saleId", saleId, _buf);
	Atf::XmlElement::encodeAsXmlElement("anotherUserId", anotherUserId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("cash", cash, _buf);
	Atf::XmlElement::encodeAsXmlElement("isStartedByBuyer", isStartedByBuyer, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "validUntil", validUntil);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierTChipsPrecancelOneBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("saleId"))
		{
			saleId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("anotherUserId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, anotherUserId)) return false;
		}
		else if (_element.equals("tChips"))
		{
			tChips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cash"))
		{
			cash = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isStartedByBuyer"))
		{
			isStartedByBuyer = (*_value.ptr() == '1');
		}
		else if (_element.equals("validUntil"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, validUntil);
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierTChipsPrecancelOneBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierTChipsPrecancelOneBody())) // not empty
	{
		_body.composeUINT32(saleId);
		_body.composeString(anotherUserId);
		_body.composeINT32(tChips);
		_body.composeINT32(cash);
		_body.composeBOOL(isStartedByBuyer);
		_body.composeSrvTime(validUntil);
		_body.composeString(currency);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierTChipsPrecancelOneBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(saleId);
	_parser0.parseStringP(anotherUserId);
	_parser0.parseINT32(tChips);
	_parser0.parseINT32(cash);
	_parser0.parseBOOL(isStartedByBuyer);
	_parser0.parseSrvTime(validUntil);
	_parser0.parseStringP(currency);
}

const char *CashierServer::cli::CashierTChipsPrecancelOneBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("saleId", saleId);
	_jsonstr.compose("anotherUserId", anotherUserId);
	_jsonstr.compose("tChips", tChips);
	_jsonstr.compose("cash", cash);
	_jsonstr.compose("isStartedByBuyer", isStartedByBuyer);
	_jsonstr.compose("validUntil", validUntil);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void CashierServer::cli::CashierTChipsPrecancelOneBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("saleId", saleId);
	_jparser.parseByNameThrow("anotherUserId", anotherUserId);
	_jparser.parseByNameThrow("tChips", tChips);
	_jparser.parseByNameThrow("cash", cash);
	_jparser.parseByNameThrow("isStartedByBuyer", isStartedByBuyer);
	_jparser.parseByNameThrow("validUntil", validUntil);
	_jparser.parseByNameThrow("currency", currency);
}

/* static */ void CashierServer::cli::CashierTChipsPrecancelOneBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 saleId; _jparser.validateByNameThrow("saleId", saleId);
	AtfValidator::validateInt(_descr, "saleId", saleId, _checker, __FILE__, __LINE__);
	PString anotherUserId; _jparser.validateByNameThrow("anotherUserId", anotherUserId);
	AtfValidator::validateInt(_descr, "anotherUserId", anotherUserId.length(), _checker, __FILE__, __LINE__);
	INT32 tChips; _jparser.validateByNameThrow("tChips", tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	INT32 cash; _jparser.validateByNameThrow("cash", cash);
	AtfValidator::validateInt(_descr, "cash", cash, _checker, __FILE__, __LINE__);
	bool isStartedByBuyer; _jparser.validateByNameThrow("isStartedByBuyer", isStartedByBuyer);
	AtfValidator::validateInt(_descr, "isStartedByBuyer", isStartedByBuyer, _checker, __FILE__, __LINE__);
	CommSrvTime validUntil; _jparser.validateByNameThrow("validUntil", validUntil);
	AtfValidator::validateSrvDateTime(_descr, "validUntil", validUntil, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierTChipsPrecancelOneBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 saleId; _parser0.parseUINT32(saleId);
	AtfValidator::validateInt(_descr, "saleId", saleId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "anotherUserId"); size_t szAnotherUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "anotherUserId", szAnotherUserId, _checker, __FILE__, __LINE__);
	INT32 tChips; _parser0.parseINT32(tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	INT32 cash; _parser0.parseINT32(cash);
	AtfValidator::validateInt(_descr, "cash", cash, _checker, __FILE__, __LINE__);
	bool isStartedByBuyer; _parser0.parseBOOL(isStartedByBuyer);
	AtfValidator::validateInt(_descr, "isStartedByBuyer", isStartedByBuyer, _checker, __FILE__, __LINE__);
	CommSrvTime validUntil; _parser0.parseSrvTime(validUntil);
	AtfValidator::validateSrvDateTime(_descr, "validUntil", validUntil, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	precancelEntries.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::equals(const Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		precancelEntries.equals(_o.precancelEntries);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_TCHIPS_PRECANCEL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_PRECANCEL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("precancelEntries=");
		precancelEntries.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_TCHIPS_PRECANCEL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		precancelEntries.toXmlString("precancelEntries", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("precancelEntries"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierTChipsPrecancelOneBody, 4 > >::FromXmlString(_value, precancelEntries)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		precancelEntries.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		precancelEntries.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("precancelEntries", precancelEntries);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("precancelEntries", precancelEntries);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_PRECANCEL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CashierTChipsPrecancelOneBody > precancelEntries; _jparser.validateByNameThrow("precancelEntries", precancelEntries);
		AtfValidator::validateInt(_descr, "precancelEntries", precancelEntries.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_PRECANCEL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szPrecancelEntries = Atf::LAtfVector< CashierTChipsPrecancelOneBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("precancelEntries"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "precancelEntries", szPrecancelEntries, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_CANCELID
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::Protocol_MSG_CASHIER_TCHIPS_CANCELID()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::clear()
{
	saleIds.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::equals(const Protocol_MSG_CASHIER_TCHIPS_CANCELID& _o) const
{
	return saleIds.equals(_o.saleIds);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_TCHIPS_CANCELID != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_TCHIPS_CANCELID*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_CANCELID).append(")");
	_buf.append(',');
	_buf.append("saleIds=");
	saleIds.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_TCHIPS_CANCELID).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	saleIds.toXmlString("saleIds", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("saleIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, saleIds)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	saleIds.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::parseMsg(CommMsgParser& _parser)
{
	saleIds.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("saleIds", saleIds);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("saleIds", saleIds);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_CANCELID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< UINT32 > saleIds; _jparser.validateByNameThrow("saleIds", saleIds);
	AtfValidator::validateIntMax(_descr, "saleIds", saleIds.size(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_CANCELID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szSaleIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("saleIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "saleIds", szSaleIds, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashieTChipsSaleBody
//=================================================================

CashierServer::cli::CashieTChipsSaleBody::CashieTChipsSaleBody()
{
	clear();
}

void CashierServer::cli::CashieTChipsSaleBody::clear()
{
	saleId = 0;
	errCode2 = 0;
}

bool CashierServer::cli::CashieTChipsSaleBody::equals(const CashieTChipsSaleBody& _o) const
{
	return saleId == _o.saleId &&
		errCode2 == _o.errCode2;
}

const char *CashierServer::cli::CashieTChipsSaleBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("saleId=");
	_buf.appendUint(saleId);
	_buf.append(',');
	_buf.append("errCode2=");
	_buf.appendInt(errCode2);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashieTChipsSaleBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("saleId", saleId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode2", errCode2, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashieTChipsSaleBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("saleId"))
		{
			saleId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errCode2"))
		{
			errCode2 = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashieTChipsSaleBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashieTChipsSaleBody())) // not empty
	{
		_body.composeUINT32(saleId);
		_body.composeINT16(errCode2);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashieTChipsSaleBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(saleId);
	_parser0.parseINT16(errCode2);
}

const char *CashierServer::cli::CashieTChipsSaleBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("saleId", saleId);
	_jsonstr.compose("errCode2", errCode2);
	return _buf.c_str();
}

void CashierServer::cli::CashieTChipsSaleBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("saleId", saleId);
	_jparser.parseByNameThrow("errCode2", errCode2);
}

/* static */ void CashierServer::cli::CashieTChipsSaleBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 saleId; _jparser.validateByNameThrow("saleId", saleId);
	AtfValidator::validateInt(_descr, "saleId", saleId, _checker, __FILE__, __LINE__);
	INT16 errCode2; _jparser.validateByNameThrow("errCode2", errCode2);
	AtfValidator::validateInt(_descr, "errCode2", errCode2, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashieTChipsSaleBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 saleId; _parser0.parseUINT32(saleId);
	AtfValidator::validateInt(_descr, "saleId", saleId, _checker, __FILE__, __LINE__);
	INT16 errCode2; _parser0.parseINT16(errCode2);
	AtfValidator::validateInt(_descr, "errCode2", errCode2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	sales.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::equals(const Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		sales.equals(_o.sales);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_TCHIPS_CANCELID_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_CANCELID_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("sales=");
		sales.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_TCHIPS_CANCELID_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		sales.toXmlString("sales", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("sales"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashieTChipsSaleBody, 4 > >::FromXmlString(_value, sales)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		sales.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		sales.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("sales", sales);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("sales", sales);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_CANCELID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CashieTChipsSaleBody > sales; _jparser.validateByNameThrow("sales", sales);
		AtfValidator::validateInt(_descr, "sales", sales.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_CANCELID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSales = Atf::LAtfVector< CashieTChipsSaleBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sales"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "sales", szSales, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::clear()
{
	tChips = 0;
	cash = 0;
	currency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::equals(const Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS& _o) const
{
	return tChips == _o.tChips &&
		cash == _o.cash &&
		Atf::atfPStringEquals(currency, _o.currency);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_TCHIPS_SALE_TO_PSTARS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_SALE_TO_PSTARS).append(")");
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("cash=");
	_buf.appendInt(cash);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_TCHIPS_SALE_TO_PSTARS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("cash", cash, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tChips"))
			{
				tChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cash"))
			{
				cash = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(tChips);
	_msg.composeINT32(cash);
	_msg.composeString(currency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(tChips);
	_parser.parseINT32(cash);
	_parser.parseStringP(currency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tChips", tChips);
	_jsonstr.compose("cash", cash);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tChips", tChips);
	_jparser.parseByNameThrow("cash", cash);
	_jparser.parseByNameThrow("currency", currency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_SALE_TO_PSTARS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 tChips; _jparser.validateByNameThrow("tChips", tChips);
	AtfValidator::validateIntRange(_descr, "tChips", tChips, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 cash; _jparser.validateByNameThrow("cash", cash);
	AtfValidator::validateIntRange(_descr, "cash", cash, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_SALE_TO_PSTARS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT32 tChips; _parser.parseINT32(tChips);
	AtfValidator::validateIntRange(_descr, "tChips", tChips, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 cash; _parser.parseINT32(cash);
	AtfValidator::validateIntRange(_descr, "cash", cash, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::equals(const Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TSALE_GET_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::Protocol_MSG_CASHIER_TSALE_GET_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::equals(const Protocol_MSG_CASHIER_TSALE_GET_INFO& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_TSALE_GET_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_TSALE_GET_INFO*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TSALE_GET_INFO).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_TSALE_GET_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TSALE_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TSALE_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tChipsToCashMinimumRate_x1M = 0;
	tSaleToPStarsEnabled = false;
	tChipsToCashPStarsRate_x1M = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::equals(const Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		tChipsToCashMinimumRate_x1M == _o.tChipsToCashMinimumRate_x1M &&
		tSaleToPStarsEnabled == _o.tSaleToPStarsEnabled &&
		tChipsToCashPStarsRate_x1M == _o.tChipsToCashPStarsRate_x1M;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_TSALE_GET_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TSALE_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tChipsToCashMinimumRate_x1M=");
		_buf.appendInt(tChipsToCashMinimumRate_x1M);
		_buf.append(',');
		_buf.append("tSaleToPStarsEnabled=");
		_buf.appendUint(tSaleToPStarsEnabled);
		_buf.append(',');
		_buf.append("tChipsToCashPStarsRate_x1M=");
		_buf.appendInt(tChipsToCashPStarsRate_x1M);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_TSALE_GET_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("tChipsToCashMinimumRate_x1M", tChipsToCashMinimumRate_x1M, _buf);
		Atf::XmlElement::encodeAsXmlElement("tSaleToPStarsEnabled", tSaleToPStarsEnabled, _buf);
		Atf::XmlElement::encodeAsXmlElement("tChipsToCashPStarsRate_x1M", tChipsToCashPStarsRate_x1M, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("tChipsToCashMinimumRate_x1M"))
			{
				tChipsToCashMinimumRate_x1M = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tSaleToPStarsEnabled"))
			{
				tSaleToPStarsEnabled = (*_value.ptr() == '1');
			}
			else if (_element.equals("tChipsToCashPStarsRate_x1M"))
			{
				tChipsToCashPStarsRate_x1M = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(tChipsToCashMinimumRate_x1M);
		_msg.composeBOOL(tSaleToPStarsEnabled);
		_msg.composeINT32(tChipsToCashPStarsRate_x1M);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(tChipsToCashMinimumRate_x1M);
		_parser.parseBOOL(tSaleToPStarsEnabled);
		_parser.parseINT32(tChipsToCashPStarsRate_x1M);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("tChipsToCashMinimumRate_x1M", tChipsToCashMinimumRate_x1M);
		_jsonstr.compose("tSaleToPStarsEnabled", tSaleToPStarsEnabled);
		_jsonstr.compose("tChipsToCashPStarsRate_x1M", tChipsToCashPStarsRate_x1M);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("tChipsToCashMinimumRate_x1M", tChipsToCashMinimumRate_x1M);
		_jparser.parseByNameThrow("tSaleToPStarsEnabled", tSaleToPStarsEnabled);
		_jparser.parseByNameThrow("tChipsToCashPStarsRate_x1M", tChipsToCashPStarsRate_x1M);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TSALE_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 tChipsToCashMinimumRate_x1M; _jparser.validateByNameThrow("tChipsToCashMinimumRate_x1M", tChipsToCashMinimumRate_x1M);
		AtfValidator::validateInt(_descr, "tChipsToCashMinimumRate_x1M", tChipsToCashMinimumRate_x1M, _checker, __FILE__, __LINE__);
		bool tSaleToPStarsEnabled; _jparser.validateByNameThrow("tSaleToPStarsEnabled", tSaleToPStarsEnabled);
		AtfValidator::validateInt(_descr, "tSaleToPStarsEnabled", tSaleToPStarsEnabled, _checker, __FILE__, __LINE__);
		INT32 tChipsToCashPStarsRate_x1M; _jparser.validateByNameThrow("tChipsToCashPStarsRate_x1M", tChipsToCashPStarsRate_x1M);
		AtfValidator::validateInt(_descr, "tChipsToCashPStarsRate_x1M", tChipsToCashPStarsRate_x1M, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TSALE_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 tChipsToCashMinimumRate_x1M; _parser.parseINT32(tChipsToCashMinimumRate_x1M);
		AtfValidator::validateInt(_descr, "tChipsToCashMinimumRate_x1M", tChipsToCashMinimumRate_x1M, _checker, __FILE__, __LINE__);
		bool tSaleToPStarsEnabled; _parser.parseBOOL(tSaleToPStarsEnabled);
		AtfValidator::validateInt(_descr, "tSaleToPStarsEnabled", tSaleToPStarsEnabled, _checker, __FILE__, __LINE__);
		INT32 tChipsToCashPStarsRate_x1M; _parser.parseINT32(tChipsToCashPStarsRate_x1M);
		AtfValidator::validateInt(_descr, "tChipsToCashPStarsRate_x1M", tChipsToCashPStarsRate_x1M, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::clear()
{
	paySystemByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::equals(const Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO& _o) const
{
	return paySystemByte == _o.paySystemByte;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paySystemByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemByte", paySystemByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierAmountCurrencyBody
//=================================================================

CashierServer::cli::CashierAmountCurrencyBody::CashierAmountCurrencyBody()
{
	clear();
}

void CashierServer::cli::CashierAmountCurrencyBody::clear()
{
	amount = 0;
	currency.clear();
}

bool CashierServer::cli::CashierAmountCurrencyBody::equals(const CashierAmountCurrencyBody& _o) const
{
	return amount == _o.amount &&
		Atf::atfPStringEquals(currency, _o.currency);
}

const char *CashierServer::cli::CashierAmountCurrencyBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierAmountCurrencyBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierAmountCurrencyBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("amount"))
		{
			amount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierAmountCurrencyBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierAmountCurrencyBody())) // not empty
	{
		_body.composeINT32(amount);
		_body.composeString(currency);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierAmountCurrencyBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(amount);
	_parser0.parseStringP(currency);
}

const char *CashierServer::cli::CashierAmountCurrencyBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void CashierServer::cli::CashierAmountCurrencyBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("currency", currency);
}

/* static */ void CashierServer::cli::CashierAmountCurrencyBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierAmountCurrencyBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 amount; _parser0.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	infos.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::equals(const Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		infos.equals(_o.infos);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("infos=");
		infos.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		infos.toXmlString("infos", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("infos"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierAmountCurrencyBody, 4 > >::FromXmlString(_value, infos)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		infos.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		infos.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("infos", infos);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("infos", infos);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CashierAmountCurrencyBody > infos; _jparser.validateByNameThrow("infos", infos);
		AtfValidator::validateInt(_descr, "infos", infos.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szInfos = Atf::LAtfVector< CashierAmountCurrencyBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("infos"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "infos", szInfos, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::clear()
{
	fdCallFrom = 0;
	targetAmount = 0;
	targetAcctCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::equals(const Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO& _o) const
{
	return fdCallFrom == _o.fdCallFrom &&
		targetAmount == _o.targetAmount &&
		Atf::atfPStringEquals(targetAcctCurrency, _o.targetAcctCurrency);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_FAST_DEPOSIT_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_FAST_DEPOSIT_INFO).append(")");
	_buf.append(',');
	_buf.append("fdCallFrom=");
	_buf.appendInt(fdCallFrom);
	_buf.append(',');
	_buf.append("targetAmount=");
	_buf.appendInt(targetAmount);
	_buf.append(',');
	_buf.append("targetAcctCurrency=");
	_buf.append(targetAcctCurrency);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_FAST_DEPOSIT_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("fdCallFrom", fdCallFrom, _buf);
	Atf::XmlElement::encodeAsXmlElement("targetAmount", targetAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("targetAcctCurrency", targetAcctCurrency, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("fdCallFrom"))
			{
				fdCallFrom = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("targetAmount"))
			{
				targetAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("targetAcctCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, targetAcctCurrency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(fdCallFrom);
	_msg.composeINT32(targetAmount);
	_msg.composeString(targetAcctCurrency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(fdCallFrom);
	_parser.parseINT32(targetAmount);
	_parser.parseStringP(targetAcctCurrency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("fdCallFrom", fdCallFrom);
	_jsonstr.compose("targetAmount", targetAmount);
	_jsonstr.compose("targetAcctCurrency", targetAcctCurrency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("fdCallFrom", fdCallFrom);
	_jparser.parseByNameThrow("targetAmount", targetAmount);
	_jparser.parseByNameThrow("targetAcctCurrency", targetAcctCurrency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_FAST_DEPOSIT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 fdCallFrom; _jparser.validateByNameThrow("fdCallFrom", fdCallFrom);
	AtfValidator::validateIntRange(_descr, "fdCallFrom", fdCallFrom, eFastDepositCallFromUnknown, eFastDepositCallFromLast, _checker, __FILE__, __LINE__);
	INT32 targetAmount; _jparser.validateByNameThrow("targetAmount", targetAmount);
	AtfValidator::validateIntRange(_descr, "targetAmount", targetAmount, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString targetAcctCurrency; _jparser.validateByNameThrow("targetAcctCurrency", targetAcctCurrency);
	AtfValidator::validateIntMax(_descr, "targetAcctCurrency", targetAcctCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_FAST_DEPOSIT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT32 fdCallFrom; _parser.parseINT32(fdCallFrom);
	AtfValidator::validateIntRange(_descr, "fdCallFrom", fdCallFrom, eFastDepositCallFromUnknown, eFastDepositCallFromLast, _checker, __FILE__, __LINE__);
	INT32 targetAmount; _parser.parseINT32(targetAmount);
	AtfValidator::validateIntRange(_descr, "targetAmount", targetAmount, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "targetAcctCurrency"); size_t szTargetAcctCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "targetAcctCurrency", szTargetAcctCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	cardTypeByte = 0;
	paysystemName.clear();
	status = 0;
	procAmount = 0;
	procCurrency.clear();
	extraAcctAmountNeeded = 0;
	cardInfoId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::equals(const Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		cardTypeByte == _o.cardTypeByte &&
		Atf::atfPStringEquals(paysystemName, _o.paysystemName) &&
		status == _o.status &&
		procAmount == _o.procAmount &&
		Atf::atfPStringEquals(procCurrency, _o.procCurrency) &&
		extraAcctAmountNeeded == _o.extraAcctAmountNeeded &&
		cardInfoId == _o.cardInfoId;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("cardTypeByte=");
		_buf.appendUint(cardTypeByte);
		_buf.append(',');
		_buf.append("paysystemName=");
		_buf.append(paysystemName);
		_buf.append(',');
		_buf.append("status=");
		_buf.appendInt(status);
		_buf.append(',');
		_buf.append("procAmount=");
		_buf.appendInt(procAmount);
		_buf.append(',');
		_buf.append("procCurrency=");
		_buf.append(procCurrency);
		_buf.append(',');
		_buf.append("extraAcctAmountNeeded=");
		_buf.appendInt(extraAcctAmountNeeded);
		_buf.append(',');
		_buf.append("cardInfoId=");
		_buf.appendUint(cardInfoId);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("cardTypeByte", cardTypeByte, _buf);
		Atf::XmlElement::encodeAsXmlElement("paysystemName", paysystemName, _buf);
		Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
		Atf::XmlElement::encodeAsXmlElement("procAmount", procAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("procCurrency", procCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("extraAcctAmountNeeded", extraAcctAmountNeeded, _buf);
		Atf::XmlElement::encodeAsXmlElement("cardInfoId", cardInfoId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("cardTypeByte"))
			{
				cardTypeByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("paysystemName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, paysystemName)) return false;
			}
			else if (_element.equals("status"))
			{
				status = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("procAmount"))
			{
				procAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("procCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, procCurrency)) return false;
			}
			else if (_element.equals("extraAcctAmountNeeded"))
			{
				extraAcctAmountNeeded = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cardInfoId"))
			{
				cardInfoId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBYTE(cardTypeByte);
		_msg.composeString(paysystemName);
		_msg.composeINT32(status);
		_msg.composeINT32(procAmount);
		_msg.composeString(procCurrency);
		_msg.composeINT32(extraAcctAmountNeeded);
		_msg.composeUINT32(cardInfoId);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBYTE(cardTypeByte);
		_parser.parseStringP(paysystemName);
		_parser.parseINT32(status);
		_parser.parseINT32(procAmount);
		_parser.parseStringP(procCurrency);
		_parser.parseINT32(extraAcctAmountNeeded);
		_parser.parseUINT32(cardInfoId);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("cardTypeByte", cardTypeByte);
		_jsonstr.compose("paysystemName", paysystemName);
		_jsonstr.compose("status", status);
		_jsonstr.compose("procAmount", procAmount);
		_jsonstr.compose("procCurrency", procCurrency);
		_jsonstr.compose("extraAcctAmountNeeded", extraAcctAmountNeeded);
		_jsonstr.compose("cardInfoId", cardInfoId);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("cardTypeByte", cardTypeByte);
		_jparser.parseByNameThrow("paysystemName", paysystemName);
		_jparser.parseByNameThrow("status", status);
		_jparser.parseByNameThrow("procAmount", procAmount);
		_jparser.parseByNameThrow("procCurrency", procCurrency);
		_jparser.parseByNameThrow("extraAcctAmountNeeded", extraAcctAmountNeeded);
		_jparser.parseByNameThrow("cardInfoId", cardInfoId);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE cardTypeByte; _jparser.validateByNameThrow("cardTypeByte", cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
		PString paysystemName; _jparser.validateByNameThrow("paysystemName", paysystemName);
		AtfValidator::validateInt(_descr, "paysystemName", paysystemName.length(), _checker, __FILE__, __LINE__);
		INT32 status; _jparser.validateByNameThrow("status", status);
		AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
		INT32 procAmount; _jparser.validateByNameThrow("procAmount", procAmount);
		AtfValidator::validateInt(_descr, "procAmount", procAmount, _checker, __FILE__, __LINE__);
		PString procCurrency; _jparser.validateByNameThrow("procCurrency", procCurrency);
		AtfValidator::validateInt(_descr, "procCurrency", procCurrency.length(), _checker, __FILE__, __LINE__);
		INT32 extraAcctAmountNeeded; _jparser.validateByNameThrow("extraAcctAmountNeeded", extraAcctAmountNeeded);
		AtfValidator::validateInt(_descr, "extraAcctAmountNeeded", extraAcctAmountNeeded, _checker, __FILE__, __LINE__);
		UINT32 cardInfoId; _jparser.validateByNameThrow("cardInfoId", cardInfoId);
		AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "paysystemName"); size_t szPaysystemName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "paysystemName", szPaysystemName, _checker, __FILE__, __LINE__);
		INT32 status; _parser.parseINT32(status);
		AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
		INT32 procAmount; _parser.parseINT32(procAmount);
		AtfValidator::validateInt(_descr, "procAmount", procAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "procCurrency"); size_t szProcCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "procCurrency", szProcCurrency, _checker, __FILE__, __LINE__);
		INT32 extraAcctAmountNeeded; _parser.parseINT32(extraAcctAmountNeeded);
		AtfValidator::validateInt(_descr, "extraAcctAmountNeeded", extraAcctAmountNeeded, _checker, __FILE__, __LINE__);
		UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
		AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::clear()
{
	paySystemByte = 0;
	fdStatus = 0;
	procAmount = 0;
	procCurrency.clear();
	cardInfoId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::equals(const Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		fdStatus == _o.fdStatus &&
		procAmount == _o.procAmount &&
		Atf::atfPStringEquals(procCurrency, _o.procCurrency) &&
		cardInfoId == _o.cardInfoId;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("fdStatus=");
	_buf.appendInt(fdStatus);
	_buf.append(',');
	_buf.append("procAmount=");
	_buf.appendInt(procAmount);
	_buf.append(',');
	_buf.append("procCurrency=");
	_buf.append(procCurrency);
	_buf.append(',');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("fdStatus", fdStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("procAmount", procAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("procCurrency", procCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardInfoId", cardInfoId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fdStatus"))
			{
				fdStatus = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("procAmount"))
			{
				procAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("procCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, procCurrency)) return false;
			}
			else if (_element.equals("cardInfoId"))
			{
				cardInfoId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeINT32(fdStatus);
	_msg.composeINT32(procAmount);
	_msg.composeString(procCurrency);
	_msg.composeUINT32(cardInfoId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseINT32(fdStatus);
	_parser.parseINT32(procAmount);
	_parser.parseStringP(procCurrency);
	_parser.parseUINT32(cardInfoId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemByte", paySystemByte);
	_jsonstr.compose("fdStatus", fdStatus);
	_jsonstr.compose("procAmount", procAmount);
	_jsonstr.compose("procCurrency", procCurrency);
	_jsonstr.compose("cardInfoId", cardInfoId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
	_jparser.parseByNameThrow("fdStatus", fdStatus);
	_jparser.parseByNameThrow("procAmount", procAmount);
	_jparser.parseByNameThrow("procCurrency", procCurrency);
	_jparser.parseByNameThrow("cardInfoId", cardInfoId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	INT32 fdStatus; _jparser.validateByNameThrow("fdStatus", fdStatus);
	{ const INT32 fdStatus_enum[] = { eFastDepositStatusNotExists, eFastDepositStatusDisabled, eFastDepositStatusActive }; AtfValidator::validateEnum(_descr, "fdStatus", fdStatus, fdStatus_enum, _checker, __FILE__, __LINE__); }
	INT32 procAmount; _jparser.validateByNameThrow("procAmount", procAmount);
	AtfValidator::validateIntRange(_descr, "procAmount", procAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString procCurrency; _jparser.validateByNameThrow("procCurrency", procCurrency);
	AtfValidator::validateIntMax(_descr, "procCurrency", procCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _jparser.validateByNameThrow("cardInfoId", cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	INT32 fdStatus; _parser.parseINT32(fdStatus);
	{ const INT32 fdStatus_enum[] = { eFastDepositStatusNotExists, eFastDepositStatusDisabled, eFastDepositStatusActive }; AtfValidator::validateEnum(_descr, "fdStatus", fdStatus, fdStatus_enum, _checker, __FILE__, __LINE__); }
	INT32 procAmount; _parser.parseINT32(procAmount);
	AtfValidator::validateIntRange(_descr, "procAmount", procAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "procCurrency"); size_t szProcCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "procCurrency", szProcCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::equals(const Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::clear()
{
	paySystemByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::equals(const Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO& _o) const
{
	return paySystemByte == _o.paySystemByte;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paySystemByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemByte", paySystemByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::equals(const Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::equals(const Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_RM_NOK_HELD_FUNDS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_RM_NOK_HELD_FUNDS).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_RM_NOK_HELD_FUNDS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RM_NOK_HELD_FUNDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RM_NOK_HELD_FUNDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierHeldTransBody
//=================================================================

CashierServer::cli::CashierHeldTransBody::CashierHeldTransBody()
{
	clear();
}

void CashierServer::cli::CashierHeldTransBody::clear()
{
	transId = 0;
	amountAcct = 0;
	currencyAcct.clear();
	started.setNull();
	cardTypeByte = 0;
	paysystemName.clear();
}

bool CashierServer::cli::CashierHeldTransBody::equals(const CashierHeldTransBody& _o) const
{
	return transId == _o.transId &&
		amountAcct == _o.amountAcct &&
		Atf::atfPStringEquals(currencyAcct, _o.currencyAcct) &&
		started.equals(_o.started) &&
		cardTypeByte == _o.cardTypeByte &&
		Atf::atfPStringEquals(paysystemName, _o.paysystemName);
}

const char *CashierServer::cli::CashierHeldTransBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("amountAcct=");
	_buf.appendInt(amountAcct);
	_buf.append(',');
	_buf.append("currencyAcct=");
	_buf.append(currencyAcct);
	_buf.append(',');
	_buf.append("started=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, started);
	_buf.append(',');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	_buf.append(',');
	_buf.append("paysystemName=");
	_buf.append(paysystemName);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierHeldTransBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
	Atf::XmlElement::encodeAsXmlElement("amountAcct", amountAcct, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyAcct", currencyAcct, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "started", started);
	Atf::XmlElement::encodeAsXmlElement("cardTypeByte", cardTypeByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("paysystemName", paysystemName, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierHeldTransBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("transId"))
		{
			transId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("amountAcct"))
		{
			amountAcct = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currencyAcct"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currencyAcct)) return false;
		}
		else if (_element.equals("started"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, started);
		}
		else if (_element.equals("cardTypeByte"))
		{
			cardTypeByte = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("paysystemName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, paysystemName)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierHeldTransBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierHeldTransBody())) // not empty
	{
		_body.composeUINT32(transId);
		_body.composeINT32(amountAcct);
		_body.composeString(currencyAcct);
		_body.composeSrvTime(started);
		_body.composeBYTE(cardTypeByte);
		_body.composeString(paysystemName);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierHeldTransBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(transId);
	_parser0.parseINT32(amountAcct);
	_parser0.parseStringP(currencyAcct);
	_parser0.parseSrvTime(started);
	_parser0.parseBYTE(cardTypeByte);
	_parser0.parseStringP(paysystemName);
}

const char *CashierServer::cli::CashierHeldTransBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("transId", transId);
	_jsonstr.compose("amountAcct", amountAcct);
	_jsonstr.compose("currencyAcct", currencyAcct);
	_jsonstr.compose("started", started);
	_jsonstr.compose("cardTypeByte", cardTypeByte);
	_jsonstr.compose("paysystemName", paysystemName);
	return _buf.c_str();
}

void CashierServer::cli::CashierHeldTransBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("transId", transId);
	_jparser.parseByNameThrow("amountAcct", amountAcct);
	_jparser.parseByNameThrow("currencyAcct", currencyAcct);
	_jparser.parseByNameThrow("started", started);
	_jparser.parseByNameThrow("cardTypeByte", cardTypeByte);
	_jparser.parseByNameThrow("paysystemName", paysystemName);
}

/* static */ void CashierServer::cli::CashierHeldTransBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 transId; _jparser.validateByNameThrow("transId", transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	INT32 amountAcct; _jparser.validateByNameThrow("amountAcct", amountAcct);
	AtfValidator::validateInt(_descr, "amountAcct", amountAcct, _checker, __FILE__, __LINE__);
	PString currencyAcct; _jparser.validateByNameThrow("currencyAcct", currencyAcct);
	AtfValidator::validateInt(_descr, "currencyAcct", currencyAcct.length(), _checker, __FILE__, __LINE__);
	CommSrvTime started; _jparser.validateByNameThrow("started", started);
	AtfValidator::validateSrvDateTime(_descr, "started", started, _checker, __FILE__, __LINE__);
	BYTE cardTypeByte; _jparser.validateByNameThrow("cardTypeByte", cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	PString paysystemName; _jparser.validateByNameThrow("paysystemName", paysystemName);
	AtfValidator::validateInt(_descr, "paysystemName", paysystemName.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierHeldTransBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 transId; _parser0.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	INT32 amountAcct; _parser0.parseINT32(amountAcct);
	AtfValidator::validateInt(_descr, "amountAcct", amountAcct, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currencyAcct"); size_t szCurrencyAcct = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currencyAcct", szCurrencyAcct, _checker, __FILE__, __LINE__);
	CommSrvTime started; _parser0.parseSrvTime(started);
	AtfValidator::validateSrvDateTime(_descr, "started", started, _checker, __FILE__, __LINE__);
	BYTE cardTypeByte; _parser0.parseBYTE(cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "paysystemName"); size_t szPaysystemName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "paysystemName", szPaysystemName, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	transactions.clear();
	totalOnHold = 0;
	denominatedCurrency.clear();
	allowToRejectFunds = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::equals(const Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		transactions.equals(_o.transactions) &&
		totalOnHold == _o.totalOnHold &&
		Atf::atfPStringEquals(denominatedCurrency, _o.denominatedCurrency) &&
		allowToRejectFunds == _o.allowToRejectFunds;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("transactions=");
		transactions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("totalOnHold=");
		_buf.appendInt(totalOnHold);
		_buf.append(',');
		_buf.append("denominatedCurrency=");
		_buf.append(denominatedCurrency);
		_buf.append(',');
		_buf.append("allowToRejectFunds=");
		_buf.appendUint(allowToRejectFunds);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		transactions.toXmlString("transactions", _buf);
		Atf::XmlElement::encodeAsXmlElement("totalOnHold", totalOnHold, _buf);
		Atf::XmlElement::encodeAsXmlElement("denominatedCurrency", denominatedCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("allowToRejectFunds", allowToRejectFunds, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("transactions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierHeldTransBody, 4 > >::FromXmlString(_value, transactions)) return false;
			}
			else if (_element.equals("totalOnHold"))
			{
				totalOnHold = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("denominatedCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, denominatedCurrency)) return false;
			}
			else if (_element.equals("allowToRejectFunds"))
			{
				allowToRejectFunds = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		transactions.composeMsg(_msg, _ignoreJSON);
		_msg.composeINT32(totalOnHold);
		_msg.composeString(denominatedCurrency);
		_msg.composeUINT32(allowToRejectFunds);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		transactions.parseMsg(_parser);
		_parser.parseINT32(totalOnHold);
		_parser.parseStringP(denominatedCurrency);
		_parser.parseUINT32(allowToRejectFunds);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("transactions", transactions);
		_jsonstr.compose("totalOnHold", totalOnHold);
		_jsonstr.compose("denominatedCurrency", denominatedCurrency);
		_jsonstr.compose("allowToRejectFunds", allowToRejectFunds);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("transactions", transactions);
		_jparser.parseByNameThrow("totalOnHold", totalOnHold);
		_jparser.parseByNameThrow("denominatedCurrency", denominatedCurrency);
		_jparser.parseByNameThrow("allowToRejectFunds", allowToRejectFunds);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CashierHeldTransBody > transactions; _jparser.validateByNameThrow("transactions", transactions);
		AtfValidator::validateInt(_descr, "transactions", transactions.size(), _checker, __FILE__, __LINE__);
		INT32 totalOnHold; _jparser.validateByNameThrow("totalOnHold", totalOnHold);
		AtfValidator::validateInt(_descr, "totalOnHold", totalOnHold, _checker, __FILE__, __LINE__);
		PString denominatedCurrency; _jparser.validateByNameThrow("denominatedCurrency", denominatedCurrency);
		AtfValidator::validateInt(_descr, "denominatedCurrency", denominatedCurrency.length(), _checker, __FILE__, __LINE__);
		UINT32 allowToRejectFunds; _jparser.validateByNameThrow("allowToRejectFunds", allowToRejectFunds);
		AtfValidator::validateInt(_descr, "allowToRejectFunds", allowToRejectFunds, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTransactions = Atf::LAtfVector< CashierHeldTransBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("transactions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "transactions", szTransactions, _checker, __FILE__, __LINE__);
		INT32 totalOnHold; _parser.parseINT32(totalOnHold);
		AtfValidator::validateInt(_descr, "totalOnHold", totalOnHold, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "denominatedCurrency"); size_t szDenominatedCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "denominatedCurrency", szDenominatedCurrency, _checker, __FILE__, __LINE__);
		UINT32 allowToRejectFunds; _parser.parseUINT32(allowToRejectFunds);
		AtfValidator::validateInt(_descr, "allowToRejectFunds", allowToRejectFunds, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::equals(const Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::equals(const Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_SAVED_CARDS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::Protocol_MSG_CASHIER_GET_SAVED_CARDS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::equals(const Protocol_MSG_CASHIER_GET_SAVED_CARDS& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_SAVED_CARDS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_SAVED_CARDS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_SAVED_CARDS).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_SAVED_CARDS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_SAVED_CARDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_SAVED_CARDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierOneCardBody
//=================================================================

CashierServer::cli::CashierOneCardBody::CashierOneCardBody()
{
	clear();
}

void CashierServer::cli::CashierOneCardBody::clear()
{
	infoId = 0;
	ccId = 0;
	paysystemByte = 0;
	flagsForClient = 0;
	oldCardNumPlain.clear();
	maskedCardNum.clear();
	expYear = 0;
	expMonth = 0;
	lastUse.setNull();
	currencyProc.clear();
	savedProcAmount = 0;
}

bool CashierServer::cli::CashierOneCardBody::equals(const CashierOneCardBody& _o) const
{
	return infoId == _o.infoId &&
		ccId == _o.ccId &&
		paysystemByte == _o.paysystemByte &&
		flagsForClient == _o.flagsForClient &&
		Atf::atfPStringEquals(oldCardNumPlain, _o.oldCardNumPlain) &&
		Atf::atfPStringEquals(maskedCardNum, _o.maskedCardNum) &&
		expYear == _o.expYear &&
		expMonth == _o.expMonth &&
		lastUse.equals(_o.lastUse) &&
		Atf::atfPStringEquals(currencyProc, _o.currencyProc) &&
		savedProcAmount == _o.savedProcAmount;
}

const char *CashierServer::cli::CashierOneCardBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("infoId=");
	_buf.appendUint(infoId);
	_buf.append(',');
	_buf.append("ccId=");
	_buf.appendUint(ccId);
	_buf.append(',');
	_buf.append("paysystemByte=");
	_buf.appendUint(paysystemByte);
	_buf.append(',');
	_buf.append("flagsForClient=");
	_buf.appendUint(flagsForClient);
	_buf.append(',');
	_buf.append("oldCardNumPlain=");
	_buf.append(oldCardNumPlain);
	_buf.append(',');
	_buf.append("maskedCardNum=");
	_buf.append(maskedCardNum);
	_buf.append(',');
	_buf.append("expYear=");
	_buf.appendUint(expYear);
	_buf.append(',');
	_buf.append("expMonth=");
	_buf.appendUint(expMonth);
	_buf.append(',');
	_buf.append("lastUse=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, lastUse);
	_buf.append(',');
	_buf.append("currencyProc=");
	_buf.append(currencyProc);
	_buf.append(',');
	_buf.append("savedProcAmount=");
	_buf.appendInt(savedProcAmount);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierOneCardBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("infoId", infoId, _buf);
	Atf::XmlElement::encodeAsXmlElement("ccId", ccId, _buf);
	Atf::XmlElement::encodeAsXmlElement("paysystemByte", paysystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("flagsForClient", flagsForClient, _buf);
	Atf::XmlElement::encodeAsXmlElement("oldCardNumPlain", oldCardNumPlain, _buf);
	Atf::XmlElement::encodeAsXmlElement("maskedCardNum", maskedCardNum, _buf);
	Atf::XmlElement::encodeAsXmlElement("expYear", expYear, _buf);
	Atf::XmlElement::encodeAsXmlElement("expMonth", expMonth, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "lastUse", lastUse);
	Atf::XmlElement::encodeAsXmlElement("currencyProc", currencyProc, _buf);
	Atf::XmlElement::encodeAsXmlElement("savedProcAmount", savedProcAmount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierOneCardBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("infoId"))
		{
			infoId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ccId"))
		{
			ccId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("paysystemByte"))
		{
			paysystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flagsForClient"))
		{
			flagsForClient = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("oldCardNumPlain"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, oldCardNumPlain)) return false;
		}
		else if (_element.equals("maskedCardNum"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, maskedCardNum)) return false;
		}
		else if (_element.equals("expYear"))
		{
			expYear = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("expMonth"))
		{
			expMonth = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lastUse"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, lastUse);
		}
		else if (_element.equals("currencyProc"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currencyProc)) return false;
		}
		else if (_element.equals("savedProcAmount"))
		{
			savedProcAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierOneCardBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierOneCardBody())) // not empty
	{
		_body.composeUINT32(infoId);
		_body.composeUINT32(ccId);
		_body.composeBYTE(paysystemByte);
		_body.composeUINT32(flagsForClient);
		_body.composeString(oldCardNumPlain);
		_body.composeString(maskedCardNum);
		_body.composeUINT16(expYear);
		_body.composeBYTE(expMonth);
		_body.composeSrvTime(lastUse);
		_body.composeString(currencyProc);
		_body.composeINT32(savedProcAmount);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierOneCardBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(infoId);
	_parser0.parseUINT32(ccId);
	_parser0.parseBYTE(paysystemByte);
	_parser0.parseUINT32(flagsForClient);
	_parser0.parseStringP(oldCardNumPlain);
	_parser0.parseStringP(maskedCardNum);
	_parser0.parseUINT16(expYear);
	_parser0.parseBYTE(expMonth);
	_parser0.parseSrvTime(lastUse);
	_parser0.parseStringP(currencyProc);
	_parser0.parseINT32(savedProcAmount);
}

const char *CashierServer::cli::CashierOneCardBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("infoId", infoId);
	_jsonstr.compose("ccId", ccId);
	_jsonstr.compose("paysystemByte", paysystemByte);
	_jsonstr.compose("flagsForClient", flagsForClient);
	_jsonstr.compose("oldCardNumPlain", oldCardNumPlain);
	_jsonstr.compose("maskedCardNum", maskedCardNum);
	_jsonstr.compose("expYear", expYear);
	_jsonstr.compose("expMonth", expMonth);
	_jsonstr.compose("lastUse", lastUse);
	_jsonstr.compose("currencyProc", currencyProc);
	_jsonstr.compose("savedProcAmount", savedProcAmount);
	return _buf.c_str();
}

void CashierServer::cli::CashierOneCardBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("infoId", infoId);
	_jparser.parseByNameThrow("ccId", ccId);
	_jparser.parseByNameThrow("paysystemByte", paysystemByte);
	_jparser.parseByNameThrow("flagsForClient", flagsForClient);
	_jparser.parseByNameThrow("oldCardNumPlain", oldCardNumPlain);
	_jparser.parseByNameThrow("maskedCardNum", maskedCardNum);
	_jparser.parseByNameThrow("expYear", expYear);
	_jparser.parseByNameThrow("expMonth", expMonth);
	_jparser.parseByNameThrow("lastUse", lastUse);
	_jparser.parseByNameThrow("currencyProc", currencyProc);
	_jparser.parseByNameThrow("savedProcAmount", savedProcAmount);
}

/* static */ void CashierServer::cli::CashierOneCardBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 infoId; _jparser.validateByNameThrow("infoId", infoId);
	AtfValidator::validateInt(_descr, "infoId", infoId, _checker, __FILE__, __LINE__);
	UINT32 ccId; _jparser.validateByNameThrow("ccId", ccId);
	AtfValidator::validateInt(_descr, "ccId", ccId, _checker, __FILE__, __LINE__);
	BYTE paysystemByte; _jparser.validateByNameThrow("paysystemByte", paysystemByte);
	AtfValidator::validateInt(_descr, "paysystemByte", paysystemByte, _checker, __FILE__, __LINE__);
	UINT32 flagsForClient; _jparser.validateByNameThrow("flagsForClient", flagsForClient);
	AtfValidator::validateInt(_descr, "flagsForClient", flagsForClient, _checker, __FILE__, __LINE__);
	PString oldCardNumPlain; _jparser.validateByNameThrow("oldCardNumPlain", oldCardNumPlain);
	AtfValidator::validateInt(_descr, "oldCardNumPlain", oldCardNumPlain.length(), _checker, __FILE__, __LINE__);
	PString maskedCardNum; _jparser.validateByNameThrow("maskedCardNum", maskedCardNum);
	AtfValidator::validateInt(_descr, "maskedCardNum", maskedCardNum.length(), _checker, __FILE__, __LINE__);
	UINT16 expYear; _jparser.validateByNameThrow("expYear", expYear);
	AtfValidator::validateInt(_descr, "expYear", expYear, _checker, __FILE__, __LINE__);
	BYTE expMonth; _jparser.validateByNameThrow("expMonth", expMonth);
	AtfValidator::validateInt(_descr, "expMonth", expMonth, _checker, __FILE__, __LINE__);
	CommSrvTime lastUse; _jparser.validateByNameThrow("lastUse", lastUse);
	AtfValidator::validateSrvDateTime(_descr, "lastUse", lastUse, _checker, __FILE__, __LINE__);
	PString currencyProc; _jparser.validateByNameThrow("currencyProc", currencyProc);
	AtfValidator::validateInt(_descr, "currencyProc", currencyProc.length(), _checker, __FILE__, __LINE__);
	INT32 savedProcAmount; _jparser.validateByNameThrow("savedProcAmount", savedProcAmount);
	AtfValidator::validateInt(_descr, "savedProcAmount", savedProcAmount, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierOneCardBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 infoId; _parser0.parseUINT32(infoId);
	AtfValidator::validateInt(_descr, "infoId", infoId, _checker, __FILE__, __LINE__);
	UINT32 ccId; _parser0.parseUINT32(ccId);
	AtfValidator::validateInt(_descr, "ccId", ccId, _checker, __FILE__, __LINE__);
	BYTE paysystemByte; _parser0.parseBYTE(paysystemByte);
	AtfValidator::validateInt(_descr, "paysystemByte", paysystemByte, _checker, __FILE__, __LINE__);
	UINT32 flagsForClient; _parser0.parseUINT32(flagsForClient);
	AtfValidator::validateInt(_descr, "flagsForClient", flagsForClient, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "oldCardNumPlain"); size_t szOldCardNumPlain = strlen(_dummy);
	AtfValidator::validateInt(_descr, "oldCardNumPlain", szOldCardNumPlain, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "maskedCardNum"); size_t szMaskedCardNum = strlen(_dummy);
	AtfValidator::validateInt(_descr, "maskedCardNum", szMaskedCardNum, _checker, __FILE__, __LINE__);
	UINT16 expYear; _parser0.parseUINT16(expYear);
	AtfValidator::validateInt(_descr, "expYear", expYear, _checker, __FILE__, __LINE__);
	BYTE expMonth; _parser0.parseBYTE(expMonth);
	AtfValidator::validateInt(_descr, "expMonth", expMonth, _checker, __FILE__, __LINE__);
	CommSrvTime lastUse; _parser0.parseSrvTime(lastUse);
	AtfValidator::validateSrvDateTime(_descr, "lastUse", lastUse, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currencyProc"); size_t szCurrencyProc = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currencyProc", szCurrencyProc, _checker, __FILE__, __LINE__);
	INT32 savedProcAmount; _parser0.parseINT32(savedProcAmount);
	AtfValidator::validateInt(_descr, "savedProcAmount", savedProcAmount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	cards.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::equals(const Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		cards.equals(_o.cards);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_SAVED_CARDS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_SAVED_CARDS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("cards=");
		cards.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_SAVED_CARDS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		cards.toXmlString("cards", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("cards"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierOneCardBody, 4 > >::FromXmlString(_value, cards)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		cards.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		cards.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("cards", cards);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("cards", cards);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_SAVED_CARDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CashierOneCardBody > cards; _jparser.validateByNameThrow("cards", cards);
		AtfValidator::validateInt(_descr, "cards", cards.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_SAVED_CARDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szCards = Atf::LAtfVector< CashierOneCardBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cards"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DELETE_SAVED_CARD
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::Protocol_MSG_CASHIER_DELETE_SAVED_CARD()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::clear()
{
	paySystemByte = 0;
	cardInfoId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::equals(const Protocol_MSG_CASHIER_DELETE_SAVED_CARD& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		cardInfoId == _o.cardInfoId;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_DELETE_SAVED_CARD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_DELETE_SAVED_CARD*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DELETE_SAVED_CARD).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_DELETE_SAVED_CARD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardInfoId", cardInfoId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cardInfoId"))
			{
				cardInfoId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeUINT32(cardInfoId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseUINT32(cardInfoId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemByte", paySystemByte);
	_jsonstr.compose("cardInfoId", cardInfoId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
	_jparser.parseByNameThrow("cardInfoId", cardInfoId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_SAVED_CARD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _jparser.validateByNameThrow("cardInfoId", cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_SAVED_CARD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::equals(const Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_DELETE_SAVED_CARD_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DELETE_SAVED_CARD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_DELETE_SAVED_CARD_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_SAVED_CARD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_SAVED_CARD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PLAY_TRANSFER
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::Protocol_MSG_CASHIER_PLAY_TRANSFER()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::clear()
{
	userTo.clear();
	amount64 = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::equals(const Protocol_MSG_CASHIER_PLAY_TRANSFER& _o) const
{
	return Atf::atfPStringEquals(userTo, _o.userTo) &&
		amount64 == _o.amount64;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PLAY_TRANSFER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PLAY_TRANSFER*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PLAY_TRANSFER).append(")");
	_buf.append(',');
	_buf.append("userTo=");
	_buf.append(userTo);
	_buf.append(',');
	_buf.append("amount64=");
	_buf.appendInt64(amount64);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PLAY_TRANSFER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userTo", userTo, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount64", amount64, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userTo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userTo)) return false;
			}
			else if (_element.equals("amount64"))
			{
				amount64 = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userTo);
	_msg.composeINT64(amount64);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userTo);
	_parser.parseINT64(amount64);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userTo", userTo);
	_jsonstr.compose("amount64", amount64);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userTo", userTo);
	_jparser.parseByNameThrow("amount64", amount64);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_TRANSFER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userTo; _jparser.validateByNameThrow("userTo", userTo);
	AtfValidator::validateIntMax(_descr, "userTo", userTo.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT64 amount64; _jparser.validateByNameThrow("amount64", amount64);
	AtfValidator::validateIntRange(_descr, "amount64", amount64, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_TRANSFER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userTo"); size_t szUserTo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userTo", szUserTo, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT64 amount64; _parser.parseINT64(amount64);
	AtfValidator::validateIntRange(_descr, "amount64", amount64, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::equals(const Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PLAY_TRANSFER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PLAY_TRANSFER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PLAY_TRANSFER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_TRANSFER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_TRANSFER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DEPOSIT_CHECK
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::Protocol_MSG_CASHIER_DEPOSIT_CHECK()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::clear()
{
	paySystemByte = 0;
	procAmount = 0;
	procCurrency.clear();
	acctAmount = 0;
	acctCurrency.clear();
	requestFlags = 0;
	cardNum.clear();
	cardNumEncrypted.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::equals(const Protocol_MSG_CASHIER_DEPOSIT_CHECK& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		procAmount == _o.procAmount &&
		Atf::atfPStringEquals(procCurrency, _o.procCurrency) &&
		acctAmount == _o.acctAmount &&
		Atf::atfPStringEquals(acctCurrency, _o.acctCurrency) &&
		requestFlags == _o.requestFlags &&
		Atf::atfPStringEquals(cardNum, _o.cardNum) &&
		cardNumEncrypted.size() == _o.cardNumEncrypted.size() && memcmp(cardNumEncrypted.ptr(), _o.cardNumEncrypted.ptr(), cardNumEncrypted.size()) == 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_DEPOSIT_CHECK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_DEPOSIT_CHECK*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DEPOSIT_CHECK).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("procAmount=");
	_buf.appendInt64(procAmount);
	_buf.append(',');
	_buf.append("procCurrency=");
	_buf.append(procCurrency);
	_buf.append(',');
	_buf.append("acctAmount=");
	_buf.appendInt64(acctAmount);
	_buf.append(',');
	_buf.append("acctCurrency=");
	_buf.append(acctCurrency);
	_buf.append(',');
	_buf.append("requestFlags=");
	_buf.appendUint(requestFlags);
	_buf.append(',');
	_buf.append("cardNum=");
	_buf.append(cardNum);
	_buf.append(',');
	_buf.append("cardNumEncrypted=");
	Atf::AtfTempl<PBlock>::ToTraceString(_buf, cardNumEncrypted);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_DEPOSIT_CHECK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("procAmount", procAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("procCurrency", procCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("acctAmount", acctAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("acctCurrency", acctCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("requestFlags", requestFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardNum", cardNum, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardNumEncrypted", cardNumEncrypted, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("procAmount"))
			{
				procAmount = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("procCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, procCurrency)) return false;
			}
			else if (_element.equals("acctAmount"))
			{
				acctAmount = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("acctCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, acctCurrency)) return false;
			}
			else if (_element.equals("requestFlags"))
			{
				requestFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cardNum"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, cardNum)) return false;
			}
			else if (_element.equals("cardNumEncrypted"))
			{
				Atf::XmlElement::_movePBlockWithNullStrip(_value, cardNumEncrypted);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeINT64(procAmount);
	_msg.composeString(procCurrency);
	_msg.composeINT64(acctAmount);
	_msg.composeString(acctCurrency);
	_msg.composeUINT32(requestFlags);
	_msg.composeString(cardNum);
	_msg._composeVarBlock(cardNumEncrypted.ptr(), cardNumEncrypted.size());
}

void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseINT64(procAmount);
	_parser.parseStringP(procCurrency);
	_parser.parseINT64(acctAmount);
	_parser.parseStringP(acctCurrency);
	_parser.parseUINT32(requestFlags);
	_parser.parseStringP(cardNum);
	if(_parser.parseEnded()) return;
	_parser.parsePBlock(cardNumEncrypted);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemByte", paySystemByte);
	_jsonstr.compose("procAmount", procAmount);
	_jsonstr.compose("procCurrency", procCurrency);
	_jsonstr.compose("acctAmount", acctAmount);
	_jsonstr.compose("acctCurrency", acctCurrency);
	_jsonstr.compose("requestFlags", requestFlags);
	_jsonstr.compose("cardNum", cardNum);
	_jsonstr.compose("cardNumEncrypted", cardNumEncrypted);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
	_jparser.parseByNameThrow("procAmount", procAmount);
	_jparser.parseByNameThrow("procCurrency", procCurrency);
	_jparser.parseByNameThrow("acctAmount", acctAmount);
	_jparser.parseByNameThrow("acctCurrency", acctCurrency);
	_jparser.parseByNameThrow("requestFlags", requestFlags);
	_jparser.parseByNameThrow("cardNum", cardNum);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("cardNumEncrypted", cardNumEncrypted);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DEPOSIT_CHECK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	INT64 procAmount; _jparser.validateByNameThrow("procAmount", procAmount);
	AtfValidator::validateIntRange(_descr, "procAmount", procAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString procCurrency; _jparser.validateByNameThrow("procCurrency", procCurrency);
	AtfValidator::validateIntMax(_descr, "procCurrency", procCurrency.length(), 100, _checker, __FILE__, __LINE__);
	INT64 acctAmount; _jparser.validateByNameThrow("acctAmount", acctAmount);
	AtfValidator::validateIntRange(_descr, "acctAmount", acctAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString acctCurrency; _jparser.validateByNameThrow("acctCurrency", acctCurrency);
	AtfValidator::validateIntMax(_descr, "acctCurrency", acctCurrency.length(), 100, _checker, __FILE__, __LINE__);
	UINT32 requestFlags; _jparser.validateByNameThrow("requestFlags", requestFlags);
	AtfValidator::validateIntMax(_descr, "requestFlags", requestFlags, ((((UINT32)eCashierDepositCheckFlag_Last)<<1)-1), _checker, __FILE__, __LINE__);
	PString cardNum; _jparser.validateByNameThrow("cardNum", cardNum);
	AtfValidator::validateIntMax(_descr, "cardNum", cardNum.length(), CARDNUM_LEN, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PBlock cardNumEncrypted; _jparser.validateByNameThrow("cardNumEncrypted", cardNumEncrypted);
	AtfValidator::validateIntMax(_descr, "cardNumEncrypted", cardNumEncrypted.size(), 4000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DEPOSIT_CHECK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	INT64 procAmount; _parser.parseINT64(procAmount);
	AtfValidator::validateIntRange(_descr, "procAmount", procAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "procCurrency"); size_t szProcCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "procCurrency", szProcCurrency, 100, _checker, __FILE__, __LINE__);
	INT64 acctAmount; _parser.parseINT64(acctAmount);
	AtfValidator::validateIntRange(_descr, "acctAmount", acctAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "acctCurrency"); size_t szAcctCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "acctCurrency", szAcctCurrency, 100, _checker, __FILE__, __LINE__);
	UINT32 requestFlags; _parser.parseUINT32(requestFlags);
	AtfValidator::validateIntMax(_descr, "requestFlags", requestFlags, ((((UINT32)eCashierDepositCheckFlag_Last)<<1)-1), _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cardNum"); size_t szCardNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cardNum", szCardNum, CARDNUM_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	const BYTE* cardNumEncrypted; size_t szCardNumEncrypted; _parser._parseVarBlock(cardNumEncrypted, szCardNumEncrypted);  /*cardNumEncrypted*/
	AtfValidator::validateIntMax(_descr, "cardNumEncrypted", szCardNumEncrypted, 4000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierUpsellAwardBody
//=================================================================

CashierServer::cli::CashierUpsellAwardBody::CashierUpsellAwardBody()
{
	clear();
}

void CashierServer::cli::CashierUpsellAwardBody::clear()
{
	proposedProcAmount = 0;
	proposedAcctAmount = 0;
	award = 0;
	awardInAcctCurrency = 0;
}

bool CashierServer::cli::CashierUpsellAwardBody::equals(const CashierUpsellAwardBody& _o) const
{
	return proposedProcAmount == _o.proposedProcAmount &&
		proposedAcctAmount == _o.proposedAcctAmount &&
		award == _o.award &&
		awardInAcctCurrency == _o.awardInAcctCurrency;
}

const char *CashierServer::cli::CashierUpsellAwardBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("proposedProcAmount=");
	_buf.appendInt64(proposedProcAmount);
	_buf.append(',');
	_buf.append("proposedAcctAmount=");
	_buf.appendInt64(proposedAcctAmount);
	_buf.append(',');
	_buf.append("award=");
	_buf.appendInt64(award);
	_buf.append(',');
	_buf.append("awardInAcctCurrency=");
	_buf.appendInt64(awardInAcctCurrency);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierUpsellAwardBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("proposedProcAmount", proposedProcAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("proposedAcctAmount", proposedAcctAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("award", award, _buf);
	Atf::XmlElement::encodeAsXmlElement("awardInAcctCurrency", awardInAcctCurrency, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierUpsellAwardBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("proposedProcAmount"))
		{
			proposedProcAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("proposedAcctAmount"))
		{
			proposedAcctAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("award"))
		{
			award = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("awardInAcctCurrency"))
		{
			awardInAcctCurrency = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierUpsellAwardBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierUpsellAwardBody())) // not empty
	{
		_body.composeINT64(proposedProcAmount);
		_body.composeINT64(proposedAcctAmount);
		_body.composeINT64(award);
		_body.composeINT64(awardInAcctCurrency);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierUpsellAwardBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(proposedProcAmount);
	_parser0.parseINT64(proposedAcctAmount);
	_parser0.parseINT64(award);
	_parser0.parseINT64(awardInAcctCurrency);
}

const char *CashierServer::cli::CashierUpsellAwardBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("proposedProcAmount", proposedProcAmount);
	_jsonstr.compose("proposedAcctAmount", proposedAcctAmount);
	_jsonstr.compose("award", award);
	_jsonstr.compose("awardInAcctCurrency", awardInAcctCurrency);
	return _buf.c_str();
}

void CashierServer::cli::CashierUpsellAwardBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("proposedProcAmount", proposedProcAmount);
	_jparser.parseByNameThrow("proposedAcctAmount", proposedAcctAmount);
	_jparser.parseByNameThrow("award", award);
	_jparser.parseByNameThrow("awardInAcctCurrency", awardInAcctCurrency);
}

/* static */ void CashierServer::cli::CashierUpsellAwardBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 proposedProcAmount; _jparser.validateByNameThrow("proposedProcAmount", proposedProcAmount);
	AtfValidator::validateInt(_descr, "proposedProcAmount", proposedProcAmount, _checker, __FILE__, __LINE__);
	INT64 proposedAcctAmount; _jparser.validateByNameThrow("proposedAcctAmount", proposedAcctAmount);
	AtfValidator::validateInt(_descr, "proposedAcctAmount", proposedAcctAmount, _checker, __FILE__, __LINE__);
	INT64 award; _jparser.validateByNameThrow("award", award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	INT64 awardInAcctCurrency; _jparser.validateByNameThrow("awardInAcctCurrency", awardInAcctCurrency);
	AtfValidator::validateInt(_descr, "awardInAcctCurrency", awardInAcctCurrency, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierUpsellAwardBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT64 proposedProcAmount; _parser0.parseINT64(proposedProcAmount);
	AtfValidator::validateInt(_descr, "proposedProcAmount", proposedProcAmount, _checker, __FILE__, __LINE__);
	INT64 proposedAcctAmount; _parser0.parseINT64(proposedAcctAmount);
	AtfValidator::validateInt(_descr, "proposedAcctAmount", proposedAcctAmount, _checker, __FILE__, __LINE__);
	INT64 award; _parser0.parseINT64(award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	INT64 awardInAcctCurrency; _parser0.parseINT64(awardInAcctCurrency);
	AtfValidator::validateInt(_descr, "awardInAcctCurrency", awardInAcctCurrency, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierUpsellBody
//=================================================================

CashierServer::cli::CashierUpsellBody::CashierUpsellBody()
{
	clear();
}

void CashierServer::cli::CashierUpsellBody::clear()
{
	awardId = 0;
	awardType = 0;
	upsellCaptionText.clear();
	baseCurrency.clear();
	awards.clear();
	timerValueSecs = 0;
}

bool CashierServer::cli::CashierUpsellBody::equals(const CashierUpsellBody& _o) const
{
	return awardId == _o.awardId &&
		awardType == _o.awardType &&
		Atf::atfPStringEquals(upsellCaptionText, _o.upsellCaptionText) &&
		Atf::atfPStringEquals(baseCurrency, _o.baseCurrency) &&
		awards.equals(_o.awards) &&
		timerValueSecs == _o.timerValueSecs;
}

const char *CashierServer::cli::CashierUpsellBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("awardId=");
	_buf.appendUint(awardId);
	_buf.append(',');
	_buf.append("awardType=");
	_buf.appendInt(awardType);
	_buf.append(',');
	_buf.append("upsellCaptionText=");
	_buf.append(upsellCaptionText);
	_buf.append(',');
	_buf.append("baseCurrency=");
	_buf.append(baseCurrency);
	_buf.append(',');
	_buf.append("awards=");
	awards.toTraceString(_buf);
	_buf.append(',');
	_buf.append("timerValueSecs=");
	_buf.appendInt(timerValueSecs);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierUpsellBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("awardId", awardId, _buf);
	Atf::XmlElement::encodeAsXmlElement("awardType", awardType, _buf);
	Atf::XmlElement::encodeAsXmlElement("upsellCaptionText", upsellCaptionText, _buf);
	Atf::XmlElement::encodeAsXmlElement("baseCurrency", baseCurrency, _buf);
	awards.toXmlString("awards", _buf);
	Atf::XmlElement::encodeAsXmlElement("timerValueSecs", timerValueSecs, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierUpsellBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("awardId"))
		{
			awardId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("awardType"))
		{
			awardType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("upsellCaptionText"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, upsellCaptionText)) return false;
		}
		else if (_element.equals("baseCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, baseCurrency)) return false;
		}
		else if (_element.equals("awards"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CashierUpsellAwardBody, 4 > >::FromXmlString(_value, awards)) return false;
		}
		else if (_element.equals("timerValueSecs"))
		{
			timerValueSecs = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierUpsellBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierUpsellBody())) // not empty
	{
		_body.composeUINT32(awardId);
		_body.composeINT32(awardType);
		_body.composeString(upsellCaptionText);
		_body.composeString(baseCurrency);
		awards.composeMsg(_body, _ignoreJSON);
		_body.composeINT32(timerValueSecs);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierUpsellBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(awardId);
	_parser0.parseINT32(awardType);
	_parser0.parseStringP(upsellCaptionText);
	_parser0.parseStringP(baseCurrency);
	awards.parseMsg(_parser0);
	_parser0.parseINT32(timerValueSecs);
}

const char *CashierServer::cli::CashierUpsellBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("awardId", awardId);
	_jsonstr.compose("awardType", awardType);
	_jsonstr.compose("upsellCaptionText", upsellCaptionText);
	_jsonstr.compose("baseCurrency", baseCurrency);
	_jsonstr.compose("awards", awards);
	_jsonstr.compose("timerValueSecs", timerValueSecs);
	return _buf.c_str();
}

void CashierServer::cli::CashierUpsellBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("awardId", awardId);
	_jparser.parseByNameThrow("awardType", awardType);
	_jparser.parseByNameThrow("upsellCaptionText", upsellCaptionText);
	_jparser.parseByNameThrow("baseCurrency", baseCurrency);
	_jparser.parseByNameThrow("awards", awards);
	_jparser.parseByNameThrow("timerValueSecs", timerValueSecs);
}

/* static */ void CashierServer::cli::CashierUpsellBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 awardId; _jparser.validateByNameThrow("awardId", awardId);
	AtfValidator::validateInt(_descr, "awardId", awardId, _checker, __FILE__, __LINE__);
	INT32 awardType; _jparser.validateByNameThrow("awardType", awardType);
	AtfValidator::validateInt(_descr, "awardType", awardType, _checker, __FILE__, __LINE__);
	PString upsellCaptionText; _jparser.validateByNameThrow("upsellCaptionText", upsellCaptionText);
	AtfValidator::validateInt(_descr, "upsellCaptionText", upsellCaptionText.length(), _checker, __FILE__, __LINE__);
	PString baseCurrency; _jparser.validateByNameThrow("baseCurrency", baseCurrency);
	AtfValidator::validateInt(_descr, "baseCurrency", baseCurrency.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< CashierUpsellAwardBody > awards; _jparser.validateByNameThrow("awards", awards);
	AtfValidator::validateInt(_descr, "awards", awards.size(), _checker, __FILE__, __LINE__);
	INT32 timerValueSecs; _jparser.validateByNameThrow("timerValueSecs", timerValueSecs);
	AtfValidator::validateInt(_descr, "timerValueSecs", timerValueSecs, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierUpsellBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 awardId; _parser0.parseUINT32(awardId);
	AtfValidator::validateInt(_descr, "awardId", awardId, _checker, __FILE__, __LINE__);
	INT32 awardType; _parser0.parseINT32(awardType);
	AtfValidator::validateInt(_descr, "awardType", awardType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "upsellCaptionText"); size_t szUpsellCaptionText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "upsellCaptionText", szUpsellCaptionText, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "baseCurrency"); size_t szBaseCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "baseCurrency", szBaseCurrency, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAwards = Atf::LAtfVector< CashierUpsellAwardBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("awards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "awards", szAwards, _checker, __FILE__, __LINE__);
	INT32 timerValueSecs; _parser0.parseINT32(timerValueSecs);
	AtfValidator::validateInt(_descr, "timerValueSecs", timerValueSecs, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	replyFlags = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::equals(const Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		replyFlags == _o.replyFlags;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_DEPOSIT_CHECK_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DEPOSIT_CHECK_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append(',');
		_buf.append("replyFlags=");
		_buf.appendUint(replyFlags);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_DEPOSIT_CHECK_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("replyFlags", replyFlags, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("replyFlags"))
			{
				replyFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		CommMsgBody _msg0;
		_msg.composeMsgBody(_msg0);
		_msg.composeUINT32(replyFlags);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		parseAnonymousMsgBody0(_parser);
		_parser.parseUINT32(replyFlags);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("replyFlags", replyFlags);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("replyFlags", replyFlags);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DEPOSIT_CHECK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 replyFlags; _jparser.validateByNameThrow("replyFlags", replyFlags);
		AtfValidator::validateInt(_descr, "replyFlags", replyFlags, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DEPOSIT_CHECK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		UINT32 replyFlags; _parser.parseUINT32(replyFlags);
		AtfValidator::validateInt(_descr, "replyFlags", replyFlags, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                Protocol_MSG_CASHIER_3V_PREREGISTER
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::Protocol_MSG_CASHIER_3V_PREREGISTER()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::equals(const Protocol_MSG_CASHIER_3V_PREREGISTER& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_3V_PREREGISTER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_3V_PREREGISTER*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_3V_PREREGISTER).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_3V_PREREGISTER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_3V_PREREGISTER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_3V_PREREGISTER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	signupUrl.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::equals(const Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(signupUrl, _o.signupUrl);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_3V_PREREGISTER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_3V_PREREGISTER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("signupUrl=");
		_buf.append(signupUrl);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_3V_PREREGISTER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("signupUrl", signupUrl, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("signupUrl"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, signupUrl)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(signupUrl);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(signupUrl);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("signupUrl", signupUrl);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("signupUrl", signupUrl);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_3V_PREREGISTER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString signupUrl; _jparser.validateByNameThrow("signupUrl", signupUrl);
		AtfValidator::validateInt(_descr, "signupUrl", signupUrl.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_3V_PREREGISTER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "signupUrl"); size_t szSignupUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "signupUrl", szSignupUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    BuyPmUserBody
//=================================================================

CashierServer::cli::BuyPmUserBody::BuyPmUserBody()
{
	clear();
}

void CashierServer::cli::BuyPmUserBody::clear()
{
	addr1.clear();
	addr2.clear();
	city.clear();
	state.clear();
	country.clear();
	zipCode.clear();
	firstName.clear();
	lastName.clear();
}

bool CashierServer::cli::BuyPmUserBody::equals(const BuyPmUserBody& _o) const
{
	return Atf::atfPStringEquals(addr1, _o.addr1) &&
		Atf::atfPStringEquals(addr2, _o.addr2) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(country, _o.country) &&
		Atf::atfPStringEquals(zipCode, _o.zipCode) &&
		Atf::atfPStringEquals(firstName, _o.firstName) &&
		Atf::atfPStringEquals(lastName, _o.lastName);
}

const char *CashierServer::cli::BuyPmUserBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("addr1=");
	_buf.append(addr1);
	_buf.append(',');
	_buf.append("addr2=");
	_buf.append(addr2);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("zipCode=");
	_buf.append(zipCode);
	_buf.append(',');
	_buf.append("firstName=");
	_buf.append(firstName);
	_buf.append(',');
	_buf.append("lastName=");
	_buf.append(lastName);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::BuyPmUserBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("addr1", addr1, _buf);
	Atf::XmlElement::encodeAsXmlElement("addr2", addr2, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("zipCode", zipCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("firstName", firstName, _buf);
	Atf::XmlElement::encodeAsXmlElement("lastName", lastName, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::BuyPmUserBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("addr1"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, addr1)) return false;
		}
		else if (_element.equals("addr2"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, addr2)) return false;
		}
		else if (_element.equals("city"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
		}
		else if (_element.equals("state"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("zipCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, zipCode)) return false;
		}
		else if (_element.equals("firstName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, firstName)) return false;
		}
		else if (_element.equals("lastName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, lastName)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::BuyPmUserBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(BuyPmUserBody())) // not empty
	{
		_body.composeString(addr1);
		_body.composeString(addr2);
		_body.composeString(city);
		_body.composeString(state);
		_body.composeString(country);
		_body.composeString(zipCode);
		_body.composeString(firstName);
		_body.composeString(lastName);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::BuyPmUserBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(addr1);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(addr2);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(city);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(state);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(country);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(zipCode);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(firstName);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(lastName);
}

const char *CashierServer::cli::BuyPmUserBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("addr1", addr1);
	_jsonstr.compose("addr2", addr2);
	_jsonstr.compose("city", city);
	_jsonstr.compose("state", state);
	_jsonstr.compose("country", country);
	_jsonstr.compose("zipCode", zipCode);
	_jsonstr.compose("firstName", firstName);
	_jsonstr.compose("lastName", lastName);
	return _buf.c_str();
}

void CashierServer::cli::BuyPmUserBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("addr1", addr1);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("addr2", addr2);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("city", city);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("state", state);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("country", country);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("zipCode", zipCode);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("firstName", firstName);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("lastName", lastName);
}

/* static */ void CashierServer::cli::BuyPmUserBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString addr1; _jparser.validateByNameThrow("addr1", addr1);
	AtfValidator::validateIntMax(_descr, "addr1", addr1.length(), USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString addr2; _jparser.validateByNameThrow("addr2", addr2);
	AtfValidator::validateIntMax(_descr, "addr2", addr2.length(), USER_ADDR2_LEN, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateIntMax(_descr, "city", city.length(), USER_CITY_LEN, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateIntMax(_descr, "state", state.length(), USER_STATE_LEN, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString zipCode; _jparser.validateByNameThrow("zipCode", zipCode);
	AtfValidator::validateIntMax(_descr, "zipCode", zipCode.length(), USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString firstName; _jparser.validateByNameThrow("firstName", firstName);
	AtfValidator::validateIntMax(_descr, "firstName", firstName.length(), USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString lastName; _jparser.validateByNameThrow("lastName", lastName);
	AtfValidator::validateIntMax(_descr, "lastName", lastName.length(), USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::BuyPmUserBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "addr1"); size_t szAddr1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "addr1", szAddr1, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "addr2"); size_t szAddr2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "addr2", szAddr2, USER_ADDR2_LEN, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "zipCode"); size_t szZipCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zipCode", szZipCode, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "firstName", szFirstName, USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "lastName"); size_t szLastName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "lastName", szLastName, USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    BuyPmCardBody
//=================================================================

CashierServer::cli::BuyPmCardBody::BuyPmCardBody()
{
	clear();
}

void CashierServer::cli::BuyPmCardBody::clear()
{
	cardInfoId = 0;
	cardNum.clear();
	cardCvv.clear();
	expYear = 0;
	expMonth = 0;
	encryptedCardNumAndCvv.clear();
}

bool CashierServer::cli::BuyPmCardBody::equals(const BuyPmCardBody& _o) const
{
	return cardInfoId == _o.cardInfoId &&
		Atf::atfPStringEquals(cardNum, _o.cardNum) &&
		Atf::atfPStringEquals(cardCvv, _o.cardCvv) &&
		expYear == _o.expYear &&
		expMonth == _o.expMonth &&
		encryptedCardNumAndCvv.size() == _o.encryptedCardNumAndCvv.size() && memcmp(encryptedCardNumAndCvv.ptr(), _o.encryptedCardNumAndCvv.ptr(), encryptedCardNumAndCvv.size()) == 0;
}

const char *CashierServer::cli::BuyPmCardBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	_buf.append(',');
	_buf.append("cardNum=");
	_buf.append(cardNum);
	_buf.append(',');
	_buf.append("cardCvv=");
	_buf.append(cardCvv);
	_buf.append(',');
	_buf.append("expYear=");
	_buf.appendUint(expYear);
	_buf.append(',');
	_buf.append("expMonth=");
	_buf.appendUint(expMonth);
	_buf.append(',');
	_buf.append("encryptedCardNumAndCvv=");
	Atf::AtfTempl<PBlock>::ToTraceString(_buf, encryptedCardNumAndCvv);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::BuyPmCardBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("cardInfoId", cardInfoId, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardNum", cardNum, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardCvv", cardCvv, _buf);
	Atf::XmlElement::encodeAsXmlElement("expYear", expYear, _buf);
	Atf::XmlElement::encodeAsXmlElement("expMonth", expMonth, _buf);
	Atf::XmlElement::encodeAsXmlElement("encryptedCardNumAndCvv", encryptedCardNumAndCvv, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::BuyPmCardBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cardInfoId"))
		{
			cardInfoId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cardNum"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cardNum)) return false;
		}
		else if (_element.equals("cardCvv"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cardCvv)) return false;
		}
		else if (_element.equals("expYear"))
		{
			expYear = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("expMonth"))
		{
			expMonth = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("encryptedCardNumAndCvv"))
		{
			Atf::XmlElement::_movePBlockWithNullStrip(_value, encryptedCardNumAndCvv);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::BuyPmCardBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(BuyPmCardBody())) // not empty
	{
		_body.composeUINT32(cardInfoId);
		_body.composeString(cardNum);
		_body.composeString(cardCvv);
		_body.composeUINT16(expYear);
		_body.composeBYTE(expMonth);
		_body._composeVarBlock(encryptedCardNumAndCvv.ptr(), encryptedCardNumAndCvv.size());
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::BuyPmCardBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(cardInfoId);
	_parser0.parseStringP(cardNum);
	_parser0.parseStringP(cardCvv);
	_parser0.parseUINT16(expYear);
	_parser0.parseBYTE(expMonth);
	if(_parser0.parseEnded()) return;
	_parser0.parsePBlock(encryptedCardNumAndCvv);
}

const char *CashierServer::cli::BuyPmCardBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cardInfoId", cardInfoId);
	_jsonstr.compose("cardNum", cardNum);
	_jsonstr.compose("cardCvv", cardCvv);
	_jsonstr.compose("expYear", expYear);
	_jsonstr.compose("expMonth", expMonth);
	_jsonstr.compose("encryptedCardNumAndCvv", encryptedCardNumAndCvv);
	return _buf.c_str();
}

void CashierServer::cli::BuyPmCardBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cardInfoId", cardInfoId);
	_jparser.parseByNameThrow("cardNum", cardNum);
	_jparser.parseByNameThrow("cardCvv", cardCvv);
	_jparser.parseByNameThrow("expYear", expYear);
	_jparser.parseByNameThrow("expMonth", expMonth);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("encryptedCardNumAndCvv", encryptedCardNumAndCvv);
}

/* static */ void CashierServer::cli::BuyPmCardBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 cardInfoId; _jparser.validateByNameThrow("cardInfoId", cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	PString cardNum; _jparser.validateByNameThrow("cardNum", cardNum);
	AtfValidator::validateIntMax(_descr, "cardNum", cardNum.length(), CARDNUM_LEN, _checker, __FILE__, __LINE__);
	PString cardCvv; _jparser.validateByNameThrow("cardCvv", cardCvv);
	AtfValidator::validateIntMax(_descr, "cardCvv", cardCvv.length(), CARD_CVV_LEN, _checker, __FILE__, __LINE__);
	UINT16 expYear; _jparser.validateByNameThrow("expYear", expYear);
	AtfValidator::validateIntMax(_descr, "expYear", expYear, 3000, _checker, __FILE__, __LINE__);
	BYTE expMonth; _jparser.validateByNameThrow("expMonth", expMonth);
	AtfValidator::validateIntMax(_descr, "expMonth", expMonth, 12, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PBlock encryptedCardNumAndCvv; _jparser.validateByNameThrow("encryptedCardNumAndCvv", encryptedCardNumAndCvv);
	AtfValidator::validateIntMax(_descr, "encryptedCardNumAndCvv", encryptedCardNumAndCvv.size(), 4000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::BuyPmCardBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 cardInfoId; _parser0.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "cardNum"); size_t szCardNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cardNum", szCardNum, CARDNUM_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "cardCvv"); size_t szCardCvv = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cardCvv", szCardCvv, CARD_CVV_LEN, _checker, __FILE__, __LINE__);
	UINT16 expYear; _parser0.parseUINT16(expYear);
	AtfValidator::validateIntMax(_descr, "expYear", expYear, 3000, _checker, __FILE__, __LINE__);
	BYTE expMonth; _parser0.parseBYTE(expMonth);
	AtfValidator::validateIntMax(_descr, "expMonth", expMonth, 12, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	const BYTE* encryptedCardNumAndCvv; size_t szEncryptedCardNumAndCvv; _parser0._parseVarBlock(encryptedCardNumAndCvv, szEncryptedCardNumAndCvv);  /*encryptedCardNumAndCvv*/
	AtfValidator::validateIntMax(_descr, "encryptedCardNumAndCvv", szEncryptedCardNumAndCvv, 4000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_BUY_PM
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::Protocol_MSG_CASHIER_BUY_PM()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::clear()
{
	converted = 0;
	currency.clear();
	playMoneyPurchaseAmount = 0;
	userBody.clear();
	paySystemByte = 0;
	cardBody.clear();
	saveCardInfoRequested = false;
	cliPsSpecificBodyIn.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::equals(const Protocol_MSG_CASHIER_BUY_PM& _o) const
{
	return converted == _o.converted &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		playMoneyPurchaseAmount == _o.playMoneyPurchaseAmount &&
		userBody.equals(_o.userBody) &&
		paySystemByte == _o.paySystemByte &&
		cardBody.equals(_o.cardBody) &&
		saveCardInfoRequested == _o.saveCardInfoRequested &&
		cliPsSpecificBodyIn.equals(_o.cliPsSpecificBodyIn);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_BUY_PM != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_BUY_PM*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BUY_PM).append(")");
	_buf.append(',');
	_buf.append("converted=");
	_buf.appendInt(converted);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("playMoneyPurchaseAmount=");
	_buf.appendInt64(playMoneyPurchaseAmount);
	_buf.append(',');
	_buf.append("userBody=");
	userBody.toTraceString(_buf);
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("cardBody=");
	cardBody.toTraceString(_buf);
	_buf.append(',');
	_buf.append("saveCardInfoRequested=");
	_buf.appendUint(saveCardInfoRequested);
	_buf.append(',');
	_buf.append("cliPsSpecificBodyIn=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(cliPsSpecificBodyIn, _buf); _buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_BUY_PM).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("converted", converted, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("playMoneyPurchaseAmount", playMoneyPurchaseAmount, _buf);
	userBody.toXmlString("userBody", _buf);
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	cardBody.toXmlString("cardBody", _buf);
	Atf::XmlElement::encodeAsXmlElement("saveCardInfoRequested", saveCardInfoRequested, _buf);
	Atf::XmlElement::encodeAsXmlElement("cliPsSpecificBodyIn", cliPsSpecificBodyIn, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("converted"))
			{
				converted = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("playMoneyPurchaseAmount"))
			{
				playMoneyPurchaseAmount = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userBody"))
			{
				if(!Atf::AtfTempl< BuyPmUserBody >::FromXmlString(_value, userBody)) return false;
			}
			else if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cardBody"))
			{
				if(!Atf::AtfTempl< BuyPmCardBody >::FromXmlString(_value, cardBody)) return false;
			}
			else if (_element.equals("saveCardInfoRequested"))
			{
				saveCardInfoRequested = (*_value.ptr() == '1');
			}
			else if (_element.equals("cliPsSpecificBodyIn"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, cliPsSpecificBodyIn)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(converted);
	_msg.composeString(currency);
	_msg.composeINT64(playMoneyPurchaseAmount);
	userBody.composeMsg(_msg, _ignoreJSON);
	_msg.composeBYTE(paySystemByte);
	cardBody.composeMsg(_msg, _ignoreJSON);
	_msg.composeBOOL(saveCardInfoRequested);
	_msg.composeMsgBody(cliPsSpecificBodyIn);
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(converted);
	_parser.parseStringP(currency);
	_parser.parseINT64(playMoneyPurchaseAmount);
	userBody.parseMsg(_parser);
	_parser.parseBYTE(paySystemByte);
	cardBody.parseMsg(_parser);
	_parser.parseBOOL(saveCardInfoRequested);
	if(_parser.parseEnded()) return;
	_parser.parseMsgBody(cliPsSpecificBodyIn);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("converted", converted);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("playMoneyPurchaseAmount", playMoneyPurchaseAmount);
	_jsonstr.compose("userBody", userBody);
	_jsonstr.compose("paySystemByte", paySystemByte);
	_jsonstr.compose("cardBody", cardBody);
	_jsonstr.compose("saveCardInfoRequested", saveCardInfoRequested);
	_jsonstr.compose("cliPsSpecificBodyIn", cliPsSpecificBodyIn);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("converted", converted);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("playMoneyPurchaseAmount", playMoneyPurchaseAmount);
	_jparser.parseByNameThrow("userBody", userBody);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
	_jparser.parseByNameThrow("cardBody", cardBody);
	_jparser.parseByNameThrow("saveCardInfoRequested", saveCardInfoRequested);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("cliPsSpecificBodyIn", cliPsSpecificBodyIn);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 converted; _jparser.validateByNameThrow("converted", converted);
	AtfValidator::validateIntRange(_descr, "converted", converted, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT64 playMoneyPurchaseAmount; _jparser.validateByNameThrow("playMoneyPurchaseAmount", playMoneyPurchaseAmount);
	AtfValidator::validateIntRange(_descr, "playMoneyPurchaseAmount", playMoneyPurchaseAmount, 0, ((INT64)PINT32_MAX*CASHTRANS_PM_MULTIPLIER), _checker, __FILE__, __LINE__);
	BuyPmUserBody userBody; _jparser.validateByNameThrow("userBody", userBody);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	BuyPmCardBody cardBody; _jparser.validateByNameThrow("cardBody", cardBody);
	bool saveCardInfoRequested; _jparser.validateByNameThrow("saveCardInfoRequested", saveCardInfoRequested);
	AtfValidator::validateInt(_descr, "saveCardInfoRequested", saveCardInfoRequested, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::CopyableMsgBody cliPsSpecificBodyIn; _jparser.validateByNameThrow("cliPsSpecificBodyIn", cliPsSpecificBodyIn);
	AtfValidator::validateIntMax(_descr, "cliPsSpecificBodyIn", cliPsSpecificBodyIn._size(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT32 converted; _parser.parseINT32(converted);
	AtfValidator::validateIntRange(_descr, "converted", converted, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT64 playMoneyPurchaseAmount; _parser.parseINT64(playMoneyPurchaseAmount);
	AtfValidator::validateIntRange(_descr, "playMoneyPurchaseAmount", playMoneyPurchaseAmount, 0, ((INT64)PINT32_MAX*CASHTRANS_PM_MULTIPLIER), _checker, __FILE__, __LINE__);
	PString _descbuf;
	BuyPmUserBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userBody"), _fieldsWithUnparsedContent);
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	BuyPmCardBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cardBody"), _fieldsWithUnparsedContent);
	bool saveCardInfoRequested; _parser.parseBOOL(saveCardInfoRequested);
	AtfValidator::validateInt(_descr, "saveCardInfoRequested", saveCardInfoRequested, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	size_t szCliPsSpecificBodyIn; _parser.skipMsgBody(szCliPsSpecificBodyIn);  /*cliPsSpecificBodyIn*/
	AtfValidator::validateIntMax(_descr, "cliPsSpecificBodyIn", szCliPsSpecificBodyIn, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BUY_PM_COMPLETE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::Protocol_MSG_CASHIER_BUY_PM_COMPLETE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::clear()
{
	errCode = 0;
	errDescr.clear();
	pmpApprovedPopUp.clear();
	transId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::equals(const Protocol_MSG_CASHIER_BUY_PM_COMPLETE& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(pmpApprovedPopUp, _o.pmpApprovedPopUp) &&
		transId == _o.transId;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_BUY_PM_COMPLETE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_BUY_PM_COMPLETE*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BUY_PM_COMPLETE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("pmpApprovedPopUp=");
		_buf.append(pmpApprovedPopUp);
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_BUY_PM_COMPLETE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("pmpApprovedPopUp", pmpApprovedPopUp, _buf);
		Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("pmpApprovedPopUp"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, pmpApprovedPopUp)) return false;
			}
			else if (_element.equals("transId"))
			{
				transId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(pmpApprovedPopUp);
		_msg.composeUINT32(transId);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(pmpApprovedPopUp);
		_parser.parseUINT32(transId);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("pmpApprovedPopUp", pmpApprovedPopUp);
		_jsonstr.compose("transId", transId);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("pmpApprovedPopUp", pmpApprovedPopUp);
		_jparser.parseByNameThrow("transId", transId);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_COMPLETE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString pmpApprovedPopUp; _jparser.validateByNameThrow("pmpApprovedPopUp", pmpApprovedPopUp);
		AtfValidator::validateInt(_descr, "pmpApprovedPopUp", pmpApprovedPopUp.length(), _checker, __FILE__, __LINE__);
		UINT32 transId; _jparser.validateByNameThrow("transId", transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_COMPLETE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "pmpApprovedPopUp"); size_t szPmpApprovedPopUp = strlen(_dummy);
		AtfValidator::validateInt(_descr, "pmpApprovedPopUp", szPmpApprovedPopUp, _checker, __FILE__, __LINE__);
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BUY_PM_CONFIRM
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::Protocol_MSG_CASHIER_BUY_PM_CONFIRM()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::clear()
{
	errCode = 0;
	errDescr.clear();
	transId = 0;
	message.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::equals(const Protocol_MSG_CASHIER_BUY_PM_CONFIRM& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		transId == _o.transId &&
		Atf::atfPStringEquals(message, _o.message);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_BUY_PM_CONFIRM != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_BUY_PM_CONFIRM*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BUY_PM_CONFIRM).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
		_buf.append(',');
		_buf.append("message=");
		_buf.append(message);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_BUY_PM_CONFIRM).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
		Atf::XmlElement::encodeAsXmlElement("message", message, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("transId"))
			{
				transId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("message"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, message)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(transId);
		_msg.composeString(message);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(transId);
		_parser.parseStringP(message);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("transId", transId);
		_jsonstr.compose("message", message);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("transId", transId);
		_jparser.parseByNameThrow("message", message);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_CONFIRM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _jparser.validateByNameThrow("transId", transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		PString message; _jparser.validateByNameThrow("message", message);
		AtfValidator::validateInt(_descr, "message", message.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_CONFIRM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "message"); size_t szMessage = strlen(_dummy);
		AtfValidator::validateInt(_descr, "message", szMessage, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::clear()
{
	transId = 0;
	status = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::equals(const Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED& _o) const
{
	return transId == _o.transId &&
		status == _o.status &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_MBOOKERS_REDIRECTED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_MBOOKERS_REDIRECTED).append(")");
	_buf.append(',');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_MBOOKERS_REDIRECTED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("transId"))
			{
				transId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("status"))
			{
				status = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(transId);
	_msg.composeUINT32(status);
	_msg.composeString(errDescr);
}

void CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(transId);
	_parser.parseUINT32(status);
	_parser.parseStringP(errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("transId", transId);
	_jsonstr.compose("status", status);
	_jsonstr.compose("errDescr", errDescr);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("transId", transId);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("errDescr", errDescr);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_MBOOKERS_REDIRECTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 transId; _jparser.validateByNameThrow("transId", transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
	AtfValidator::validateIntMax(_descr, "errDescr", errDescr.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_MBOOKERS_REDIRECTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 transId; _parser.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "errDescr", szErrDescr, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::clear()
{
	storeId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::equals(const Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL& _o) const
{
	return storeId == _o.storeId;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PM_PURCH_ITEMS_AVAIL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PM_PURCH_ITEMS_AVAIL).append(")");
	_buf.append(',');
	_buf.append("storeId=");
	_buf.appendUint(storeId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PM_PURCH_ITEMS_AVAIL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("storeId", storeId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("storeId"))
			{
				storeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(storeId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(storeId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("storeId", storeId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("storeId", storeId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_PURCH_ITEMS_AVAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 storeId; _jparser.validateByNameThrow("storeId", storeId);
	AtfValidator::validateIntRange(_descr, "storeId", storeId, ClientPlayChipsStore_web, ClientPlayChipsStore_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_PURCH_ITEMS_AVAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 storeId; _parser.parseUINT32(storeId);
	AtfValidator::validateIntRange(_descr, "storeId", storeId, ClientPlayChipsStore_web, ClientPlayChipsStore_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierPurchaseBody
//=================================================================

CashierServer::cli::CashierPurchaseBody::CashierPurchaseBody()
{
	clear();
}

void CashierServer::cli::CashierPurchaseBody::clear()
{
	cashPrice = 0;
	currency.clear();
	playMoneyAmt = 0;
	productId.clear();
	itemFlags = 0;
	savingRate_x1M = 0;
}

bool CashierServer::cli::CashierPurchaseBody::equals(const CashierPurchaseBody& _o) const
{
	return cashPrice == _o.cashPrice &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		playMoneyAmt == _o.playMoneyAmt &&
		Atf::atfPStringEquals(productId, _o.productId) &&
		itemFlags == _o.itemFlags &&
		savingRate_x1M == _o.savingRate_x1M;
}

const char *CashierServer::cli::CashierPurchaseBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cashPrice=");
	_buf.appendInt(cashPrice);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("playMoneyAmt=");
	_buf.appendInt64(playMoneyAmt);
	_buf.append(',');
	_buf.append("productId=");
	_buf.append(productId);
	_buf.append(',');
	_buf.append("itemFlags=");
	_buf.appendUint(itemFlags);
	_buf.append(',');
	_buf.append("savingRate_x1M=");
	_buf.appendInt(savingRate_x1M);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierPurchaseBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("cashPrice", cashPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("playMoneyAmt", playMoneyAmt, _buf);
	Atf::XmlElement::encodeAsXmlElement("productId", productId, _buf);
	Atf::XmlElement::encodeAsXmlElement("itemFlags", itemFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("savingRate_x1M", savingRate_x1M, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierPurchaseBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cashPrice"))
		{
			cashPrice = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("playMoneyAmt"))
		{
			playMoneyAmt = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("productId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, productId)) return false;
		}
		else if (_element.equals("itemFlags"))
		{
			itemFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("savingRate_x1M"))
		{
			savingRate_x1M = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierPurchaseBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierPurchaseBody())) // not empty
	{
		_body.composeINT32(cashPrice);
		_body.composeString(currency);
		_body.composeINT64(playMoneyAmt);
		_body.composeString(productId);
		_body.composeUINT32(itemFlags);
		_body.composeINT32(savingRate_x1M);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierPurchaseBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(cashPrice);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(playMoneyAmt);
	_parser0.parseStringP(productId);
	_parser0.parseUINT32(itemFlags);
	_parser0.parseINT32(savingRate_x1M);
}

const char *CashierServer::cli::CashierPurchaseBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cashPrice", cashPrice);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("playMoneyAmt", playMoneyAmt);
	_jsonstr.compose("productId", productId);
	_jsonstr.compose("itemFlags", itemFlags);
	_jsonstr.compose("savingRate_x1M", savingRate_x1M);
	return _buf.c_str();
}

void CashierServer::cli::CashierPurchaseBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cashPrice", cashPrice);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("playMoneyAmt", playMoneyAmt);
	_jparser.parseByNameThrow("productId", productId);
	_jparser.parseByNameThrow("itemFlags", itemFlags);
	_jparser.parseByNameThrow("savingRate_x1M", savingRate_x1M);
}

/* static */ void CashierServer::cli::CashierPurchaseBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 cashPrice; _jparser.validateByNameThrow("cashPrice", cashPrice);
	AtfValidator::validateInt(_descr, "cashPrice", cashPrice, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT64 playMoneyAmt; _jparser.validateByNameThrow("playMoneyAmt", playMoneyAmt);
	AtfValidator::validateInt(_descr, "playMoneyAmt", playMoneyAmt, _checker, __FILE__, __LINE__);
	PString productId; _jparser.validateByNameThrow("productId", productId);
	AtfValidator::validateInt(_descr, "productId", productId.length(), _checker, __FILE__, __LINE__);
	UINT32 itemFlags; _jparser.validateByNameThrow("itemFlags", itemFlags);
	AtfValidator::validateInt(_descr, "itemFlags", itemFlags, _checker, __FILE__, __LINE__);
	INT32 savingRate_x1M; _jparser.validateByNameThrow("savingRate_x1M", savingRate_x1M);
	AtfValidator::validateInt(_descr, "savingRate_x1M", savingRate_x1M, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierPurchaseBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 cashPrice; _parser0.parseINT32(cashPrice);
	AtfValidator::validateInt(_descr, "cashPrice", cashPrice, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 playMoneyAmt; _parser0.parseINT64(playMoneyAmt);
	AtfValidator::validateInt(_descr, "playMoneyAmt", playMoneyAmt, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "productId"); size_t szProductId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "productId", szProductId, _checker, __FILE__, __LINE__);
	UINT32 itemFlags; _parser0.parseUINT32(itemFlags);
	AtfValidator::validateInt(_descr, "itemFlags", itemFlags, _checker, __FILE__, __LINE__);
	INT32 savingRate_x1M; _parser0.parseINT32(savingRate_x1M);
	AtfValidator::validateInt(_descr, "savingRate_x1M", savingRate_x1M, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	purchases.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::equals(const Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		purchases.equals(_o.purchases);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("purchases=");
		purchases.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		purchases.toXmlString("purchases", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("purchases"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierPurchaseBody, 4 > >::FromXmlString(_value, purchases)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		purchases.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		purchases.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("purchases", purchases);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("purchases", purchases);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CashierPurchaseBody > purchases; _jparser.validateByNameThrow("purchases", purchases);
		AtfValidator::validateInt(_descr, "purchases", purchases.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szPurchases = Atf::LAtfVector< CashierPurchaseBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("purchases"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "purchases", szPurchases, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BUY_PM_GOOGLE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::Protocol_MSG_CASHIER_BUY_PM_GOOGLE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::clear()
{
	order.clear();
	signature.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::equals(const Protocol_MSG_CASHIER_BUY_PM_GOOGLE& _o) const
{
	return Atf::atfPStringEquals(order, _o.order) &&
		Atf::atfPStringEquals(signature, _o.signature);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_BUY_PM_GOOGLE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_BUY_PM_GOOGLE*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BUY_PM_GOOGLE).append(")");
	_buf.append(',');
	_buf.append("order=");
	_buf.append(order);
	_buf.append(',');
	_buf.append("signature=");
	_buf.append(signature);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_BUY_PM_GOOGLE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("order", order, _buf);
	Atf::XmlElement::encodeAsXmlElement("signature", signature, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("order"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, order)) return false;
			}
			else if (_element.equals("signature"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, signature)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(order);
	_msg.composeString(signature);
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(order);
	_parser.parseStringP(signature);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("order", order);
	_jsonstr.compose("signature", signature);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("order", order);
	_jparser.parseByNameThrow("signature", signature);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_GOOGLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString order; _jparser.validateByNameThrow("order", order);
	AtfValidator::validateIntMax(_descr, "order", order.length(), 1000, _checker, __FILE__, __LINE__);
	PString signature; _jparser.validateByNameThrow("signature", signature);
	AtfValidator::validateIntMax(_descr, "signature", signature.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_GOOGLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "order"); size_t szOrder = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "order", szOrder, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "signature"); size_t szSignature = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "signature", szSignature, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierCommmonBuyPmReply
//=================================================================

CashierServer::cli::CashierCommmonBuyPmReply::CashierCommmonBuyPmReply()
{
	clear();
}

void CashierServer::cli::CashierCommmonBuyPmReply::clear()
{
	errCode = 0;
	errDescr.clear();
	pmpApprovedPopUp.clear();
	transId = 0;
}

bool CashierServer::cli::CashierCommmonBuyPmReply::equals(const CashierCommmonBuyPmReply& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(pmpApprovedPopUp, _o.pmpApprovedPopUp) &&
		transId == _o.transId;
}

const char *CashierServer::cli::CashierCommmonBuyPmReply::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("pmpApprovedPopUp=");
		_buf.append(pmpApprovedPopUp);
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierCommmonBuyPmReply::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("pmpApprovedPopUp", pmpApprovedPopUp, _buf);
		Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierCommmonBuyPmReply::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("errCode"))
		{
			errCode = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errDescr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
		}
		else if (_element.equals("pmpApprovedPopUp"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, pmpApprovedPopUp)) return false;
		}
		else if (_element.equals("transId"))
		{
			transId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierCommmonBuyPmReply::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(pmpApprovedPopUp);
		_msg.composeUINT32(transId);
	}
}

void CashierServer::cli::CashierCommmonBuyPmReply::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(pmpApprovedPopUp);
		_parser.parseUINT32(transId);
	}
}

const char *CashierServer::cli::CashierCommmonBuyPmReply::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("pmpApprovedPopUp", pmpApprovedPopUp);
		_jsonstr.compose("transId", transId);
	}
	return _buf.c_str();
}

void CashierServer::cli::CashierCommmonBuyPmReply::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("pmpApprovedPopUp", pmpApprovedPopUp);
		_jparser.parseByNameThrow("transId", transId);
	}
}

/* static */ void CashierServer::cli::CashierCommmonBuyPmReply::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString pmpApprovedPopUp; _jparser.validateByNameThrow("pmpApprovedPopUp", pmpApprovedPopUp);
		AtfValidator::validateInt(_descr, "pmpApprovedPopUp", pmpApprovedPopUp.length(), _checker, __FILE__, __LINE__);
		UINT32 transId; _jparser.validateByNameThrow("transId", transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::CashierCommmonBuyPmReply::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "pmpApprovedPopUp"); size_t szPmpApprovedPopUp = strlen(_dummy);
		AtfValidator::validateInt(_descr, "pmpApprovedPopUp", szPmpApprovedPopUp, _checker, __FILE__, __LINE__);
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::clear()
{
	reply.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::equals(const Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY& _o) const
{
	return reply.equals(_o.reply);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_BUY_PM_GOOGLE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BUY_PM_GOOGLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("reply=");
	reply.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_BUY_PM_GOOGLE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	reply.toXmlString("reply", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reply"))
			{
				if(!Atf::AtfTempl< CashierCommmonBuyPmReply >::FromXmlString(_value, reply)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	reply.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	reply.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reply", reply);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reply", reply);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_GOOGLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	CashierCommmonBuyPmReply reply; _jparser.validateByNameThrow("reply", reply);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_GOOGLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	CashierCommmonBuyPmReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BUY_PM_APPLE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::Protocol_MSG_CASHIER_BUY_PM_APPLE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::clear()
{
	order.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::equals(const Protocol_MSG_CASHIER_BUY_PM_APPLE& _o) const
{
	return Atf::atfPStringEquals(order, _o.order);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_BUY_PM_APPLE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_BUY_PM_APPLE*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BUY_PM_APPLE).append(")");
	_buf.append(',');
	_buf.append("order=");
	_buf.append(order);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_BUY_PM_APPLE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("order", order, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("order"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, order)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(order);
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(order);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("order", order);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("order", order);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_APPLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString order; _jparser.validateByNameThrow("order", order);
	AtfValidator::validateIntMax(_descr, "order", order.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_APPLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "order"); size_t szOrder = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "order", szOrder, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::clear()
{
	reply.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::equals(const Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY& _o) const
{
	return reply.equals(_o.reply);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_BUY_PM_APPLE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BUY_PM_APPLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("reply=");
	reply.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_BUY_PM_APPLE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	reply.toXmlString("reply", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reply"))
			{
				if(!Atf::AtfTempl< CashierCommmonBuyPmReply >::FromXmlString(_value, reply)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	reply.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	reply.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reply", reply);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reply", reply);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_APPLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	CashierCommmonBuyPmReply reply; _jparser.validateByNameThrow("reply", reply);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_APPLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	CashierCommmonBuyPmReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::clear()
{
	isForCashout = false;
	cardTypeByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::equals(const Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO& _o) const
{
	return isForCashout == _o.isForCashout &&
		cardTypeByte == _o.cardTypeByte;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_ASTROPAY_BANKINFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_ASTROPAY_BANKINFO).append(")");
	_buf.append(',');
	_buf.append("isForCashout=");
	_buf.appendUint(isForCashout);
	_buf.append(',');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_ASTROPAY_BANKINFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("isForCashout", isForCashout, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardTypeByte", cardTypeByte, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("isForCashout"))
			{
				isForCashout = (*_value.ptr() == '1');
			}
			else if (_element.equals("cardTypeByte"))
			{
				cardTypeByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(isForCashout);
	_msg.composeBYTE(cardTypeByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(isForCashout);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(cardTypeByte);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("isForCashout", isForCashout);
	_jsonstr.compose("cardTypeByte", cardTypeByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("isForCashout", isForCashout);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("cardTypeByte", cardTypeByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_ASTROPAY_BANKINFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool isForCashout; _jparser.validateByNameThrow("isForCashout", isForCashout);
	AtfValidator::validateInt(_descr, "isForCashout", isForCashout, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE cardTypeByte; _jparser.validateByNameThrow("cardTypeByte", cardTypeByte);
	AtfValidator::validateIntRange(_descr, "cardTypeByte", cardTypeByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_ASTROPAY_BANKINFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool isForCashout; _parser.parseBOOL(isForCashout);
	AtfValidator::validateInt(_descr, "isForCashout", isForCashout, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
	AtfValidator::validateIntRange(_descr, "cardTypeByte", cardTypeByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    AstropayDirectUserBankRef
//=================================================================

CashierServer::cli::AstropayDirectUserBankRef::AstropayDirectUserBankRef()
{
	clear();
}

void CashierServer::cli::AstropayDirectUserBankRef::clear()
{
	bankId = 0;
	bankCode.clear();
	bankName.clear();
	bankCurrency.clear();
	branchName.clear();
	nicAlias.clear();
	country.clear();
	nicValue.clear();
	bankAccount.clear();
	accountType.clear();
}

bool CashierServer::cli::AstropayDirectUserBankRef::equals(const AstropayDirectUserBankRef& _o) const
{
	return bankId == _o.bankId &&
		Atf::atfPStringEquals(bankCode, _o.bankCode) &&
		Atf::atfPStringEquals(bankName, _o.bankName) &&
		Atf::atfPStringEquals(bankCurrency, _o.bankCurrency) &&
		Atf::atfPStringEquals(branchName, _o.branchName) &&
		Atf::atfPStringEquals(nicAlias, _o.nicAlias) &&
		Atf::atfPStringEquals(country, _o.country) &&
		Atf::atfPStringEquals(nicValue, _o.nicValue) &&
		Atf::atfPStringEquals(bankAccount, _o.bankAccount) &&
		Atf::atfPStringEquals(accountType, _o.accountType);
}

const char *CashierServer::cli::AstropayDirectUserBankRef::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("bankId=");
	_buf.appendUint(bankId);
	_buf.append(',');
	_buf.append("bankCode=");
	_buf.append(bankCode);
	_buf.append(',');
	_buf.append("bankName=");
	_buf.append(bankName);
	_buf.append(',');
	_buf.append("bankCurrency=");
	_buf.append(bankCurrency);
	_buf.append(',');
	_buf.append("branchName=");
	_buf.append(branchName);
	_buf.append(',');
	_buf.append("nicAlias=");
	_buf.append(nicAlias);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("nicValue=");
	_buf.append(nicValue);
	_buf.append(',');
	_buf.append("bankAccount=");
	_buf.append(bankAccount);
	_buf.append(',');
	_buf.append("accountType=");
	_buf.append(accountType);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::AstropayDirectUserBankRef::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("bankId", bankId, _buf);
	Atf::XmlElement::encodeAsXmlElement("bankCode", bankCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("bankName", bankName, _buf);
	Atf::XmlElement::encodeAsXmlElement("bankCurrency", bankCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("branchName", branchName, _buf);
	Atf::XmlElement::encodeAsXmlElement("nicAlias", nicAlias, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("nicValue", nicValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("bankAccount", bankAccount, _buf);
	Atf::XmlElement::encodeAsXmlElement("accountType", accountType, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::AstropayDirectUserBankRef::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("bankId"))
		{
			bankId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bankCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, bankCode)) return false;
		}
		else if (_element.equals("bankName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, bankName)) return false;
		}
		else if (_element.equals("bankCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, bankCurrency)) return false;
		}
		else if (_element.equals("branchName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, branchName)) return false;
		}
		else if (_element.equals("nicAlias"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, nicAlias)) return false;
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("nicValue"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, nicValue)) return false;
		}
		else if (_element.equals("bankAccount"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, bankAccount)) return false;
		}
		else if (_element.equals("accountType"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, accountType)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::AstropayDirectUserBankRef::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(bankId);
	_msg.composeString(bankCode);
	_msg.composeString(bankName);
	_msg.composeString(bankCurrency);
	_msg.composeString(branchName);
	_msg.composeString(nicAlias);
	_msg.composeString(country);
	_msg.composeString(nicValue);
	_msg.composeString(bankAccount);
	_msg.composeString(accountType);
}

void CashierServer::cli::AstropayDirectUserBankRef::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(bankId);
	_parser.parseStringP(bankCode);
	_parser.parseStringP(bankName);
	_parser.parseStringP(bankCurrency);
	_parser.parseStringP(branchName);
	_parser.parseStringP(nicAlias);
	_parser.parseStringP(country);
	_parser.parseStringP(nicValue);
	_parser.parseStringP(bankAccount);
	_parser.parseStringP(accountType);
}

const char *CashierServer::cli::AstropayDirectUserBankRef::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("bankId", bankId);
	_jsonstr.compose("bankCode", bankCode);
	_jsonstr.compose("bankName", bankName);
	_jsonstr.compose("bankCurrency", bankCurrency);
	_jsonstr.compose("branchName", branchName);
	_jsonstr.compose("nicAlias", nicAlias);
	_jsonstr.compose("country", country);
	_jsonstr.compose("nicValue", nicValue);
	_jsonstr.compose("bankAccount", bankAccount);
	_jsonstr.compose("accountType", accountType);
	return _buf.c_str();
}

void CashierServer::cli::AstropayDirectUserBankRef::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("bankId", bankId);
	_jparser.parseByNameThrow("bankCode", bankCode);
	_jparser.parseByNameThrow("bankName", bankName);
	_jparser.parseByNameThrow("bankCurrency", bankCurrency);
	_jparser.parseByNameThrow("branchName", branchName);
	_jparser.parseByNameThrow("nicAlias", nicAlias);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("nicValue", nicValue);
	_jparser.parseByNameThrow("bankAccount", bankAccount);
	_jparser.parseByNameThrow("accountType", accountType);
}

/* static */ void CashierServer::cli::AstropayDirectUserBankRef::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 bankId; _jparser.validateByNameThrow("bankId", bankId);
	AtfValidator::validateInt(_descr, "bankId", bankId, _checker, __FILE__, __LINE__);
	PString bankCode; _jparser.validateByNameThrow("bankCode", bankCode);
	AtfValidator::validateIntMax(_descr, "bankCode", bankCode.length(), ASTROPAYDIRECT_BANKCODE_LEN, _checker, __FILE__, __LINE__);
	PString bankName; _jparser.validateByNameThrow("bankName", bankName);
	AtfValidator::validateIntMax(_descr, "bankName", bankName.length(), ASTROPAYDIRECT_BANKNAME_LEN, _checker, __FILE__, __LINE__);
	PString bankCurrency; _jparser.validateByNameThrow("bankCurrency", bankCurrency);
	AtfValidator::validateIntMax(_descr, "bankCurrency", bankCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	PString branchName; _jparser.validateByNameThrow("branchName", branchName);
	AtfValidator::validateIntMax(_descr, "branchName", branchName.length(), ASTROPAYDIRECT_BRANCHNAME_LEN, _checker, __FILE__, __LINE__);
	PString nicAlias; _jparser.validateByNameThrow("nicAlias", nicAlias);
	AtfValidator::validateIntMax(_descr, "nicAlias", nicAlias.length(), ASTROPAYDIRECT_NICALIAS_LEN, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	PString nicValue; _jparser.validateByNameThrow("nicValue", nicValue);
	AtfValidator::validateIntMax(_descr, "nicValue", nicValue.length(), ASTROPAYDIRECT_NICVALUE_LEN, _checker, __FILE__, __LINE__);
	PString bankAccount; _jparser.validateByNameThrow("bankAccount", bankAccount);
	AtfValidator::validateIntMax(_descr, "bankAccount", bankAccount.length(), ASTROPAYDIRECT_ACCTNUM_LEN, _checker, __FILE__, __LINE__);
	PString accountType; _jparser.validateByNameThrow("accountType", accountType);
	AtfValidator::validateIntMax(_descr, "accountType", accountType.length(), ASTROPAYDIRECT_ACCTTYPE_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::AstropayDirectUserBankRef::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 bankId; _parser.parseUINT32(bankId);
	AtfValidator::validateInt(_descr, "bankId", bankId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bankCode"); size_t szBankCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankCode", szBankCode, ASTROPAYDIRECT_BANKCODE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bankName"); size_t szBankName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankName", szBankName, ASTROPAYDIRECT_BANKNAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bankCurrency"); size_t szBankCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankCurrency", szBankCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "branchName"); size_t szBranchName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "branchName", szBranchName, ASTROPAYDIRECT_BRANCHNAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "nicAlias"); size_t szNicAlias = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "nicAlias", szNicAlias, ASTROPAYDIRECT_NICALIAS_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "nicValue"); size_t szNicValue = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "nicValue", szNicValue, ASTROPAYDIRECT_NICVALUE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bankAccount"); size_t szBankAccount = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankAccount", szBankAccount, ASTROPAYDIRECT_ACCTNUM_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "accountType"); size_t szAccountType = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "accountType", szAccountType, ASTROPAYDIRECT_ACCTTYPE_LEN, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	index = 0;
	bankInfos.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::equals(const Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		index == _o.index &&
		bankInfos.equals(_o.bankInfos);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("index=");
		_buf.appendInt(index);
		_buf.append(',');
		_buf.append("bankInfos=");
		bankInfos.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("index", index, _buf);
		bankInfos.toXmlString("bankInfos", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("index"))
			{
				index = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bankInfos"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< AstropayDirectUserBankRef, 4 > >::FromXmlString(_value, bankInfos)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT16(index);
		bankInfos.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT16(index);
		bankInfos.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("index", index);
		_jsonstr.compose("bankInfos", bankInfos);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("index", index);
		_jparser.parseByNameThrow("bankInfos", bankInfos);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT16 index; _jparser.validateByNameThrow("index", index);
		AtfValidator::validateInt(_descr, "index", index, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< AstropayDirectUserBankRef > bankInfos; _jparser.validateByNameThrow("bankInfos", bankInfos);
		AtfValidator::validateInt(_descr, "bankInfos", bankInfos.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT16 index; _parser.parseINT16(index);
		AtfValidator::validateInt(_descr, "index", index, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szBankInfos = Atf::LAtfVector< AstropayDirectUserBankRef, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("bankInfos"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "bankInfos", szBankInfos, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ASTROPAY_CASHIN
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::Protocol_MSG_CASHIER_ASTROPAY_CASHIN()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::clear()
{
	bankId = 0;
	cpf.clear();
	amount64 = 0;
	bonusCode.clear();
	cardTypeByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::equals(const Protocol_MSG_CASHIER_ASTROPAY_CASHIN& _o) const
{
	return bankId == _o.bankId &&
		Atf::atfPStringEquals(cpf, _o.cpf) &&
		amount64 == _o.amount64 &&
		Atf::atfPStringEquals(bonusCode, _o.bonusCode) &&
		cardTypeByte == _o.cardTypeByte;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_ASTROPAY_CASHIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_ASTROPAY_CASHIN*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ASTROPAY_CASHIN).append(")");
	_buf.append(',');
	_buf.append("bankId=");
	_buf.appendUint(bankId);
	_buf.append(',');
	_buf.append("cpf=");
	_buf.append(cpf);
	_buf.append(',');
	_buf.append("amount64=");
	_buf.appendInt64(amount64);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_ASTROPAY_CASHIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("bankId", bankId, _buf);
	Atf::XmlElement::encodeAsXmlElement("cpf", cpf, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount64", amount64, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusCode", bonusCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardTypeByte", cardTypeByte, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("bankId"))
			{
				bankId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cpf"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, cpf)) return false;
			}
			else if (_element.equals("amount64"))
			{
				amount64 = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bonusCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bonusCode)) return false;
			}
			else if (_element.equals("cardTypeByte"))
			{
				cardTypeByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(bankId);
	_msg.composeString(cpf);
	_msg.composeINT64(amount64);
	_msg.composeString(bonusCode);
	_msg.composeBYTE(cardTypeByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(bankId);
	_parser.parseStringP(cpf);
	_parser.parseINT64(amount64);
	_parser.parseStringP(bonusCode);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(cardTypeByte);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("bankId", bankId);
	_jsonstr.compose("cpf", cpf);
	_jsonstr.compose("amount64", amount64);
	_jsonstr.compose("bonusCode", bonusCode);
	_jsonstr.compose("cardTypeByte", cardTypeByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("bankId", bankId);
	_jparser.parseByNameThrow("cpf", cpf);
	_jparser.parseByNameThrow("amount64", amount64);
	_jparser.parseByNameThrow("bonusCode", bonusCode);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("cardTypeByte", cardTypeByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ASTROPAY_CASHIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 bankId; _jparser.validateByNameThrow("bankId", bankId);
	AtfValidator::validateInt(_descr, "bankId", bankId, _checker, __FILE__, __LINE__);
	PString cpf; _jparser.validateByNameThrow("cpf", cpf);
	AtfValidator::validateIntMax(_descr, "cpf", cpf.length(), 100, _checker, __FILE__, __LINE__);
	INT64 amount64; _jparser.validateByNameThrow("amount64", amount64);
	AtfValidator::validateIntRange(_descr, "amount64", amount64, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString bonusCode; _jparser.validateByNameThrow("bonusCode", bonusCode);
	AtfValidator::validateIntMax(_descr, "bonusCode", bonusCode.length(), BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE cardTypeByte; _jparser.validateByNameThrow("cardTypeByte", cardTypeByte);
	AtfValidator::validateIntRange(_descr, "cardTypeByte", cardTypeByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ASTROPAY_CASHIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 bankId; _parser.parseUINT32(bankId);
	AtfValidator::validateInt(_descr, "bankId", bankId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cpf"); size_t szCpf = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cpf", szCpf, 100, _checker, __FILE__, __LINE__);
	INT64 amount64; _parser.parseINT64(amount64);
	AtfValidator::validateIntRange(_descr, "amount64", amount64, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
	AtfValidator::validateIntRange(_descr, "cardTypeByte", cardTypeByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::clear()
{
	errCode = 0;
	errDescr.clear();
	redirectUrl.clear();
	amount64 = 0;
	bankInfo.clear();
	cardTypeByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::equals(const Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(redirectUrl, _o.redirectUrl) &&
		amount64 == _o.amount64 &&
		bankInfo.equals(_o.bankInfo) &&
		cardTypeByte == _o.cardTypeByte;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("redirectUrl=");
		_buf.append(redirectUrl);
		_buf.append(',');
		_buf.append("amount64=");
		_buf.appendInt64(amount64);
		_buf.append(',');
		_buf.append("bankInfo=");
		bankInfo.toTraceString(_buf);
		_buf.append(',');
		_buf.append("cardTypeByte=");
		_buf.appendUint(cardTypeByte);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("redirectUrl", redirectUrl, _buf);
		Atf::XmlElement::encodeAsXmlElement("amount64", amount64, _buf);
		bankInfo.toXmlString("bankInfo", _buf);
		Atf::XmlElement::encodeAsXmlElement("cardTypeByte", cardTypeByte, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("redirectUrl"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, redirectUrl)) return false;
			}
			else if (_element.equals("amount64"))
			{
				amount64 = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bankInfo"))
			{
				if(!Atf::AtfTempl< AstropayDirectUserBankRef >::FromXmlString(_value, bankInfo)) return false;
			}
			else if (_element.equals("cardTypeByte"))
			{
				cardTypeByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(redirectUrl);
		_msg.composeINT64(amount64);
		bankInfo.composeMsg(_msg, _ignoreJSON);
		_msg.composeBYTE(cardTypeByte);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(redirectUrl);
		_parser.parseINT64(amount64);
		bankInfo.parseMsg(_parser);
		_parser.parseBYTE(cardTypeByte);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("redirectUrl", redirectUrl);
		_jsonstr.compose("amount64", amount64);
		_jsonstr.compose("bankInfo", bankInfo);
		_jsonstr.compose("cardTypeByte", cardTypeByte);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("redirectUrl", redirectUrl);
		_jparser.parseByNameThrow("amount64", amount64);
		_jparser.parseByNameThrow("bankInfo", bankInfo);
		_jparser.parseByNameThrow("cardTypeByte", cardTypeByte);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString redirectUrl; _jparser.validateByNameThrow("redirectUrl", redirectUrl);
		AtfValidator::validateInt(_descr, "redirectUrl", redirectUrl.length(), _checker, __FILE__, __LINE__);
		INT64 amount64; _jparser.validateByNameThrow("amount64", amount64);
		AtfValidator::validateInt(_descr, "amount64", amount64, _checker, __FILE__, __LINE__);
		AstropayDirectUserBankRef bankInfo; _jparser.validateByNameThrow("bankInfo", bankInfo);
		BYTE cardTypeByte; _jparser.validateByNameThrow("cardTypeByte", cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "redirectUrl"); size_t szRedirectUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "redirectUrl", szRedirectUrl, _checker, __FILE__, __LINE__);
		INT64 amount64; _parser.parseINT64(amount64);
		AtfValidator::validateInt(_descr, "amount64", amount64, _checker, __FILE__, __LINE__);
		PString _descbuf;
		AstropayDirectUserBankRef::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("bankInfo"), _fieldsWithUnparsedContent);
		BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::clear()
{
	bankInfo.clear();
	cardTypeByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::equals(const Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO& _o) const
{
	return bankInfo.equals(_o.bankInfo) &&
		cardTypeByte == _o.cardTypeByte;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SAVE_ASTROPAY_BANKINFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SAVE_ASTROPAY_BANKINFO).append(")");
	_buf.append(',');
	_buf.append("bankInfo=");
	bankInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SAVE_ASTROPAY_BANKINFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	bankInfo.toXmlString("bankInfo", _buf);
	Atf::XmlElement::encodeAsXmlElement("cardTypeByte", cardTypeByte, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("bankInfo"))
			{
				if(!Atf::AtfTempl< AstropayDirectUserBankRef >::FromXmlString(_value, bankInfo)) return false;
			}
			else if (_element.equals("cardTypeByte"))
			{
				cardTypeByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	bankInfo.composeMsg(_msg, _ignoreJSON);
	_msg.composeBYTE(cardTypeByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::parseMsg(CommMsgParser& _parser)
{
	bankInfo.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(cardTypeByte);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("bankInfo", bankInfo);
	_jsonstr.compose("cardTypeByte", cardTypeByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("bankInfo", bankInfo);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("cardTypeByte", cardTypeByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_ASTROPAY_BANKINFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	AstropayDirectUserBankRef bankInfo; _jparser.validateByNameThrow("bankInfo", bankInfo);
	if(_jparser.parseEnded()) return;
	BYTE cardTypeByte; _jparser.validateByNameThrow("cardTypeByte", cardTypeByte);
	AtfValidator::validateIntRange(_descr, "cardTypeByte", cardTypeByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_ASTROPAY_BANKINFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	AstropayDirectUserBankRef::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("bankInfo"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
	AtfValidator::validateIntRange(_descr, "cardTypeByte", cardTypeByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::equals(const Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::clear()
{
	currencyDst.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::equals(const Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT& _o) const
{
	return Atf::atfPStringEquals(currencyDst, _o.currencyDst);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT).append(")");
	_buf.append(',');
	_buf.append("currencyDst=");
	_buf.append(currencyDst);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("currencyDst", currencyDst, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("currencyDst"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currencyDst)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(currencyDst);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(currencyDst);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currencyDst", currencyDst);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currencyDst", currencyDst);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currencyDst; _jparser.validateByNameThrow("currencyDst", currencyDst);
	AtfValidator::validateIntMax(_descr, "currencyDst", currencyDst.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "currencyDst"); size_t szCurrencyDst = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currencyDst", szCurrencyDst, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::equals(const Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::equals(const Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::equals(const Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::clear()
{
	paySystemByte = cardTypePayLucky;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::equals(const Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO& _o) const
{
	return paySystemByte == _o.paySystemByte;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_PAYLUCKY_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_PAYLUCKY_INFO).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_PAYLUCKY_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paySystemByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemByte", paySystemByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PAYLUCKY_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	{ const BYTE paySystemByte_enum[] = { cardTypePayLucky, cardTypeSightline, cardTypeSightlineNR }; AtfValidator::validateEnum(_descr, "paySystemByte", paySystemByte, paySystemByte_enum, _checker, __FILE__, __LINE__); }
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PAYLUCKY_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	{ const BYTE paySystemByte_enum[] = { cardTypePayLucky, cardTypeSightline, cardTypeSightlineNR }; AtfValidator::validateEnum(_descr, "paySystemByte", paySystemByte, paySystemByte_enum, _checker, __FILE__, __LINE__); }
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	payLuckyBalance = 0;
	sightLineMaxBalance = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::equals(const Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		payLuckyBalance == _o.payLuckyBalance &&
		sightLineMaxBalance == _o.sightLineMaxBalance;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("payLuckyBalance=");
		_buf.appendInt(payLuckyBalance);
		_buf.append(',');
		_buf.append("sightLineMaxBalance=");
		_buf.appendInt(sightLineMaxBalance);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("payLuckyBalance", payLuckyBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("sightLineMaxBalance", sightLineMaxBalance, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("payLuckyBalance"))
			{
				payLuckyBalance = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sightLineMaxBalance"))
			{
				sightLineMaxBalance = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(payLuckyBalance);
		_msg.composeINT32(sightLineMaxBalance);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(payLuckyBalance);
		_parser.parseINT32(sightLineMaxBalance);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("payLuckyBalance", payLuckyBalance);
		_jsonstr.compose("sightLineMaxBalance", sightLineMaxBalance);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("payLuckyBalance", payLuckyBalance);
		_jparser.parseByNameThrow("sightLineMaxBalance", sightLineMaxBalance);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 payLuckyBalance; _jparser.validateByNameThrow("payLuckyBalance", payLuckyBalance);
		AtfValidator::validateInt(_descr, "payLuckyBalance", payLuckyBalance, _checker, __FILE__, __LINE__);
		INT32 sightLineMaxBalance; _jparser.validateByNameThrow("sightLineMaxBalance", sightLineMaxBalance);
		AtfValidator::validateInt(_descr, "sightLineMaxBalance", sightLineMaxBalance, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 payLuckyBalance; _parser.parseINT32(payLuckyBalance);
		AtfValidator::validateInt(_descr, "payLuckyBalance", payLuckyBalance, _checker, __FILE__, __LINE__);
		INT32 sightLineMaxBalance; _parser.parseINT32(sightLineMaxBalance);
		AtfValidator::validateInt(_descr, "sightLineMaxBalance", sightLineMaxBalance, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::clear()
{
	pin.clear();
	balanceCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::equals(const Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY& _o) const
{
	return Atf::atfPStringEquals(pin, _o.pin) &&
		Atf::atfPStringEquals(balanceCurrency, _o.balanceCurrency);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_VANILLA_AMTCURRENCY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_VANILLA_AMTCURRENCY).append(")");
	_buf.append(',');
	_buf.append("pin=");
	_buf.append(pin);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_VANILLA_AMTCURRENCY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pin", pin, _buf);
	Atf::XmlElement::encodeAsXmlElement("balanceCurrency", balanceCurrency, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pin"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, pin)) return false;
			}
			else if (_element.equals("balanceCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, balanceCurrency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(pin);
	_msg.composeString(balanceCurrency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(pin);
	_parser.parseStringP(balanceCurrency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pin", pin);
	_jsonstr.compose("balanceCurrency", balanceCurrency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("pin", pin);
	_jparser.parseByNameThrow("balanceCurrency", balanceCurrency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_VANILLA_AMTCURRENCY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString pin; _jparser.validateByNameThrow("pin", pin);
	AtfValidator::validateIntMax(_descr, "pin", pin.length(), 100, _checker, __FILE__, __LINE__);
	PString balanceCurrency; _jparser.validateByNameThrow("balanceCurrency", balanceCurrency);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", balanceCurrency.length(), 100, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_VANILLA_AMTCURRENCY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "pin"); size_t szPin = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "pin", szPin, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", szBalanceCurrency, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	procAmount = 0;
	procCurrency.clear();
	balanceAmount = 0;
	balanceCurrency.clear();
	pin.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::equals(const Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		procAmount == _o.procAmount &&
		Atf::atfPStringEquals(procCurrency, _o.procCurrency) &&
		balanceAmount == _o.balanceAmount &&
		Atf::atfPStringEquals(balanceCurrency, _o.balanceCurrency) &&
		Atf::atfPStringEquals(pin, _o.pin);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("procAmount=");
		_buf.appendUint(procAmount);
		_buf.append(',');
		_buf.append("procCurrency=");
		_buf.append(procCurrency);
		_buf.append(',');
		_buf.append("balanceAmount=");
		_buf.appendUint(balanceAmount);
		_buf.append(',');
		_buf.append("balanceCurrency=");
		_buf.append(balanceCurrency);
		_buf.append(',');
		_buf.append("pin=");
		_buf.append(pin);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("procAmount", procAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("procCurrency", procCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("balanceAmount", balanceAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("balanceCurrency", balanceCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("pin", pin, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("procAmount"))
			{
				procAmount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("procCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, procCurrency)) return false;
			}
			else if (_element.equals("balanceAmount"))
			{
				balanceAmount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("balanceCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, balanceCurrency)) return false;
			}
			else if (_element.equals("pin"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, pin)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(procAmount);
		_msg.composeString(procCurrency);
		_msg.composeUINT32(balanceAmount);
		_msg.composeString(balanceCurrency);
		_msg.composeString(pin);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(procAmount);
		_parser.parseStringP(procCurrency);
		_parser.parseUINT32(balanceAmount);
		_parser.parseStringP(balanceCurrency);
		_parser.parseStringP(pin);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("procAmount", procAmount);
		_jsonstr.compose("procCurrency", procCurrency);
		_jsonstr.compose("balanceAmount", balanceAmount);
		_jsonstr.compose("balanceCurrency", balanceCurrency);
		_jsonstr.compose("pin", pin);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("procAmount", procAmount);
		_jparser.parseByNameThrow("procCurrency", procCurrency);
		_jparser.parseByNameThrow("balanceAmount", balanceAmount);
		_jparser.parseByNameThrow("balanceCurrency", balanceCurrency);
		_jparser.parseByNameThrow("pin", pin);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 procAmount; _jparser.validateByNameThrow("procAmount", procAmount);
		AtfValidator::validateInt(_descr, "procAmount", procAmount, _checker, __FILE__, __LINE__);
		PString procCurrency; _jparser.validateByNameThrow("procCurrency", procCurrency);
		AtfValidator::validateInt(_descr, "procCurrency", procCurrency.length(), _checker, __FILE__, __LINE__);
		UINT32 balanceAmount; _jparser.validateByNameThrow("balanceAmount", balanceAmount);
		AtfValidator::validateInt(_descr, "balanceAmount", balanceAmount, _checker, __FILE__, __LINE__);
		PString balanceCurrency; _jparser.validateByNameThrow("balanceCurrency", balanceCurrency);
		AtfValidator::validateInt(_descr, "balanceCurrency", balanceCurrency.length(), _checker, __FILE__, __LINE__);
		PString pin; _jparser.validateByNameThrow("pin", pin);
		AtfValidator::validateInt(_descr, "pin", pin.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 procAmount; _parser.parseUINT32(procAmount);
		AtfValidator::validateInt(_descr, "procAmount", procAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "procCurrency"); size_t szProcCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "procCurrency", szProcCurrency, _checker, __FILE__, __LINE__);
		UINT32 balanceAmount; _parser.parseUINT32(balanceAmount);
		AtfValidator::validateInt(_descr, "balanceAmount", balanceAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "balanceCurrency", szBalanceCurrency, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "pin"); size_t szPin = strlen(_dummy);
		AtfValidator::validateInt(_descr, "pin", szPin, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PLAY_MONEY_REFILL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::equals(const Protocol_MSG_CASHIER_PLAY_MONEY_REFILL& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PLAY_MONEY_REFILL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PLAY_MONEY_REFILL*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PLAY_MONEY_REFILL).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PLAY_MONEY_REFILL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_MONEY_REFILL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_MONEY_REFILL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierPlayMoneyCommonBody
//=================================================================

CashierServer::cli::CashierPlayMoneyCommonBody::CashierPlayMoneyCommonBody()
{
	clear();
}

void CashierServer::cli::CashierPlayMoneyCommonBody::clear()
{
	playChipsRefillPeriodSec = 0;
	playChipsAllowedForPeriodCents = 0;
	targetRefillAmountCents = 0;
	playChipsBalance = 0;
	availableForRefill = 0;
}

bool CashierServer::cli::CashierPlayMoneyCommonBody::equals(const CashierPlayMoneyCommonBody& _o) const
{
	return playChipsRefillPeriodSec == _o.playChipsRefillPeriodSec &&
		playChipsAllowedForPeriodCents == _o.playChipsAllowedForPeriodCents &&
		targetRefillAmountCents == _o.targetRefillAmountCents &&
		playChipsBalance == _o.playChipsBalance &&
		availableForRefill == _o.availableForRefill;
}

const char *CashierServer::cli::CashierPlayMoneyCommonBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("playChipsRefillPeriodSec=");
	_buf.appendInt(playChipsRefillPeriodSec);
	_buf.append(',');
	_buf.append("playChipsAllowedForPeriodCents=");
	_buf.appendInt64(playChipsAllowedForPeriodCents);
	_buf.append(',');
	_buf.append("targetRefillAmountCents=");
	_buf.appendInt64(targetRefillAmountCents);
	_buf.append(',');
	_buf.append("playChipsBalance=");
	_buf.appendInt64(playChipsBalance);
	_buf.append(',');
	_buf.append("availableForRefill=");
	_buf.appendInt64(availableForRefill);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierPlayMoneyCommonBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("playChipsRefillPeriodSec", playChipsRefillPeriodSec, _buf);
	Atf::XmlElement::encodeAsXmlElement("playChipsAllowedForPeriodCents", playChipsAllowedForPeriodCents, _buf);
	Atf::XmlElement::encodeAsXmlElement("targetRefillAmountCents", targetRefillAmountCents, _buf);
	Atf::XmlElement::encodeAsXmlElement("playChipsBalance", playChipsBalance, _buf);
	Atf::XmlElement::encodeAsXmlElement("availableForRefill", availableForRefill, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierPlayMoneyCommonBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("playChipsRefillPeriodSec"))
		{
			playChipsRefillPeriodSec = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playChipsAllowedForPeriodCents"))
		{
			playChipsAllowedForPeriodCents = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("targetRefillAmountCents"))
		{
			targetRefillAmountCents = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playChipsBalance"))
		{
			playChipsBalance = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("availableForRefill"))
		{
			availableForRefill = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierPlayMoneyCommonBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierPlayMoneyCommonBody())) // not empty
	{
		_body.composeINT32(playChipsRefillPeriodSec);
		_body.composeINT64(playChipsAllowedForPeriodCents);
		_body.composeINT64(targetRefillAmountCents);
		_body.composeINT64(playChipsBalance);
		_body.composeINT64(availableForRefill);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierPlayMoneyCommonBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(playChipsRefillPeriodSec);
	_parser0.parseINT64(playChipsAllowedForPeriodCents);
	_parser0.parseINT64(targetRefillAmountCents);
	_parser0.parseINT64(playChipsBalance);
	_parser0.parseINT64(availableForRefill);
}

const char *CashierServer::cli::CashierPlayMoneyCommonBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("playChipsRefillPeriodSec", playChipsRefillPeriodSec);
	_jsonstr.compose("playChipsAllowedForPeriodCents", playChipsAllowedForPeriodCents);
	_jsonstr.compose("targetRefillAmountCents", targetRefillAmountCents);
	_jsonstr.compose("playChipsBalance", playChipsBalance);
	_jsonstr.compose("availableForRefill", availableForRefill);
	return _buf.c_str();
}

void CashierServer::cli::CashierPlayMoneyCommonBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("playChipsRefillPeriodSec", playChipsRefillPeriodSec);
	_jparser.parseByNameThrow("playChipsAllowedForPeriodCents", playChipsAllowedForPeriodCents);
	_jparser.parseByNameThrow("targetRefillAmountCents", targetRefillAmountCents);
	_jparser.parseByNameThrow("playChipsBalance", playChipsBalance);
	_jparser.parseByNameThrow("availableForRefill", availableForRefill);
}

/* static */ void CashierServer::cli::CashierPlayMoneyCommonBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 playChipsRefillPeriodSec; _jparser.validateByNameThrow("playChipsRefillPeriodSec", playChipsRefillPeriodSec);
	AtfValidator::validateInt(_descr, "playChipsRefillPeriodSec", playChipsRefillPeriodSec, _checker, __FILE__, __LINE__);
	INT64 playChipsAllowedForPeriodCents; _jparser.validateByNameThrow("playChipsAllowedForPeriodCents", playChipsAllowedForPeriodCents);
	AtfValidator::validateInt(_descr, "playChipsAllowedForPeriodCents", playChipsAllowedForPeriodCents, _checker, __FILE__, __LINE__);
	INT64 targetRefillAmountCents; _jparser.validateByNameThrow("targetRefillAmountCents", targetRefillAmountCents);
	AtfValidator::validateInt(_descr, "targetRefillAmountCents", targetRefillAmountCents, _checker, __FILE__, __LINE__);
	INT64 playChipsBalance; _jparser.validateByNameThrow("playChipsBalance", playChipsBalance);
	AtfValidator::validateInt(_descr, "playChipsBalance", playChipsBalance, _checker, __FILE__, __LINE__);
	INT64 availableForRefill; _jparser.validateByNameThrow("availableForRefill", availableForRefill);
	AtfValidator::validateInt(_descr, "availableForRefill", availableForRefill, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierPlayMoneyCommonBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 playChipsRefillPeriodSec; _parser0.parseINT32(playChipsRefillPeriodSec);
	AtfValidator::validateInt(_descr, "playChipsRefillPeriodSec", playChipsRefillPeriodSec, _checker, __FILE__, __LINE__);
	INT64 playChipsAllowedForPeriodCents; _parser0.parseINT64(playChipsAllowedForPeriodCents);
	AtfValidator::validateInt(_descr, "playChipsAllowedForPeriodCents", playChipsAllowedForPeriodCents, _checker, __FILE__, __LINE__);
	INT64 targetRefillAmountCents; _parser0.parseINT64(targetRefillAmountCents);
	AtfValidator::validateInt(_descr, "targetRefillAmountCents", targetRefillAmountCents, _checker, __FILE__, __LINE__);
	INT64 playChipsBalance; _parser0.parseINT64(playChipsBalance);
	AtfValidator::validateInt(_descr, "playChipsBalance", playChipsBalance, _checker, __FILE__, __LINE__);
	INT64 availableForRefill; _parser0.parseINT64(availableForRefill);
	AtfValidator::validateInt(_descr, "availableForRefill", availableForRefill, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierPlayMoneyRefillResult
//=================================================================

CashierServer::cli::CashierPlayMoneyRefillResult::CashierPlayMoneyRefillResult()
{
	clear();
}

void CashierServer::cli::CashierPlayMoneyRefillResult::clear()
{
	refillResult = 0;
	refilledAmount = 0;
	nextRefillTime.setNull();
	deltaSec = 0;
}

bool CashierServer::cli::CashierPlayMoneyRefillResult::equals(const CashierPlayMoneyRefillResult& _o) const
{
	return refillResult == _o.refillResult &&
		refilledAmount == _o.refilledAmount &&
		nextRefillTime.equals(_o.nextRefillTime) &&
		deltaSec == _o.deltaSec;
}

const char *CashierServer::cli::CashierPlayMoneyRefillResult::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("refillResult=");
	_buf.appendInt(refillResult);
	if (refillResult == ePmRefillSucceeded)
	{
		_buf.append(',');
		_buf.append("refilledAmount=");
		_buf.appendInt64(refilledAmount);
		_buf.append(',');
		_buf.append("nextRefillTime=");
		Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, nextRefillTime);
		_buf.append(',');
		_buf.append("deltaSec=");
		_buf.appendInt(deltaSec);
	}
	else if (refillResult == ePmRefillAllowenceExceeded)
	{
		_buf.append(',');
		_buf.append("nextRefillTime=");
		Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, nextRefillTime);
		_buf.append(',');
		_buf.append("deltaSec=");
		_buf.appendInt(deltaSec);
	}
	else if (refillResult == ePmRefillGreaterThanTarget)
	{
		_buf.append(',');
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierPlayMoneyRefillResult::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("refillResult", refillResult, _buf);
	if (refillResult == ePmRefillSucceeded)
	{
		Atf::XmlElement::encodeAsXmlElement("refilledAmount", refilledAmount, _buf);
		Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "nextRefillTime", nextRefillTime);
		Atf::XmlElement::encodeAsXmlElement("deltaSec", deltaSec, _buf);
	}
	else if (refillResult == ePmRefillAllowenceExceeded)
	{
		Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "nextRefillTime", nextRefillTime);
		Atf::XmlElement::encodeAsXmlElement("deltaSec", deltaSec, _buf);
	}
	else if (refillResult == ePmRefillGreaterThanTarget)
	{
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierPlayMoneyRefillResult::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("refillResult"))
		{
			refillResult = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("refilledAmount"))
		{
			refilledAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextRefillTime"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, nextRefillTime);
		}
		else if (_element.equals("deltaSec"))
		{
			deltaSec = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierPlayMoneyRefillResult::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(refillResult);
	if (refillResult == ePmRefillSucceeded)
	{
		CommMsgBody _msg0;
		_msg0.composeINT64(refilledAmount);
		_msg0.composeSrvTime(nextRefillTime);
		_msg0.composeINT32(deltaSec);
		_msg.composeMsgBody(_msg0);
	}
	else if (refillResult == ePmRefillAllowenceExceeded)
	{
		CommMsgBody _msg1;
		_msg1.composeSrvTime(nextRefillTime);
		_msg1.composeINT32(deltaSec);
		_msg.composeMsgBody(_msg1);
	}
	else if (refillResult == ePmRefillGreaterThanTarget)
	{
		CommMsgBody _msg2;
		_msg.composeMsgBody(_msg2);
	}
}

void CashierServer::cli::CashierPlayMoneyRefillResult::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(refillResult);
	if (refillResult == ePmRefillSucceeded)
	{
		parseAnonymousMsgBody0(_parser);
	}
	else if (refillResult == ePmRefillAllowenceExceeded)
	{
		parseAnonymousMsgBody1(_parser);
	}
	else if (refillResult == ePmRefillGreaterThanTarget)
	{
		parseAnonymousMsgBody2(_parser);
	}
}

const char *CashierServer::cli::CashierPlayMoneyRefillResult::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("refillResult", refillResult);
	if (refillResult == ePmRefillSucceeded)
	{
		_jsonstr.compose("refilledAmount", refilledAmount);
		_jsonstr.compose("nextRefillTime", nextRefillTime);
		_jsonstr.compose("deltaSec", deltaSec);
	}
	else if (refillResult == ePmRefillAllowenceExceeded)
	{
		_jsonstr.compose("nextRefillTime", nextRefillTime);
		_jsonstr.compose("deltaSec", deltaSec);
	}
	else if (refillResult == ePmRefillGreaterThanTarget)
	{
	}
	return _buf.c_str();
}

void CashierServer::cli::CashierPlayMoneyRefillResult::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("refillResult", refillResult);
	if (refillResult == ePmRefillSucceeded)
	{
		_jparser.parseByNameThrow("refilledAmount", refilledAmount);
		_jparser.parseByNameThrow("nextRefillTime", nextRefillTime);
		_jparser.parseByNameThrow("deltaSec", deltaSec);
	}
	else if (refillResult == ePmRefillAllowenceExceeded)
	{
		_jparser.parseByNameThrow("nextRefillTime", nextRefillTime);
		_jparser.parseByNameThrow("deltaSec", deltaSec);
	}
	else if (refillResult == ePmRefillGreaterThanTarget)
	{
	}
}

/* static */ void CashierServer::cli::CashierPlayMoneyRefillResult::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 refillResult = 0;
	_jparser.validateByNameThrow("refillResult", refillResult);
	AtfValidator::validateInt(_descr, "refillResult", refillResult, _checker, __FILE__, __LINE__);
	if (refillResult == ePmRefillSucceeded)
	{
		INT64 refilledAmount; _jparser.validateByNameThrow("refilledAmount", refilledAmount);
		AtfValidator::validateInt(_descr, "refilledAmount", refilledAmount, _checker, __FILE__, __LINE__);
		CommSrvTime nextRefillTime; _jparser.validateByNameThrow("nextRefillTime", nextRefillTime);
		AtfValidator::validateSrvDateTime(_descr, "nextRefillTime", nextRefillTime, _checker, __FILE__, __LINE__);
		INT32 deltaSec; _jparser.validateByNameThrow("deltaSec", deltaSec);
		AtfValidator::validateInt(_descr, "deltaSec", deltaSec, _checker, __FILE__, __LINE__);
	}
	else if (refillResult == ePmRefillAllowenceExceeded)
	{
		CommSrvTime nextRefillTime; _jparser.validateByNameThrow("nextRefillTime", nextRefillTime);
		AtfValidator::validateSrvDateTime(_descr, "nextRefillTime", nextRefillTime, _checker, __FILE__, __LINE__);
		INT32 deltaSec; _jparser.validateByNameThrow("deltaSec", deltaSec);
		AtfValidator::validateInt(_descr, "deltaSec", deltaSec, _checker, __FILE__, __LINE__);
	}
	else if (refillResult == ePmRefillGreaterThanTarget)
	{
	}
}

/*static*/ void CashierServer::cli::CashierPlayMoneyRefillResult::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 refillResult = 0;
	_parser.parseINT32(refillResult);
	AtfValidator::validateInt(_descr, "refillResult", refillResult, _checker, __FILE__, __LINE__);
	if (refillResult == ePmRefillSucceeded)
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (refillResult == ePmRefillAllowenceExceeded)
	{
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (refillResult == ePmRefillGreaterThanTarget)
	{
		validateAnonymousMsgBody2(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
}

void CashierServer::cli::CashierPlayMoneyRefillResult::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(refilledAmount);
	_parser0.parseSrvTime(nextRefillTime);
	_parser0.parseINT32(deltaSec);
}

/*static*/ void CashierServer::cli::CashierPlayMoneyRefillResult::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT64 refilledAmount; _parser0.parseINT64(refilledAmount);
	AtfValidator::validateInt(_descr, "refilledAmount", refilledAmount, _checker, __FILE__, __LINE__);
	CommSrvTime nextRefillTime; _parser0.parseSrvTime(nextRefillTime);
	AtfValidator::validateSrvDateTime(_descr, "nextRefillTime", nextRefillTime, _checker, __FILE__, __LINE__);
	INT32 deltaSec; _parser0.parseINT32(deltaSec);
	AtfValidator::validateInt(_descr, "deltaSec", deltaSec, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::CashierPlayMoneyRefillResult::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseSrvTime(nextRefillTime);
	_parser0.parseINT32(deltaSec);
}

/*static*/ void CashierServer::cli::CashierPlayMoneyRefillResult::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	CommSrvTime nextRefillTime; _parser0.parseSrvTime(nextRefillTime);
	AtfValidator::validateSrvDateTime(_descr, "nextRefillTime", nextRefillTime, _checker, __FILE__, __LINE__);
	INT32 deltaSec; _parser0.parseINT32(deltaSec);
	AtfValidator::validateInt(_descr, "deltaSec", deltaSec, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::CashierPlayMoneyRefillResult::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
}

/*static*/ void CashierServer::cli::CashierPlayMoneyRefillResult::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	common.clear();
	refillResult.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::equals(const Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		common.equals(_o.common) &&
		refillResult.equals(_o.refillResult);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PLAY_MONEY_REFILL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PLAY_MONEY_REFILL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("common=");
		common.toTraceString(_buf);
		_buf.append(',');
		_buf.append("refillResult=");
		refillResult.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PLAY_MONEY_REFILL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		common.toXmlString("common", _buf);
		refillResult.toXmlString("refillResult", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("common"))
			{
				if(!Atf::AtfTempl< CashierPlayMoneyCommonBody >::FromXmlString(_value, common)) return false;
			}
			else if (_element.equals("refillResult"))
			{
				if(!Atf::AtfTempl< CashierPlayMoneyRefillResult >::FromXmlString(_value, refillResult)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		common.composeMsg(_msg, _ignoreJSON);
		refillResult.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		common.parseMsg(_parser);
		refillResult.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("common", common);
		_jsonstr.compose("refillResult", refillResult);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("common", common);
		_jparser.parseByNameThrow("refillResult", refillResult);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_MONEY_REFILL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		CashierPlayMoneyCommonBody common; _jparser.validateByNameThrow("common", common);
		CashierPlayMoneyRefillResult refillResult; _jparser.validateByNameThrow("refillResult", refillResult);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_MONEY_REFILL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		CashierPlayMoneyCommonBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("common"), _fieldsWithUnparsedContent);
		CashierPlayMoneyRefillResult::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("refillResult"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::equals(const Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    AdEventConfBody
//=================================================================

CashierServer::cli::AdEventConfBody::AdEventConfBody()
{
	clear();
}

void CashierServer::cli::AdEventConfBody::clear()
{
	nextAdEventTime.setNull();
	adEventPmRewardAmountCents = 0;
}

bool CashierServer::cli::AdEventConfBody::equals(const AdEventConfBody& _o) const
{
	return nextAdEventTime.equals(_o.nextAdEventTime) &&
		adEventPmRewardAmountCents == _o.adEventPmRewardAmountCents;
}

const char *CashierServer::cli::AdEventConfBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("nextAdEventTime=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, nextAdEventTime);
	_buf.append(',');
	_buf.append("adEventPmRewardAmountCents=");
	_buf.appendInt64(adEventPmRewardAmountCents);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::AdEventConfBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "nextAdEventTime", nextAdEventTime);
	Atf::XmlElement::encodeAsXmlElement("adEventPmRewardAmountCents", adEventPmRewardAmountCents, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::AdEventConfBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("nextAdEventTime"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, nextAdEventTime);
		}
		else if (_element.equals("adEventPmRewardAmountCents"))
		{
			adEventPmRewardAmountCents = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::AdEventConfBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(AdEventConfBody())) // not empty
	{
		_body.composeSrvTime(nextAdEventTime);
		_body.composeINT64(adEventPmRewardAmountCents);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::AdEventConfBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseSrvTime(nextAdEventTime);
	_parser0.parseINT64(adEventPmRewardAmountCents);
}

const char *CashierServer::cli::AdEventConfBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("nextAdEventTime", nextAdEventTime);
	_jsonstr.compose("adEventPmRewardAmountCents", adEventPmRewardAmountCents);
	return _buf.c_str();
}

void CashierServer::cli::AdEventConfBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("nextAdEventTime", nextAdEventTime);
	_jparser.parseByNameThrow("adEventPmRewardAmountCents", adEventPmRewardAmountCents);
}

/* static */ void CashierServer::cli::AdEventConfBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	CommSrvTime nextAdEventTime; _jparser.validateByNameThrow("nextAdEventTime", nextAdEventTime);
	AtfValidator::validateSrvDateTime(_descr, "nextAdEventTime", nextAdEventTime, _checker, __FILE__, __LINE__);
	INT64 adEventPmRewardAmountCents; _jparser.validateByNameThrow("adEventPmRewardAmountCents", adEventPmRewardAmountCents);
	AtfValidator::validateInt(_descr, "adEventPmRewardAmountCents", adEventPmRewardAmountCents, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::AdEventConfBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	CommSrvTime nextAdEventTime; _parser0.parseSrvTime(nextAdEventTime);
	AtfValidator::validateSrvDateTime(_descr, "nextAdEventTime", nextAdEventTime, _checker, __FILE__, __LINE__);
	INT64 adEventPmRewardAmountCents; _parser0.parseINT64(adEventPmRewardAmountCents);
	AtfValidator::validateInt(_descr, "adEventPmRewardAmountCents", adEventPmRewardAmountCents, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	playChipsRefillPeriodSec = 0;
	playChipsAllowedForPeriodCents = 0;
	targetRefillAmountCents = 0;
	availableForRefill = 0;
	nextRefillTime.setNull();
	userAdEventConf.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::equals(const Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		playChipsRefillPeriodSec == _o.playChipsRefillPeriodSec &&
		playChipsAllowedForPeriodCents == _o.playChipsAllowedForPeriodCents &&
		targetRefillAmountCents == _o.targetRefillAmountCents &&
		availableForRefill == _o.availableForRefill &&
		nextRefillTime.equals(_o.nextRefillTime) &&
		userAdEventConf.equals(_o.userAdEventConf);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("playChipsRefillPeriodSec=");
		_buf.appendInt(playChipsRefillPeriodSec);
		_buf.append(',');
		_buf.append("playChipsAllowedForPeriodCents=");
		_buf.appendInt64(playChipsAllowedForPeriodCents);
		_buf.append(',');
		_buf.append("targetRefillAmountCents=");
		_buf.appendInt64(targetRefillAmountCents);
		_buf.append(',');
		_buf.append("availableForRefill=");
		_buf.appendInt64(availableForRefill);
		_buf.append(',');
		_buf.append("nextRefillTime=");
		Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, nextRefillTime);
		_buf.append(',');
		_buf.append("userAdEventConf=");
		userAdEventConf.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("playChipsRefillPeriodSec", playChipsRefillPeriodSec, _buf);
		Atf::XmlElement::encodeAsXmlElement("playChipsAllowedForPeriodCents", playChipsAllowedForPeriodCents, _buf);
		Atf::XmlElement::encodeAsXmlElement("targetRefillAmountCents", targetRefillAmountCents, _buf);
		Atf::XmlElement::encodeAsXmlElement("availableForRefill", availableForRefill, _buf);
		Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "nextRefillTime", nextRefillTime);
		userAdEventConf.toXmlString("userAdEventConf", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("playChipsRefillPeriodSec"))
			{
				playChipsRefillPeriodSec = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playChipsAllowedForPeriodCents"))
			{
				playChipsAllowedForPeriodCents = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("targetRefillAmountCents"))
			{
				targetRefillAmountCents = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("availableForRefill"))
			{
				availableForRefill = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("nextRefillTime"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, nextRefillTime);
			}
			else if (_element.equals("userAdEventConf"))
			{
				if(!Atf::AtfTempl< AdEventConfBody >::FromXmlString(_value, userAdEventConf)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(playChipsRefillPeriodSec);
		_msg.composeINT64(playChipsAllowedForPeriodCents);
		_msg.composeINT64(targetRefillAmountCents);
		_msg.composeINT64(availableForRefill);
		_msg.composeSrvTime(nextRefillTime);
		userAdEventConf.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(playChipsRefillPeriodSec);
		_parser.parseINT64(playChipsAllowedForPeriodCents);
		_parser.parseINT64(targetRefillAmountCents);
		_parser.parseINT64(availableForRefill);
		_parser.parseSrvTime(nextRefillTime);
		if(_parser.parseEnded()) return;
		userAdEventConf.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("playChipsRefillPeriodSec", playChipsRefillPeriodSec);
		_jsonstr.compose("playChipsAllowedForPeriodCents", playChipsAllowedForPeriodCents);
		_jsonstr.compose("targetRefillAmountCents", targetRefillAmountCents);
		_jsonstr.compose("availableForRefill", availableForRefill);
		_jsonstr.compose("nextRefillTime", nextRefillTime);
		_jsonstr.compose("userAdEventConf", userAdEventConf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("playChipsRefillPeriodSec", playChipsRefillPeriodSec);
		_jparser.parseByNameThrow("playChipsAllowedForPeriodCents", playChipsAllowedForPeriodCents);
		_jparser.parseByNameThrow("targetRefillAmountCents", targetRefillAmountCents);
		_jparser.parseByNameThrow("availableForRefill", availableForRefill);
		_jparser.parseByNameThrow("nextRefillTime", nextRefillTime);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("userAdEventConf", userAdEventConf);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 playChipsRefillPeriodSec; _jparser.validateByNameThrow("playChipsRefillPeriodSec", playChipsRefillPeriodSec);
		AtfValidator::validateInt(_descr, "playChipsRefillPeriodSec", playChipsRefillPeriodSec, _checker, __FILE__, __LINE__);
		INT64 playChipsAllowedForPeriodCents; _jparser.validateByNameThrow("playChipsAllowedForPeriodCents", playChipsAllowedForPeriodCents);
		AtfValidator::validateInt(_descr, "playChipsAllowedForPeriodCents", playChipsAllowedForPeriodCents, _checker, __FILE__, __LINE__);
		INT64 targetRefillAmountCents; _jparser.validateByNameThrow("targetRefillAmountCents", targetRefillAmountCents);
		AtfValidator::validateInt(_descr, "targetRefillAmountCents", targetRefillAmountCents, _checker, __FILE__, __LINE__);
		INT64 availableForRefill; _jparser.validateByNameThrow("availableForRefill", availableForRefill);
		AtfValidator::validateInt(_descr, "availableForRefill", availableForRefill, _checker, __FILE__, __LINE__);
		CommSrvTime nextRefillTime; _jparser.validateByNameThrow("nextRefillTime", nextRefillTime);
		AtfValidator::validateSrvDateTime(_descr, "nextRefillTime", nextRefillTime, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		AdEventConfBody userAdEventConf; _jparser.validateByNameThrow("userAdEventConf", userAdEventConf);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 playChipsRefillPeriodSec; _parser.parseINT32(playChipsRefillPeriodSec);
		AtfValidator::validateInt(_descr, "playChipsRefillPeriodSec", playChipsRefillPeriodSec, _checker, __FILE__, __LINE__);
		INT64 playChipsAllowedForPeriodCents; _parser.parseINT64(playChipsAllowedForPeriodCents);
		AtfValidator::validateInt(_descr, "playChipsAllowedForPeriodCents", playChipsAllowedForPeriodCents, _checker, __FILE__, __LINE__);
		INT64 targetRefillAmountCents; _parser.parseINT64(targetRefillAmountCents);
		AtfValidator::validateInt(_descr, "targetRefillAmountCents", targetRefillAmountCents, _checker, __FILE__, __LINE__);
		INT64 availableForRefill; _parser.parseINT64(availableForRefill);
		AtfValidator::validateInt(_descr, "availableForRefill", availableForRefill, _checker, __FILE__, __LINE__);
		CommSrvTime nextRefillTime; _parser.parseSrvTime(nextRefillTime);
		AtfValidator::validateSrvDateTime(_descr, "nextRefillTime", nextRefillTime, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		PString _descbuf;
		AdEventConfBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userAdEventConf"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PM_WATCH2EARN_START
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::Protocol_MSG_CASHIER_PM_WATCH2EARN_START()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::clear()
{
	triggerType = 0;
	triggerId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::equals(const Protocol_MSG_CASHIER_PM_WATCH2EARN_START& _o) const
{
	return triggerType == _o.triggerType &&
		triggerId == _o.triggerId;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PM_WATCH2EARN_START != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PM_WATCH2EARN_START*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PM_WATCH2EARN_START).append(")");
	_buf.append(',');
	_buf.append("triggerType=");
	_buf.appendInt(triggerType);
	_buf.append(',');
	_buf.append("triggerId=");
	_buf.appendUint64(triggerId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PM_WATCH2EARN_START).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("triggerType", triggerType, _buf);
	Atf::XmlElement::encodeAsXmlElement("triggerId", triggerId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("triggerType"))
			{
				triggerType = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("triggerId"))
			{
				triggerId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(triggerType);
	_msg.composeUINT64(triggerId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(triggerType);
	_parser.parseUINT64(triggerId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("triggerType", triggerType);
	_jsonstr.compose("triggerId", triggerId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("triggerType", triggerType);
	_jparser.parseByNameThrow("triggerId", triggerId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_WATCH2EARN_START";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 triggerType; _jparser.validateByNameThrow("triggerType", triggerType);
	AtfValidator::validateIntRange(_descr, "triggerType", triggerType, ePlayMoneyAdTriggerType_Undefined, ePlayMoneyAdTriggerType_Last, _checker, __FILE__, __LINE__);
	UINT64 triggerId; _jparser.validateByNameThrow("triggerId", triggerId);
	AtfValidator::validateUint(_descr, "triggerId", triggerId, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_WATCH2EARN_START";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 triggerType; _parser.parseINT32(triggerType);
	AtfValidator::validateIntRange(_descr, "triggerType", triggerType, ePlayMoneyAdTriggerType_Undefined, ePlayMoneyAdTriggerType_Last, _checker, __FILE__, __LINE__);
	UINT64 triggerId; _parser.parseUINT64(triggerId);
	AtfValidator::validateUint(_descr, "triggerId", triggerId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	eventId = 0;
	nextAdEventTime.setNull();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::equals(const Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		eventId == _o.eventId &&
		nextAdEventTime.equals(_o.nextAdEventTime);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PM_WATCH2EARN_START_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PM_WATCH2EARN_START_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("eventId=");
		_buf.appendUint(eventId);
		_buf.append(',');
		_buf.append("nextAdEventTime=");
		Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, nextAdEventTime);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PM_WATCH2EARN_START_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("eventId", eventId, _buf);
		Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "nextAdEventTime", nextAdEventTime);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("eventId"))
			{
				eventId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("nextAdEventTime"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, nextAdEventTime);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(eventId);
		_msg.composeSrvTime(nextAdEventTime);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(eventId);
		_parser.parseSrvTime(nextAdEventTime);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("eventId", eventId);
		_jsonstr.compose("nextAdEventTime", nextAdEventTime);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("eventId", eventId);
		_jparser.parseByNameThrow("nextAdEventTime", nextAdEventTime);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_WATCH2EARN_START_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 eventId; _jparser.validateByNameThrow("eventId", eventId);
		AtfValidator::validateInt(_descr, "eventId", eventId, _checker, __FILE__, __LINE__);
		CommSrvTime nextAdEventTime; _jparser.validateByNameThrow("nextAdEventTime", nextAdEventTime);
		AtfValidator::validateSrvDateTime(_descr, "nextAdEventTime", nextAdEventTime, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_WATCH2EARN_START_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 eventId; _parser.parseUINT32(eventId);
		AtfValidator::validateInt(_descr, "eventId", eventId, _checker, __FILE__, __LINE__);
		CommSrvTime nextAdEventTime; _parser.parseSrvTime(nextAdEventTime);
		AtfValidator::validateSrvDateTime(_descr, "nextAdEventTime", nextAdEventTime, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::clear()
{
	eventId = 0;
	status = 0;
	xTransStr.clear();
	infoStr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::equals(const Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH& _o) const
{
	return eventId == _o.eventId &&
		status == _o.status &&
		Atf::atfPStringEquals(xTransStr, _o.xTransStr) &&
		Atf::atfPStringEquals(infoStr, _o.infoStr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PM_WATCH2EARN_FINISH != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PM_WATCH2EARN_FINISH).append(")");
	_buf.append(',');
	_buf.append("eventId=");
	_buf.appendUint(eventId);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendInt(status);
	_buf.append(',');
	_buf.append("xTransStr=");
	_buf.append(xTransStr);
	_buf.append(',');
	_buf.append("infoStr=");
	_buf.append(infoStr);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PM_WATCH2EARN_FINISH).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("eventId", eventId, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("xTransStr", xTransStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("infoStr", infoStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("eventId"))
			{
				eventId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("status"))
			{
				status = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("xTransStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, xTransStr)) return false;
			}
			else if (_element.equals("infoStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, infoStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(eventId);
	_msg.composeINT32(status);
	_msg.composeString(xTransStr);
	_msg.composeString(infoStr);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(eventId);
	_parser.parseINT32(status);
	_parser.parseStringP(xTransStr);
	_parser.parseStringP(infoStr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("eventId", eventId);
	_jsonstr.compose("status", status);
	_jsonstr.compose("xTransStr", xTransStr);
	_jsonstr.compose("infoStr", infoStr);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("eventId", eventId);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("xTransStr", xTransStr);
	_jparser.parseByNameThrow("infoStr", infoStr);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_WATCH2EARN_FINISH";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 eventId; _jparser.validateByNameThrow("eventId", eventId);
	AtfValidator::validateInt(_descr, "eventId", eventId, _checker, __FILE__, __LINE__);
	INT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateIntRange(_descr, "status", status, ePlayMoneyAdWatchResult_Complete, ePlayMoneyAdWatchResult_Last, _checker, __FILE__, __LINE__);
	PString xTransStr; _jparser.validateByNameThrow("xTransStr", xTransStr);
	AtfValidator::validateIntMax(_descr, "xTransStr", xTransStr.length(), 1000, _checker, __FILE__, __LINE__);
	PString infoStr; _jparser.validateByNameThrow("infoStr", infoStr);
	AtfValidator::validateIntMax(_descr, "infoStr", infoStr.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_WATCH2EARN_FINISH";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 eventId; _parser.parseUINT32(eventId);
	AtfValidator::validateInt(_descr, "eventId", eventId, _checker, __FILE__, __LINE__);
	INT32 status; _parser.parseINT32(status);
	AtfValidator::validateIntRange(_descr, "status", status, ePlayMoneyAdWatchResult_Complete, ePlayMoneyAdWatchResult_Last, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "xTransStr"); size_t szXTransStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "xTransStr", szXTransStr, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "infoStr"); size_t szInfoStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "infoStr", szInfoStr, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::equals(const Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::clear()
{
	propertyTypes.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::equals(const Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS& _o) const
{
	return propertyTypes.equals(_o.propertyTypes);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS).append(")");
	_buf.append(',');
	_buf.append("propertyTypes=");
	propertyTypes.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	propertyTypes.toXmlString("propertyTypes", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("propertyTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, propertyTypes)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	propertyTypes.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::parseMsg(CommMsgParser& _parser)
{
	propertyTypes.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("propertyTypes", propertyTypes);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("propertyTypes", propertyTypes);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< INT32 > propertyTypes; _jparser.validateByNameThrow("propertyTypes", propertyTypes);
	AtfValidator::validateIntRange(_descr, "propertyTypes", propertyTypes.size(), 1, 2000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szPropertyTypes = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("propertyTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntRange(_descr, "propertyTypes", szPropertyTypes, 1, 2000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierAccountBalanceBody
//=================================================================

CashierServer::cli::CashierAccountBalanceBody::CashierAccountBalanceBody()
{
	clear();
}

void CashierServer::cli::CashierAccountBalanceBody::clear()
{
	currency.clear();
	chips = 0;
	tChips = 0;
}

bool CashierServer::cli::CashierAccountBalanceBody::equals(const CashierAccountBalanceBody& _o) const
{
	return Atf::atfPStringEquals(currency, _o.currency) &&
		chips == _o.chips &&
		tChips == _o.tChips;
}

const char *CashierServer::cli::CashierAccountBalanceBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt64(chips);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt64(tChips);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierAccountBalanceBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierAccountBalanceBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("chips"))
		{
			chips = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tChips"))
		{
			tChips = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierAccountBalanceBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierAccountBalanceBody())) // not empty
	{
		_body.composeString(currency);
		_body.composeINT64(chips);
		_body.composeINT64(tChips);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierAccountBalanceBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(chips);
	_parser0.parseINT64(tChips);
}

const char *CashierServer::cli::CashierAccountBalanceBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("tChips", tChips);
	return _buf.c_str();
}

void CashierServer::cli::CashierAccountBalanceBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("tChips", tChips);
}

/* static */ void CashierServer::cli::CashierAccountBalanceBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT64 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT64 tChips; _jparser.validateByNameThrow("tChips", tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierAccountBalanceBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 chips; _parser0.parseINT64(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT64 tChips; _parser0.parseINT64(tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	userProperties.clear();
	flags = 0;
	flags2 = 0;
	privileges = 0;
	privileges2 = 0;
	privileges3 = 0;
	playChips = 0;
	defaultCurrency.clear();
	totalAmountCurr = 0;
	accountBalances.clear();
	flags3 = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::equals(const Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		userProperties.equals(_o.userProperties) &&
		flags == _o.flags &&
		flags2 == _o.flags2 &&
		privileges == _o.privileges &&
		privileges2 == _o.privileges2 &&
		privileges3 == _o.privileges3 &&
		playChips == _o.playChips &&
		Atf::atfPStringEquals(defaultCurrency, _o.defaultCurrency) &&
		totalAmountCurr == _o.totalAmountCurr &&
		accountBalances.equals(_o.accountBalances) &&
		flags3 == _o.flags3;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userProperties=");
		userProperties.toTraceString(_buf);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
		_buf.append(',');
		_buf.append("flags2=");
		_buf.appendUint64(flags2);
		_buf.append(',');
		_buf.append("privileges=");
		_buf.appendUint(privileges);
		_buf.append(',');
		_buf.append("privileges2=");
		_buf.appendUint64(privileges2);
		_buf.append(',');
		_buf.append("privileges3=");
		_buf.appendUint64(privileges3);
		_buf.append(',');
		_buf.append("playChips=");
		_buf.appendInt64(playChips);
		_buf.append(',');
		_buf.append("defaultCurrency=");
		_buf.append(defaultCurrency);
		_buf.append(',');
		_buf.append("totalAmountCurr=");
		_buf.appendInt64(totalAmountCurr);
		_buf.append(',');
		_buf.append("accountBalances=");
		accountBalances.toTraceString(_buf);
		_buf.append(',');
		_buf.append("flags3=");
		_buf.appendUint64(flags3);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		userProperties.toXmlString("userProperties", _buf);
		Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
		Atf::XmlElement::encodeAsXmlElement("flags2", flags2, _buf);
		Atf::XmlElement::encodeAsXmlElement("privileges", privileges, _buf);
		Atf::XmlElement::encodeAsXmlElement("privileges2", privileges2, _buf);
		Atf::XmlElement::encodeAsXmlElement("privileges3", privileges3, _buf);
		Atf::XmlElement::encodeAsXmlElement("playChips", playChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("defaultCurrency", defaultCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("totalAmountCurr", totalAmountCurr, _buf);
		accountBalances.toXmlString("accountBalances", _buf);
		Atf::XmlElement::encodeAsXmlElement("flags3", flags3, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("userProperties"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< Common::AtfShared::UserPropertyBody, 4 > >::FromXmlString(_value, userProperties)) return false;
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags2"))
			{
				flags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("privileges"))
			{
				privileges = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("privileges2"))
			{
				privileges2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("privileges3"))
			{
				privileges3 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playChips"))
			{
				playChips = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("defaultCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, defaultCurrency)) return false;
			}
			else if (_element.equals("totalAmountCurr"))
			{
				totalAmountCurr = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("accountBalances"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierAccountBalanceBody, 4 > >::FromXmlString(_value, accountBalances)) return false;
			}
			else if (_element.equals("flags3"))
			{
				flags3 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		userProperties.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT32(flags);
		_msg.composeUINT64(flags2);
		_msg.composeUINT32(privileges);
		_msg.composeUINT64(privileges2);
		_msg.composeUINT64(privileges3);
		_msg.composeINT64(playChips);
		_msg.composeString(defaultCurrency);
		_msg.composeINT64(totalAmountCurr);
		accountBalances.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT64(flags3);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		userProperties.parseMsg(_parser);
		_parser.parseUINT32(flags);
		_parser.parseUINT64(flags2);
		_parser.parseUINT32(privileges);
		_parser.parseUINT64(privileges2);
		_parser.parseUINT64(privileges3);
		_parser.parseINT64(playChips);
		_parser.parseStringP(defaultCurrency);
		_parser.parseINT64(totalAmountCurr);
		accountBalances.parseMsg(_parser);
		_parser.parseUINT64(flags3);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("userProperties", userProperties);
		_jsonstr.compose("flags", flags);
		_jsonstr.compose("flags2", flags2);
		_jsonstr.compose("privileges", privileges);
		_jsonstr.compose("privileges2", privileges2);
		_jsonstr.compose("privileges3", privileges3);
		_jsonstr.compose("playChips", playChips);
		_jsonstr.compose("defaultCurrency", defaultCurrency);
		_jsonstr.compose("totalAmountCurr", totalAmountCurr);
		_jsonstr.compose("accountBalances", accountBalances);
		_jsonstr.compose("flags3", flags3);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("userProperties", userProperties);
		_jparser.parseByNameThrow("flags", flags);
		_jparser.parseByNameThrow("flags2", flags2);
		_jparser.parseByNameThrow("privileges", privileges);
		_jparser.parseByNameThrow("privileges2", privileges2);
		_jparser.parseByNameThrow("privileges3", privileges3);
		_jparser.parseByNameThrow("playChips", playChips);
		_jparser.parseByNameThrow("defaultCurrency", defaultCurrency);
		_jparser.parseByNameThrow("totalAmountCurr", totalAmountCurr);
		_jparser.parseByNameThrow("accountBalances", accountBalances);
		_jparser.parseByNameThrow("flags3", flags3);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< Common::AtfShared::UserPropertyBody > userProperties; _jparser.validateByNameThrow("userProperties", userProperties);
		AtfValidator::validateInt(_descr, "userProperties", userProperties.size(), _checker, __FILE__, __LINE__);
		UINT32 flags; _jparser.validateByNameThrow("flags", flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		UINT64 flags2; _jparser.validateByNameThrow("flags2", flags2);
		AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
		UINT32 privileges; _jparser.validateByNameThrow("privileges", privileges);
		AtfValidator::validateInt(_descr, "privileges", privileges, _checker, __FILE__, __LINE__);
		UINT64 privileges2; _jparser.validateByNameThrow("privileges2", privileges2);
		AtfValidator::validateUint(_descr, "privileges2", privileges2, _checker, __FILE__, __LINE__);
		UINT64 privileges3; _jparser.validateByNameThrow("privileges3", privileges3);
		AtfValidator::validateUint(_descr, "privileges3", privileges3, _checker, __FILE__, __LINE__);
		INT64 playChips; _jparser.validateByNameThrow("playChips", playChips);
		AtfValidator::validateInt(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
		PString defaultCurrency; _jparser.validateByNameThrow("defaultCurrency", defaultCurrency);
		AtfValidator::validateInt(_descr, "defaultCurrency", defaultCurrency.length(), _checker, __FILE__, __LINE__);
		INT64 totalAmountCurr; _jparser.validateByNameThrow("totalAmountCurr", totalAmountCurr);
		AtfValidator::validateInt(_descr, "totalAmountCurr", totalAmountCurr, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< CashierAccountBalanceBody > accountBalances; _jparser.validateByNameThrow("accountBalances", accountBalances);
		AtfValidator::validateInt(_descr, "accountBalances", accountBalances.size(), _checker, __FILE__, __LINE__);
		UINT64 flags3; _jparser.validateByNameThrow("flags3", flags3);
		AtfValidator::validateUint(_descr, "flags3", flags3, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szUserProperties = Atf::LAtfVector< Common::AtfShared::UserPropertyBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userProperties"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "userProperties", szUserProperties, _checker, __FILE__, __LINE__);
		UINT32 flags; _parser.parseUINT32(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		UINT64 flags2; _parser.parseUINT64(flags2);
		AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
		UINT32 privileges; _parser.parseUINT32(privileges);
		AtfValidator::validateInt(_descr, "privileges", privileges, _checker, __FILE__, __LINE__);
		UINT64 privileges2; _parser.parseUINT64(privileges2);
		AtfValidator::validateUint(_descr, "privileges2", privileges2, _checker, __FILE__, __LINE__);
		UINT64 privileges3; _parser.parseUINT64(privileges3);
		AtfValidator::validateUint(_descr, "privileges3", privileges3, _checker, __FILE__, __LINE__);
		INT64 playChips; _parser.parseINT64(playChips);
		AtfValidator::validateInt(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "defaultCurrency"); size_t szDefaultCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "defaultCurrency", szDefaultCurrency, _checker, __FILE__, __LINE__);
		INT64 totalAmountCurr; _parser.parseINT64(totalAmountCurr);
		AtfValidator::validateInt(_descr, "totalAmountCurr", totalAmountCurr, _checker, __FILE__, __LINE__);
		int szAccountBalances = Atf::LAtfVector< CashierAccountBalanceBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("accountBalances"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "accountBalances", szAccountBalances, _checker, __FILE__, __LINE__);
		UINT64 flags3; _parser.parseUINT64(flags3);
		AtfValidator::validateUint(_descr, "flags3", flags3, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::equals(const Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_CURRENT_USERROLLS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_CURRENT_USERROLLS).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_CURRENT_USERROLLS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_CURRENT_USERROLLS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_CURRENT_USERROLLS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierUserRollBody
//=================================================================

CashierServer::cli::CashierUserRollBody::CashierUserRollBody()
{
	clear();
}

void CashierServer::cli::CashierUserRollBody::clear()
{
	userRollId = 0;
	status = 0;
	oneRollDescription.clear();
	paidFpp = 0;
	paidCash = 0;
	initialAmount = 0;
	currentAmount = 0;
	currency.clear();
	surrenderValue = 0;
	collectedPoints = 0;
	totalPoints = 0;
	numOfBets = 0;
	clearBets = 0;
	expiration.setNull();
	rollFlags = 0;
	flags = 0;
	rollSupportedGamesJson.clear();
	redemptionLimit = 0;
	shortEligibleGameNames.clear();
	longEligibleGameNames.clear();
	stakes = 0;
	clearStakes = 0;
	rollBrandsMask = 0;
	rollRewardAssetType = 0;
	rollRewardAssetId = 0;
	rollVerticalMask = 0;
}

bool CashierServer::cli::CashierUserRollBody::equals(const CashierUserRollBody& _o) const
{
	return userRollId == _o.userRollId &&
		status == _o.status &&
		Atf::atfPStringEquals(oneRollDescription, _o.oneRollDescription) &&
		paidFpp == _o.paidFpp &&
		paidCash == _o.paidCash &&
		initialAmount == _o.initialAmount &&
		currentAmount == _o.currentAmount &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		surrenderValue == _o.surrenderValue &&
		collectedPoints == _o.collectedPoints &&
		totalPoints == _o.totalPoints &&
		numOfBets == _o.numOfBets &&
		clearBets == _o.clearBets &&
		expiration.equals(_o.expiration) &&
		rollFlags == _o.rollFlags &&
		flags == _o.flags &&
		Atf::atfPStringEquals(rollSupportedGamesJson, _o.rollSupportedGamesJson) &&
		redemptionLimit == _o.redemptionLimit &&
		Atf::atfPStringEquals(shortEligibleGameNames, _o.shortEligibleGameNames) &&
		Atf::atfPStringEquals(longEligibleGameNames, _o.longEligibleGameNames) &&
		stakes == _o.stakes &&
		clearStakes == _o.clearStakes &&
		rollBrandsMask == _o.rollBrandsMask &&
		rollRewardAssetType == _o.rollRewardAssetType &&
		rollRewardAssetId == _o.rollRewardAssetId &&
		rollVerticalMask == _o.rollVerticalMask;
}

const char *CashierServer::cli::CashierUserRollBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userRollId=");
	_buf.appendUint(userRollId);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendInt(status);
	_buf.append(',');
	_buf.append("oneRollDescription=");
	_buf.append(oneRollDescription);
	_buf.append(',');
	_buf.append("paidFpp=");
	_buf.appendInt(paidFpp);
	_buf.append(',');
	_buf.append("paidCash=");
	_buf.appendInt(paidCash);
	_buf.append(',');
	_buf.append("initialAmount=");
	_buf.appendInt(initialAmount);
	_buf.append(',');
	_buf.append("currentAmount=");
	_buf.appendInt(currentAmount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("surrenderValue=");
	_buf.appendInt(surrenderValue);
	_buf.append(',');
	_buf.append("collectedPoints=");
	_buf.appendInt(collectedPoints);
	_buf.append(',');
	_buf.append("totalPoints=");
	_buf.appendInt(totalPoints);
	_buf.append(',');
	_buf.append("numOfBets=");
	_buf.appendInt(numOfBets);
	_buf.append(',');
	_buf.append("clearBets=");
	_buf.appendInt(clearBets);
	_buf.append(',');
	_buf.append("expiration=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, expiration);
	_buf.append(',');
	_buf.append("rollFlags=");
	_buf.appendUint(rollFlags);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("rollSupportedGamesJson=");
	_buf.append(rollSupportedGamesJson);
	_buf.append(',');
	_buf.append("redemptionLimit=");
	_buf.appendInt(redemptionLimit);
	_buf.append(',');
	_buf.append("shortEligibleGameNames=");
	_buf.append(shortEligibleGameNames);
	_buf.append(',');
	_buf.append("longEligibleGameNames=");
	_buf.append(longEligibleGameNames);
	_buf.append(',');
	_buf.append("stakes=");
	_buf.appendInt(stakes);
	_buf.append(',');
	_buf.append("clearStakes=");
	_buf.appendInt(clearStakes);
	_buf.append(',');
	_buf.append("rollBrandsMask=");
	_buf.appendUint(rollBrandsMask);
	_buf.append(',');
	_buf.append("rollRewardAssetType=");
	_buf.appendInt(rollRewardAssetType);
	_buf.append(',');
	_buf.append("rollRewardAssetId=");
	_buf.appendUint(rollRewardAssetId);
	_buf.append(',');
	_buf.append("rollVerticalMask=");
	_buf.appendInt(rollVerticalMask);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierUserRollBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userRollId", userRollId, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("oneRollDescription", oneRollDescription, _buf);
	Atf::XmlElement::encodeAsXmlElement("paidFpp", paidFpp, _buf);
	Atf::XmlElement::encodeAsXmlElement("paidCash", paidCash, _buf);
	Atf::XmlElement::encodeAsXmlElement("initialAmount", initialAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("currentAmount", currentAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("surrenderValue", surrenderValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("collectedPoints", collectedPoints, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalPoints", totalPoints, _buf);
	Atf::XmlElement::encodeAsXmlElement("numOfBets", numOfBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("clearBets", clearBets, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "expiration", expiration);
	Atf::XmlElement::encodeAsXmlElement("rollFlags", rollFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("rollSupportedGamesJson", rollSupportedGamesJson, _buf);
	Atf::XmlElement::encodeAsXmlElement("redemptionLimit", redemptionLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("shortEligibleGameNames", shortEligibleGameNames, _buf);
	Atf::XmlElement::encodeAsXmlElement("longEligibleGameNames", longEligibleGameNames, _buf);
	Atf::XmlElement::encodeAsXmlElement("stakes", stakes, _buf);
	Atf::XmlElement::encodeAsXmlElement("clearStakes", clearStakes, _buf);
	Atf::XmlElement::encodeAsXmlElement("rollBrandsMask", rollBrandsMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("rollRewardAssetType", rollRewardAssetType, _buf);
	Atf::XmlElement::encodeAsXmlElement("rollRewardAssetId", rollRewardAssetId, _buf);
	Atf::XmlElement::encodeAsXmlElement("rollVerticalMask", rollVerticalMask, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierUserRollBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userRollId"))
		{
			userRollId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("status"))
		{
			status = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("oneRollDescription"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, oneRollDescription)) return false;
		}
		else if (_element.equals("paidFpp"))
		{
			paidFpp = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("paidCash"))
		{
			paidCash = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("initialAmount"))
		{
			initialAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currentAmount"))
		{
			currentAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("surrenderValue"))
		{
			surrenderValue = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("collectedPoints"))
		{
			collectedPoints = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalPoints"))
		{
			totalPoints = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numOfBets"))
		{
			numOfBets = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clearBets"))
		{
			clearBets = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("expiration"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, expiration);
		}
		else if (_element.equals("rollFlags"))
		{
			rollFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rollSupportedGamesJson"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, rollSupportedGamesJson)) return false;
		}
		else if (_element.equals("redemptionLimit"))
		{
			redemptionLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("shortEligibleGameNames"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, shortEligibleGameNames)) return false;
		}
		else if (_element.equals("longEligibleGameNames"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, longEligibleGameNames)) return false;
		}
		else if (_element.equals("stakes"))
		{
			stakes = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clearStakes"))
		{
			clearStakes = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rollBrandsMask"))
		{
			rollBrandsMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rollRewardAssetType"))
		{
			rollRewardAssetType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rollRewardAssetId"))
		{
			rollRewardAssetId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rollVerticalMask"))
		{
			rollVerticalMask = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierUserRollBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierUserRollBody())) // not empty
	{
		_body.composeUINT32(userRollId);
		_body.composeINT32(status);
		_body.composeString(oneRollDescription);
		_body.composeINT32(paidFpp);
		_body.composeINT32(paidCash);
		_body.composeINT32(initialAmount);
		_body.composeINT32(currentAmount);
		_body.composeString(currency);
		_body.composeINT32(surrenderValue);
		_body.composeINT32(collectedPoints);
		_body.composeINT32(totalPoints);
		_body.composeINT32(numOfBets);
		_body.composeINT32(clearBets);
		_body.composeSrvTime(expiration);
		_body.composeUINT32(rollFlags);
		_body.composeUINT32(flags);
		_body.composeString(rollSupportedGamesJson);
		_body.composeINT32(redemptionLimit);
		_body.composeString(shortEligibleGameNames);
		_body.composeString(longEligibleGameNames);
		_body.composeINT32(stakes);
		_body.composeINT32(clearStakes);
		_body.composeUINT32(rollBrandsMask);
		_body.composeINT32(rollRewardAssetType);
		_body.composeUINT32(rollRewardAssetId);
		_body.composeINT32(rollVerticalMask);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierUserRollBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(userRollId);
	_parser0.parseINT32(status);
	_parser0.parseStringP(oneRollDescription);
	_parser0.parseINT32(paidFpp);
	_parser0.parseINT32(paidCash);
	_parser0.parseINT32(initialAmount);
	_parser0.parseINT32(currentAmount);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(surrenderValue);
	_parser0.parseINT32(collectedPoints);
	_parser0.parseINT32(totalPoints);
	_parser0.parseINT32(numOfBets);
	_parser0.parseINT32(clearBets);
	_parser0.parseSrvTime(expiration);
	_parser0.parseUINT32(rollFlags);
	_parser0.parseUINT32(flags);
	_parser0.parseStringP(rollSupportedGamesJson);
	_parser0.parseINT32(redemptionLimit);
	_parser0.parseStringP(shortEligibleGameNames);
	_parser0.parseStringP(longEligibleGameNames);
	_parser0.parseINT32(stakes);
	_parser0.parseINT32(clearStakes);
	_parser0.parseUINT32(rollBrandsMask);
	_parser0.parseINT32(rollRewardAssetType);
	_parser0.parseUINT32(rollRewardAssetId);
	_parser0.parseINT32(rollVerticalMask);
}

const char *CashierServer::cli::CashierUserRollBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userRollId", userRollId);
	_jsonstr.compose("status", status);
	_jsonstr.compose("oneRollDescription", oneRollDescription);
	_jsonstr.compose("paidFpp", paidFpp);
	_jsonstr.compose("paidCash", paidCash);
	_jsonstr.compose("initialAmount", initialAmount);
	_jsonstr.compose("currentAmount", currentAmount);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("surrenderValue", surrenderValue);
	_jsonstr.compose("collectedPoints", collectedPoints);
	_jsonstr.compose("totalPoints", totalPoints);
	_jsonstr.compose("numOfBets", numOfBets);
	_jsonstr.compose("clearBets", clearBets);
	_jsonstr.compose("expiration", expiration);
	_jsonstr.compose("rollFlags", rollFlags);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("rollSupportedGamesJson", rollSupportedGamesJson);
	_jsonstr.compose("redemptionLimit", redemptionLimit);
	_jsonstr.compose("shortEligibleGameNames", shortEligibleGameNames);
	_jsonstr.compose("longEligibleGameNames", longEligibleGameNames);
	_jsonstr.compose("stakes", stakes);
	_jsonstr.compose("clearStakes", clearStakes);
	_jsonstr.compose("rollBrandsMask", rollBrandsMask);
	_jsonstr.compose("rollRewardAssetType", rollRewardAssetType);
	_jsonstr.compose("rollRewardAssetId", rollRewardAssetId);
	_jsonstr.compose("rollVerticalMask", rollVerticalMask);
	return _buf.c_str();
}

void CashierServer::cli::CashierUserRollBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userRollId", userRollId);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("oneRollDescription", oneRollDescription);
	_jparser.parseByNameThrow("paidFpp", paidFpp);
	_jparser.parseByNameThrow("paidCash", paidCash);
	_jparser.parseByNameThrow("initialAmount", initialAmount);
	_jparser.parseByNameThrow("currentAmount", currentAmount);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("surrenderValue", surrenderValue);
	_jparser.parseByNameThrow("collectedPoints", collectedPoints);
	_jparser.parseByNameThrow("totalPoints", totalPoints);
	_jparser.parseByNameThrow("numOfBets", numOfBets);
	_jparser.parseByNameThrow("clearBets", clearBets);
	_jparser.parseByNameThrow("expiration", expiration);
	_jparser.parseByNameThrow("rollFlags", rollFlags);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("rollSupportedGamesJson", rollSupportedGamesJson);
	_jparser.parseByNameThrow("redemptionLimit", redemptionLimit);
	_jparser.parseByNameThrow("shortEligibleGameNames", shortEligibleGameNames);
	_jparser.parseByNameThrow("longEligibleGameNames", longEligibleGameNames);
	_jparser.parseByNameThrow("stakes", stakes);
	_jparser.parseByNameThrow("clearStakes", clearStakes);
	_jparser.parseByNameThrow("rollBrandsMask", rollBrandsMask);
	_jparser.parseByNameThrow("rollRewardAssetType", rollRewardAssetType);
	_jparser.parseByNameThrow("rollRewardAssetId", rollRewardAssetId);
	_jparser.parseByNameThrow("rollVerticalMask", rollVerticalMask);
}

/* static */ void CashierServer::cli::CashierUserRollBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 userRollId; _jparser.validateByNameThrow("userRollId", userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
	INT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	PString oneRollDescription; _jparser.validateByNameThrow("oneRollDescription", oneRollDescription);
	AtfValidator::validateInt(_descr, "oneRollDescription", oneRollDescription.length(), _checker, __FILE__, __LINE__);
	INT32 paidFpp; _jparser.validateByNameThrow("paidFpp", paidFpp);
	AtfValidator::validateInt(_descr, "paidFpp", paidFpp, _checker, __FILE__, __LINE__);
	INT32 paidCash; _jparser.validateByNameThrow("paidCash", paidCash);
	AtfValidator::validateInt(_descr, "paidCash", paidCash, _checker, __FILE__, __LINE__);
	INT32 initialAmount; _jparser.validateByNameThrow("initialAmount", initialAmount);
	AtfValidator::validateInt(_descr, "initialAmount", initialAmount, _checker, __FILE__, __LINE__);
	INT32 currentAmount; _jparser.validateByNameThrow("currentAmount", currentAmount);
	AtfValidator::validateInt(_descr, "currentAmount", currentAmount, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 surrenderValue; _jparser.validateByNameThrow("surrenderValue", surrenderValue);
	AtfValidator::validateInt(_descr, "surrenderValue", surrenderValue, _checker, __FILE__, __LINE__);
	INT32 collectedPoints; _jparser.validateByNameThrow("collectedPoints", collectedPoints);
	AtfValidator::validateInt(_descr, "collectedPoints", collectedPoints, _checker, __FILE__, __LINE__);
	INT32 totalPoints; _jparser.validateByNameThrow("totalPoints", totalPoints);
	AtfValidator::validateInt(_descr, "totalPoints", totalPoints, _checker, __FILE__, __LINE__);
	INT32 numOfBets; _jparser.validateByNameThrow("numOfBets", numOfBets);
	AtfValidator::validateInt(_descr, "numOfBets", numOfBets, _checker, __FILE__, __LINE__);
	INT32 clearBets; _jparser.validateByNameThrow("clearBets", clearBets);
	AtfValidator::validateInt(_descr, "clearBets", clearBets, _checker, __FILE__, __LINE__);
	CommSrvTime expiration; _jparser.validateByNameThrow("expiration", expiration);
	AtfValidator::validateSrvDateTime(_descr, "expiration", expiration, _checker, __FILE__, __LINE__);
	UINT32 rollFlags; _jparser.validateByNameThrow("rollFlags", rollFlags);
	AtfValidator::validateInt(_descr, "rollFlags", rollFlags, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	PString rollSupportedGamesJson; _jparser.validateByNameThrow("rollSupportedGamesJson", rollSupportedGamesJson);
	AtfValidator::validateInt(_descr, "rollSupportedGamesJson", rollSupportedGamesJson.length(), _checker, __FILE__, __LINE__);
	INT32 redemptionLimit; _jparser.validateByNameThrow("redemptionLimit", redemptionLimit);
	AtfValidator::validateInt(_descr, "redemptionLimit", redemptionLimit, _checker, __FILE__, __LINE__);
	PString shortEligibleGameNames; _jparser.validateByNameThrow("shortEligibleGameNames", shortEligibleGameNames);
	AtfValidator::validateInt(_descr, "shortEligibleGameNames", shortEligibleGameNames.length(), _checker, __FILE__, __LINE__);
	PString longEligibleGameNames; _jparser.validateByNameThrow("longEligibleGameNames", longEligibleGameNames);
	AtfValidator::validateInt(_descr, "longEligibleGameNames", longEligibleGameNames.length(), _checker, __FILE__, __LINE__);
	INT32 stakes; _jparser.validateByNameThrow("stakes", stakes);
	AtfValidator::validateInt(_descr, "stakes", stakes, _checker, __FILE__, __LINE__);
	INT32 clearStakes; _jparser.validateByNameThrow("clearStakes", clearStakes);
	AtfValidator::validateInt(_descr, "clearStakes", clearStakes, _checker, __FILE__, __LINE__);
	UINT32 rollBrandsMask; _jparser.validateByNameThrow("rollBrandsMask", rollBrandsMask);
	AtfValidator::validateInt(_descr, "rollBrandsMask", rollBrandsMask, _checker, __FILE__, __LINE__);
	INT32 rollRewardAssetType; _jparser.validateByNameThrow("rollRewardAssetType", rollRewardAssetType);
	AtfValidator::validateInt(_descr, "rollRewardAssetType", rollRewardAssetType, _checker, __FILE__, __LINE__);
	UINT32 rollRewardAssetId; _jparser.validateByNameThrow("rollRewardAssetId", rollRewardAssetId);
	AtfValidator::validateInt(_descr, "rollRewardAssetId", rollRewardAssetId, _checker, __FILE__, __LINE__);
	INT32 rollVerticalMask; _jparser.validateByNameThrow("rollVerticalMask", rollVerticalMask);
	AtfValidator::validateInt(_descr, "rollVerticalMask", rollVerticalMask, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierUserRollBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 userRollId; _parser0.parseUINT32(userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
	INT32 status; _parser0.parseINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "oneRollDescription"); size_t szOneRollDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "oneRollDescription", szOneRollDescription, _checker, __FILE__, __LINE__);
	INT32 paidFpp; _parser0.parseINT32(paidFpp);
	AtfValidator::validateInt(_descr, "paidFpp", paidFpp, _checker, __FILE__, __LINE__);
	INT32 paidCash; _parser0.parseINT32(paidCash);
	AtfValidator::validateInt(_descr, "paidCash", paidCash, _checker, __FILE__, __LINE__);
	INT32 initialAmount; _parser0.parseINT32(initialAmount);
	AtfValidator::validateInt(_descr, "initialAmount", initialAmount, _checker, __FILE__, __LINE__);
	INT32 currentAmount; _parser0.parseINT32(currentAmount);
	AtfValidator::validateInt(_descr, "currentAmount", currentAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 surrenderValue; _parser0.parseINT32(surrenderValue);
	AtfValidator::validateInt(_descr, "surrenderValue", surrenderValue, _checker, __FILE__, __LINE__);
	INT32 collectedPoints; _parser0.parseINT32(collectedPoints);
	AtfValidator::validateInt(_descr, "collectedPoints", collectedPoints, _checker, __FILE__, __LINE__);
	INT32 totalPoints; _parser0.parseINT32(totalPoints);
	AtfValidator::validateInt(_descr, "totalPoints", totalPoints, _checker, __FILE__, __LINE__);
	INT32 numOfBets; _parser0.parseINT32(numOfBets);
	AtfValidator::validateInt(_descr, "numOfBets", numOfBets, _checker, __FILE__, __LINE__);
	INT32 clearBets; _parser0.parseINT32(clearBets);
	AtfValidator::validateInt(_descr, "clearBets", clearBets, _checker, __FILE__, __LINE__);
	CommSrvTime expiration; _parser0.parseSrvTime(expiration);
	AtfValidator::validateSrvDateTime(_descr, "expiration", expiration, _checker, __FILE__, __LINE__);
	UINT32 rollFlags; _parser0.parseUINT32(rollFlags);
	AtfValidator::validateInt(_descr, "rollFlags", rollFlags, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "rollSupportedGamesJson"); size_t szRollSupportedGamesJson = strlen(_dummy);
	AtfValidator::validateInt(_descr, "rollSupportedGamesJson", szRollSupportedGamesJson, _checker, __FILE__, __LINE__);
	INT32 redemptionLimit; _parser0.parseINT32(redemptionLimit);
	AtfValidator::validateInt(_descr, "redemptionLimit", redemptionLimit, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "shortEligibleGameNames"); size_t szShortEligibleGameNames = strlen(_dummy);
	AtfValidator::validateInt(_descr, "shortEligibleGameNames", szShortEligibleGameNames, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "longEligibleGameNames"); size_t szLongEligibleGameNames = strlen(_dummy);
	AtfValidator::validateInt(_descr, "longEligibleGameNames", szLongEligibleGameNames, _checker, __FILE__, __LINE__);
	INT32 stakes; _parser0.parseINT32(stakes);
	AtfValidator::validateInt(_descr, "stakes", stakes, _checker, __FILE__, __LINE__);
	INT32 clearStakes; _parser0.parseINT32(clearStakes);
	AtfValidator::validateInt(_descr, "clearStakes", clearStakes, _checker, __FILE__, __LINE__);
	UINT32 rollBrandsMask; _parser0.parseUINT32(rollBrandsMask);
	AtfValidator::validateInt(_descr, "rollBrandsMask", rollBrandsMask, _checker, __FILE__, __LINE__);
	INT32 rollRewardAssetType; _parser0.parseINT32(rollRewardAssetType);
	AtfValidator::validateInt(_descr, "rollRewardAssetType", rollRewardAssetType, _checker, __FILE__, __LINE__);
	UINT32 rollRewardAssetId; _parser0.parseUINT32(rollRewardAssetId);
	AtfValidator::validateInt(_descr, "rollRewardAssetId", rollRewardAssetId, _checker, __FILE__, __LINE__);
	INT32 rollVerticalMask; _parser0.parseINT32(rollVerticalMask);
	AtfValidator::validateInt(_descr, "rollVerticalMask", rollVerticalMask, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	userRolls.clear();
	freeSpinUserRolls.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::equals(const Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		userRolls.equals(_o.userRolls) &&
		freeSpinUserRolls.equals(_o.freeSpinUserRolls);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userRolls=");
		userRolls.toTraceString(_buf);
		_buf.append(',');
		_buf.append("freeSpinUserRolls=");
		freeSpinUserRolls.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		userRolls.toXmlString("userRolls", _buf);
		freeSpinUserRolls.toXmlString("freeSpinUserRolls", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("userRolls"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierUserRollBody, 4 > >::FromXmlString(_value, userRolls)) return false;
			}
			else if (_element.equals("freeSpinUserRolls"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierUserRollBody, 4 > >::FromXmlString(_value, freeSpinUserRolls)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		userRolls.composeMsg(_msg, _ignoreJSON);
		freeSpinUserRolls.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		userRolls.parseMsg(_parser);
		freeSpinUserRolls.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("userRolls", userRolls);
		_jsonstr.compose("freeSpinUserRolls", freeSpinUserRolls);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("userRolls", userRolls);
		_jparser.parseByNameThrow("freeSpinUserRolls", freeSpinUserRolls);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CashierUserRollBody > userRolls; _jparser.validateByNameThrow("userRolls", userRolls);
		AtfValidator::validateInt(_descr, "userRolls", userRolls.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< CashierUserRollBody > freeSpinUserRolls; _jparser.validateByNameThrow("freeSpinUserRolls", freeSpinUserRolls);
		AtfValidator::validateInt(_descr, "freeSpinUserRolls", freeSpinUserRolls.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szUserRolls = Atf::LAtfVector< CashierUserRollBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userRolls"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "userRolls", szUserRolls, _checker, __FILE__, __LINE__);
		int szFreeSpinUserRolls = Atf::LAtfVector< CashierUserRollBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("freeSpinUserRolls"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "freeSpinUserRolls", szFreeSpinUserRolls, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USERROLL_STATUS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::Protocol_MSG_CASHIER_SET_USERROLL_STATUS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::clear()
{
	status.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::equals(const Protocol_MSG_CASHIER_SET_USERROLL_STATUS& _o) const
{
	return status.equals(_o.status);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_USERROLL_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_USERROLL_STATUS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USERROLL_STATUS).append(")");
	_buf.append(',');
	_buf.append("status=");
	status.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_USERROLL_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	status.toXmlString("status", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("status"))
			{
				if(!Atf::AtfTempl< common_structs::SetUserRollStatus >::FromXmlString(_value, status)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	status.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::parseMsg(CommMsgParser& _parser)
{
	status.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("status", status);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("status", status);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USERROLL_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::SetUserRollStatus status; _jparser.validateByNameThrow("status", status);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USERROLL_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SetUserRollStatus::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("status"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::clear()
{
	reply.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::equals(const Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY& _o) const
{
	return reply.equals(_o.reply);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_USERROLL_STATUS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USERROLL_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("reply=");
	reply.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_USERROLL_STATUS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	reply.toXmlString("reply", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reply"))
			{
				if(!Atf::AtfTempl< common_structs::SetUserRollStatusReply >::FromXmlString(_value, reply)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	reply.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	reply.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reply", reply);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reply", reply);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USERROLL_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::SetUserRollStatusReply reply; _jparser.validateByNameThrow("reply", reply);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USERROLL_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SetUserRollStatusReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierUserRollsOrderOneBody
//=================================================================

CashierServer::cli::CashierUserRollsOrderOneBody::CashierUserRollsOrderOneBody()
{
	clear();
}

void CashierServer::cli::CashierUserRollsOrderOneBody::clear()
{
	userRollId = 0;
}

bool CashierServer::cli::CashierUserRollsOrderOneBody::equals(const CashierUserRollsOrderOneBody& _o) const
{
	return userRollId == _o.userRollId;
}

const char *CashierServer::cli::CashierUserRollsOrderOneBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userRollId=");
	_buf.appendUint(userRollId);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierUserRollsOrderOneBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userRollId", userRollId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierUserRollsOrderOneBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userRollId"))
		{
			userRollId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierUserRollsOrderOneBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierUserRollsOrderOneBody())) // not empty
	{
		_body.composeUINT32(userRollId);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierUserRollsOrderOneBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(userRollId);
}

const char *CashierServer::cli::CashierUserRollsOrderOneBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userRollId", userRollId);
	return _buf.c_str();
}

void CashierServer::cli::CashierUserRollsOrderOneBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userRollId", userRollId);
}

/* static */ void CashierServer::cli::CashierUserRollsOrderOneBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 userRollId; _jparser.validateByNameThrow("userRollId", userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierUserRollsOrderOneBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 userRollId; _parser0.parseUINT32(userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::clear()
{
	userRollsOrder.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::equals(const Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER& _o) const
{
	return userRollsOrder.equals(_o.userRollsOrder);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_UPDATE_USERROLLS_ORDER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_UPDATE_USERROLLS_ORDER).append(")");
	_buf.append(',');
	_buf.append("userRollsOrder=");
	userRollsOrder.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_UPDATE_USERROLLS_ORDER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	userRollsOrder.toXmlString("userRollsOrder", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userRollsOrder"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierUserRollsOrderOneBody, 4 > >::FromXmlString(_value, userRollsOrder)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	userRollsOrder.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::parseMsg(CommMsgParser& _parser)
{
	userRollsOrder.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userRollsOrder", userRollsOrder);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userRollsOrder", userRollsOrder);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_UPDATE_USERROLLS_ORDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< CashierUserRollsOrderOneBody > userRollsOrder; _jparser.validateByNameThrow("userRollsOrder", userRollsOrder);
	AtfValidator::validateIntRange(_descr, "userRollsOrder", userRollsOrder.size(), 1, 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_UPDATE_USERROLLS_ORDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUserRollsOrder = Atf::LAtfVector< CashierUserRollsOrderOneBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userRollsOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntRange(_descr, "userRollsOrder", szUserRollsOrder, 1, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::equals(const Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::clear()
{
	privsMaskToSet = 0;
	privsMaskToClear = 0;
	privs2MaskToSet = 0;
	privs2MaskToClear = 0;
	privs3MaskToSet = 0;
	privs3MaskToClear = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::equals(const Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES& _o) const
{
	return privsMaskToSet == _o.privsMaskToSet &&
		privsMaskToClear == _o.privsMaskToClear &&
		privs2MaskToSet == _o.privs2MaskToSet &&
		privs2MaskToClear == _o.privs2MaskToClear &&
		privs3MaskToSet == _o.privs3MaskToSet &&
		privs3MaskToClear == _o.privs3MaskToClear;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_USER_ALL_PRIVILEGES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USER_ALL_PRIVILEGES).append(")");
	_buf.append(',');
	_buf.append("privsMaskToSet=");
	_buf.appendUint(privsMaskToSet);
	_buf.append(',');
	_buf.append("privsMaskToClear=");
	_buf.appendUint(privsMaskToClear);
	_buf.append(',');
	_buf.append("privs2MaskToSet=");
	_buf.appendUint64(privs2MaskToSet);
	_buf.append(',');
	_buf.append("privs2MaskToClear=");
	_buf.appendUint64(privs2MaskToClear);
	_buf.append(',');
	_buf.append("privs3MaskToSet=");
	_buf.appendUint64(privs3MaskToSet);
	_buf.append(',');
	_buf.append("privs3MaskToClear=");
	_buf.appendUint64(privs3MaskToClear);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_USER_ALL_PRIVILEGES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("privsMaskToSet", privsMaskToSet, _buf);
	Atf::XmlElement::encodeAsXmlElement("privsMaskToClear", privsMaskToClear, _buf);
	Atf::XmlElement::encodeAsXmlElement("privs2MaskToSet", privs2MaskToSet, _buf);
	Atf::XmlElement::encodeAsXmlElement("privs2MaskToClear", privs2MaskToClear, _buf);
	Atf::XmlElement::encodeAsXmlElement("privs3MaskToSet", privs3MaskToSet, _buf);
	Atf::XmlElement::encodeAsXmlElement("privs3MaskToClear", privs3MaskToClear, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("privsMaskToSet"))
			{
				privsMaskToSet = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("privsMaskToClear"))
			{
				privsMaskToClear = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("privs2MaskToSet"))
			{
				privs2MaskToSet = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("privs2MaskToClear"))
			{
				privs2MaskToClear = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("privs3MaskToSet"))
			{
				privs3MaskToSet = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("privs3MaskToClear"))
			{
				privs3MaskToClear = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(privsMaskToSet);
	_msg.composeUINT32(privsMaskToClear);
	_msg.composeUINT64(privs2MaskToSet);
	_msg.composeUINT64(privs2MaskToClear);
	_msg.composeUINT64(privs3MaskToSet);
	_msg.composeUINT64(privs3MaskToClear);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(privsMaskToSet);
	_parser.parseUINT32(privsMaskToClear);
	_parser.parseUINT64(privs2MaskToSet);
	_parser.parseUINT64(privs2MaskToClear);
	_parser.parseUINT64(privs3MaskToSet);
	_parser.parseUINT64(privs3MaskToClear);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("privsMaskToSet", privsMaskToSet);
	_jsonstr.compose("privsMaskToClear", privsMaskToClear);
	_jsonstr.compose("privs2MaskToSet", privs2MaskToSet);
	_jsonstr.compose("privs2MaskToClear", privs2MaskToClear);
	_jsonstr.compose("privs3MaskToSet", privs3MaskToSet);
	_jsonstr.compose("privs3MaskToClear", privs3MaskToClear);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("privsMaskToSet", privsMaskToSet);
	_jparser.parseByNameThrow("privsMaskToClear", privsMaskToClear);
	_jparser.parseByNameThrow("privs2MaskToSet", privs2MaskToSet);
	_jparser.parseByNameThrow("privs2MaskToClear", privs2MaskToClear);
	_jparser.parseByNameThrow("privs3MaskToSet", privs3MaskToSet);
	_jparser.parseByNameThrow("privs3MaskToClear", privs3MaskToClear);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_ALL_PRIVILEGES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 privsMaskToSet; _jparser.validateByNameThrow("privsMaskToSet", privsMaskToSet);
	AtfValidator::validateInt(_descr, "privsMaskToSet", privsMaskToSet, _checker, __FILE__, __LINE__);
	UINT32 privsMaskToClear; _jparser.validateByNameThrow("privsMaskToClear", privsMaskToClear);
	AtfValidator::validateInt(_descr, "privsMaskToClear", privsMaskToClear, _checker, __FILE__, __LINE__);
	UINT64 privs2MaskToSet; _jparser.validateByNameThrow("privs2MaskToSet", privs2MaskToSet);
	AtfValidator::validateUintMax(_descr, "privs2MaskToSet", privs2MaskToSet, ((ONE64<<(priv2LastUsedBit+ONE64))-ONE64), _checker, __FILE__, __LINE__);
	UINT64 privs2MaskToClear; _jparser.validateByNameThrow("privs2MaskToClear", privs2MaskToClear);
	AtfValidator::validateUint(_descr, "privs2MaskToClear", privs2MaskToClear, _checker, __FILE__, __LINE__);
	UINT64 privs3MaskToSet; _jparser.validateByNameThrow("privs3MaskToSet", privs3MaskToSet);
	AtfValidator::validateUintMax(_descr, "privs3MaskToSet", privs3MaskToSet, ((ONE64<<(priv3LastUsedBit+ONE64))-ONE64), _checker, __FILE__, __LINE__);
	UINT64 privs3MaskToClear; _jparser.validateByNameThrow("privs3MaskToClear", privs3MaskToClear);
	AtfValidator::validateUint(_descr, "privs3MaskToClear", privs3MaskToClear, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_ALL_PRIVILEGES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 privsMaskToSet; _parser.parseUINT32(privsMaskToSet);
	AtfValidator::validateInt(_descr, "privsMaskToSet", privsMaskToSet, _checker, __FILE__, __LINE__);
	UINT32 privsMaskToClear; _parser.parseUINT32(privsMaskToClear);
	AtfValidator::validateInt(_descr, "privsMaskToClear", privsMaskToClear, _checker, __FILE__, __LINE__);
	UINT64 privs2MaskToSet; _parser.parseUINT64(privs2MaskToSet);
	AtfValidator::validateUintMax(_descr, "privs2MaskToSet", privs2MaskToSet, ((ONE64<<(priv2LastUsedBit+ONE64))-ONE64), _checker, __FILE__, __LINE__);
	UINT64 privs2MaskToClear; _parser.parseUINT64(privs2MaskToClear);
	AtfValidator::validateUint(_descr, "privs2MaskToClear", privs2MaskToClear, _checker, __FILE__, __LINE__);
	UINT64 privs3MaskToSet; _parser.parseUINT64(privs3MaskToSet);
	AtfValidator::validateUintMax(_descr, "privs3MaskToSet", privs3MaskToSet, ((ONE64<<(priv3LastUsedBit+ONE64))-ONE64), _checker, __FILE__, __LINE__);
	UINT64 privs3MaskToClear; _parser.parseUINT64(privs3MaskToClear);
	AtfValidator::validateUint(_descr, "privs3MaskToClear", privs3MaskToClear, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::equals(const Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_TEXT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::Protocol_MSG_CASHIER_GET_TEXT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::clear()
{
	getTextFlags = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::equals(const Protocol_MSG_CASHIER_GET_TEXT& _o) const
{
	return getTextFlags == _o.getTextFlags;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_TEXT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_TEXT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_TEXT).append(")");
	_buf.append(',');
	_buf.append("getTextFlags=");
	_buf.appendUint(getTextFlags);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_TEXT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("getTextFlags", getTextFlags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("getTextFlags"))
			{
				getTextFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(getTextFlags);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(getTextFlags);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("getTextFlags", getTextFlags);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("getTextFlags", getTextFlags);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEXT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 getTextFlags; _jparser.validateByNameThrow("getTextFlags", getTextFlags);
	AtfValidator::validateIntMax(_descr, "getTextFlags", getTextFlags, ((((UINT32)eCashierGetTextFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEXT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 getTextFlags; _parser.parseUINT32(getTextFlags);
	AtfValidator::validateIntMax(_descr, "getTextFlags", getTextFlags, ((((UINT32)eCashierGetTextFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierGetTextRealMoneyPopupBody
//=================================================================

CashierServer::cli::CashierGetTextRealMoneyPopupBody::CashierGetTextRealMoneyPopupBody()
{
	clear();
}

void CashierServer::cli::CashierGetTextRealMoneyPopupBody::clear()
{
	localizedTitle.clear();
	localizedText.clear();
	localizedButton.clear();
}

bool CashierServer::cli::CashierGetTextRealMoneyPopupBody::equals(const CashierGetTextRealMoneyPopupBody& _o) const
{
	return Atf::atfPStringEquals(localizedTitle, _o.localizedTitle) &&
		Atf::atfPStringEquals(localizedText, _o.localizedText) &&
		Atf::atfPStringEquals(localizedButton, _o.localizedButton);
}

const char *CashierServer::cli::CashierGetTextRealMoneyPopupBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("localizedTitle=");
	_buf.append(localizedTitle);
	_buf.append(',');
	_buf.append("localizedText=");
	_buf.append(localizedText);
	_buf.append(',');
	_buf.append("localizedButton=");
	_buf.append(localizedButton);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierGetTextRealMoneyPopupBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("localizedTitle", localizedTitle, _buf);
	Atf::XmlElement::encodeAsXmlElement("localizedText", localizedText, _buf);
	Atf::XmlElement::encodeAsXmlElement("localizedButton", localizedButton, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierGetTextRealMoneyPopupBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("localizedTitle"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, localizedTitle)) return false;
		}
		else if (_element.equals("localizedText"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, localizedText)) return false;
		}
		else if (_element.equals("localizedButton"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, localizedButton)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierGetTextRealMoneyPopupBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierGetTextRealMoneyPopupBody())) // not empty
	{
		_body.composeString(localizedTitle);
		_body.composeString(localizedText);
		_body.composeString(localizedButton);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierGetTextRealMoneyPopupBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(localizedTitle);
	_parser0.parseStringP(localizedText);
	_parser0.parseStringP(localizedButton);
}

const char *CashierServer::cli::CashierGetTextRealMoneyPopupBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("localizedTitle", localizedTitle);
	_jsonstr.compose("localizedText", localizedText);
	_jsonstr.compose("localizedButton", localizedButton);
	return _buf.c_str();
}

void CashierServer::cli::CashierGetTextRealMoneyPopupBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("localizedTitle", localizedTitle);
	_jparser.parseByNameThrow("localizedText", localizedText);
	_jparser.parseByNameThrow("localizedButton", localizedButton);
}

/* static */ void CashierServer::cli::CashierGetTextRealMoneyPopupBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString localizedTitle; _jparser.validateByNameThrow("localizedTitle", localizedTitle);
	AtfValidator::validateInt(_descr, "localizedTitle", localizedTitle.length(), _checker, __FILE__, __LINE__);
	PString localizedText; _jparser.validateByNameThrow("localizedText", localizedText);
	AtfValidator::validateInt(_descr, "localizedText", localizedText.length(), _checker, __FILE__, __LINE__);
	PString localizedButton; _jparser.validateByNameThrow("localizedButton", localizedButton);
	AtfValidator::validateInt(_descr, "localizedButton", localizedButton.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::CashierGetTextRealMoneyPopupBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "localizedTitle"); size_t szLocalizedTitle = strlen(_dummy);
	AtfValidator::validateInt(_descr, "localizedTitle", szLocalizedTitle, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "localizedText"); size_t szLocalizedText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "localizedText", szLocalizedText, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "localizedButton"); size_t szLocalizedButton = strlen(_dummy);
	AtfValidator::validateInt(_descr, "localizedButton", szLocalizedButton, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierGetTextResponseOneBody
//=================================================================

CashierServer::cli::CashierGetTextResponseOneBody::CashierGetTextResponseOneBody()
{
	clear();
}

void CashierServer::cli::CashierGetTextResponseOneBody::clear()
{
	getTextFlag = 0;
	processedOk = false;
	textData.clear();
}

bool CashierServer::cli::CashierGetTextResponseOneBody::equals(const CashierGetTextResponseOneBody& _o) const
{
	return getTextFlag == _o.getTextFlag &&
		processedOk == _o.processedOk &&
		textData.equals(_o.textData);
}

const char *CashierServer::cli::CashierGetTextResponseOneBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("getTextFlag=");
	_buf.appendInt(getTextFlag);
	_buf.append(',');
	_buf.append("processedOk=");
	_buf.appendUint(processedOk);
	_buf.append(',');
	_buf.append("textData=");
	textData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::CashierGetTextResponseOneBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("getTextFlag", getTextFlag, _buf);
	Atf::XmlElement::encodeAsXmlElement("processedOk", processedOk, _buf);
	textData.toXmlString("textData", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::CashierGetTextResponseOneBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("getTextFlag"))
		{
			getTextFlag = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("processedOk"))
		{
			processedOk = (*_value.ptr() == '1');
		}
		else if (_element.equals("textData"))
		{
			if(!Atf::AtfTempl< CashierGetTextRealMoneyPopupBody >::FromXmlString(_value, textData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::CashierGetTextResponseOneBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CashierGetTextResponseOneBody())) // not empty
	{
		_body.composeINT32(getTextFlag);
		_body.composeBOOL(processedOk);
		textData.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierGetTextResponseOneBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(getTextFlag);
	_parser0.parseBOOL(processedOk);
	textData.parseMsg(_parser0);
}

const char *CashierServer::cli::CashierGetTextResponseOneBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("getTextFlag", getTextFlag);
	_jsonstr.compose("processedOk", processedOk);
	_jsonstr.compose("textData", textData);
	return _buf.c_str();
}

void CashierServer::cli::CashierGetTextResponseOneBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("getTextFlag", getTextFlag);
	_jparser.parseByNameThrow("processedOk", processedOk);
	_jparser.parseByNameThrow("textData", textData);
}

/* static */ void CashierServer::cli::CashierGetTextResponseOneBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 getTextFlag; _jparser.validateByNameThrow("getTextFlag", getTextFlag);
	AtfValidator::validateInt(_descr, "getTextFlag", getTextFlag, _checker, __FILE__, __LINE__);
	bool processedOk; _jparser.validateByNameThrow("processedOk", processedOk);
	AtfValidator::validateInt(_descr, "processedOk", processedOk, _checker, __FILE__, __LINE__);
	CashierGetTextRealMoneyPopupBody textData; _jparser.validateByNameThrow("textData", textData);
}

/*static*/ void CashierServer::cli::CashierGetTextResponseOneBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 getTextFlag; _parser0.parseINT32(getTextFlag);
	AtfValidator::validateInt(_descr, "getTextFlag", getTextFlag, _checker, __FILE__, __LINE__);
	bool processedOk; _parser0.parseBOOL(processedOk);
	AtfValidator::validateInt(_descr, "processedOk", processedOk, _checker, __FILE__, __LINE__);
	PString _descbuf;
	CashierGetTextRealMoneyPopupBody::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("textData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_TEXT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::Protocol_MSG_CASHIER_GET_TEXT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::clear()
{
	items.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::equals(const Protocol_MSG_CASHIER_GET_TEXT_REPLY& _o) const
{
	return items.equals(_o.items);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_TEXT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_TEXT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_TEXT_REPLY).append(")");
	_buf.append(',');
	_buf.append("items=");
	items.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_TEXT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	items.toXmlString("items", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("items"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CashierGetTextResponseOneBody, 4 > >::FromXmlString(_value, items)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	items.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::parseMsg(CommMsgParser& _parser)
{
	items.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("items", items);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("items", items);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEXT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< CashierGetTextResponseOneBody > items; _jparser.validateByNameThrow("items", items);
	AtfValidator::validateInt(_descr, "items", items.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEXT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szItems = Atf::LAtfVector< CashierGetTextResponseOneBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("items"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "items", szItems, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::clear()
{
	geoIpInfo.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::equals(const Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP& _o) const
{
	return Atf::atfPStringEquals(geoIpInfo, _o.geoIpInfo);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SIGHTLINE_SIGNUP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SIGHTLINE_SIGNUP).append(")");
	_buf.append(',');
	_buf.append("geoIpInfo=");
	_buf.append(geoIpInfo);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SIGHTLINE_SIGNUP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("geoIpInfo", geoIpInfo, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("geoIpInfo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, geoIpInfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(geoIpInfo);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(geoIpInfo);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("geoIpInfo", geoIpInfo);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("geoIpInfo", geoIpInfo);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SIGHTLINE_SIGNUP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString geoIpInfo; _jparser.validateByNameThrow("geoIpInfo", geoIpInfo);
	AtfValidator::validateIntMax(_descr, "geoIpInfo", geoIpInfo.length(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SIGHTLINE_SIGNUP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "geoIpInfo"); size_t szGeoIpInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "geoIpInfo", szGeoIpInfo, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::equals(const Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::equals(const Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_VALINNARELOAD_SIGNUP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VALINNARELOAD_SIGNUP).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_VALINNARELOAD_SIGNUP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALINNARELOAD_SIGNUP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALINNARELOAD_SIGNUP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::equals(const Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::equals(const Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_VALINNARELOAD_GET_BARCODE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VALINNARELOAD_GET_BARCODE).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_VALINNARELOAD_GET_BARCODE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALINNARELOAD_GET_BARCODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALINNARELOAD_GET_BARCODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::equals(const Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::clear()
{
	status.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::equals(const Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS& _o) const
{
	return status.equals(_o.status);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_GAMETICKET_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_GAMETICKET_STATUS).append(")");
	_buf.append(',');
	_buf.append("status=");
	status.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_GAMETICKET_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	status.toXmlString("status", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("status"))
			{
				if(!Atf::AtfTempl< common_structs::SetGameTicketStatus >::FromXmlString(_value, status)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	status.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::parseMsg(CommMsgParser& _parser)
{
	status.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("status", status);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("status", status);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_GAMETICKET_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::SetGameTicketStatus status; _jparser.validateByNameThrow("status", status);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_GAMETICKET_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SetGameTicketStatus::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("status"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::clear()
{
	reply.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::equals(const Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY& _o) const
{
	return reply.equals(_o.reply);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("reply=");
	reply.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	reply.toXmlString("reply", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reply"))
			{
				if(!Atf::AtfTempl< common_structs::SetGameTicketStatusReply >::FromXmlString(_value, reply)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	reply.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	reply.parseMsg(_parser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reply", reply);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reply", reply);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::SetGameTicketStatusReply reply; _jparser.validateByNameThrow("reply", reply);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SetGameTicketStatusReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::clear()
{
	setNotRemove = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::equals(const Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION& _o) const
{
	return setNotRemove == _o.setNotRemove;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION).append(")");
	_buf.append(',');
	_buf.append("setNotRemove=");
	_buf.appendUint(setNotRemove);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("setNotRemove", setNotRemove, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("setNotRemove"))
			{
				setNotRemove = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(setNotRemove);
}

void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(setNotRemove);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("setNotRemove", setNotRemove);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("setNotRemove", setNotRemove);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool setNotRemove; _jparser.validateByNameThrow("setNotRemove", setNotRemove);
	AtfValidator::validateInt(_descr, "setNotRemove", setNotRemove, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool setNotRemove; _parser.parseBOOL(setNotRemove);
	AtfValidator::validateInt(_descr, "setNotRemove", setNotRemove, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::equals(const Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::clear()
{
	totalAmountNeeded = 0;
	currency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::equals(const Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT& _o) const
{
	return totalAmountNeeded == _o.totalAmountNeeded &&
		Atf::atfPStringEquals(currency, _o.currency);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT).append(")");
	_buf.append(',');
	_buf.append("totalAmountNeeded=");
	_buf.appendInt(totalAmountNeeded);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("totalAmountNeeded", totalAmountNeeded, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("totalAmountNeeded"))
			{
				totalAmountNeeded = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(totalAmountNeeded);
	_msg.composeString(currency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(totalAmountNeeded);
	_parser.parseStringP(currency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("totalAmountNeeded", totalAmountNeeded);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("totalAmountNeeded", totalAmountNeeded);
	_jparser.parseByNameThrow("currency", currency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 totalAmountNeeded; _jparser.validateByNameThrow("totalAmountNeeded", totalAmountNeeded);
	AtfValidator::validateIntRange(_descr, "totalAmountNeeded", totalAmountNeeded, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT32 totalAmountNeeded; _parser.parseINT32(totalAmountNeeded);
	AtfValidator::validateIntRange(_descr, "totalAmountNeeded", totalAmountNeeded, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	amountAfter = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::equals(const Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		amountAfter == _o.amountAfter;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("amountAfter=");
		_buf.appendInt(amountAfter);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("amountAfter", amountAfter, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("amountAfter"))
			{
				amountAfter = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(amountAfter);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(amountAfter);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("amountAfter", amountAfter);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("amountAfter", amountAfter);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 amountAfter; _jparser.validateByNameThrow("amountAfter", amountAfter);
		AtfValidator::validateInt(_descr, "amountAfter", amountAfter, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 amountAfter; _parser.parseINT32(amountAfter);
		AtfValidator::validateInt(_descr, "amountAfter", amountAfter, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::clear()
{
	targetCurrency.clear();
	convActionTypeInt = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::equals(const Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE& _o) const
{
	return Atf::atfPStringEquals(targetCurrency, _o.targetCurrency) &&
		convActionTypeInt == _o.convActionTypeInt;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_DENOMINATED_BALANCE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_DENOMINATED_BALANCE).append(")");
	_buf.append(',');
	_buf.append("targetCurrency=");
	_buf.append(targetCurrency);
	_buf.append(',');
	_buf.append("convActionTypeInt=");
	_buf.appendInt(convActionTypeInt);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_DENOMINATED_BALANCE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("targetCurrency", targetCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("convActionTypeInt", convActionTypeInt, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("targetCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, targetCurrency)) return false;
			}
			else if (_element.equals("convActionTypeInt"))
			{
				convActionTypeInt = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(targetCurrency);
	_msg.composeINT32(convActionTypeInt);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(targetCurrency);
	_parser.parseINT32(convActionTypeInt);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("targetCurrency", targetCurrency);
	_jsonstr.compose("convActionTypeInt", convActionTypeInt);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("targetCurrency", targetCurrency);
	_jparser.parseByNameThrow("convActionTypeInt", convActionTypeInt);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_DENOMINATED_BALANCE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString targetCurrency; _jparser.validateByNameThrow("targetCurrency", targetCurrency);
	AtfValidator::validateIntMax(_descr, "targetCurrency", targetCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 convActionTypeInt; _jparser.validateByNameThrow("convActionTypeInt", convActionTypeInt);
	AtfValidator::validateIntRange(_descr, "convActionTypeInt", convActionTypeInt, eConvActionDefault, eConvActionPoolBettingLast, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_DENOMINATED_BALANCE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "targetCurrency"); size_t szTargetCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "targetCurrency", szTargetCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 convActionTypeInt; _parser.parseINT32(convActionTypeInt);
	AtfValidator::validateIntRange(_descr, "convActionTypeInt", convActionTypeInt, eConvActionDefault, eConvActionPoolBettingLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    DenominatedBalanceOneAccBody
//=================================================================

CashierServer::cli::DenominatedBalanceOneAccBody::DenominatedBalanceOneAccBody()
{
	clear();
}

void CashierServer::cli::DenominatedBalanceOneAccBody::clear()
{
	acctCurrency.clear();
	convRate_x100M = 0;
	chips = 0;
	chipsInTC = 0;
	tChips = 0;
	tChipsInTC = 0;
}

bool CashierServer::cli::DenominatedBalanceOneAccBody::equals(const DenominatedBalanceOneAccBody& _o) const
{
	return Atf::atfPStringEquals(acctCurrency, _o.acctCurrency) &&
		convRate_x100M == _o.convRate_x100M &&
		chips == _o.chips &&
		chipsInTC == _o.chipsInTC &&
		tChips == _o.tChips &&
		tChipsInTC == _o.tChipsInTC;
}

const char *CashierServer::cli::DenominatedBalanceOneAccBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("acctCurrency=");
	_buf.append(acctCurrency);
	_buf.append(',');
	_buf.append("convRate_x100M=");
	_buf.appendInt64(convRate_x100M);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt64(chips);
	_buf.append(',');
	_buf.append("chipsInTC=");
	_buf.appendInt64(chipsInTC);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt64(tChips);
	_buf.append(',');
	_buf.append("tChipsInTC=");
	_buf.appendInt64(tChipsInTC);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::DenominatedBalanceOneAccBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("acctCurrency", acctCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("convRate_x100M", convRate_x100M, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("chipsInTC", chipsInTC, _buf);
	Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("tChipsInTC", tChipsInTC, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::DenominatedBalanceOneAccBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("acctCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, acctCurrency)) return false;
		}
		else if (_element.equals("convRate_x100M"))
		{
			convRate_x100M = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chips"))
		{
			chips = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chipsInTC"))
		{
			chipsInTC = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tChips"))
		{
			tChips = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tChipsInTC"))
		{
			tChipsInTC = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::DenominatedBalanceOneAccBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(DenominatedBalanceOneAccBody())) // not empty
	{
		_body.composeString(acctCurrency);
		_body.composeINT64(convRate_x100M);
		_body.composeINT64(chips);
		_body.composeINT64(chipsInTC);
		_body.composeINT64(tChips);
		_body.composeINT64(tChipsInTC);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::DenominatedBalanceOneAccBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(acctCurrency);
	_parser0.parseINT64(convRate_x100M);
	_parser0.parseINT64(chips);
	_parser0.parseINT64(chipsInTC);
	_parser0.parseINT64(tChips);
	_parser0.parseINT64(tChipsInTC);
}

const char *CashierServer::cli::DenominatedBalanceOneAccBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("acctCurrency", acctCurrency);
	_jsonstr.compose("convRate_x100M", convRate_x100M);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("chipsInTC", chipsInTC);
	_jsonstr.compose("tChips", tChips);
	_jsonstr.compose("tChipsInTC", tChipsInTC);
	return _buf.c_str();
}

void CashierServer::cli::DenominatedBalanceOneAccBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("acctCurrency", acctCurrency);
	_jparser.parseByNameThrow("convRate_x100M", convRate_x100M);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("chipsInTC", chipsInTC);
	_jparser.parseByNameThrow("tChips", tChips);
	_jparser.parseByNameThrow("tChipsInTC", tChipsInTC);
}

/* static */ void CashierServer::cli::DenominatedBalanceOneAccBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString acctCurrency; _jparser.validateByNameThrow("acctCurrency", acctCurrency);
	AtfValidator::validateInt(_descr, "acctCurrency", acctCurrency.length(), _checker, __FILE__, __LINE__);
	INT64 convRate_x100M; _jparser.validateByNameThrow("convRate_x100M", convRate_x100M);
	AtfValidator::validateInt(_descr, "convRate_x100M", convRate_x100M, _checker, __FILE__, __LINE__);
	INT64 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT64 chipsInTC; _jparser.validateByNameThrow("chipsInTC", chipsInTC);
	AtfValidator::validateInt(_descr, "chipsInTC", chipsInTC, _checker, __FILE__, __LINE__);
	INT64 tChips; _jparser.validateByNameThrow("tChips", tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	INT64 tChipsInTC; _jparser.validateByNameThrow("tChipsInTC", tChipsInTC);
	AtfValidator::validateInt(_descr, "tChipsInTC", tChipsInTC, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::DenominatedBalanceOneAccBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "acctCurrency"); size_t szAcctCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "acctCurrency", szAcctCurrency, _checker, __FILE__, __LINE__);
	INT64 convRate_x100M; _parser0.parseINT64(convRate_x100M);
	AtfValidator::validateInt(_descr, "convRate_x100M", convRate_x100M, _checker, __FILE__, __LINE__);
	INT64 chips; _parser0.parseINT64(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT64 chipsInTC; _parser0.parseINT64(chipsInTC);
	AtfValidator::validateInt(_descr, "chipsInTC", chipsInTC, _checker, __FILE__, __LINE__);
	INT64 tChips; _parser0.parseINT64(tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	INT64 tChipsInTC; _parser0.parseINT64(tChipsInTC);
	AtfValidator::validateInt(_descr, "tChipsInTC", tChipsInTC, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	targetCurrency.clear();
	denominatedBalanceAccs.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::equals(const Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(targetCurrency, _o.targetCurrency) &&
		denominatedBalanceAccs.equals(_o.denominatedBalanceAccs);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("targetCurrency=");
		_buf.append(targetCurrency);
		_buf.append(',');
		_buf.append("denominatedBalanceAccs=");
		denominatedBalanceAccs.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("targetCurrency", targetCurrency, _buf);
		denominatedBalanceAccs.toXmlString("denominatedBalanceAccs", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("targetCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, targetCurrency)) return false;
			}
			else if (_element.equals("denominatedBalanceAccs"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< DenominatedBalanceOneAccBody, 4 > >::FromXmlString(_value, denominatedBalanceAccs)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(targetCurrency);
		denominatedBalanceAccs.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(targetCurrency);
		denominatedBalanceAccs.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("targetCurrency", targetCurrency);
		_jsonstr.compose("denominatedBalanceAccs", denominatedBalanceAccs);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("targetCurrency", targetCurrency);
		_jparser.parseByNameThrow("denominatedBalanceAccs", denominatedBalanceAccs);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString targetCurrency; _jparser.validateByNameThrow("targetCurrency", targetCurrency);
		AtfValidator::validateInt(_descr, "targetCurrency", targetCurrency.length(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< DenominatedBalanceOneAccBody > denominatedBalanceAccs; _jparser.validateByNameThrow("denominatedBalanceAccs", denominatedBalanceAccs);
		AtfValidator::validateInt(_descr, "denominatedBalanceAccs", denominatedBalanceAccs.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "targetCurrency"); size_t szTargetCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "targetCurrency", szTargetCurrency, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szDenominatedBalanceAccs = Atf::LAtfVector< DenominatedBalanceOneAccBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("denominatedBalanceAccs"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "denominatedBalanceAccs", szDenominatedBalanceAccs, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_REGISTER
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::Protocol_MSG_CASHIER_STARSWALLET_REGISTER()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::clear()
{
	mobilePhone.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::equals(const Protocol_MSG_CASHIER_STARSWALLET_REGISTER& _o) const
{
	return Atf::atfPStringEquals(mobilePhone, _o.mobilePhone);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_STARSWALLET_REGISTER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_STARSWALLET_REGISTER*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_REGISTER).append(")");
	_buf.append(',');
	_buf.append("mobilePhone=");
	_buf.append(mobilePhone);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_STARSWALLET_REGISTER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("mobilePhone", mobilePhone, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("mobilePhone"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, mobilePhone)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(mobilePhone);
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(mobilePhone);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("mobilePhone", mobilePhone);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("mobilePhone", mobilePhone);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_REGISTER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString mobilePhone; _jparser.validateByNameThrow("mobilePhone", mobilePhone);
	AtfValidator::validateIntMax(_descr, "mobilePhone", mobilePhone.length(), USER_MOBILE_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_REGISTER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "mobilePhone"); size_t szMobilePhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "mobilePhone", szMobilePhone, USER_MOBILE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::equals(const Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_STARSWALLET_REGISTER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_REGISTER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_STARSWALLET_REGISTER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_REGISTER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_REGISTER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::clear()
{
	newMobileNumber.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::equals(const Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE& _o) const
{
	return Atf::atfPStringEquals(newMobileNumber, _o.newMobileNumber);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_STARSWALLET_CHANGE_MOBILE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_CHANGE_MOBILE).append(")");
	_buf.append(',');
	_buf.append("newMobileNumber=");
	_buf.append(newMobileNumber);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_STARSWALLET_CHANGE_MOBILE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("newMobileNumber", newMobileNumber, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("newMobileNumber"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, newMobileNumber)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(newMobileNumber);
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(newMobileNumber);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("newMobileNumber", newMobileNumber);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("newMobileNumber", newMobileNumber);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_CHANGE_MOBILE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString newMobileNumber; _jparser.validateByNameThrow("newMobileNumber", newMobileNumber);
	AtfValidator::validateIntMax(_descr, "newMobileNumber", newMobileNumber.length(), USER_MOBILE_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_CHANGE_MOBILE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "newMobileNumber"); size_t szNewMobileNumber = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "newMobileNumber", szNewMobileNumber, USER_MOBILE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::equals(const Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::equals(const Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_STARSWALLET_RESEND_OTP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_RESEND_OTP).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_STARSWALLET_RESEND_OTP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_RESEND_OTP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_RESEND_OTP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::equals(const Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::equals(const Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_STARSWALLET_OTP_RECEIVED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_OTP_RECEIVED).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_STARSWALLET_OTP_RECEIVED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_OTP_RECEIVED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_OTP_RECEIVED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::equals(const Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::clear()
{
	cashoutAmount = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::equals(const Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO& _o) const
{
	return cashoutAmount == _o.cashoutAmount;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_IND_USER_TAX_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_IND_USER_TAX_INFO).append(")");
	_buf.append(',');
	_buf.append("cashoutAmount=");
	_buf.appendInt(cashoutAmount);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_IND_USER_TAX_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("cashoutAmount", cashoutAmount, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("cashoutAmount"))
			{
				cashoutAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(cashoutAmount);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(cashoutAmount);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cashoutAmount", cashoutAmount);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cashoutAmount", cashoutAmount);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_IND_USER_TAX_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 cashoutAmount; _jparser.validateByNameThrow("cashoutAmount", cashoutAmount);
	AtfValidator::validateIntRange(_descr, "cashoutAmount", cashoutAmount, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_IND_USER_TAX_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 cashoutAmount; _parser.parseINT32(cashoutAmount);
	AtfValidator::validateIntRange(_descr, "cashoutAmount", cashoutAmount, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	taxAmount = 0;
	totalBalance = 0;
	unUsedBalance = 0;
	taxableCashout = 0;
	indiaTaxFreeCashout = 0;
	indiaTaxRate_x1M = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::equals(const Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		taxAmount == _o.taxAmount &&
		totalBalance == _o.totalBalance &&
		unUsedBalance == _o.unUsedBalance &&
		taxableCashout == _o.taxableCashout &&
		indiaTaxFreeCashout == _o.indiaTaxFreeCashout &&
		indiaTaxRate_x1M == _o.indiaTaxRate_x1M;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("taxAmount=");
		_buf.appendInt(taxAmount);
		_buf.append(',');
		_buf.append("totalBalance=");
		_buf.appendInt(totalBalance);
		_buf.append(',');
		_buf.append("unUsedBalance=");
		_buf.appendInt(unUsedBalance);
		_buf.append(',');
		_buf.append("taxableCashout=");
		_buf.appendInt(taxableCashout);
		_buf.append(',');
		_buf.append("indiaTaxFreeCashout=");
		_buf.appendInt(indiaTaxFreeCashout);
		_buf.append(',');
		_buf.append("indiaTaxRate_x1M=");
		_buf.appendInt(indiaTaxRate_x1M);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("taxAmount", taxAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("totalBalance", totalBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("unUsedBalance", unUsedBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("taxableCashout", taxableCashout, _buf);
		Atf::XmlElement::encodeAsXmlElement("indiaTaxFreeCashout", indiaTaxFreeCashout, _buf);
		Atf::XmlElement::encodeAsXmlElement("indiaTaxRate_x1M", indiaTaxRate_x1M, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("taxAmount"))
			{
				taxAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("totalBalance"))
			{
				totalBalance = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("unUsedBalance"))
			{
				unUsedBalance = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("taxableCashout"))
			{
				taxableCashout = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("indiaTaxFreeCashout"))
			{
				indiaTaxFreeCashout = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("indiaTaxRate_x1M"))
			{
				indiaTaxRate_x1M = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(taxAmount);
		_msg.composeINT32(totalBalance);
		_msg.composeINT32(unUsedBalance);
		_msg.composeINT32(taxableCashout);
		_msg.composeINT32(indiaTaxFreeCashout);
		_msg.composeINT32(indiaTaxRate_x1M);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(taxAmount);
		_parser.parseINT32(totalBalance);
		_parser.parseINT32(unUsedBalance);
		_parser.parseINT32(taxableCashout);
		_parser.parseINT32(indiaTaxFreeCashout);
		_parser.parseINT32(indiaTaxRate_x1M);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("taxAmount", taxAmount);
		_jsonstr.compose("totalBalance", totalBalance);
		_jsonstr.compose("unUsedBalance", unUsedBalance);
		_jsonstr.compose("taxableCashout", taxableCashout);
		_jsonstr.compose("indiaTaxFreeCashout", indiaTaxFreeCashout);
		_jsonstr.compose("indiaTaxRate_x1M", indiaTaxRate_x1M);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("taxAmount", taxAmount);
		_jparser.parseByNameThrow("totalBalance", totalBalance);
		_jparser.parseByNameThrow("unUsedBalance", unUsedBalance);
		_jparser.parseByNameThrow("taxableCashout", taxableCashout);
		_jparser.parseByNameThrow("indiaTaxFreeCashout", indiaTaxFreeCashout);
		_jparser.parseByNameThrow("indiaTaxRate_x1M", indiaTaxRate_x1M);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 taxAmount; _jparser.validateByNameThrow("taxAmount", taxAmount);
		AtfValidator::validateInt(_descr, "taxAmount", taxAmount, _checker, __FILE__, __LINE__);
		INT32 totalBalance; _jparser.validateByNameThrow("totalBalance", totalBalance);
		AtfValidator::validateInt(_descr, "totalBalance", totalBalance, _checker, __FILE__, __LINE__);
		INT32 unUsedBalance; _jparser.validateByNameThrow("unUsedBalance", unUsedBalance);
		AtfValidator::validateInt(_descr, "unUsedBalance", unUsedBalance, _checker, __FILE__, __LINE__);
		INT32 taxableCashout; _jparser.validateByNameThrow("taxableCashout", taxableCashout);
		AtfValidator::validateInt(_descr, "taxableCashout", taxableCashout, _checker, __FILE__, __LINE__);
		INT32 indiaTaxFreeCashout; _jparser.validateByNameThrow("indiaTaxFreeCashout", indiaTaxFreeCashout);
		AtfValidator::validateInt(_descr, "indiaTaxFreeCashout", indiaTaxFreeCashout, _checker, __FILE__, __LINE__);
		INT32 indiaTaxRate_x1M; _jparser.validateByNameThrow("indiaTaxRate_x1M", indiaTaxRate_x1M);
		AtfValidator::validateInt(_descr, "indiaTaxRate_x1M", indiaTaxRate_x1M, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 taxAmount; _parser.parseINT32(taxAmount);
		AtfValidator::validateInt(_descr, "taxAmount", taxAmount, _checker, __FILE__, __LINE__);
		INT32 totalBalance; _parser.parseINT32(totalBalance);
		AtfValidator::validateInt(_descr, "totalBalance", totalBalance, _checker, __FILE__, __LINE__);
		INT32 unUsedBalance; _parser.parseINT32(unUsedBalance);
		AtfValidator::validateInt(_descr, "unUsedBalance", unUsedBalance, _checker, __FILE__, __LINE__);
		INT32 taxableCashout; _parser.parseINT32(taxableCashout);
		AtfValidator::validateInt(_descr, "taxableCashout", taxableCashout, _checker, __FILE__, __LINE__);
		INT32 indiaTaxFreeCashout; _parser.parseINT32(indiaTaxFreeCashout);
		AtfValidator::validateInt(_descr, "indiaTaxFreeCashout", indiaTaxFreeCashout, _checker, __FILE__, __LINE__);
		INT32 indiaTaxRate_x1M; _parser.parseINT32(indiaTaxRate_x1M);
		AtfValidator::validateInt(_descr, "indiaTaxRate_x1M", indiaTaxRate_x1M, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CC_BIN_CHECK
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::Protocol_MSG_CASHIER_CC_BIN_CHECK()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::clear()
{
	cardBin.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::equals(const Protocol_MSG_CASHIER_CC_BIN_CHECK& _o) const
{
	return Atf::atfPStringEquals(cardBin, _o.cardBin);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CC_BIN_CHECK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CC_BIN_CHECK*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CC_BIN_CHECK).append(")");
	_buf.append(',');
	_buf.append("cardBin=");
	_buf.append(cardBin);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CC_BIN_CHECK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("cardBin", cardBin, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("cardBin"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, cardBin)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(cardBin);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(cardBin);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cardBin", cardBin);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cardBin", cardBin);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CC_BIN_CHECK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString cardBin; _jparser.validateByNameThrow("cardBin", cardBin);
	AtfValidator::validateIntMax(_descr, "cardBin", cardBin.length(), 100, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CC_BIN_CHECK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "cardBin"); size_t szCardBin = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cardBin", szCardBin, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	bHostile = false;
	paySystemByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::equals(const Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		bHostile == _o.bHostile &&
		paySystemByte == _o.paySystemByte;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CC_BIN_CHECK_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CC_BIN_CHECK_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("bHostile=");
		_buf.appendUint(bHostile);
		_buf.append(',');
		_buf.append("paySystemByte=");
		_buf.appendUint(paySystemByte);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CC_BIN_CHECK_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("bHostile", bHostile, _buf);
		Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("bHostile"))
			{
				bHostile = (*_value.ptr() == '1');
			}
			else if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(bHostile);
		_msg.composeBYTE(paySystemByte);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(bHostile);
		_parser.parseBYTE(paySystemByte);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("bHostile", bHostile);
		_jsonstr.compose("paySystemByte", paySystemByte);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("bHostile", bHostile);
		_jparser.parseByNameThrow("paySystemByte", paySystemByte);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CC_BIN_CHECK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool bHostile; _jparser.validateByNameThrow("bHostile", bHostile);
		AtfValidator::validateInt(_descr, "bHostile", bHostile, _checker, __FILE__, __LINE__);
		BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
		AtfValidator::validateInt(_descr, "paySystemByte", paySystemByte, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CC_BIN_CHECK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool bHostile; _parser.parseBOOL(bHostile);
		AtfValidator::validateInt(_descr, "bHostile", bHostile, _checker, __FILE__, __LINE__);
		BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
		AtfValidator::validateInt(_descr, "paySystemByte", paySystemByte, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BONUS_CHECK
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::Protocol_MSG_CASHIER_BONUS_CHECK()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::clear()
{
	paySystemByte = 0;
	bonusCode.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::equals(const Protocol_MSG_CASHIER_BONUS_CHECK& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		Atf::atfPStringEquals(bonusCode, _o.bonusCode);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_BONUS_CHECK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_BONUS_CHECK*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BONUS_CHECK).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_BONUS_CHECK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("bonusCode", bonusCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bonusCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bonusCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeString(bonusCode);
}

void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseStringP(bonusCode);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemByte", paySystemByte);
	_jsonstr.compose("bonusCode", bonusCode);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
	_jparser.parseByNameThrow("bonusCode", bonusCode);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BONUS_CHECK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	PString bonusCode; _jparser.validateByNameThrow("bonusCode", bonusCode);
	AtfValidator::validateIntMax(_descr, "bonusCode", bonusCode.length(), BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BONUS_CHECK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BONUS_CHECK_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::equals(const Protocol_MSG_CASHIER_BONUS_CHECK_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_BONUS_CHECK_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_BONUS_CHECK_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BONUS_CHECK_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_BONUS_CHECK_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BONUS_CHECK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BONUS_CHECK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::equals(const Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_NET_REPORT_BRIEF != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_NET_REPORT_BRIEF).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_NET_REPORT_BRIEF).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_NET_REPORT_BRIEF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_NET_REPORT_BRIEF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::equals(const Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	countryPrefix.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::equals(const Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(countryPrefix, _o.countryPrefix);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("countryPrefix=");
		_buf.append(countryPrefix);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("countryPrefix", countryPrefix, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("countryPrefix"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, countryPrefix)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(countryPrefix);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(countryPrefix);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("countryPrefix", countryPrefix);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("countryPrefix", countryPrefix);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString countryPrefix; _jparser.validateByNameThrow("countryPrefix", countryPrefix);
		AtfValidator::validateInt(_descr, "countryPrefix", countryPrefix.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "countryPrefix"); size_t szCountryPrefix = strlen(_dummy);
		AtfValidator::validateInt(_descr, "countryPrefix", szCountryPrefix, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::clear()
{
	balanceCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::equals(const Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE& _o) const
{
	return Atf::atfPStringEquals(balanceCurrency, _o.balanceCurrency);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_AG_OPERATOR_BALANCE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_AG_OPERATOR_BALANCE).append(")");
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_AG_OPERATOR_BALANCE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("balanceCurrency", balanceCurrency, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("balanceCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, balanceCurrency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(balanceCurrency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(balanceCurrency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("balanceCurrency", balanceCurrency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("balanceCurrency", balanceCurrency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_AG_OPERATOR_BALANCE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString balanceCurrency; _jparser.validateByNameThrow("balanceCurrency", balanceCurrency);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", balanceCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_AG_OPERATOR_BALANCE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", szBalanceCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	operatorCurrency.clear();
	operatorAmount = 0;
	balanceCurrency.clear();
	balanceAmount = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::equals(const Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(operatorCurrency, _o.operatorCurrency) &&
		operatorAmount == _o.operatorAmount &&
		Atf::atfPStringEquals(balanceCurrency, _o.balanceCurrency) &&
		balanceAmount == _o.balanceAmount;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("operatorCurrency=");
		_buf.append(operatorCurrency);
		_buf.append(',');
		_buf.append("operatorAmount=");
		_buf.appendInt64(operatorAmount);
		_buf.append(',');
		_buf.append("balanceCurrency=");
		_buf.append(balanceCurrency);
		_buf.append(',');
		_buf.append("balanceAmount=");
		_buf.appendInt64(balanceAmount);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("operatorCurrency", operatorCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("operatorAmount", operatorAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("balanceCurrency", balanceCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("balanceAmount", balanceAmount, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("operatorCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, operatorCurrency)) return false;
			}
			else if (_element.equals("operatorAmount"))
			{
				operatorAmount = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("balanceCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, balanceCurrency)) return false;
			}
			else if (_element.equals("balanceAmount"))
			{
				balanceAmount = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(operatorCurrency);
		_msg.composeINT64(operatorAmount);
		_msg.composeString(balanceCurrency);
		_msg.composeINT64(balanceAmount);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(operatorCurrency);
		_parser.parseINT64(operatorAmount);
		_parser.parseStringP(balanceCurrency);
		_parser.parseINT64(balanceAmount);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("operatorCurrency", operatorCurrency);
		_jsonstr.compose("operatorAmount", operatorAmount);
		_jsonstr.compose("balanceCurrency", balanceCurrency);
		_jsonstr.compose("balanceAmount", balanceAmount);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("operatorCurrency", operatorCurrency);
		_jparser.parseByNameThrow("operatorAmount", operatorAmount);
		_jparser.parseByNameThrow("balanceCurrency", balanceCurrency);
		_jparser.parseByNameThrow("balanceAmount", balanceAmount);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString operatorCurrency; _jparser.validateByNameThrow("operatorCurrency", operatorCurrency);
		AtfValidator::validateInt(_descr, "operatorCurrency", operatorCurrency.length(), _checker, __FILE__, __LINE__);
		INT64 operatorAmount; _jparser.validateByNameThrow("operatorAmount", operatorAmount);
		AtfValidator::validateInt(_descr, "operatorAmount", operatorAmount, _checker, __FILE__, __LINE__);
		PString balanceCurrency; _jparser.validateByNameThrow("balanceCurrency", balanceCurrency);
		AtfValidator::validateInt(_descr, "balanceCurrency", balanceCurrency.length(), _checker, __FILE__, __LINE__);
		INT64 balanceAmount; _jparser.validateByNameThrow("balanceAmount", balanceAmount);
		AtfValidator::validateInt(_descr, "balanceAmount", balanceAmount, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "operatorCurrency"); size_t szOperatorCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "operatorCurrency", szOperatorCurrency, _checker, __FILE__, __LINE__);
		INT64 operatorAmount; _parser.parseINT64(operatorAmount);
		AtfValidator::validateInt(_descr, "operatorAmount", operatorAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "balanceCurrency", szBalanceCurrency, _checker, __FILE__, __LINE__);
		INT64 balanceAmount; _parser.parseINT64(balanceAmount);
		AtfValidator::validateInt(_descr, "balanceAmount", balanceAmount, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_TRANSINFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::Protocol_MSG_CASHIER_GET_TRANSINFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::clear()
{
	transId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::equals(const Protocol_MSG_CASHIER_GET_TRANSINFO& _o) const
{
	return transId == _o.transId;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_TRANSINFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_TRANSINFO*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_TRANSINFO).append(")");
	_buf.append(',');
	_buf.append("transId=");
	_buf.appendUint(transId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_TRANSINFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("transId"))
			{
				transId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(transId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(transId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("transId", transId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("transId", transId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TRANSINFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 transId; _jparser.validateByNameThrow("transId", transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TRANSINFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 transId; _parser.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	transId = 0;
	status.clear();
	paysystemByte = 0;
	gateway.clear();
	procAmount = 0;
	procCurrency.clear();
	balanceAmount = 0;
	balanceCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::equals(const Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		transId == _o.transId &&
		Atf::atfPStringEquals(status, _o.status) &&
		paysystemByte == _o.paysystemByte &&
		Atf::atfPStringEquals(gateway, _o.gateway) &&
		procAmount == _o.procAmount &&
		Atf::atfPStringEquals(procCurrency, _o.procCurrency) &&
		balanceAmount == _o.balanceAmount &&
		Atf::atfPStringEquals(balanceCurrency, _o.balanceCurrency);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_TRANSINFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_TRANSINFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
		_buf.append(',');
		_buf.append("status=");
		_buf.append(status);
		_buf.append(',');
		_buf.append("paysystemByte=");
		_buf.appendUint(paysystemByte);
		_buf.append(',');
		_buf.append("gateway=");
		_buf.append(gateway);
		_buf.append(',');
		_buf.append("procAmount=");
		_buf.appendInt(procAmount);
		_buf.append(',');
		_buf.append("procCurrency=");
		_buf.append(procCurrency);
		_buf.append(',');
		_buf.append("balanceAmount=");
		_buf.appendInt(balanceAmount);
		_buf.append(',');
		_buf.append("balanceCurrency=");
		_buf.append(balanceCurrency);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_TRANSINFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
		Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
		Atf::XmlElement::encodeAsXmlElement("paysystemByte", paysystemByte, _buf);
		Atf::XmlElement::encodeAsXmlElement("gateway", gateway, _buf);
		Atf::XmlElement::encodeAsXmlElement("procAmount", procAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("procCurrency", procCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("balanceAmount", balanceAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("balanceCurrency", balanceCurrency, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("transId"))
			{
				transId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("status"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, status)) return false;
			}
			else if (_element.equals("paysystemByte"))
			{
				paysystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gateway"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, gateway)) return false;
			}
			else if (_element.equals("procAmount"))
			{
				procAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("procCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, procCurrency)) return false;
			}
			else if (_element.equals("balanceAmount"))
			{
				balanceAmount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("balanceCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, balanceCurrency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(transId);
		_msg.composeString(status);
		_msg.composeBYTE(paysystemByte);
		_msg.composeString(gateway);
		_msg.composeINT32(procAmount);
		_msg.composeString(procCurrency);
		_msg.composeINT32(balanceAmount);
		_msg.composeString(balanceCurrency);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(transId);
		_parser.parseStringP(status);
		_parser.parseBYTE(paysystemByte);
		_parser.parseStringP(gateway);
		_parser.parseINT32(procAmount);
		_parser.parseStringP(procCurrency);
		_parser.parseINT32(balanceAmount);
		_parser.parseStringP(balanceCurrency);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("transId", transId);
		_jsonstr.compose("status", status);
		_jsonstr.compose("paysystemByte", paysystemByte);
		_jsonstr.compose("gateway", gateway);
		_jsonstr.compose("procAmount", procAmount);
		_jsonstr.compose("procCurrency", procCurrency);
		_jsonstr.compose("balanceAmount", balanceAmount);
		_jsonstr.compose("balanceCurrency", balanceCurrency);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("transId", transId);
		_jparser.parseByNameThrow("status", status);
		_jparser.parseByNameThrow("paysystemByte", paysystemByte);
		_jparser.parseByNameThrow("gateway", gateway);
		_jparser.parseByNameThrow("procAmount", procAmount);
		_jparser.parseByNameThrow("procCurrency", procCurrency);
		_jparser.parseByNameThrow("balanceAmount", balanceAmount);
		_jparser.parseByNameThrow("balanceCurrency", balanceCurrency);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TRANSINFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _jparser.validateByNameThrow("transId", transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		PString status; _jparser.validateByNameThrow("status", status);
		AtfValidator::validateInt(_descr, "status", status.length(), _checker, __FILE__, __LINE__);
		BYTE paysystemByte; _jparser.validateByNameThrow("paysystemByte", paysystemByte);
		AtfValidator::validateInt(_descr, "paysystemByte", paysystemByte, _checker, __FILE__, __LINE__);
		PString gateway; _jparser.validateByNameThrow("gateway", gateway);
		AtfValidator::validateInt(_descr, "gateway", gateway.length(), _checker, __FILE__, __LINE__);
		INT32 procAmount; _jparser.validateByNameThrow("procAmount", procAmount);
		AtfValidator::validateInt(_descr, "procAmount", procAmount, _checker, __FILE__, __LINE__);
		PString procCurrency; _jparser.validateByNameThrow("procCurrency", procCurrency);
		AtfValidator::validateInt(_descr, "procCurrency", procCurrency.length(), _checker, __FILE__, __LINE__);
		INT32 balanceAmount; _jparser.validateByNameThrow("balanceAmount", balanceAmount);
		AtfValidator::validateInt(_descr, "balanceAmount", balanceAmount, _checker, __FILE__, __LINE__);
		PString balanceCurrency; _jparser.validateByNameThrow("balanceCurrency", balanceCurrency);
		AtfValidator::validateInt(_descr, "balanceCurrency", balanceCurrency.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TRANSINFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "status"); size_t szStatus = strlen(_dummy);
		AtfValidator::validateInt(_descr, "status", szStatus, _checker, __FILE__, __LINE__);
		BYTE paysystemByte; _parser.parseBYTE(paysystemByte);
		AtfValidator::validateInt(_descr, "paysystemByte", paysystemByte, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "gateway"); size_t szGateway = strlen(_dummy);
		AtfValidator::validateInt(_descr, "gateway", szGateway, _checker, __FILE__, __LINE__);
		INT32 procAmount; _parser.parseINT32(procAmount);
		AtfValidator::validateInt(_descr, "procAmount", procAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "procCurrency"); size_t szProcCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "procCurrency", szProcCurrency, _checker, __FILE__, __LINE__);
		INT32 balanceAmount; _parser.parseINT32(balanceAmount);
		AtfValidator::validateInt(_descr, "balanceAmount", balanceAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "balanceCurrency", szBalanceCurrency, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::clear()
{
	paySystemByte = 0;
	consentValue = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::equals(const Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		consentValue == _o.consentValue;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("consentValue=");
	_buf.appendInt(consentValue);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paySystemByte", paySystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("consentValue", consentValue, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paySystemByte"))
			{
				paySystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("consentValue"))
			{
				consentValue = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeINT32(consentValue);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseINT32(consentValue);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paySystemByte", paySystemByte);
	_jsonstr.compose("consentValue", consentValue);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paySystemByte", paySystemByte);
	_jparser.parseByNameThrow("consentValue", consentValue);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paySystemByte; _jparser.validateByNameThrow("paySystemByte", paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	INT32 consentValue; _jparser.validateByNameThrow("consentValue", consentValue);
	{ const INT32 consentValue_enum[] = {eUserPaysystemConsent_No, eUserPaysystemConsent_Yes}; AtfValidator::validateEnum(_descr, "consentValue", consentValue, consentValue_enum, _checker, __FILE__, __LINE__); }
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	INT32 consentValue; _parser.parseINT32(consentValue);
	{ const INT32 consentValue_enum[] = {eUserPaysystemConsent_No, eUserPaysystemConsent_Yes}; AtfValidator::validateEnum(_descr, "consentValue", consentValue, consentValue_enum, _checker, __FILE__, __LINE__); }
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::equals(const Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::clear()
{
	cashoutAmount = 0;
	balanceCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::equals(const Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX& _o) const
{
	return cashoutAmount == _o.cashoutAmount &&
		Atf::atfPStringEquals(balanceCurrency, _o.balanceCurrency);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX).append(")");
	_buf.append(',');
	_buf.append("cashoutAmount=");
	_buf.appendInt64(cashoutAmount);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("cashoutAmount", cashoutAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("balanceCurrency", balanceCurrency, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("cashoutAmount"))
			{
				cashoutAmount = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("balanceCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, balanceCurrency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(cashoutAmount);
	_msg.composeString(balanceCurrency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(cashoutAmount);
	_parser.parseStringP(balanceCurrency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cashoutAmount", cashoutAmount);
	_jsonstr.compose("balanceCurrency", balanceCurrency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cashoutAmount", cashoutAmount);
	_jparser.parseByNameThrow("balanceCurrency", balanceCurrency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 cashoutAmount; _jparser.validateByNameThrow("cashoutAmount", cashoutAmount);
	AtfValidator::validateIntRange(_descr, "cashoutAmount", cashoutAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString balanceCurrency; _jparser.validateByNameThrow("balanceCurrency", balanceCurrency);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", balanceCurrency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT64 cashoutAmount; _parser.parseINT64(cashoutAmount);
	AtfValidator::validateIntRange(_descr, "cashoutAmount", cashoutAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", szBalanceCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	taxAmountInBalanceCurrency = 0;
	cashoutRemainder = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::equals(const Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		taxAmountInBalanceCurrency == _o.taxAmountInBalanceCurrency &&
		cashoutRemainder == _o.cashoutRemainder;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("taxAmountInBalanceCurrency=");
		_buf.appendInt64(taxAmountInBalanceCurrency);
		_buf.append(',');
		_buf.append("cashoutRemainder=");
		_buf.appendInt64(cashoutRemainder);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("taxAmountInBalanceCurrency", taxAmountInBalanceCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("cashoutRemainder", cashoutRemainder, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("taxAmountInBalanceCurrency"))
			{
				taxAmountInBalanceCurrency = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cashoutRemainder"))
			{
				cashoutRemainder = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT64(taxAmountInBalanceCurrency);
		_msg.composeINT64(cashoutRemainder);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT64(taxAmountInBalanceCurrency);
		_parser.parseINT64(cashoutRemainder);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("taxAmountInBalanceCurrency", taxAmountInBalanceCurrency);
		_jsonstr.compose("cashoutRemainder", cashoutRemainder);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("taxAmountInBalanceCurrency", taxAmountInBalanceCurrency);
		_jparser.parseByNameThrow("cashoutRemainder", cashoutRemainder);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 taxAmountInBalanceCurrency; _jparser.validateByNameThrow("taxAmountInBalanceCurrency", taxAmountInBalanceCurrency);
		AtfValidator::validateInt(_descr, "taxAmountInBalanceCurrency", taxAmountInBalanceCurrency, _checker, __FILE__, __LINE__);
		INT64 cashoutRemainder; _jparser.validateByNameThrow("cashoutRemainder", cashoutRemainder);
		AtfValidator::validateInt(_descr, "cashoutRemainder", cashoutRemainder, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 taxAmountInBalanceCurrency; _parser.parseINT64(taxAmountInBalanceCurrency);
		AtfValidator::validateInt(_descr, "taxAmountInBalanceCurrency", taxAmountInBalanceCurrency, _checker, __FILE__, __LINE__);
		INT64 cashoutRemainder; _parser.parseINT64(cashoutRemainder);
		AtfValidator::validateInt(_descr, "cashoutRemainder", cashoutRemainder, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::equals(const Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_VANILLADIRECT_BARCODE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_VANILLADIRECT_BARCODE).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_VANILLADIRECT_BARCODE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_VANILLADIRECT_BARCODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_VANILLADIRECT_BARCODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	barcode.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::equals(const Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(barcode, _o.barcode);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("barcode=");
		_buf.append(barcode);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("barcode", barcode, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("barcode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, barcode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(barcode);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(barcode);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("barcode", barcode);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("barcode", barcode);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString barcode; _jparser.validateByNameThrow("barcode", barcode);
		AtfValidator::validateInt(_descr, "barcode", barcode.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "barcode"); size_t szBarcode = strlen(_dummy);
		AtfValidator::validateInt(_descr, "barcode", szBarcode, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::equals(const Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_STARSWALLET_RESEND_MTAN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_RESEND_MTAN).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_STARSWALLET_RESEND_MTAN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_RESEND_MTAN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_RESEND_MTAN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::equals(const Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::clear()
{
	mtan.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::equals(const Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN& _o) const
{
	return Atf::atfPStringEquals(mtan, _o.mtan);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_STARSWALLET_CHECK_MTAN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_CHECK_MTAN).append(")");
	_buf.append(',');
	_buf.append("mtan=");
	_buf.append(mtan);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_STARSWALLET_CHECK_MTAN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("mtan", mtan, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("mtan"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, mtan)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(mtan);
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(mtan);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("mtan", mtan);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("mtan", mtan);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_CHECK_MTAN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString mtan; _jparser.validateByNameThrow("mtan", mtan);
	AtfValidator::validateIntMax(_descr, "mtan", mtan.length(), 50, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_CHECK_MTAN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "mtan"); size_t szMtan = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "mtan", szMtan, 50, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::equals(const Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::clear()
{
	initiative.clear();
	validationURL.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::equals(const Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION& _o) const
{
	return Atf::atfPStringEquals(initiative, _o.initiative) &&
		Atf::atfPStringEquals(validationURL, _o.validationURL);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION).append(")");
	_buf.append(',');
	_buf.append("initiative=");
	_buf.append(initiative);
	_buf.append(',');
	_buf.append("validationURL=");
	_buf.append(validationURL);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("initiative", initiative, _buf);
	Atf::XmlElement::encodeAsXmlElement("validationURL", validationURL, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("initiative"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, initiative)) return false;
			}
			else if (_element.equals("validationURL"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, validationURL)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(initiative);
	_msg.composeString(validationURL);
}

void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(initiative);
	_parser.parseStringP(validationURL);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("initiative", initiative);
	_jsonstr.compose("validationURL", validationURL);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("initiative", initiative);
	_jparser.parseByNameThrow("validationURL", validationURL);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString initiative; _jparser.validateByNameThrow("initiative", initiative);
	AtfValidator::validateIntMax(_descr, "initiative", initiative.length(), 10000, _checker, __FILE__, __LINE__);
	PString validationURL; _jparser.validateByNameThrow("validationURL", validationURL);
	AtfValidator::validateIntMax(_descr, "validationURL", validationURL.length(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "initiative"); size_t szInitiative = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "initiative", szInitiative, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "validationURL"); size_t szValidationURL = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "validationURL", szValidationURL, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	merchantSession.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::equals(const Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(merchantSession, _o.merchantSession);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("merchantSession=");
		_buf.append(merchantSession);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("merchantSession", merchantSession, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("merchantSession"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, merchantSession)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(merchantSession);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(merchantSession);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("merchantSession", merchantSession);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("merchantSession", merchantSession);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString merchantSession; _jparser.validateByNameThrow("merchantSession", merchantSession);
		AtfValidator::validateInt(_descr, "merchantSession", merchantSession.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "merchantSession"); size_t szMerchantSession = strlen(_dummy);
		AtfValidator::validateInt(_descr, "merchantSession", szMerchantSession, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TempAccountLimitStatus
//=================================================================

CashierServer::cli::TempAccountLimitStatus::TempAccountLimitStatus()
{
	clear();
}

void CashierServer::cli::TempAccountLimitStatus::clear()
{
	limitAmount = 0;
	limitCurrency.clear();
	availAmount = 0;
	availBalanceCurrency.clear();
}

bool CashierServer::cli::TempAccountLimitStatus::equals(const TempAccountLimitStatus& _o) const
{
	return limitAmount == _o.limitAmount &&
		Atf::atfPStringEquals(limitCurrency, _o.limitCurrency) &&
		availAmount == _o.availAmount &&
		Atf::atfPStringEquals(availBalanceCurrency, _o.availBalanceCurrency);
}

const char *CashierServer::cli::TempAccountLimitStatus::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limitAmount=");
	_buf.appendInt(limitAmount);
	_buf.append(',');
	_buf.append("limitCurrency=");
	_buf.append(limitCurrency);
	_buf.append(',');
	_buf.append("availAmount=");
	_buf.appendInt(availAmount);
	_buf.append(',');
	_buf.append("availBalanceCurrency=");
	_buf.append(availBalanceCurrency);
	_buf.append('}');
	return _buf.c_str();
}

const char *CashierServer::cli::TempAccountLimitStatus::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("limitAmount", limitAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("limitCurrency", limitCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("availAmount", availAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("availBalanceCurrency", availBalanceCurrency, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CashierServer::cli::TempAccountLimitStatus::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("limitAmount"))
		{
			limitAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("limitCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, limitCurrency)) return false;
		}
		else if (_element.equals("availAmount"))
		{
			availAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("availBalanceCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, availBalanceCurrency)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CashierServer::cli::TempAccountLimitStatus::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TempAccountLimitStatus())) // not empty
	{
		_body.composeINT32(limitAmount);
		_body.composeString(limitCurrency);
		_body.composeINT32(availAmount);
		_body.composeString(availBalanceCurrency);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::TempAccountLimitStatus::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(limitAmount);
	_parser0.parseStringP(limitCurrency);
	_parser0.parseINT32(availAmount);
	_parser0.parseStringP(availBalanceCurrency);
}

const char *CashierServer::cli::TempAccountLimitStatus::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limitAmount", limitAmount);
	_jsonstr.compose("limitCurrency", limitCurrency);
	_jsonstr.compose("availAmount", availAmount);
	_jsonstr.compose("availBalanceCurrency", availBalanceCurrency);
	return _buf.c_str();
}

void CashierServer::cli::TempAccountLimitStatus::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("limitAmount", limitAmount);
	_jparser.parseByNameThrow("limitCurrency", limitCurrency);
	_jparser.parseByNameThrow("availAmount", availAmount);
	_jparser.parseByNameThrow("availBalanceCurrency", availBalanceCurrency);
}

/* static */ void CashierServer::cli::TempAccountLimitStatus::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 limitAmount; _jparser.validateByNameThrow("limitAmount", limitAmount);
	AtfValidator::validateInt(_descr, "limitAmount", limitAmount, _checker, __FILE__, __LINE__);
	PString limitCurrency; _jparser.validateByNameThrow("limitCurrency", limitCurrency);
	AtfValidator::validateInt(_descr, "limitCurrency", limitCurrency.length(), _checker, __FILE__, __LINE__);
	INT32 availAmount; _jparser.validateByNameThrow("availAmount", availAmount);
	AtfValidator::validateInt(_descr, "availAmount", availAmount, _checker, __FILE__, __LINE__);
	PString availBalanceCurrency; _jparser.validateByNameThrow("availBalanceCurrency", availBalanceCurrency);
	AtfValidator::validateInt(_descr, "availBalanceCurrency", availBalanceCurrency.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::TempAccountLimitStatus::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 limitAmount; _parser0.parseINT32(limitAmount);
	AtfValidator::validateInt(_descr, "limitAmount", limitAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "limitCurrency"); size_t szLimitCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "limitCurrency", szLimitCurrency, _checker, __FILE__, __LINE__);
	INT32 availAmount; _parser0.parseINT32(availAmount);
	AtfValidator::validateInt(_descr, "availAmount", availAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "availBalanceCurrency"); size_t szAvailBalanceCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "availBalanceCurrency", szAvailBalanceCurrency, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::equals(const Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	enabled = false;
	cashoutLimit.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::equals(const Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		enabled == _o.enabled &&
		cashoutLimit.equals(_o.cashoutLimit);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("enabled=");
		_buf.appendUint(enabled);
		_buf.append(',');
		_buf.append("cashoutLimit=");
		cashoutLimit.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("enabled", enabled, _buf);
		cashoutLimit.toXmlString("cashoutLimit", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("enabled"))
			{
				enabled = (*_value.ptr() == '1');
			}
			else if (_element.equals("cashoutLimit"))
			{
				if(!Atf::AtfTempl< TempAccountLimitStatus >::FromXmlString(_value, cashoutLimit)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(enabled);
		cashoutLimit.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(enabled);
		cashoutLimit.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("enabled", enabled);
		_jsonstr.compose("cashoutLimit", cashoutLimit);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("enabled", enabled);
		_jparser.parseByNameThrow("cashoutLimit", cashoutLimit);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool enabled; _jparser.validateByNameThrow("enabled", enabled);
		AtfValidator::validateInt(_descr, "enabled", enabled, _checker, __FILE__, __LINE__);
		TempAccountLimitStatus cashoutLimit; _jparser.validateByNameThrow("cashoutLimit", cashoutLimit);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool enabled; _parser.parseBOOL(enabled);
		AtfValidator::validateInt(_descr, "enabled", enabled, _checker, __FILE__, __LINE__);
		PString _descbuf;
		TempAccountLimitStatus::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cashoutLimit"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::equals(const Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS& _o) const
{
	return true;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	enabled = false;
	limitStatus.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::equals(const Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		enabled == _o.enabled &&
		limitStatus.equals(_o.limitStatus);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("enabled=");
		_buf.appendUint(enabled);
		_buf.append(',');
		_buf.append("limitStatus=");
		limitStatus.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("enabled", enabled, _buf);
		limitStatus.toXmlString("limitStatus", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("enabled"))
			{
				enabled = (*_value.ptr() == '1');
			}
			else if (_element.equals("limitStatus"))
			{
				if(!Atf::AtfTempl< TempAccountLimitStatus >::FromXmlString(_value, limitStatus)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(enabled);
		limitStatus.composeMsg(_msg, _ignoreJSON);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(enabled);
		limitStatus.parseMsg(_parser);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("enabled", enabled);
		_jsonstr.compose("limitStatus", limitStatus);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("enabled", enabled);
		_jparser.parseByNameThrow("limitStatus", limitStatus);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool enabled; _jparser.validateByNameThrow("enabled", enabled);
		AtfValidator::validateInt(_descr, "enabled", enabled, _checker, __FILE__, __LINE__);
		TempAccountLimitStatus limitStatus; _jparser.validateByNameThrow("limitStatus", limitStatus);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool enabled; _parser.parseBOOL(enabled);
		AtfValidator::validateInt(_descr, "enabled", enabled, _checker, __FILE__, __LINE__);
		PString _descbuf;
		TempAccountLimitStatus::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limitStatus"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::clear()
{
	transId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::equals(const Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED& _o) const
{
	return transId == _o.transId;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED).append(")");
	_buf.append(',');
	_buf.append("transId=");
	_buf.appendUint(transId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("transId", transId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("transId"))
			{
				transId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(transId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(transId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("transId", transId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("transId", transId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 transId; _jparser.validateByNameThrow("transId", transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 transId; _parser.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::equals(const Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_PLAID_DATA
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::Protocol_MSG_CASHIER_GET_PLAID_DATA()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::clear()
{
	paysystemByte = 0;
	amount = 0;
	currency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::equals(const Protocol_MSG_CASHIER_GET_PLAID_DATA& _o) const
{
	return paysystemByte == _o.paysystemByte &&
		amount == _o.amount &&
		Atf::atfPStringEquals(currency, _o.currency);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_PLAID_DATA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_PLAID_DATA*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_PLAID_DATA).append(")");
	_buf.append(',');
	_buf.append("paysystemByte=");
	_buf.appendUint(paysystemByte);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_PLAID_DATA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("paysystemByte", paysystemByte, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("paysystemByte"))
			{
				paysystemByte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("amount"))
			{
				amount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(paysystemByte);
	_msg.composeINT32(amount);
	_msg.composeString(currency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paysystemByte);
	_parser.parseINT32(amount);
	_parser.parseStringP(currency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("paysystemByte", paysystemByte);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("paysystemByte", paysystemByte);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("currency", currency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PLAID_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE paysystemByte; _jparser.validateByNameThrow("paysystemByte", paysystemByte);
	AtfValidator::validateInt(_descr, "paysystemByte", paysystemByte, _checker, __FILE__, __LINE__);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), CURRENCY_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PLAID_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE paysystemByte; _parser.parseBYTE(paysystemByte);
	AtfValidator::validateInt(_descr, "paysystemByte", paysystemByte, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	plaidEnvironment.clear();
	plaidPublicKey.clear();
	bankLookupPreference.clear();
	isPlaidAccountInSystem = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::equals(const Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(plaidEnvironment, _o.plaidEnvironment) &&
		Atf::atfPStringEquals(plaidPublicKey, _o.plaidPublicKey) &&
		Atf::atfPStringEquals(bankLookupPreference, _o.bankLookupPreference) &&
		isPlaidAccountInSystem == _o.isPlaidAccountInSystem;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_GET_PLAID_DATA_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_PLAID_DATA_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("plaidEnvironment=");
		_buf.append(plaidEnvironment);
		_buf.append(',');
		_buf.append("plaidPublicKey=");
		_buf.append(plaidPublicKey);
		_buf.append(',');
		_buf.append("bankLookupPreference=");
		_buf.append(bankLookupPreference);
		_buf.append(',');
		_buf.append("isPlaidAccountInSystem=");
		_buf.appendUint(isPlaidAccountInSystem);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_GET_PLAID_DATA_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("plaidEnvironment", plaidEnvironment, _buf);
		Atf::XmlElement::encodeAsXmlElement("plaidPublicKey", plaidPublicKey, _buf);
		Atf::XmlElement::encodeAsXmlElement("bankLookupPreference", bankLookupPreference, _buf);
		Atf::XmlElement::encodeAsXmlElement("isPlaidAccountInSystem", isPlaidAccountInSystem, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("plaidEnvironment"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, plaidEnvironment)) return false;
			}
			else if (_element.equals("plaidPublicKey"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, plaidPublicKey)) return false;
			}
			else if (_element.equals("bankLookupPreference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, bankLookupPreference)) return false;
			}
			else if (_element.equals("isPlaidAccountInSystem"))
			{
				isPlaidAccountInSystem = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(plaidEnvironment);
		_msg.composeString(plaidPublicKey);
		_msg.composeString(bankLookupPreference);
		_msg.composeBOOL(isPlaidAccountInSystem);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(plaidEnvironment);
		_parser.parseStringP(plaidPublicKey);
		_parser.parseStringP(bankLookupPreference);
		_parser.parseBOOL(isPlaidAccountInSystem);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("plaidEnvironment", plaidEnvironment);
		_jsonstr.compose("plaidPublicKey", plaidPublicKey);
		_jsonstr.compose("bankLookupPreference", bankLookupPreference);
		_jsonstr.compose("isPlaidAccountInSystem", isPlaidAccountInSystem);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("plaidEnvironment", plaidEnvironment);
		_jparser.parseByNameThrow("plaidPublicKey", plaidPublicKey);
		_jparser.parseByNameThrow("bankLookupPreference", bankLookupPreference);
		_jparser.parseByNameThrow("isPlaidAccountInSystem", isPlaidAccountInSystem);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PLAID_DATA_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString plaidEnvironment; _jparser.validateByNameThrow("plaidEnvironment", plaidEnvironment);
		AtfValidator::validateInt(_descr, "plaidEnvironment", plaidEnvironment.length(), _checker, __FILE__, __LINE__);
		PString plaidPublicKey; _jparser.validateByNameThrow("plaidPublicKey", plaidPublicKey);
		AtfValidator::validateInt(_descr, "plaidPublicKey", plaidPublicKey.length(), _checker, __FILE__, __LINE__);
		PString bankLookupPreference; _jparser.validateByNameThrow("bankLookupPreference", bankLookupPreference);
		AtfValidator::validateInt(_descr, "bankLookupPreference", bankLookupPreference.length(), _checker, __FILE__, __LINE__);
		bool isPlaidAccountInSystem; _jparser.validateByNameThrow("isPlaidAccountInSystem", isPlaidAccountInSystem);
		AtfValidator::validateInt(_descr, "isPlaidAccountInSystem", isPlaidAccountInSystem, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PLAID_DATA_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "plaidEnvironment"); size_t szPlaidEnvironment = strlen(_dummy);
		AtfValidator::validateInt(_descr, "plaidEnvironment", szPlaidEnvironment, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "plaidPublicKey"); size_t szPlaidPublicKey = strlen(_dummy);
		AtfValidator::validateInt(_descr, "plaidPublicKey", szPlaidPublicKey, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bankLookupPreference"); size_t szBankLookupPreference = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bankLookupPreference", szBankLookupPreference, _checker, __FILE__, __LINE__);
		bool isPlaidAccountInSystem; _parser.parseBOOL(isPlaidAccountInSystem);
		AtfValidator::validateInt(_descr, "isPlaidAccountInSystem", isPlaidAccountInSystem, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::clear()
{
	plaidPublicToken.clear();
	plaidBankAccountId.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::equals(const Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT& _o) const
{
	return Atf::atfPStringEquals(plaidPublicToken, _o.plaidPublicToken) &&
		Atf::atfPStringEquals(plaidBankAccountId, _o.plaidBankAccountId);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_ADD_PLAID_ACCOUNT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ADD_PLAID_ACCOUNT).append(")");
	_buf.append(',');
	_buf.append("plaidPublicToken=");
	_buf.append(plaidPublicToken);
	_buf.append(',');
	_buf.append("plaidBankAccountId=");
	_buf.append(plaidBankAccountId);
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_ADD_PLAID_ACCOUNT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("plaidPublicToken", plaidPublicToken, _buf);
	Atf::XmlElement::encodeAsXmlElement("plaidBankAccountId", plaidBankAccountId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("plaidPublicToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, plaidPublicToken)) return false;
			}
			else if (_element.equals("plaidBankAccountId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, plaidBankAccountId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(plaidPublicToken);
	_msg.composeString(plaidBankAccountId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(plaidPublicToken);
	_parser.parseStringP(plaidBankAccountId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("plaidPublicToken", plaidPublicToken);
	_jsonstr.compose("plaidBankAccountId", plaidBankAccountId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("plaidPublicToken", plaidPublicToken);
	_jparser.parseByNameThrow("plaidBankAccountId", plaidBankAccountId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ADD_PLAID_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString plaidPublicToken; _jparser.validateByNameThrow("plaidPublicToken", plaidPublicToken);
	AtfValidator::validateIntMin(_descr, "plaidPublicToken", plaidPublicToken.length(), 1, _checker, __FILE__, __LINE__);
	PString plaidBankAccountId; _jparser.validateByNameThrow("plaidBankAccountId", plaidBankAccountId);
	AtfValidator::validateIntMin(_descr, "plaidBankAccountId", plaidBankAccountId.length(), 1, _checker, __FILE__, __LINE__);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ADD_PLAID_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "plaidPublicToken"); size_t szPlaidPublicToken = strlen(_dummy);
	AtfValidator::validateIntMin(_descr, "plaidPublicToken", szPlaidPublicToken, 1, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "plaidBankAccountId"); size_t szPlaidBankAccountId = strlen(_dummy);
	AtfValidator::validateIntMin(_descr, "plaidBankAccountId", szPlaidBankAccountId, 1, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::equals(const Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY*)_other));
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_USER_LOGGED_IN
//=================================================================

CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::Protocol_MSG_CASHIER_USER_LOGGED_IN()
{
	clear();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::clear()
{
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::equals(const Protocol_MSG_CASHIER_USER_LOGGED_IN& _o) const
{
	return true;
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_USER_LOGGED_IN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_USER_LOGGED_IN*)_other));
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_USER_LOGGED_IN).append(")");
	return _buf.c_str();
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_USER_LOGGED_IN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::parseMsg(CommMsgParser& _parser)
{
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_LOGGED_IN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_LOGGED_IN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY
//=================================================================

CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY()
{
	clear();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::equals(const Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_USER_LOGGED_IN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY*)_other));
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_USER_LOGGED_IN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_USER_LOGGED_IN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_LOGGED_IN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_LOGGED_IN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USERROLL_STATUS
//=================================================================

CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::Protocol_MSG_CASHIER_SET_USERROLL_STATUS()
{
	clear();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::clear()
{
	status.clear();
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::equals(const Protocol_MSG_CASHIER_SET_USERROLL_STATUS& _o) const
{
	return status.equals(_o.status);
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_USERROLL_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_USERROLL_STATUS*)_other));
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USERROLL_STATUS).append(")");
	_buf.append(',');
	_buf.append("status=");
	status.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_USERROLL_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	status.toXmlString("status", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("status"))
			{
				if(!Atf::AtfTempl< common_structs::SetUserRollStatus >::FromXmlString(_value, status)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	status.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::parseMsg(CommMsgParser& _parser)
{
	status.parseMsg(_parser);
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("status", status);
	return _buf.c_str();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("status", status);
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USERROLL_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::SetUserRollStatus status; _jparser.validateByNameThrow("status", status);
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USERROLL_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SetUserRollStatus::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("status"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY
//=================================================================

CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY()
{
	clear();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::clear()
{
	reply.clear();
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::equals(const Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY& _o) const
{
	return reply.equals(_o.reply);
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_USERROLL_STATUS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY*)_other));
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USERROLL_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("reply=");
	reply.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_USERROLL_STATUS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	reply.toXmlString("reply", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reply"))
			{
				if(!Atf::AtfTempl< common_structs::SetUserRollStatusReply >::FromXmlString(_value, reply)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	reply.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	reply.parseMsg(_parser);
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reply", reply);
	return _buf.c_str();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reply", reply);
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USERROLL_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::SetUserRollStatusReply reply; _jparser.validateByNameThrow("reply", reply);
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USERROLL_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SetUserRollStatusReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS
//=================================================================

CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS()
{
	clear();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::clear()
{
	status.clear();
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::equals(const Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS& _o) const
{
	return status.equals(_o.status);
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_GAMETICKET_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS*)_other));
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_GAMETICKET_STATUS).append(")");
	_buf.append(',');
	_buf.append("status=");
	status.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_GAMETICKET_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	status.toXmlString("status", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("status"))
			{
				if(!Atf::AtfTempl< common_structs::SetGameTicketStatus >::FromXmlString(_value, status)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	status.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::parseMsg(CommMsgParser& _parser)
{
	status.parseMsg(_parser);
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("status", status);
	return _buf.c_str();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("status", status);
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_GAMETICKET_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::SetGameTicketStatus status; _jparser.validateByNameThrow("status", status);
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_GAMETICKET_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SetGameTicketStatus::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("status"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY
//=================================================================

CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY()
{
	clear();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::clear()
{
	reply.clear();
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::equals(const Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY& _o) const
{
	return reply.equals(_o.reply);
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY*)_other));
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("reply=");
	reply.toTraceString(_buf);
	return _buf.c_str();
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	reply.toXmlString("reply", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reply"))
			{
				if(!Atf::AtfTempl< common_structs::SetGameTicketStatusReply >::FromXmlString(_value, reply)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	reply.composeMsg(_msg, _ignoreJSON);
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	reply.parseMsg(_parser);
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reply", reply);
	return _buf.c_str();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reply", reply);
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	common_structs::SetGameTicketStatusReply reply; _jparser.validateByNameThrow("reply", reply);
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SetGameTicketStatusReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* CashierServer::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_CASHIER_3V_PREREGISTER: _obj = new cli::Protocol_MSG_CASHIER_3V_PREREGISTER(); break;
			case MSG_CASHIER_3V_PREREGISTER_REPLY: _obj = new cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY(); break;
			case MSG_CASHIER_ADD_PLAID_ACCOUNT: _obj = new cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT(); break;
			case MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY(); break;
			case MSG_CASHIER_AGEVERIVICATION2: _obj = new cli::Protocol_MSG_CASHIER_AGEVERIVICATION2(); break;
			case MSG_CASHIER_AGEVERIVICATION2_CANCEL: _obj = new cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL(); break;
			case MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY: _obj = new cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY(); break;
			case MSG_CASHIER_AGEVERIVICATION2_REPLY: _obj = new cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY(); break;
			case MSG_CASHIER_AGE_CHECK_UK: _obj = new cli::Protocol_MSG_CASHIER_AGE_CHECK_UK(); break;
			case MSG_CASHIER_AGE_CHECK_UK_REPLY: _obj = new cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY(); break;
			case MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION: _obj = new cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION(); break;
			case MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY: _obj = new cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY(); break;
			case MSG_CASHIER_ASTROPAY_CASHIN: _obj = new cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN(); break;
			case MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT: _obj = new cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT(); break;
			case MSG_CASHIER_AVLS_REQUEST: _obj = new cli::Protocol_MSG_CASHIER_AVLS_REQUEST(); break;
			case MSG_CASHIER_AVLS_REQUEST_REPLY: _obj = new cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY(); break;
			case MSG_CASHIER_BONUS_CHECK: _obj = new cli::Protocol_MSG_CASHIER_BONUS_CHECK(); break;
			case MSG_CASHIER_BONUS_CHECK_REPLY: _obj = new cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY(); break;
			case MSG_CASHIER_BPAY_REQUEST: _obj = new cli::Protocol_MSG_CASHIER_BPAY_REQUEST(); break;
			case MSG_CASHIER_BPAY_REQUEST_REPLY: _obj = new cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY(); break;
			case MSG_CASHIER_BUY_PM: _obj = new cli::Protocol_MSG_CASHIER_BUY_PM(); break;
			case MSG_CASHIER_BUY_PM_APPLE: _obj = new cli::Protocol_MSG_CASHIER_BUY_PM_APPLE(); break;
			case MSG_CASHIER_BUY_PM_APPLE_REPLY: _obj = new cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY(); break;
			case MSG_CASHIER_BUY_PM_COMPLETE: _obj = new cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE(); break;
			case MSG_CASHIER_BUY_PM_CONFIRM: _obj = new cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM(); break;
			case MSG_CASHIER_BUY_PM_GOOGLE: _obj = new cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE(); break;
			case MSG_CASHIER_BUY_PM_GOOGLE_REPLY: _obj = new cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY(); break;
			case MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX: _obj = new cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX(); break;
			case MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY: _obj = new cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY(); break;
			case MSG_CASHIER_CANCEL_PENDING_CASHOUTS: _obj = new cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS(); break;
			case MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY(); break;
			case MSG_CASHIER_CASHIN_CC: _obj = new cli::Protocol_MSG_CASHIER_CASHIN_CC(); break;
			case MSG_CASHIER_CASHIN_CC_COMPLETE: _obj = new cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE(); break;
			case MSG_CASHIER_CASHIN_CC_CONFIRM: _obj = new cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM(); break;
			case MSG_CASHIER_CASHIN_CC_REDIRECTED: _obj = new cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED(); break;
			case MSG_CASHIER_CASHIN_HOSTED: _obj = new cli::Protocol_MSG_CASHIER_CASHIN_HOSTED(); break;
			case MSG_CASHIER_CASHIN_HOSTED_REDIRECT: _obj = new cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT(); break;
			case MSG_CASHIER_CASHIN_NT: _obj = new cli::Protocol_MSG_CASHIER_CASHIN_NT(); break;
			case MSG_CASHIER_CASHIN_NT_COMPLETE: _obj = new cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE(); break;
			case MSG_CASHIER_CASHIN_NT_CONFIRM: _obj = new cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM(); break;
			case MSG_CASHIER_CASHOUT: _obj = new cli::Protocol_MSG_CASHIER_CASHOUT(); break;
			case MSG_CASHIER_CASHOUT_COMPLETE: _obj = new cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE(); break;
			case MSG_CASHIER_CC_BIN_CHECK: _obj = new cli::Protocol_MSG_CASHIER_CC_BIN_CHECK(); break;
			case MSG_CASHIER_CC_BIN_CHECK_REPLY: _obj = new cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY(); break;
			case MSG_CASHIER_CHECK_PAYSYSTEM: _obj = new cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM(); break;
			case MSG_CASHIER_CHECK_PAYSYSTEM2: _obj = new cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2(); break;
			case MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY: _obj = new cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY(); break;
			case MSG_CASHIER_CHECK_PAYSYSTEM_REPLY: _obj = new cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY(); break;
			case MSG_CASHIER_CHECK_PLI: _obj = new cli::Protocol_MSG_CASHIER_CHECK_PLI(); break;
			case MSG_CASHIER_CHECK_PLI_REPLY: _obj = new cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY(); break;
			case MSG_CASHIER_CHIPS_INFO2: _obj = new cli::Protocol_MSG_CASHIER_CHIPS_INFO2(); break;
			case MSG_CASHIER_CHIPS_INFO2_REPLY: _obj = new cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY(); break;
			case MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS: _obj = new cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS(); break;
			case MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY(); break;
			case MSG_CASHIER_CONVERT_ALL_ASSETS: _obj = new cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS(); break;
			case MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY(); break;
			case MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT: _obj = new cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT(); break;
			case MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY(); break;
			case MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT: _obj = new cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT(); break;
			case MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY(); break;
			case MSG_CASHIER_CONVRATES_SUBSET: _obj = new cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET(); break;
			case MSG_CASHIER_CONVRATES_SUBSET_REPLY: _obj = new cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY(); break;
			case MSG_CASHIER_CREATE_REDEEM_ACCOUNT: _obj = new cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT(); break;
			case MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY(); break;
			case MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER: _obj = new cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER(); break;
			case MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY: _obj = new cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY(); break;
			case MSG_CASHIER_DAD_REQUEST: _obj = new cli::Protocol_MSG_CASHIER_DAD_REQUEST(); break;
			case MSG_CASHIER_DAD_REQUEST_REPLY: _obj = new cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY(); break;
			case MSG_CASHIER_DBT_VALIDATE: _obj = new cli::Protocol_MSG_CASHIER_DBT_VALIDATE(); break;
			case MSG_CASHIER_DBT_VALIDATE_REPLY: _obj = new cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY(); break;
			case MSG_CASHIER_DELETE_CURRENCY_ACCOUNT: _obj = new cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT(); break;
			case MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY(); break;
			case MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO: _obj = new cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO(); break;
			case MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY: _obj = new cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY(); break;
			case MSG_CASHIER_DELETE_SAVED_CARD: _obj = new cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD(); break;
			case MSG_CASHIER_DELETE_SAVED_CARD_REPLY: _obj = new cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY(); break;
			case MSG_CASHIER_DEPOSIT_CHECK: _obj = new cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK(); break;
			case MSG_CASHIER_DEPOSIT_CHECK_REPLY: _obj = new cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY(); break;
			case MSG_CASHIER_ENVOY_LBT_BANK_SELECTED: _obj = new cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED(); break;
			case MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY: _obj = new cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY(); break;
			case MSG_CASHIER_ENVOY_LBT_GET_BANKS: _obj = new cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS(); break;
			case MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY(); break;
			case MSG_CASHIER_ESMIGRATION2: _obj = new cli::Protocol_MSG_CASHIER_ESMIGRATION2(); break;
			case MSG_CASHIER_ESMIGRATION2_CANCEL: _obj = new cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL(); break;
			case MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY: _obj = new cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY(); break;
			case MSG_CASHIER_ESMIGRATION2_DEPOSIT: _obj = new cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT(); break;
			case MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY(); break;
			case MSG_CASHIER_ESMIGRATION2_GET_INFO: _obj = new cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO(); break;
			case MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY: _obj = new cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY(); break;
			case MSG_CASHIER_ESMIGRATION2_REPLY: _obj = new cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY(); break;
			case MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED: _obj = new cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED(); break;
			case MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY: _obj = new cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY(); break;
			case MSG_CASHIER_FRMIGRATION: _obj = new cli::Protocol_MSG_CASHIER_FRMIGRATION(); break;
			case MSG_CASHIER_FRMIGRATION_CANCEL: _obj = new cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL(); break;
			case MSG_CASHIER_FRMIGRATION_CANCEL_REPLY: _obj = new cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY(); break;
			case MSG_CASHIER_FRMIGRATION_DEPOSIT: _obj = new cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT(); break;
			case MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY(); break;
			case MSG_CASHIER_FRMIGRATION_GET_INFO: _obj = new cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO(); break;
			case MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY: _obj = new cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY(); break;
			case MSG_CASHIER_FRMIGRATION_LIVESUPPORT: _obj = new cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT(); break;
			case MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY(); break;
			case MSG_CASHIER_FRMIGRATION_REPLY: _obj = new cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY(); break;
			case MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL: _obj = new cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL(); break;
			case MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY(); break;
			case MSG_CASHIER_GET_AG_OPERATOR_BALANCE: _obj = new cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE(); break;
			case MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY(); break;
			case MSG_CASHIER_GET_ASTROPAY_BANKINFO: _obj = new cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO(); break;
			case MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY(); break;
			case MSG_CASHIER_GET_CURRENT_USERROLLS: _obj = new cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS(); break;
			case MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY(); break;
			case MSG_CASHIER_GET_DBT_FIELDS: _obj = new cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS(); break;
			case MSG_CASHIER_GET_DBT_FIELDS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY(); break;
			case MSG_CASHIER_GET_DENOMINATED_BALANCE: _obj = new cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE(); break;
			case MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY(); break;
			case MSG_CASHIER_GET_FAST_DEPOSIT_INFO: _obj = new cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO(); break;
			case MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY(); break;
			case MSG_CASHIER_GET_IND_USER_TAX_INFO: _obj = new cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO(); break;
			case MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY(); break;
			case MSG_CASHIER_GET_NET_REPORT_BRIEF: _obj = new cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF(); break;
			case MSG_CASHIER_GET_PAYLUCKY_INFO: _obj = new cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO(); break;
			case MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY(); break;
			case MSG_CASHIER_GET_PENDING_CASHOUTS: _obj = new cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS(); break;
			case MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY(); break;
			case MSG_CASHIER_GET_PLAID_DATA: _obj = new cli::Protocol_MSG_CASHIER_GET_PLAID_DATA(); break;
			case MSG_CASHIER_GET_PLAID_DATA_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY(); break;
			case MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS: _obj = new cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS(); break;
			case MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY(); break;
			case MSG_CASHIER_GET_RESCUE_PAYSYSTEMS: _obj = new cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS(); break;
			case MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY(); break;
			case MSG_CASHIER_GET_RMF_BANKACCOUNT: _obj = new cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT(); break;
			case MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY(); break;
			case MSG_CASHIER_GET_RM_NOK_HELD_FUNDS: _obj = new cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS(); break;
			case MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY(); break;
			case MSG_CASHIER_GET_SAVED_CARDS: _obj = new cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS(); break;
			case MSG_CASHIER_GET_SAVED_CARDS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY(); break;
			case MSG_CASHIER_GET_SPENDING_LIMIT: _obj = new cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT(); break;
			case MSG_CASHIER_GET_SPENDING_LIMIT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY(); break;
			case MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS: _obj = new cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS(); break;
			case MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY(); break;
			case MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS: _obj = new cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS(); break;
			case MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY(); break;
			case MSG_CASHIER_GET_TEXT: _obj = new cli::Protocol_MSG_CASHIER_GET_TEXT(); break;
			case MSG_CASHIER_GET_TEXT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY(); break;
			case MSG_CASHIER_GET_TRANSINFO: _obj = new cli::Protocol_MSG_CASHIER_GET_TRANSINFO(); break;
			case MSG_CASHIER_GET_TRANSINFO_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY(); break;
			case MSG_CASHIER_GET_UNCLEARED_DEPOSITS2: _obj = new cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2(); break;
			case MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY(); break;
			case MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX: _obj = new cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX(); break;
			case MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY(); break;
			case MSG_CASHIER_GET_USER_LIMIT: _obj = new cli::Protocol_MSG_CASHIER_GET_USER_LIMIT(); break;
			case MSG_CASHIER_GET_USER_LIMIT_EX: _obj = new cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX(); break;
			case MSG_CASHIER_GET_USER_LIMIT_EX_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY(); break;
			case MSG_CASHIER_GET_USER_LIMIT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY(); break;
			case MSG_CASHIER_GET_USER_PRIVS: _obj = new cli::Protocol_MSG_CASHIER_GET_USER_PRIVS(); break;
			case MSG_CASHIER_GET_USER_PRIVS_2: _obj = new cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2(); break;
			case MSG_CASHIER_GET_USER_PRIVS_2_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY(); break;
			case MSG_CASHIER_GET_USER_PRIVS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY(); break;
			case MSG_CASHIER_GET_VANILLADIRECT_BARCODE: _obj = new cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE(); break;
			case MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY(); break;
			case MSG_CASHIER_GET_VANILLA_AMTCURRENCY: _obj = new cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY(); break;
			case MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY: _obj = new cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY(); break;
			case MSG_CASHIER_HISTORY2: _obj = new cli::Protocol_MSG_CASHIER_HISTORY2(); break;
			case MSG_CASHIER_HISTORY2_REPLY: _obj = new cli::Protocol_MSG_CASHIER_HISTORY2_REPLY(); break;
			case MSG_CASHIER_HOSTED_DONE: _obj = new cli::Protocol_MSG_CASHIER_HOSTED_DONE(); break;
			case MSG_CASHIER_INCREASE_PLI: _obj = new cli::Protocol_MSG_CASHIER_INCREASE_PLI(); break;
			case MSG_CASHIER_INCREASE_PLI_REPLY: _obj = new cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY(); break;
			case MSG_CASHIER_INIT_WIRECARD_DEPOSIT: _obj = new cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT(); break;
			case MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY(); break;
			case MSG_CASHIER_MBOOKERS_REDIRECTED: _obj = new cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED(); break;
			case MSG_CASHIER_NEW_CURRENCY_ACCOUNT: _obj = new cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT(); break;
			case MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY(); break;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL: _obj = new cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL(); break;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_PM: _obj = new cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM(); break;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY: _obj = new cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY(); break;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO: _obj = new cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO(); break;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY: _obj = new cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY(); break;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY: _obj = new cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY(); break;
			case MSG_CASHIER_PAYSYSTEMS_LIMITS: _obj = new cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS(); break;
			case MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY(); break;
			case MSG_CASHIER_PLAY_MONEY_REFILL: _obj = new cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL(); break;
			case MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO: _obj = new cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO(); break;
			case MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY: _obj = new cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY(); break;
			case MSG_CASHIER_PLAY_MONEY_REFILL_REPLY: _obj = new cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY(); break;
			case MSG_CASHIER_PLAY_TRANSFER: _obj = new cli::Protocol_MSG_CASHIER_PLAY_TRANSFER(); break;
			case MSG_CASHIER_PLAY_TRANSFER_REPLY: _obj = new cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY(); break;
			case MSG_CASHIER_PM_PURCH_ITEMS_AVAIL: _obj = new cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL(); break;
			case MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY: _obj = new cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY(); break;
			case MSG_CASHIER_PM_WATCH2EARN_FINISH: _obj = new cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH(); break;
			case MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY: _obj = new cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY(); break;
			case MSG_CASHIER_PM_WATCH2EARN_START: _obj = new cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START(); break;
			case MSG_CASHIER_PM_WATCH2EARN_START_REPLY: _obj = new cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY(); break;
			case MSG_CASHIER_PRE_CASHIN2: _obj = new cli::Protocol_MSG_CASHIER_PRE_CASHIN2(); break;
			case MSG_CASHIER_PRE_CASHIN2_REPLY: _obj = new cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY(); break;
			case MSG_CASHIER_PRE_CASHOUT: _obj = new cli::Protocol_MSG_CASHIER_PRE_CASHOUT(); break;
			case MSG_CASHIER_PRE_CASHOUT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY(); break;
			case MSG_CASHIER_PSTARSPAY_BANK_SELECTED: _obj = new cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED(); break;
			case MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY: _obj = new cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY(); break;
			case MSG_CASHIER_REAL_PRE_TRANSFER: _obj = new cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER(); break;
			case MSG_CASHIER_REAL_PRE_TRANSFER_REPLY: _obj = new cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY(); break;
			case MSG_CASHIER_REAL_TRANSFER: _obj = new cli::Protocol_MSG_CASHIER_REAL_TRANSFER(); break;
			case MSG_CASHIER_REAL_TRANSFER_REPLY: _obj = new cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY(); break;
			case MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS: _obj = new cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS(); break;
			case MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY(); break;
			case MSG_CASHIER_SAVED_CARD: _obj = new cli::Protocol_MSG_CASHIER_SAVED_CARD(); break;
			case MSG_CASHIER_SAVED_CARD_REPLY: _obj = new cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY(); break;
			case MSG_CASHIER_SAVE_ASTROPAY_BANKINFO: _obj = new cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO(); break;
			case MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY: _obj = new cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY(); break;
			case MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT: _obj = new cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT(); break;
			case MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY(); break;
			case MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO: _obj = new cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO(); break;
			case MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY: _obj = new cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY(); break;
			case MSG_CASHIER_SEND_USER_DOCS: _obj = new cli::Protocol_MSG_CASHIER_SEND_USER_DOCS(); break;
			case MSG_CASHIER_SEND_USER_DOCS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY(); break;
			case MSG_CASHIER_SET_DEFAULT_ACCOUNT: _obj = new cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT(); break;
			case MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY(); break;
			case MSG_CASHIER_SET_GAMETICKET_STATUS: _obj = new cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS(); break;
			case MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY(); break;
			case MSG_CASHIER_SET_RMF_BANKACCOUNT: _obj = new cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT(); break;
			case MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY(); break;
			case MSG_CASHIER_SET_SPENDING_LIMIT: _obj = new cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT(); break;
			case MSG_CASHIER_SET_SPENDING_LIMIT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY(); break;
			case MSG_CASHIER_SET_USERROLL_STATUS: _obj = new cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS(); break;
			case MSG_CASHIER_SET_USERROLL_STATUS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY(); break;
			case MSG_CASHIER_SET_USER_ALL_PRIVILEGES: _obj = new cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES(); break;
			case MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY: _obj = new cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY(); break;
			case MSG_CASHIER_SET_USER_LIMIT: _obj = new cli::Protocol_MSG_CASHIER_SET_USER_LIMIT(); break;
			case MSG_CASHIER_SET_USER_LIMIT_EX: _obj = new cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX(); break;
			case MSG_CASHIER_SET_USER_LIMIT_EX_REPLY: _obj = new cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY(); break;
			case MSG_CASHIER_SET_USER_LIMIT_REPLY: _obj = new cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY(); break;
			case MSG_CASHIER_SIGHTLINE_SIGNUP: _obj = new cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP(); break;
			case MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY: _obj = new cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY(); break;
			case MSG_CASHIER_STARSWALLET_CHANGE_MOBILE: _obj = new cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE(); break;
			case MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY: _obj = new cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY(); break;
			case MSG_CASHIER_STARSWALLET_CHECK_MTAN: _obj = new cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN(); break;
			case MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY: _obj = new cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY(); break;
			case MSG_CASHIER_STARSWALLET_OTP_RECEIVED: _obj = new cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED(); break;
			case MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY: _obj = new cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY(); break;
			case MSG_CASHIER_STARSWALLET_REGISTER: _obj = new cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER(); break;
			case MSG_CASHIER_STARSWALLET_REGISTER_REPLY: _obj = new cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY(); break;
			case MSG_CASHIER_STARSWALLET_RESEND_MTAN: _obj = new cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN(); break;
			case MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY: _obj = new cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY(); break;
			case MSG_CASHIER_STARSWALLET_RESEND_OTP: _obj = new cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP(); break;
			case MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY: _obj = new cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY(); break;
			case MSG_CASHIER_SUGGEST_PAYSYSTEMS: _obj = new cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS(); break;
			case MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY(); break;
			case MSG_CASHIER_TCHIPS_CANCELID: _obj = new cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID(); break;
			case MSG_CASHIER_TCHIPS_CANCELID_REPLY: _obj = new cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY(); break;
			case MSG_CASHIER_TCHIPS_PRECANCEL: _obj = new cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL(); break;
			case MSG_CASHIER_TCHIPS_PRECANCEL_REPLY: _obj = new cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY(); break;
			case MSG_CASHIER_TCHIPS_PRESALE: _obj = new cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE(); break;
			case MSG_CASHIER_TCHIPS_PRESALE_REPLY: _obj = new cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY(); break;
			case MSG_CASHIER_TCHIPS_SALE: _obj = new cli::Protocol_MSG_CASHIER_TCHIPS_SALE(); break;
			case MSG_CASHIER_TCHIPS_SALE_REPLY: _obj = new cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY(); break;
			case MSG_CASHIER_TCHIPS_SALE_TO_PSTARS: _obj = new cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS(); break;
			case MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY: _obj = new cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY(); break;
			case MSG_CASHIER_TSALE_GET_INFO: _obj = new cli::Protocol_MSG_CASHIER_TSALE_GET_INFO(); break;
			case MSG_CASHIER_TSALE_GET_INFO_REPLY: _obj = new cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY(); break;
			case MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION: _obj = new cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION(); break;
			case MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY: _obj = new cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY(); break;
			case MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO: _obj = new cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO(); break;
			case MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY: _obj = new cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY(); break;
			case MSG_CASHIER_UPDATE_USERROLLS_ORDER: _obj = new cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER(); break;
			case MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY: _obj = new cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY(); break;
			case MSG_CASHIER_USER_ACCT_PROC_REGISTRATION: _obj = new cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION(); break;
			case MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY: _obj = new cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY(); break;
			case MSG_CASHIER_USER_BONUSHIST_NEW: _obj = new cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW(); break;
			case MSG_CASHIER_USER_BONUSHIST_NEW_REPLY: _obj = new cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY(); break;
			case MSG_CASHIER_VALIDATION_CANCEL: _obj = new cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL(); break;
			case MSG_CASHIER_VALIDATION_CANCEL_REPLY: _obj = new cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY(); break;
			case MSG_CASHIER_VALINNARELOAD_GET_BARCODE: _obj = new cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE(); break;
			case MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY: _obj = new cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY(); break;
			case MSG_CASHIER_VALINNARELOAD_SIGNUP: _obj = new cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP(); break;
			case MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY: _obj = new cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY(); break;
			case MSG_CASHIER_VERIFY_AGE: _obj = new cli::Protocol_MSG_CASHIER_VERIFY_AGE(); break;
			case MSG_CASHIER_VERIFY_AGE_REPLY: _obj = new cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY(); break;
			case MSG_CASHIER_VIP_INFO: _obj = new cli::Protocol_MSG_CASHIER_VIP_INFO(); break;
			case MSG_CASHIER_VIP_INFO_REPLY: _obj = new cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY(); break;
			case MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO: _obj = new cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO(); break;
			case MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY: _obj = new cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY(); break;
			case MSG_CASHIER_WIRE_REQUEST: _obj = new cli::Protocol_MSG_CASHIER_WIRE_REQUEST(); break;
			case MSG_CASHIER_WIRE_REQUEST_REPLY: _obj = new cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY(); break;
		}
	}
	else if(!strcmp(_nameSpace, "cli_lite"))
	{
		switch(_msgId)
		{
			case MSG_CASHIER_SET_GAMETICKET_STATUS: _obj = new cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS(); break;
			case MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY: _obj = new cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY(); break;
			case MSG_CASHIER_SET_USERROLL_STATUS: _obj = new cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS(); break;
			case MSG_CASHIER_SET_USERROLL_STATUS_REPLY: _obj = new cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY(); break;
			case MSG_CASHIER_USER_LOGGED_IN: _obj = new cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN(); break;
			case MSG_CASHIER_USER_LOGGED_IN_REPLY: _obj = new cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool CashierServer::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_CASHIER_3V_PREREGISTER: cli::Protocol_MSG_CASHIER_3V_PREREGISTER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_3V_PREREGISTER_REPLY: cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ADD_PLAID_ACCOUNT: cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGEVERIVICATION2: cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGEVERIVICATION2_CANCEL: cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY: cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGEVERIVICATION2_REPLY: cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGE_CHECK_UK: cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGE_CHECK_UK_REPLY: cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION: cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY: cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ASTROPAY_CASHIN: cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT: cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AVLS_REQUEST: cli::Protocol_MSG_CASHIER_AVLS_REQUEST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AVLS_REQUEST_REPLY: cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BONUS_CHECK: cli::Protocol_MSG_CASHIER_BONUS_CHECK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BONUS_CHECK_REPLY: cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BPAY_REQUEST: cli::Protocol_MSG_CASHIER_BPAY_REQUEST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BPAY_REQUEST_REPLY: cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM: cli::Protocol_MSG_CASHIER_BUY_PM::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_APPLE: cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_APPLE_REPLY: cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_COMPLETE: cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_CONFIRM: cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_GOOGLE: cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_GOOGLE_REPLY: cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX: cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY: cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CANCEL_PENDING_CASHOUTS: cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY: cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_CC: cli::Protocol_MSG_CASHIER_CASHIN_CC::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_CC_COMPLETE: cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_CC_CONFIRM: cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_CC_REDIRECTED: cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_HOSTED: cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_HOSTED_REDIRECT: cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_NT: cli::Protocol_MSG_CASHIER_CASHIN_NT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_NT_COMPLETE: cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_NT_CONFIRM: cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHOUT: cli::Protocol_MSG_CASHIER_CASHOUT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHOUT_COMPLETE: cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CC_BIN_CHECK: cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CC_BIN_CHECK_REPLY: cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PAYSYSTEM: cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PAYSYSTEM2: cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY: cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PAYSYSTEM_REPLY: cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PLI: cli::Protocol_MSG_CASHIER_CHECK_PLI::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PLI_REPLY: cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHIPS_INFO2: cli::Protocol_MSG_CASHIER_CHIPS_INFO2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHIPS_INFO2_REPLY: cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS: cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY: cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_ALL_ASSETS: cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY: cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT: cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY: cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT: cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY: cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVRATES_SUBSET: cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVRATES_SUBSET_REPLY: cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CREATE_REDEEM_ACCOUNT: cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER: cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY: cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DAD_REQUEST: cli::Protocol_MSG_CASHIER_DAD_REQUEST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DAD_REQUEST_REPLY: cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DBT_VALIDATE: cli::Protocol_MSG_CASHIER_DBT_VALIDATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DBT_VALIDATE_REPLY: cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_CURRENCY_ACCOUNT: cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO: cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY: cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_SAVED_CARD: cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_SAVED_CARD_REPLY: cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DEPOSIT_CHECK: cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DEPOSIT_CHECK_REPLY: cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ENVOY_LBT_BANK_SELECTED: cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY: cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ENVOY_LBT_GET_BANKS: cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY: cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2: cli::Protocol_MSG_CASHIER_ESMIGRATION2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_CANCEL: cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY: cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_DEPOSIT: cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY: cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_GET_INFO: cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY: cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_REPLY: cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED: cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY: cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION: cli::Protocol_MSG_CASHIER_FRMIGRATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_CANCEL: cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_CANCEL_REPLY: cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_DEPOSIT: cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY: cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_GET_INFO: cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY: cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_LIVESUPPORT: cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY: cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_REPLY: cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL: cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY: cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_AG_OPERATOR_BALANCE: cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY: cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_ASTROPAY_BANKINFO: cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY: cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_CURRENT_USERROLLS: cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY: cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_DBT_FIELDS: cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_DBT_FIELDS_REPLY: cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_DENOMINATED_BALANCE: cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY: cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_FAST_DEPOSIT_INFO: cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY: cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_IND_USER_TAX_INFO: cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY: cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_NET_REPORT_BRIEF: cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PAYLUCKY_INFO: cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY: cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PENDING_CASHOUTS: cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY: cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PLAID_DATA: cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PLAID_DATA_REPLY: cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS: cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY: cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RESCUE_PAYSYSTEMS: cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY: cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RMF_BANKACCOUNT: cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RM_NOK_HELD_FUNDS: cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY: cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_SAVED_CARDS: cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_SAVED_CARDS_REPLY: cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_SPENDING_LIMIT: cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_SPENDING_LIMIT_REPLY: cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS: cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY: cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS: cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY: cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEXT: cli::Protocol_MSG_CASHIER_GET_TEXT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEXT_REPLY: cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TRANSINFO: cli::Protocol_MSG_CASHIER_GET_TRANSINFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TRANSINFO_REPLY: cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_UNCLEARED_DEPOSITS2: cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY: cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX: cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY: cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_LIMIT: cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_LIMIT_EX: cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_LIMIT_EX_REPLY: cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_LIMIT_REPLY: cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_PRIVS: cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_PRIVS_2: cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_PRIVS_2_REPLY: cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_PRIVS_REPLY: cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_VANILLADIRECT_BARCODE: cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY: cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_VANILLA_AMTCURRENCY: cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY: cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_HISTORY2: cli::Protocol_MSG_CASHIER_HISTORY2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_HISTORY2_REPLY: cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_HOSTED_DONE: cli::Protocol_MSG_CASHIER_HOSTED_DONE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_INCREASE_PLI: cli::Protocol_MSG_CASHIER_INCREASE_PLI::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_INCREASE_PLI_REPLY: cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_INIT_WIRECARD_DEPOSIT: cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY: cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_MBOOKERS_REDIRECTED: cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_NEW_CURRENCY_ACCOUNT: cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_PM: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_LIMITS: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_MONEY_REFILL: cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO: cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY: cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_MONEY_REFILL_REPLY: cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_TRANSFER: cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_TRANSFER_REPLY: cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_PURCH_ITEMS_AVAIL: cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY: cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_WATCH2EARN_FINISH: cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY: cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_WATCH2EARN_START: cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_WATCH2EARN_START_REPLY: cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PRE_CASHIN2: cli::Protocol_MSG_CASHIER_PRE_CASHIN2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PRE_CASHIN2_REPLY: cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PRE_CASHOUT: cli::Protocol_MSG_CASHIER_PRE_CASHOUT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PRE_CASHOUT_REPLY: cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PSTARSPAY_BANK_SELECTED: cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY: cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REAL_PRE_TRANSFER: cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REAL_PRE_TRANSFER_REPLY: cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REAL_TRANSFER: cli::Protocol_MSG_CASHIER_REAL_TRANSFER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REAL_TRANSFER_REPLY: cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS: cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY: cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVED_CARD: cli::Protocol_MSG_CASHIER_SAVED_CARD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVED_CARD_REPLY: cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_ASTROPAY_BANKINFO: cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY: cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT: cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY: cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO: cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY: cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SEND_USER_DOCS: cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SEND_USER_DOCS_REPLY: cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_DEFAULT_ACCOUNT: cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_GAMETICKET_STATUS: cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY: cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_RMF_BANKACCOUNT: cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_SPENDING_LIMIT: cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_SPENDING_LIMIT_REPLY: cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USERROLL_STATUS: cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USERROLL_STATUS_REPLY: cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_ALL_PRIVILEGES: cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY: cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_LIMIT: cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_LIMIT_EX: cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_LIMIT_EX_REPLY: cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_LIMIT_REPLY: cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SIGHTLINE_SIGNUP: cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY: cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_CHANGE_MOBILE: cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_CHECK_MTAN: cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_OTP_RECEIVED: cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_REGISTER: cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_REGISTER_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_RESEND_MTAN: cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_RESEND_OTP: cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SUGGEST_PAYSYSTEMS: cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY: cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_CANCELID: cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_CANCELID_REPLY: cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_PRECANCEL: cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_PRECANCEL_REPLY: cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_PRESALE: cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_PRESALE_REPLY: cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_SALE: cli::Protocol_MSG_CASHIER_TCHIPS_SALE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_SALE_REPLY: cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_SALE_TO_PSTARS: cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY: cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TSALE_GET_INFO: cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TSALE_GET_INFO_REPLY: cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION: cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY: cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO: cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY: cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_UPDATE_USERROLLS_ORDER: cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY: cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_ACCT_PROC_REGISTRATION: cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY: cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_BONUSHIST_NEW: cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_BONUSHIST_NEW_REPLY: cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALIDATION_CANCEL: cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALIDATION_CANCEL_REPLY: cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALINNARELOAD_GET_BARCODE: cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY: cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALINNARELOAD_SIGNUP: cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY: cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VERIFY_AGE: cli::Protocol_MSG_CASHIER_VERIFY_AGE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VERIFY_AGE_REPLY: cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VIP_INFO: cli::Protocol_MSG_CASHIER_VIP_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VIP_INFO_REPLY: cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO: cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY: cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_WIRE_REQUEST: cli::Protocol_MSG_CASHIER_WIRE_REQUEST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_WIRE_REQUEST_REPLY: cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli_lite"))
	{
		switch(_msgId)
		{
			case MSG_CASHIER_SET_GAMETICKET_STATUS: cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY: cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USERROLL_STATUS: cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USERROLL_STATUS_REPLY: cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_LOGGED_IN: cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_LOGGED_IN_REPLY: cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool CashierServer::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_CASHIER_3V_PREREGISTER: cli::Protocol_MSG_CASHIER_3V_PREREGISTER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_3V_PREREGISTER_REPLY: cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ADD_PLAID_ACCOUNT: cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGEVERIVICATION2: cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGEVERIVICATION2_CANCEL: cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY: cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGEVERIVICATION2_REPLY: cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGE_CHECK_UK: cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGE_CHECK_UK_REPLY: cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION: cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY: cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ASTROPAY_CASHIN: cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT: cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AVLS_REQUEST: cli::Protocol_MSG_CASHIER_AVLS_REQUEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AVLS_REQUEST_REPLY: cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BONUS_CHECK: cli::Protocol_MSG_CASHIER_BONUS_CHECK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BONUS_CHECK_REPLY: cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BPAY_REQUEST: cli::Protocol_MSG_CASHIER_BPAY_REQUEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BPAY_REQUEST_REPLY: cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM: cli::Protocol_MSG_CASHIER_BUY_PM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_APPLE: cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_APPLE_REPLY: cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_COMPLETE: cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_CONFIRM: cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_GOOGLE: cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_GOOGLE_REPLY: cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX: cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY: cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CANCEL_PENDING_CASHOUTS: cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY: cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_CC: cli::Protocol_MSG_CASHIER_CASHIN_CC::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_CC_COMPLETE: cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_CC_CONFIRM: cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_CC_REDIRECTED: cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_HOSTED: cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_HOSTED_REDIRECT: cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_NT: cli::Protocol_MSG_CASHIER_CASHIN_NT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_NT_COMPLETE: cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_NT_CONFIRM: cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHOUT: cli::Protocol_MSG_CASHIER_CASHOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHOUT_COMPLETE: cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CC_BIN_CHECK: cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CC_BIN_CHECK_REPLY: cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PAYSYSTEM: cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PAYSYSTEM2: cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY: cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PAYSYSTEM_REPLY: cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PLI: cli::Protocol_MSG_CASHIER_CHECK_PLI::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PLI_REPLY: cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHIPS_INFO2: cli::Protocol_MSG_CASHIER_CHIPS_INFO2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHIPS_INFO2_REPLY: cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS: cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY: cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_ALL_ASSETS: cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY: cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT: cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY: cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT: cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY: cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVRATES_SUBSET: cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVRATES_SUBSET_REPLY: cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CREATE_REDEEM_ACCOUNT: cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER: cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY: cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DAD_REQUEST: cli::Protocol_MSG_CASHIER_DAD_REQUEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DAD_REQUEST_REPLY: cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DBT_VALIDATE: cli::Protocol_MSG_CASHIER_DBT_VALIDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DBT_VALIDATE_REPLY: cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_CURRENCY_ACCOUNT: cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO: cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY: cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_SAVED_CARD: cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_SAVED_CARD_REPLY: cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DEPOSIT_CHECK: cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DEPOSIT_CHECK_REPLY: cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ENVOY_LBT_BANK_SELECTED: cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY: cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ENVOY_LBT_GET_BANKS: cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY: cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2: cli::Protocol_MSG_CASHIER_ESMIGRATION2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_CANCEL: cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY: cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_DEPOSIT: cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY: cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_GET_INFO: cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY: cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_REPLY: cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED: cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY: cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION: cli::Protocol_MSG_CASHIER_FRMIGRATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_CANCEL: cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_CANCEL_REPLY: cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_DEPOSIT: cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY: cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_GET_INFO: cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY: cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_LIVESUPPORT: cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY: cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_REPLY: cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL: cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY: cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_AG_OPERATOR_BALANCE: cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY: cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_ASTROPAY_BANKINFO: cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY: cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_CURRENT_USERROLLS: cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY: cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_DBT_FIELDS: cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_DBT_FIELDS_REPLY: cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_DENOMINATED_BALANCE: cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY: cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_FAST_DEPOSIT_INFO: cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY: cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_IND_USER_TAX_INFO: cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY: cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_NET_REPORT_BRIEF: cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PAYLUCKY_INFO: cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY: cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PENDING_CASHOUTS: cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY: cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PLAID_DATA: cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PLAID_DATA_REPLY: cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS: cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY: cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RESCUE_PAYSYSTEMS: cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY: cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RMF_BANKACCOUNT: cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RM_NOK_HELD_FUNDS: cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY: cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_SAVED_CARDS: cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_SAVED_CARDS_REPLY: cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_SPENDING_LIMIT: cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_SPENDING_LIMIT_REPLY: cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS: cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY: cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS: cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY: cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEXT: cli::Protocol_MSG_CASHIER_GET_TEXT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEXT_REPLY: cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TRANSINFO: cli::Protocol_MSG_CASHIER_GET_TRANSINFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TRANSINFO_REPLY: cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_UNCLEARED_DEPOSITS2: cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY: cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX: cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY: cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_LIMIT: cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_LIMIT_EX: cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_LIMIT_EX_REPLY: cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_LIMIT_REPLY: cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_PRIVS: cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_PRIVS_2: cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_PRIVS_2_REPLY: cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_PRIVS_REPLY: cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_VANILLADIRECT_BARCODE: cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY: cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_VANILLA_AMTCURRENCY: cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY: cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_HISTORY2: cli::Protocol_MSG_CASHIER_HISTORY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_HISTORY2_REPLY: cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_HOSTED_DONE: cli::Protocol_MSG_CASHIER_HOSTED_DONE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_INCREASE_PLI: cli::Protocol_MSG_CASHIER_INCREASE_PLI::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_INCREASE_PLI_REPLY: cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_INIT_WIRECARD_DEPOSIT: cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY: cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_MBOOKERS_REDIRECTED: cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_NEW_CURRENCY_ACCOUNT: cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_PM: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_LIMITS: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_MONEY_REFILL: cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO: cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY: cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_MONEY_REFILL_REPLY: cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_TRANSFER: cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_TRANSFER_REPLY: cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_PURCH_ITEMS_AVAIL: cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY: cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_WATCH2EARN_FINISH: cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY: cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_WATCH2EARN_START: cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_WATCH2EARN_START_REPLY: cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PRE_CASHIN2: cli::Protocol_MSG_CASHIER_PRE_CASHIN2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PRE_CASHIN2_REPLY: cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PRE_CASHOUT: cli::Protocol_MSG_CASHIER_PRE_CASHOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PRE_CASHOUT_REPLY: cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PSTARSPAY_BANK_SELECTED: cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY: cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REAL_PRE_TRANSFER: cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REAL_PRE_TRANSFER_REPLY: cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REAL_TRANSFER: cli::Protocol_MSG_CASHIER_REAL_TRANSFER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REAL_TRANSFER_REPLY: cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS: cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY: cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVED_CARD: cli::Protocol_MSG_CASHIER_SAVED_CARD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVED_CARD_REPLY: cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_ASTROPAY_BANKINFO: cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY: cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT: cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY: cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO: cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY: cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SEND_USER_DOCS: cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SEND_USER_DOCS_REPLY: cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_DEFAULT_ACCOUNT: cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_GAMETICKET_STATUS: cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY: cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_RMF_BANKACCOUNT: cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_SPENDING_LIMIT: cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_SPENDING_LIMIT_REPLY: cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USERROLL_STATUS: cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USERROLL_STATUS_REPLY: cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_ALL_PRIVILEGES: cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY: cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_LIMIT: cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_LIMIT_EX: cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_LIMIT_EX_REPLY: cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_LIMIT_REPLY: cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SIGHTLINE_SIGNUP: cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY: cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_CHANGE_MOBILE: cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_CHECK_MTAN: cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_OTP_RECEIVED: cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_REGISTER: cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_REGISTER_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_RESEND_MTAN: cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_RESEND_OTP: cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SUGGEST_PAYSYSTEMS: cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY: cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_CANCELID: cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_CANCELID_REPLY: cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_PRECANCEL: cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_PRECANCEL_REPLY: cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_PRESALE: cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_PRESALE_REPLY: cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_SALE: cli::Protocol_MSG_CASHIER_TCHIPS_SALE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_SALE_REPLY: cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_SALE_TO_PSTARS: cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY: cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TSALE_GET_INFO: cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TSALE_GET_INFO_REPLY: cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION: cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY: cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO: cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY: cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_UPDATE_USERROLLS_ORDER: cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY: cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_ACCT_PROC_REGISTRATION: cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY: cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_BONUSHIST_NEW: cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_BONUSHIST_NEW_REPLY: cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALIDATION_CANCEL: cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALIDATION_CANCEL_REPLY: cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALINNARELOAD_GET_BARCODE: cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY: cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALINNARELOAD_SIGNUP: cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY: cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VERIFY_AGE: cli::Protocol_MSG_CASHIER_VERIFY_AGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VERIFY_AGE_REPLY: cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VIP_INFO: cli::Protocol_MSG_CASHIER_VIP_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VIP_INFO_REPLY: cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO: cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY: cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_WIRE_REQUEST: cli::Protocol_MSG_CASHIER_WIRE_REQUEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_WIRE_REQUEST_REPLY: cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli_lite"))
	{
		switch(_msgId)
		{
			case MSG_CASHIER_SET_GAMETICKET_STATUS: cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY: cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USERROLL_STATUS: cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USERROLL_STATUS_REPLY: cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_LOGGED_IN: cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_LOGGED_IN_REPLY: cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

