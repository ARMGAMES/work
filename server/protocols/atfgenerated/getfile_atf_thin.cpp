/**
 * getfile_atf_thin.cpp
 *
 * This file was auto-generated from getfile_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin getfile_atf.txt
 */
 
#include "getfile_atf_thin.h"

//=================================================================
//                Protocol_MSG_GET_FILE_CHUNK
//=================================================================

GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::Protocol_MSG_GET_FILE_CHUNK()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::Protocol_MSG_GET_FILE_CHUNK(Protocol_MSG_GET_FILE_CHUNK&& _o)
	: client_reqId(std::move(_o.client_reqId))
	, filePath(std::move(_o.filePath))
	, offset(std::move(_o.offset))
	, verInfo(std::move(_o.verInfo))
{
}

GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK& GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::operator=(Protocol_MSG_GET_FILE_CHUNK&& _o)
{
	if(this != &_o)
	{
		client_reqId = std::move(_o.client_reqId);
		filePath = std::move(_o.filePath);
		offset = std::move(_o.offset);
		verInfo = std::move(_o.verInfo);
	}
	return *this;
}

#endif

void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::clear()
{
	client_reqId = 0;
	filePath.clear();
	offset = 0;
	verInfo.clear();
}

bool GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::equals(const Protocol_MSG_GET_FILE_CHUNK& _o) const
{
	return client_reqId == _o.client_reqId &&
		filePath.equals(_o.filePath) &&
		offset == _o.offset &&
		verInfo.equals(_o.verInfo);
}

const char *GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_GET_FILE_CHUNK).append(")");
	_buf.append(',');
	_buf.append("client_reqId=");
	_buf.appendUint(client_reqId);
	_buf.append(',');
	_buf.append("filePath=");
	_buf.append(filePath);
	_buf.append(',');
	_buf.append("offset=");
	_buf.appendUint(offset);
	_buf.append(',');
	_buf.append("verInfo=");
	_buf.append(verInfo);
	return _buf.c_str();
}

void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(client_reqId);
	_msg.composeString(filePath);
	_msg.composeUINT32(offset);
	_msg.composeString(verInfo);
}

void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(client_reqId);
	_parser.parseStringP(filePath);
	_parser.parseUINT32(offset);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(verInfo);
}

/*static*/ void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_GET_FILE_CHUNK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 client_reqId; _parser.parseUINT32(client_reqId);
	AtfValidator::validateInt(_descr, "client_reqId", client_reqId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "filePath"); size_t szFilePath = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "filePath", szFilePath, 100, _checker, __FILE__, __LINE__);
	UINT32 offset; _parser.parseUINT32(offset);
	AtfValidator::validateIntMax(_descr, "offset", offset, 500000000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "verInfo"); size_t szVerInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "verInfo", szVerInfo, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_GET_FILE_CHUNK_REPLY
//=================================================================

GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::Protocol_MSG_GET_FILE_CHUNK_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::Protocol_MSG_GET_FILE_CHUNK_REPLY(Protocol_MSG_GET_FILE_CHUNK_REPLY&& _o)
	: client_reqId(std::move(_o.client_reqId))
	, error(std::move(_o.error))
	, errMsg(std::move(_o.errMsg))
	, fileLength(std::move(_o.fileLength))
	, isLast(std::move(_o.isLast))
	, chunk(std::move(_o.chunk))
{
}

GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY& GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::operator=(Protocol_MSG_GET_FILE_CHUNK_REPLY&& _o)
{
	if(this != &_o)
	{
		client_reqId = std::move(_o.client_reqId);
		error = std::move(_o.error);
		errMsg = std::move(_o.errMsg);
		fileLength = std::move(_o.fileLength);
		isLast = std::move(_o.isLast);
		chunk = std::move(_o.chunk);
	}
	return *this;
}

#endif

void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::clear()
{
	client_reqId = 0;
	error = 0;
	errMsg.clear();
	fileLength = 0;
	isLast = 0;
	chunk.clear();
}

bool GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::equals(const Protocol_MSG_GET_FILE_CHUNK_REPLY& _o) const
{
	return client_reqId == _o.client_reqId &&
		error == _o.error &&
		errMsg.equals(_o.errMsg) &&
		fileLength == _o.fileLength &&
		isLast == _o.isLast &&
		chunk.size() == _o.chunk.size() && memcmp(chunk.ptr(), _o.chunk.ptr(), chunk.size()) == 0;
}

const char *GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_GET_FILE_CHUNK_REPLY).append(")");
	_buf.append(',');
	_buf.append("client_reqId=");
	_buf.appendUint(client_reqId);
	_buf.append(',');
	_buf.append("error=");
	_buf.appendUint(error);
	if (error)
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	else
	{
		_buf.append(',');
		_buf.append("fileLength=");
		_buf.appendUint(fileLength);
		_buf.append(',');
		_buf.append("isLast=");
		_buf.appendUint(isLast);
		_buf.append(',');
		_buf.append("chunk=");
		ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, chunk);
	}
	return _buf.c_str();
}

void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(client_reqId);
	_msg.composeUINT16(error);
	if (error)
	{
		_msg.composeString(errMsg);
	}
	else
	{
		_msg.composeUINT32(fileLength);
		_msg.composeBYTE(isLast);
		_msg._composeVarBlock(chunk.ptr(), chunk.size());
	}
}

void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(client_reqId);
	_parser.parseUINT16(error);
	if (error)
	{
		_parser.parseStringP(errMsg);
	}
	else
	{
		_parser.parseUINT32(fileLength);
		_parser.parseBYTE(isLast);
		_parser.parsePBlock(chunk);
	}
}

/*static*/ void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_GET_FILE_CHUNK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 error = 0;
	UINT32 client_reqId; _parser.parseUINT32(client_reqId);
	AtfValidator::validateInt(_descr, "client_reqId", client_reqId, _checker, __FILE__, __LINE__);
	_parser.parseUINT16(error);
	AtfValidator::validateInt(_descr, "error", error, _checker, __FILE__, __LINE__);
	if (error)
	{
		_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 fileLength; _parser.parseUINT32(fileLength);
		AtfValidator::validateInt(_descr, "fileLength", fileLength, _checker, __FILE__, __LINE__);
		BYTE isLast; _parser.parseBYTE(isLast);
		AtfValidator::validateInt(_descr, "isLast", isLast, _checker, __FILE__, __LINE__);
		const BYTE* chunk; size_t szChunk; _parser._parseVarBlock(chunk, szChunk);  /*chunk*/
		AtfValidator::validateInt(_descr, "chunk", szChunk, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool GetFile::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "getfile_client"))
	{
		switch(_msgId)
		{
			case MSG_GET_FILE_CHUNK: getfile_client::Protocol_MSG_GET_FILE_CHUNK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_GET_FILE_CHUNK_REPLY: getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

