#include "UserDefStructs.h"
#include "brands.h"
#include "dbm.h"


#define TOP_LEVEL_NAMESPACE   BrandProt   	// @no_thin_version
#define TOP_LEVEL_NAMESPACE   BrandProtThin	// @only_thin_version


MsgBodyStruct AvatarImg
{
	// new members must be composed at the end and parsed with parseEnded() condition
	INT16 avatarGameType max eAvatarGameType_Last;
	UINT32 imageId;
};

MsgBodyStruct BrandImg
{
	// new members must be composed at the end and parsed with parseEnded() condition
	UINT32 brand;
	UINT32 imageId;
	vector<AvatarImg> avatars parseEndOptB4Me;
};

MsgBodyStruct BrandImageList
{
	// new members must be composed at the end and parsed with parseEnded() condition
	vector< BrandImg > images;

	@Override size_t size() const
	{
		return images.size();
	}

	@Override void addOrUpdate(UINT32 brand, UINT32 imageId)
	{
		for(size_t i = 0; i < images.size(); ++i)
		{
			if(images[i].brand == brand)
			{
				images[i].imageId = imageId;
				return;
			}
		}

		BrandImg img;
		img.brand = brand;
		img.imageId = imageId;

		images.push_back(img);
	}
	
	@Override void addAvatar(UINT32 brand, UINT32 avatarGameType, UINT32 imageId)
	{
		for(size_t i = 0; i < images.size(); ++i)
		{
			if(images[i].brand == brand)
			{
				AvatarImg avatar;
				avatar.avatarGameType = static_cast< INT16 >( avatarGameType );
				avatar.imageId = imageId;
				images[i].avatars.push_back(avatar);
				return;
			}
		}
		
		BrandImg img;
		img.brand = brand;
		AvatarImg avatar;
		avatar.avatarGameType = static_cast< INT16 >( avatarGameType );
		avatar.imageId = imageId;
		img.avatars.push_back(avatar);
		images.push_back(img);
	}

	@Override UINT32 getAvatar(UINT32 brand, INT16 avatarGameType = eAvatarGameType_Undefined) const
	{
		UINT32 imageId = 0;

		if (avatarGameType != eAvatarGameType_Invalid)
		{
			for (auto&& image : images)
			{
				if (avatarGameType != eAvatarGameType_Undefined)
				{
					if (image.brand == brand)
					{
						for (auto&& avatar : image.avatars)
						{
							if (avatar.avatarGameType == avatarGameType)
								return avatar.imageId;
						}
					}
				}
				else if (image.imageId)
				{
					if (image.brand == brand)
						return image.imageId;

					imageId = image.imageId;
				}
			}
		}

		return imageId;
	}

	@Override void compose(CommMsgBody& msg) const
	{
		composeMsg(msg);
	}

	@Override void parse(CommMsgParser& parser)
	{
		parseMsg(parser);
	}

	@Override void swap(BrandImageList& other)
	{
		images.swap(other.images);
	}

	@Override
	void composeMsgForPublication(bool hasShowImagePriv, UINT32 pokerStarsImageIdToBePublish, BrandImageList& brandImageList) const
	{
		if( hasShowImagePriv )
		{
			if(size() == 0 && pokerStarsImageIdToBePublish != 0)
			{
				brandImageList.clear();
				brandImageList.addOrUpdate(BrandType_PokerStars, pokerStarsImageIdToBePublish);
			}
			else
			{
				// assume pokerstars image is already there
				brandImageList = *this;
			}
		}
		else  // no privilege to show the pokerstars image
		{
			if(size() == 0)
			{
				brandImageList = *this;
			}
			else
			{
				brandImageList.clear();
				
				// only publish fulltilt image
				for(size_t i = 0; i < images.size(); ++i)
				{
					if(images[i].brand == BrandType_FullTilt)
					{
						brandImageList.addOrUpdate(BrandType_FullTilt, images[i].imageId);
						break;
					}
				}
				
				for(size_t i = 0; i < images.size(); ++i)
				{
					auto&& currImg = images[i];
					for (size_t j = 0; j < currImg.avatars.size(); ++j)
					{
						brandImageList.addAvatar(currImg.brand, currImg.avatars[j].avatarGameType, currImg.avatars[j].imageId);
					}
				}
			}
		}		
	}	
	
	@Override
	void composeMsgForPublication(bool hasShowImagePriv, UINT32 pokerStarsImageIdToBePublish, CommMsgBody& body) const
	{
		BrandImageList brandImageList;
		composeMsgForPublication(hasShowImagePriv, pokerStarsImageIdToBePublish, brandImageList);
		brandImageList.composeMsg(body);
	}
};


