/**
 * mtlobby_atf_cli_thin.cpp
 *
 * This file was auto-generated from mtlobby_atf_cli.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin mtlobby_atf_cli.txt
 */
 
#include "mtlobby_atf_cli_thin.h"

//=================================================================
//                    UserStatsReply
//=================================================================

MTLobbyCli::UserStatsReply::UserStatsReply()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::UserStatsReply::UserStatsReply(UserStatsReply&& _o)
	: place(std::move(_o.place))
	, totalPlayers(std::move(_o.totalPlayers))
	, tableName(std::move(_o.tableName))
	, userName(std::move(_o.userName))
	, city(std::move(_o.city))
	, chips(std::move(_o.chips))
	, tableServer(std::move(_o.tableServer))
	, tableObject(std::move(_o.tableObject))
	, country(std::move(_o.country))
	, showCity(std::move(_o.showCity))
	, fromFlightId(std::move(_o.fromFlightId))
	, fromFlightName(std::move(_o.fromFlightName))
	, bountyAndKnockouts(std::move(_o.bountyAndKnockouts))
	, rebuysDone(std::move(_o.rebuysDone))
	, addonsDone(std::move(_o.addonsDone))
	, rebuysRemaining(std::move(_o.rebuysRemaining))
	, headBounty(std::move(_o.headBounty))
{
}

MTLobbyCli::UserStatsReply& MTLobbyCli::UserStatsReply::operator=(UserStatsReply&& _o)
{
	if(this != &_o)
	{
		place = std::move(_o.place);
		totalPlayers = std::move(_o.totalPlayers);
		tableName = std::move(_o.tableName);
		userName = std::move(_o.userName);
		city = std::move(_o.city);
		chips = std::move(_o.chips);
		tableServer = std::move(_o.tableServer);
		tableObject = std::move(_o.tableObject);
		country = std::move(_o.country);
		showCity = std::move(_o.showCity);
		fromFlightId = std::move(_o.fromFlightId);
		fromFlightName = std::move(_o.fromFlightName);
		bountyAndKnockouts = std::move(_o.bountyAndKnockouts);
		rebuysDone = std::move(_o.rebuysDone);
		addonsDone = std::move(_o.addonsDone);
		rebuysRemaining = std::move(_o.rebuysRemaining);
		headBounty = std::move(_o.headBounty);
	}
	return *this;
}

#endif

void MTLobbyCli::UserStatsReply::clear()
{
	place = 0;
	totalPlayers = 0;
	tableName.clear();
	userName.clear();
	city.clear();
	chips = 0;
	tableServer.clear();
	tableObject.clear();
	country.clear();
	showCity = 0;
	fromFlightId = 0;
	fromFlightName.clear();
	bountyAndKnockouts = 0;
	rebuysDone = 0;
	addonsDone = 0;
	rebuysRemaining = 0;
	headBounty = 0;
}

bool MTLobbyCli::UserStatsReply::equals(const UserStatsReply& _o) const
{
	return place == _o.place &&
		totalPlayers == _o.totalPlayers &&
		tableName.equals(_o.tableName) &&
		userName.equals(_o.userName) &&
		city.equals(_o.city) &&
		chips == _o.chips &&
		tableServer.equals(_o.tableServer) &&
		tableObject.equals(_o.tableObject) &&
		country.equals(_o.country) &&
		showCity == _o.showCity &&
		fromFlightId == _o.fromFlightId &&
		fromFlightName.equals(_o.fromFlightName) &&
		bountyAndKnockouts == _o.bountyAndKnockouts &&
		rebuysDone == _o.rebuysDone &&
		addonsDone == _o.addonsDone &&
		rebuysRemaining == _o.rebuysRemaining &&
		headBounty == _o.headBounty;
}

const char *MTLobbyCli::UserStatsReply::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("place=");
	_buf.appendUint(place);
	_buf.append(',');
	_buf.append("totalPlayers=");
	_buf.appendInt(totalPlayers);
	_buf.append(',');
	_buf.append("tableName=");
	_buf.append(tableName);
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendUint(chips);
	_buf.append(',');
	_buf.append("tableServer=");
	_buf.append(tableServer);
	_buf.append(',');
	_buf.append("tableObject=");
	_buf.append(tableObject);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("showCity=");
	_buf.appendUint(showCity);
	_buf.append(',');
	_buf.append("fromFlightId=");
	_buf.appendUint(fromFlightId);
	_buf.append(',');
	_buf.append("fromFlightName=");
	_buf.append(fromFlightName);
	_buf.append(',');
	_buf.append("bountyAndKnockouts=");
	_buf.appendInt(bountyAndKnockouts);
	_buf.append(',');
	_buf.append("rebuysDone=");
	_buf.appendUint(rebuysDone);
	_buf.append(',');
	_buf.append("addonsDone=");
	_buf.appendUint(addonsDone);
	_buf.append(',');
	_buf.append("rebuysRemaining=");
	_buf.appendInt(rebuysRemaining);
	_buf.append(',');
	_buf.append("headBounty=");
	_buf.appendInt(headBounty);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::UserStatsReply::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(place);
	_msg.composeINT32(totalPlayers);
	_msg.composeString(tableName);
	_msg.composeString(userName);
	_msg.composeString(city);
	_msg.composeUINT32(chips);
	_msg.composeString(tableServer);
	_msg.composeString(tableObject);
	_msg.composeString(country);
	_msg.composeBYTE(showCity);
	_msg.composeUINT32(fromFlightId);
	_msg.composeString(fromFlightName);
	_msg.composeINT32(bountyAndKnockouts);
	_msg.composeUINT16(rebuysDone);
	_msg.composeUINT16(addonsDone);
	_msg.composeINT16(rebuysRemaining);
	_msg.composeINT32(headBounty);
}

void MTLobbyCli::UserStatsReply::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(place);
	_parser.parseINT32(totalPlayers);
	_parser.parseStringP(tableName);
	_parser.parseStringP(userName);
	_parser.parseStringP(city);
	_parser.parseUINT32(chips);
	_parser.parseStringP(tableServer);
	_parser.parseStringP(tableObject);
	_parser.parseStringP(country);
	_parser.parseBYTE(showCity);
	_parser.parseUINT32(fromFlightId);
	_parser.parseStringP(fromFlightName);
	_parser.parseINT32(bountyAndKnockouts);
	_parser.parseUINT16(rebuysDone);
	_parser.parseUINT16(addonsDone);
	_parser.parseINT16(rebuysRemaining);
	_parser.parseINT32(headBounty);
}

/*static*/ void MTLobbyCli::UserStatsReply::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 place; _parser.parseUINT32(place);
	AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	INT32 totalPlayers; _parser.parseINT32(totalPlayers);
	AtfValidator::validateInt(_descr, "totalPlayers", totalPlayers, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableName"); size_t szTableName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableName", szTableName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userName", szUserName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	UINT32 chips; _parser.parseUINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableServer"); size_t szTableServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableServer", szTableServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableObject"); size_t szTableObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableObject", szTableObject, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	BYTE showCity; _parser.parseBYTE(showCity);
	AtfValidator::validateInt(_descr, "showCity", showCity, _checker, __FILE__, __LINE__);
	UINT32 fromFlightId; _parser.parseUINT32(fromFlightId);
	AtfValidator::validateInt(_descr, "fromFlightId", fromFlightId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "fromFlightName"); size_t szFromFlightName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "fromFlightName", szFromFlightName, _checker, __FILE__, __LINE__);
	INT32 bountyAndKnockouts; _parser.parseINT32(bountyAndKnockouts);
	AtfValidator::validateInt(_descr, "bountyAndKnockouts", bountyAndKnockouts, _checker, __FILE__, __LINE__);
	UINT16 rebuysDone; _parser.parseUINT16(rebuysDone);
	AtfValidator::validateInt(_descr, "rebuysDone", rebuysDone, _checker, __FILE__, __LINE__);
	UINT16 addonsDone; _parser.parseUINT16(addonsDone);
	AtfValidator::validateInt(_descr, "addonsDone", addonsDone, _checker, __FILE__, __LINE__);
	INT16 rebuysRemaining; _parser.parseINT16(rebuysRemaining);
	AtfValidator::validateInt(_descr, "rebuysRemaining", rebuysRemaining, _checker, __FILE__, __LINE__);
	INT32 headBounty; _parser.parseINT32(headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSpendLimit
//=================================================================

MTLobbyCli::TournSpendLimit::TournSpendLimit()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::TournSpendLimit::TournSpendLimit(TournSpendLimit&& _o)
	: limitImposed(std::move(_o.limitImposed))
	, spendAmount(std::move(_o.spendAmount))
	, spendLimit(std::move(_o.spendLimit))
{
}

MTLobbyCli::TournSpendLimit& MTLobbyCli::TournSpendLimit::operator=(TournSpendLimit&& _o)
{
	if(this != &_o)
	{
		limitImposed = std::move(_o.limitImposed);
		spendAmount = std::move(_o.spendAmount);
		spendLimit = std::move(_o.spendLimit);
	}
	return *this;
}

#endif

void MTLobbyCli::TournSpendLimit::clear()
{
	limitImposed = false;
	spendAmount = 0;
	spendLimit = 0;
}

bool MTLobbyCli::TournSpendLimit::equals(const TournSpendLimit& _o) const
{
	return limitImposed == _o.limitImposed &&
		spendAmount == _o.spendAmount &&
		spendLimit == _o.spendLimit;
}

const char *MTLobbyCli::TournSpendLimit::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limitImposed=");
	_buf.appendUint(limitImposed);
	if( limitImposed )
	{
		_buf.append(',');
		_buf.append("spendAmount=");
		_buf.appendInt(spendAmount);
		_buf.append(',');
		_buf.append("spendLimit=");
		_buf.appendInt(spendLimit);
	}
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::TournSpendLimit::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TournSpendLimit())) // not empty
	{
		_body.composeBOOL(limitImposed);
		if( limitImposed )
		{
			_body.composeINT32(spendAmount);
			_body.composeINT32(spendLimit);
		}
	}

	_msg.composeMsgBody(_body);
}

void MTLobbyCli::TournSpendLimit::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(limitImposed);
	if( limitImposed )
	{
		_parser0.parseINT32(spendAmount);
		_parser0.parseINT32(spendLimit);
	}
}

/*static*/ void MTLobbyCli::TournSpendLimit::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool limitImposed = false;
	_parser0.parseBOOL(limitImposed);
	AtfValidator::validateInt(_descr, "limitImposed", limitImposed, _checker, __FILE__, __LINE__);
	if( limitImposed )
	{
		INT32 spendAmount; _parser0.parseINT32(spendAmount);
		AtfValidator::validateInt(_descr, "spendAmount", spendAmount, _checker, __FILE__, __LINE__);
		INT32 spendLimit; _parser0.parseINT32(spendLimit);
		AtfValidator::validateInt(_descr, "spendLimit", spendLimit, _checker, __FILE__, __LINE__);
	}
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    P_TicketType
//=================================================================

MTLobbyCli::publication::P_TicketType::P_TicketType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::P_TicketType::P_TicketType(P_TicketType&& _o)
	: ticketTypeId(std::move(_o.ticketTypeId))
	, name(std::move(_o.name))
{
}

MTLobbyCli::publication::P_TicketType& MTLobbyCli::publication::P_TicketType::operator=(P_TicketType&& _o)
{
	if(this != &_o)
	{
		ticketTypeId = std::move(_o.ticketTypeId);
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::P_TicketType::clear()
{
	ticketTypeId = 0;
	name.clear();
}

bool MTLobbyCli::publication::P_TicketType::equals(const P_TicketType& _o) const
{
	return ticketTypeId == _o.ticketTypeId &&
		name.equals(_o.name);
}

const char *MTLobbyCli::publication::P_TicketType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketTypeId=");
	_buf.appendUint(ticketTypeId);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::P_TicketType::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT16(ticketTypeId);
	_msg.composeString(name);
}

void MTLobbyCli::publication::P_TicketType::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(ticketTypeId);
	_parser.parseStringP(name);
}

/*static*/ void MTLobbyCli::publication::P_TicketType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT16 ticketTypeId; _parser.parseUINT16(ticketTypeId);
	AtfValidator::validateInt(_descr, "ticketTypeId", ticketTypeId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_FppReward
//=================================================================

MTLobbyCli::publication::P_FppReward::P_FppReward()
{
	clear();
}

void MTLobbyCli::publication::P_FppReward::clear()
{
	siteId = 0;
	reward = 0;
}

bool MTLobbyCli::publication::P_FppReward::equals(const P_FppReward& _o) const
{
	return siteId == _o.siteId &&
		reward == _o.reward;
}

const char *MTLobbyCli::publication::P_FppReward::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("reward=");
	_buf.appendUint(reward);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::P_FppReward::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(P_FppReward())) // not empty
	{
		_body.composeUINT32(siteId);
		_body.composeUINT32(reward);
	}

	_msg.composeMsgBody(_body);
}

void MTLobbyCli::publication::P_FppReward::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(reward);
}

/*static*/ void MTLobbyCli::publication::P_FppReward::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	UINT32 reward; _parser0.parseUINT32(reward);
	AtfValidator::validateInt(_descr, "reward", reward, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    P_MultiDayInfo
//=================================================================

MTLobbyCli::publication::P_MultiDayInfo::P_MultiDayInfo()
{
	clear();
}

void MTLobbyCli::publication::P_MultiDayInfo::clear()
{
	props = 0;
	dayOneStopValue = 0;
	dayTwoStartMinutes = 0;
	dayTwoStart.setNull();
}

bool MTLobbyCli::publication::P_MultiDayInfo::equals(const P_MultiDayInfo& _o) const
{
	return props == _o.props &&
		dayOneStopValue == _o.dayOneStopValue &&
		dayTwoStartMinutes == _o.dayTwoStartMinutes &&
		dayTwoStart.equals(_o.dayTwoStart);
}

const char *MTLobbyCli::publication::P_MultiDayInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("props=");
	_buf.appendUint(props);
	_buf.append(',');
	_buf.append("dayOneStopValue=");
	_buf.appendInt(dayOneStopValue);
	_buf.append(',');
	_buf.append("dayTwoStartMinutes=");
	_buf.appendUint(dayTwoStartMinutes);
	_buf.append(',');
	_buf.append("dayTwoStart=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, dayTwoStart);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::P_MultiDayInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(P_MultiDayInfo())) // not empty
	{
		_body.composeUINT32(props);
		_body.composeINT32(dayOneStopValue);
		_body.composeUINT32(dayTwoStartMinutes);
		_body.composeSrvTime(dayTwoStart);
	}

	_msg.composeMsgBody(_body);
}

void MTLobbyCli::publication::P_MultiDayInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(props);
	_parser0.parseINT32(dayOneStopValue);
	_parser0.parseUINT32(dayTwoStartMinutes);
	_parser0.parseSrvTime(dayTwoStart);
}

/*static*/ void MTLobbyCli::publication::P_MultiDayInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 props; _parser0.parseUINT32(props);
	AtfValidator::validateInt(_descr, "props", props, _checker, __FILE__, __LINE__);
	INT32 dayOneStopValue; _parser0.parseINT32(dayOneStopValue);
	AtfValidator::validateInt(_descr, "dayOneStopValue", dayOneStopValue, _checker, __FILE__, __LINE__);
	UINT32 dayTwoStartMinutes; _parser0.parseUINT32(dayTwoStartMinutes);
	AtfValidator::validateInt(_descr, "dayTwoStartMinutes", dayTwoStartMinutes, _checker, __FILE__, __LINE__);
	SrvTime dayTwoStart; _parser0.parseSrvTime(dayTwoStart);
	AtfValidator::validateSrvDateTime(_descr, "dayTwoStart", dayTwoStart, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournSubscr_Static
//=================================================================

MTLobbyCli::publication::TournSubscr_Static::TournSubscr_Static()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_Static::TournSubscr_Static(TournSubscr_Static&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, startingChips(std::move(_o.startingChips))
	, maxPlayers(std::move(_o.maxPlayers))
	, playersPerTable(std::move(_o.playersPerTable))
	, gameType(std::move(_o.gameType))
	, isHiLo(std::move(_o.isHiLo))
	, startingTime(std::move(_o.startingTime))
	, registrationStarts(std::move(_o.registrationStarts))
	, registrationEnds(std::move(_o.registrationEnds))
	, seatingStarts(std::move(_o.seatingStarts))
	, minPlayers(std::move(_o.minPlayers))
	, restricted(std::move(_o.restricted))
	, fppReward(std::move(_o.fppReward))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, isRestricted(std::move(_o.isRestricted))
	, isPwdProtected(std::move(_o.isPwdProtected))
	, name(std::move(_o.name))
	, numRebuys(std::move(_o.numRebuys))
	, rebuyChips(std::move(_o.rebuyChips))
	, _obsolete_1(std::move(_o._obsolete_1))
	, rebuyMaxChips(std::move(_o.rebuyMaxChips))
	, numAddOns(std::move(_o.numAddOns))
	, addOnChips(std::move(_o.addOnChips))
	, _obsolete_2(std::move(_o._obsolete_2))
	, addOnMaxChips(std::move(_o.addOnMaxChips))
	, scriptPrizeAddOn(std::move(_o.scriptPrizeAddOn))
	, guaranteedPrizePool(std::move(_o.guaranteedPrizePool))
	, tournFlags(std::move(_o.tournFlags))
	, maxAllins(std::move(_o.maxAllins))
	, awardSchema(std::move(_o.awardSchema))
	, timeBank(std::move(_o.timeBank))
	, unregistrationEnds_t(std::move(_o.unregistrationEnds_t))
	, satelliteTarget(std::move(_o.satelliteTarget))
	, satelliteTargetBuyIn(std::move(_o.satelliteTargetBuyIn))
	, rebuyFppPrice(std::move(_o.rebuyFppPrice))
	, addOnFppPrice(std::move(_o.addOnFppPrice))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, startingTime_t(std::move(_o.startingTime_t))
	, registrationStarts_t(std::move(_o.registrationStarts_t))
	, registrationEnds_t(std::move(_o.registrationEnds_t))
	, seatingStarts_t(std::move(_o.seatingStarts_t))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, tournProp2(std::move(_o.tournProp2))
	, ticketTypes(std::move(_o.ticketTypes))
	, tableLogo(std::move(_o.tableLogo))
	, finalTableText(std::move(_o.finalTableText))
	, chatLang(std::move(_o.chatLang))
	, lobbyRestricted(std::move(_o.lobbyRestricted))
	, fppFraction(std::move(_o.fppFraction))
	, currency(std::move(_o.currency))
	, rebuyFppReward(std::move(_o.rebuyFppReward))
	, addOnFppReward(std::move(_o.addOnFppReward))
	, fppRewardPercent(std::move(_o.fppRewardPercent))
	, nPublishLobbyPlayersLess(std::move(_o.nPublishLobbyPlayersLess))
	, bounty(std::move(_o.bounty))
	, fallbackSatelliteTargets(std::move(_o.fallbackSatelliteTargets))
	, teamProBounties(std::move(_o.teamProBounties))
	, bountyMultipliers(std::move(_o.bountyMultipliers))
	, publPropFlag(std::move(_o.publPropFlag))
	, multiDayTournProps(std::move(_o.multiDayTournProps))
	, multiDayTournDayOneStopValue(std::move(_o.multiDayTournDayOneStopValue))
	, multiDayTournDayTwoStartMinutes(std::move(_o.multiDayTournDayTwoStartMinutes))
	, multiDayTournDayTwoStarts(std::move(_o.multiDayTournDayTwoStarts))
	, satelliteTargetReference(std::move(_o.satelliteTargetReference))
	, satelliteTargetReferenceLock(std::move(_o.satelliteTargetReferenceLock))
	, clubId(std::move(_o.clubId))
	, timedTournType(std::move(_o.timedTournType))
	, timedTournLevelsOrMinutes(std::move(_o.timedTournLevelsOrMinutes))
	, timedTournPayoutStructure(std::move(_o.timedTournPayoutStructure))
	, _obsolete_3(std::move(_o._obsolete_3))
	, fppRewards(std::move(_o.fppRewards))
	, speedDisplay(std::move(_o.speedDisplay))
	, tournBrand(std::move(_o.tournBrand))
	, scalePM(std::move(_o.scalePM))
	, blitzNormalDealingThreshold(std::move(_o.blitzNormalDealingThreshold))
	, _obsolete_4(std::move(_o._obsolete_4))
	, progressiveKnockout(std::move(_o.progressiveKnockout))
	, tableText(std::move(_o.tableText))
	, reEntryAllowed(std::move(_o.reEntryAllowed))
	, tournMask(std::move(_o.tournMask))
	, tournMask2(std::move(_o.tournMask2))
	, tournMask3(std::move(_o.tournMask3))
	, tournMask4(std::move(_o.tournMask4))
	, internalReference(std::move(_o.internalReference))
	, favoriteReference(std::move(_o.favoriteReference))
	, ticketPrice(std::move(_o.ticketPrice))
	, tournFlags2(std::move(_o.tournFlags2))
	, cannotUnregisterFromTarget(std::move(_o.cannotUnregisterFromTarget))
	, initialStacks(std::move(_o.initialStacks))
	, singleStackChips(std::move(_o.singleStackChips))
	, forceReloadAllStacksInLevel(std::move(_o.forceReloadAllStacksInLevel))
	, forceReloadAllStacksInMinutes(std::move(_o.forceReloadAllStacksInMinutes))
	, reloadStacksOnlyWhenEmpty(std::move(_o.reloadStacksOnlyWhenEmpty))
	, targetWhenStarts(std::move(_o.targetWhenStarts))
	, admission(std::move(_o.admission))
	, siteMask(std::move(_o.siteMask))
	, publStartLevel(std::move(_o.publStartLevel))
	, tournMask5(std::move(_o.tournMask5))
	, tournMask6(std::move(_o.tournMask6))
	, dealExclusionType(std::move(_o.dealExclusionType))
	, dealExclusionValue(std::move(_o.dealExclusionValue))
	, timedTournPlayersPercent(std::move(_o.timedTournPlayersPercent))
	, _obsolete_5(std::move(_o._obsolete_5))
	, spinGoStartDelay(std::move(_o.spinGoStartDelay))
	, rmPmLobby(std::move(_o.rmPmLobby))
	, brandMask(std::move(_o.brandMask))
	, playerKnockOutAddOn(std::move(_o.playerKnockOutAddOn))
	, totalKnockOutAddOn(std::move(_o.totalKnockOutAddOn))
	, knockOutAddOnProgressive(std::move(_o.knockOutAddOnProgressive))
	, sitGoStarterGameId(std::move(_o.sitGoStarterGameId))
	, numStandardButton(std::move(_o.numStandardButton))
	, lateRegDelta(std::move(_o.lateRegDelta))
	, finalTablePlusOne(std::move(_o.finalTablePlusOne))
	, multidayIndex(std::move(_o.multidayIndex))
	, multiDayInfo(std::move(_o.multiDayInfo))
	, criteria(std::move(_o.criteria))
	, groupReference(std::move(_o.groupReference))
{
}

MTLobbyCli::publication::TournSubscr_Static& MTLobbyCli::publication::TournSubscr_Static::operator=(TournSubscr_Static&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		startingChips = std::move(_o.startingChips);
		maxPlayers = std::move(_o.maxPlayers);
		playersPerTable = std::move(_o.playersPerTable);
		gameType = std::move(_o.gameType);
		isHiLo = std::move(_o.isHiLo);
		startingTime = std::move(_o.startingTime);
		registrationStarts = std::move(_o.registrationStarts);
		registrationEnds = std::move(_o.registrationEnds);
		seatingStarts = std::move(_o.seatingStarts);
		minPlayers = std::move(_o.minPlayers);
		restricted = std::move(_o.restricted);
		fppReward = std::move(_o.fppReward);
		fppBuyIn = std::move(_o.fppBuyIn);
		isRestricted = std::move(_o.isRestricted);
		isPwdProtected = std::move(_o.isPwdProtected);
		name = std::move(_o.name);
		numRebuys = std::move(_o.numRebuys);
		rebuyChips = std::move(_o.rebuyChips);
		_obsolete_1 = std::move(_o._obsolete_1);
		rebuyMaxChips = std::move(_o.rebuyMaxChips);
		numAddOns = std::move(_o.numAddOns);
		addOnChips = std::move(_o.addOnChips);
		_obsolete_2 = std::move(_o._obsolete_2);
		addOnMaxChips = std::move(_o.addOnMaxChips);
		scriptPrizeAddOn = std::move(_o.scriptPrizeAddOn);
		guaranteedPrizePool = std::move(_o.guaranteedPrizePool);
		tournFlags = std::move(_o.tournFlags);
		maxAllins = std::move(_o.maxAllins);
		awardSchema = std::move(_o.awardSchema);
		timeBank = std::move(_o.timeBank);
		unregistrationEnds_t = std::move(_o.unregistrationEnds_t);
		satelliteTarget = std::move(_o.satelliteTarget);
		satelliteTargetBuyIn = std::move(_o.satelliteTargetBuyIn);
		rebuyFppPrice = std::move(_o.rebuyFppPrice);
		addOnFppPrice = std::move(_o.addOnFppPrice);
		isPlayMoney = std::move(_o.isPlayMoney);
		startingTime_t = std::move(_o.startingTime_t);
		registrationStarts_t = std::move(_o.registrationStarts_t);
		registrationEnds_t = std::move(_o.registrationEnds_t);
		seatingStarts_t = std::move(_o.seatingStarts_t);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		tournProp2 = std::move(_o.tournProp2);
		ticketTypes = std::move(_o.ticketTypes);
		tableLogo = std::move(_o.tableLogo);
		finalTableText = std::move(_o.finalTableText);
		chatLang = std::move(_o.chatLang);
		lobbyRestricted = std::move(_o.lobbyRestricted);
		fppFraction = std::move(_o.fppFraction);
		currency = std::move(_o.currency);
		rebuyFppReward = std::move(_o.rebuyFppReward);
		addOnFppReward = std::move(_o.addOnFppReward);
		fppRewardPercent = std::move(_o.fppRewardPercent);
		nPublishLobbyPlayersLess = std::move(_o.nPublishLobbyPlayersLess);
		bounty = std::move(_o.bounty);
		fallbackSatelliteTargets = std::move(_o.fallbackSatelliteTargets);
		teamProBounties = std::move(_o.teamProBounties);
		bountyMultipliers = std::move(_o.bountyMultipliers);
		publPropFlag = std::move(_o.publPropFlag);
		multiDayTournProps = std::move(_o.multiDayTournProps);
		multiDayTournDayOneStopValue = std::move(_o.multiDayTournDayOneStopValue);
		multiDayTournDayTwoStartMinutes = std::move(_o.multiDayTournDayTwoStartMinutes);
		multiDayTournDayTwoStarts = std::move(_o.multiDayTournDayTwoStarts);
		satelliteTargetReference = std::move(_o.satelliteTargetReference);
		satelliteTargetReferenceLock = std::move(_o.satelliteTargetReferenceLock);
		clubId = std::move(_o.clubId);
		timedTournType = std::move(_o.timedTournType);
		timedTournLevelsOrMinutes = std::move(_o.timedTournLevelsOrMinutes);
		timedTournPayoutStructure = std::move(_o.timedTournPayoutStructure);
		_obsolete_3 = std::move(_o._obsolete_3);
		fppRewards = std::move(_o.fppRewards);
		speedDisplay = std::move(_o.speedDisplay);
		tournBrand = std::move(_o.tournBrand);
		scalePM = std::move(_o.scalePM);
		blitzNormalDealingThreshold = std::move(_o.blitzNormalDealingThreshold);
		_obsolete_4 = std::move(_o._obsolete_4);
		progressiveKnockout = std::move(_o.progressiveKnockout);
		tableText = std::move(_o.tableText);
		reEntryAllowed = std::move(_o.reEntryAllowed);
		tournMask = std::move(_o.tournMask);
		tournMask2 = std::move(_o.tournMask2);
		tournMask3 = std::move(_o.tournMask3);
		tournMask4 = std::move(_o.tournMask4);
		internalReference = std::move(_o.internalReference);
		favoriteReference = std::move(_o.favoriteReference);
		ticketPrice = std::move(_o.ticketPrice);
		tournFlags2 = std::move(_o.tournFlags2);
		cannotUnregisterFromTarget = std::move(_o.cannotUnregisterFromTarget);
		initialStacks = std::move(_o.initialStacks);
		singleStackChips = std::move(_o.singleStackChips);
		forceReloadAllStacksInLevel = std::move(_o.forceReloadAllStacksInLevel);
		forceReloadAllStacksInMinutes = std::move(_o.forceReloadAllStacksInMinutes);
		reloadStacksOnlyWhenEmpty = std::move(_o.reloadStacksOnlyWhenEmpty);
		targetWhenStarts = std::move(_o.targetWhenStarts);
		admission = std::move(_o.admission);
		siteMask = std::move(_o.siteMask);
		publStartLevel = std::move(_o.publStartLevel);
		tournMask5 = std::move(_o.tournMask5);
		tournMask6 = std::move(_o.tournMask6);
		dealExclusionType = std::move(_o.dealExclusionType);
		dealExclusionValue = std::move(_o.dealExclusionValue);
		timedTournPlayersPercent = std::move(_o.timedTournPlayersPercent);
		_obsolete_5 = std::move(_o._obsolete_5);
		spinGoStartDelay = std::move(_o.spinGoStartDelay);
		rmPmLobby = std::move(_o.rmPmLobby);
		brandMask = std::move(_o.brandMask);
		playerKnockOutAddOn = std::move(_o.playerKnockOutAddOn);
		totalKnockOutAddOn = std::move(_o.totalKnockOutAddOn);
		knockOutAddOnProgressive = std::move(_o.knockOutAddOnProgressive);
		sitGoStarterGameId = std::move(_o.sitGoStarterGameId);
		numStandardButton = std::move(_o.numStandardButton);
		lateRegDelta = std::move(_o.lateRegDelta);
		finalTablePlusOne = std::move(_o.finalTablePlusOne);
		multidayIndex = std::move(_o.multidayIndex);
		multiDayInfo = std::move(_o.multiDayInfo);
		criteria = std::move(_o.criteria);
		groupReference = std::move(_o.groupReference);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_Static::clear()
{
	tournamentId = 0;
	buyIn = 0;
	rake = 0;
	startingChips = 0;
	maxPlayers = 0;
	playersPerTable = 0;
	gameType = 0;
	isHiLo = false;
	startingTime.setNull();
	registrationStarts.setNull();
	registrationEnds.setNull();
	seatingStarts.setNull();
	minPlayers = 0;
	restricted = 0;
	fppReward = 0;
	fppBuyIn = 0;
	isRestricted = false;
	isPwdProtected = false;
	name.clear();
	numRebuys = 0;
	rebuyChips = 0;
	_obsolete_1 = 0;
	rebuyMaxChips = 0;
	numAddOns = 0;
	addOnChips = 0;
	_obsolete_2 = 0;
	addOnMaxChips = 0;
	scriptPrizeAddOn = 0;
	guaranteedPrizePool = 0;
	tournFlags = 0;
	maxAllins = 0;
	awardSchema = 0;
	timeBank = 0;
	unregistrationEnds_t = 0;
	satelliteTarget = 0;
	satelliteTargetBuyIn = 0;
	rebuyFppPrice = 0;
	addOnFppPrice = 0;
	isPlayMoney = false;
	startingTime_t = 0;
	registrationStarts_t = 0;
	registrationEnds_t = 0;
	seatingStarts_t = 0;
	tournFlagsServInt = 0;
	tournProp2 = 0;
	ticketTypes.clear();
	tableLogo = 0;
	finalTableText.clear();
	chatLang = 0;
	lobbyRestricted = 0;
	fppFraction = 0;
	currency.clear();
	rebuyFppReward = 0;
	addOnFppReward = 0;
	fppRewardPercent = 0;
	nPublishLobbyPlayersLess = 0;
	bounty = 0;
	fallbackSatelliteTargets.clear();
	teamProBounties.clear();
	bountyMultipliers.clear();
	publPropFlag = 0;
	multiDayTournProps = 0;
	multiDayTournDayOneStopValue = 0;
	multiDayTournDayTwoStartMinutes = 0;
	multiDayTournDayTwoStarts.setNull();
	satelliteTargetReference.clear();
	satelliteTargetReferenceLock = 0;
	clubId = 0;
	timedTournType = 0;
	timedTournLevelsOrMinutes = 0;
	timedTournPayoutStructure = 0;
	_obsolete_3 = false;
	fppRewards.clear();
	speedDisplay = 0;
	tournBrand.clear();
	scalePM = 0;
	blitzNormalDealingThreshold = 0;
	_obsolete_4 = false;
	progressiveKnockout = 0;
	tableText.clear();
	reEntryAllowed = 0;
	tournMask = 0;
	tournMask2 = 0;
	tournMask3 = 0;
	tournMask4 = 0;
	internalReference.clear();
	favoriteReference.clear();
	ticketPrice = 0;
	tournFlags2 = 0;
	cannotUnregisterFromTarget = false;
	initialStacks = 0;
	singleStackChips = 0;
	forceReloadAllStacksInLevel = 0;
	forceReloadAllStacksInMinutes = 0;
	reloadStacksOnlyWhenEmpty = false;
	targetWhenStarts.setNull();
	admission.clear();
	siteMask = 0;
	publStartLevel = 0;
	tournMask5 = 0;
	tournMask6 = 0;
	dealExclusionType = 0;
	dealExclusionValue = 0;
	timedTournPlayersPercent = 0;
	_obsolete_5 = 0;
	spinGoStartDelay = 0;
	rmPmLobby = 0;
	brandMask = 0;
	playerKnockOutAddOn = 0;
	totalKnockOutAddOn = 0;
	knockOutAddOnProgressive = 0;
	sitGoStarterGameId = 0;
	numStandardButton = 0;
	lateRegDelta = 0;
	finalTablePlusOne = 0;
	multidayIndex = 0;
	multiDayInfo.clear();
	criteria.clear();
	groupReference.clear();
}

bool MTLobbyCli::publication::TournSubscr_Static::equals(const TournSubscr_Static& _o) const
{
	return tournamentId == _o.tournamentId &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		startingChips == _o.startingChips &&
		maxPlayers == _o.maxPlayers &&
		playersPerTable == _o.playersPerTable &&
		gameType == _o.gameType &&
		isHiLo == _o.isHiLo &&
		startingTime.equals(_o.startingTime) &&
		registrationStarts.equals(_o.registrationStarts) &&
		registrationEnds.equals(_o.registrationEnds) &&
		seatingStarts.equals(_o.seatingStarts) &&
		minPlayers == _o.minPlayers &&
		restricted == _o.restricted &&
		fppReward == _o.fppReward &&
		fppBuyIn == _o.fppBuyIn &&
		isRestricted == _o.isRestricted &&
		isPwdProtected == _o.isPwdProtected &&
		name.equals(_o.name) &&
		numRebuys == _o.numRebuys &&
		rebuyChips == _o.rebuyChips &&
		_obsolete_1 == _o._obsolete_1 &&
		rebuyMaxChips == _o.rebuyMaxChips &&
		numAddOns == _o.numAddOns &&
		addOnChips == _o.addOnChips &&
		_obsolete_2 == _o._obsolete_2 &&
		addOnMaxChips == _o.addOnMaxChips &&
		scriptPrizeAddOn == _o.scriptPrizeAddOn &&
		guaranteedPrizePool == _o.guaranteedPrizePool &&
		tournFlags == _o.tournFlags &&
		maxAllins == _o.maxAllins &&
		awardSchema == _o.awardSchema &&
		timeBank == _o.timeBank &&
		unregistrationEnds_t == _o.unregistrationEnds_t &&
		satelliteTarget == _o.satelliteTarget &&
		satelliteTargetBuyIn == _o.satelliteTargetBuyIn &&
		rebuyFppPrice == _o.rebuyFppPrice &&
		addOnFppPrice == _o.addOnFppPrice &&
		isPlayMoney == _o.isPlayMoney &&
		startingTime_t == _o.startingTime_t &&
		registrationStarts_t == _o.registrationStarts_t &&
		registrationEnds_t == _o.registrationEnds_t &&
		seatingStarts_t == _o.seatingStarts_t &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		tournProp2 == _o.tournProp2 &&
		ticketTypes.equals(_o.ticketTypes) &&
		tableLogo == _o.tableLogo &&
		finalTableText.equals(_o.finalTableText) &&
		chatLang == _o.chatLang &&
		lobbyRestricted == _o.lobbyRestricted &&
		fppFraction == _o.fppFraction &&
		currency.equals(_o.currency) &&
		rebuyFppReward == _o.rebuyFppReward &&
		addOnFppReward == _o.addOnFppReward &&
		fppRewardPercent == _o.fppRewardPercent &&
		nPublishLobbyPlayersLess == _o.nPublishLobbyPlayersLess &&
		bounty == _o.bounty &&
		fallbackSatelliteTargets.equals(_o.fallbackSatelliteTargets) &&
		teamProBounties.equals(_o.teamProBounties) &&
		bountyMultipliers.equals(_o.bountyMultipliers) &&
		publPropFlag == _o.publPropFlag &&
		multiDayTournProps == _o.multiDayTournProps &&
		multiDayTournDayOneStopValue == _o.multiDayTournDayOneStopValue &&
		multiDayTournDayTwoStartMinutes == _o.multiDayTournDayTwoStartMinutes &&
		multiDayTournDayTwoStarts.equals(_o.multiDayTournDayTwoStarts) &&
		satelliteTargetReference.equals(_o.satelliteTargetReference) &&
		satelliteTargetReferenceLock == _o.satelliteTargetReferenceLock &&
		clubId == _o.clubId &&
		timedTournType == _o.timedTournType &&
		timedTournLevelsOrMinutes == _o.timedTournLevelsOrMinutes &&
		timedTournPayoutStructure == _o.timedTournPayoutStructure &&
		_obsolete_3 == _o._obsolete_3 &&
		fppRewards.equals(_o.fppRewards) &&
		speedDisplay == _o.speedDisplay &&
		tournBrand.equals(_o.tournBrand) &&
		scalePM == _o.scalePM &&
		blitzNormalDealingThreshold == _o.blitzNormalDealingThreshold &&
		_obsolete_4 == _o._obsolete_4 &&
		progressiveKnockout == _o.progressiveKnockout &&
		tableText.equals(_o.tableText) &&
		reEntryAllowed == _o.reEntryAllowed &&
		tournMask == _o.tournMask &&
		tournMask2 == _o.tournMask2 &&
		tournMask3 == _o.tournMask3 &&
		tournMask4 == _o.tournMask4 &&
		internalReference.equals(_o.internalReference) &&
		favoriteReference.equals(_o.favoriteReference) &&
		ticketPrice == _o.ticketPrice &&
		tournFlags2 == _o.tournFlags2 &&
		cannotUnregisterFromTarget == _o.cannotUnregisterFromTarget &&
		initialStacks == _o.initialStacks &&
		singleStackChips == _o.singleStackChips &&
		forceReloadAllStacksInLevel == _o.forceReloadAllStacksInLevel &&
		forceReloadAllStacksInMinutes == _o.forceReloadAllStacksInMinutes &&
		reloadStacksOnlyWhenEmpty == _o.reloadStacksOnlyWhenEmpty &&
		targetWhenStarts.equals(_o.targetWhenStarts) &&
		admission.equals(_o.admission) &&
		siteMask == _o.siteMask &&
		publStartLevel == _o.publStartLevel &&
		tournMask5 == _o.tournMask5 &&
		tournMask6 == _o.tournMask6 &&
		dealExclusionType == _o.dealExclusionType &&
		dealExclusionValue == _o.dealExclusionValue &&
		timedTournPlayersPercent == _o.timedTournPlayersPercent &&
		_obsolete_5 == _o._obsolete_5 &&
		spinGoStartDelay == _o.spinGoStartDelay &&
		rmPmLobby == _o.rmPmLobby &&
		brandMask == _o.brandMask &&
		playerKnockOutAddOn == _o.playerKnockOutAddOn &&
		totalKnockOutAddOn == _o.totalKnockOutAddOn &&
		knockOutAddOnProgressive == _o.knockOutAddOnProgressive &&
		sitGoStarterGameId == _o.sitGoStarterGameId &&
		numStandardButton == _o.numStandardButton &&
		lateRegDelta == _o.lateRegDelta &&
		finalTablePlusOne == _o.finalTablePlusOne &&
		multidayIndex == _o.multidayIndex &&
		multiDayInfo.equals(_o.multiDayInfo) &&
		criteria.equals(_o.criteria) &&
		groupReference.equals(_o.groupReference);
}

const char *MTLobbyCli::publication::TournSubscr_Static::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("startingChips=");
	_buf.appendUint(startingChips);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("playersPerTable=");
	_buf.appendUint(playersPerTable);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("startingTime=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, startingTime);
	_buf.append(',');
	_buf.append("registrationStarts=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, registrationStarts);
	_buf.append(',');
	_buf.append("registrationEnds=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, registrationEnds);
	_buf.append(',');
	_buf.append("seatingStarts=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, seatingStarts);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("restricted=");
	_buf.appendUint(restricted);
	_buf.append(',');
	_buf.append("fppReward=");
	_buf.appendUint(fppReward);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("isRestricted=");
	_buf.appendUint(isRestricted);
	_buf.append(',');
	_buf.append("isPwdProtected=");
	_buf.appendUint(isPwdProtected);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("numRebuys=");
	_buf.appendUint(numRebuys);
	_buf.append(',');
	_buf.append("rebuyChips=");
	_buf.appendUint(rebuyChips);
	_buf.append(',');
	_buf.append("_obsolete_1=");
	_buf.appendUint(_obsolete_1);
	_buf.append(',');
	_buf.append("rebuyMaxChips=");
	_buf.appendUint(rebuyMaxChips);
	_buf.append(',');
	_buf.append("numAddOns=");
	_buf.appendUint(numAddOns);
	_buf.append(',');
	_buf.append("addOnChips=");
	_buf.appendUint(addOnChips);
	_buf.append(',');
	_buf.append("_obsolete_2=");
	_buf.appendUint(_obsolete_2);
	_buf.append(',');
	_buf.append("addOnMaxChips=");
	_buf.appendUint(addOnMaxChips);
	_buf.append(',');
	_buf.append("scriptPrizeAddOn=");
	_buf.appendUint(scriptPrizeAddOn);
	_buf.append(',');
	_buf.append("guaranteedPrizePool=");
	_buf.appendUint(guaranteedPrizePool);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("maxAllins=");
	_buf.appendUint(maxAllins);
	_buf.append(',');
	_buf.append("awardSchema=");
	_buf.appendUint(awardSchema);
	_buf.append(',');
	_buf.append("timeBank=");
	_buf.appendUint(timeBank);
	_buf.append(',');
	_buf.append("unregistrationEnds_t=");
	_buf.appendUint(unregistrationEnds_t);
	_buf.append(',');
	_buf.append("satelliteTarget=");
	_buf.appendUint(satelliteTarget);
	_buf.append(',');
	_buf.append("satelliteTargetBuyIn=");
	_buf.appendUint(satelliteTargetBuyIn);
	_buf.append(',');
	_buf.append("rebuyFppPrice=");
	_buf.appendUint(rebuyFppPrice);
	_buf.append(',');
	_buf.append("addOnFppPrice=");
	_buf.appendUint(addOnFppPrice);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("startingTime_t=");
	_buf.appendUint(startingTime_t);
	_buf.append(',');
	_buf.append("registrationStarts_t=");
	_buf.appendUint(registrationStarts_t);
	_buf.append(',');
	_buf.append("registrationEnds_t=");
	_buf.appendUint(registrationEnds_t);
	_buf.append(',');
	_buf.append("seatingStarts_t=");
	_buf.appendUint(seatingStarts_t);
	_buf.append(',');
	_buf.append("tournFlagsServInt=");
	_buf.appendUint(tournFlagsServInt);
	_buf.append(',');
	_buf.append("tournProp2=");
	_buf.appendUint(tournProp2);
	_buf.append(',');
	_buf.append("ticketTypes=");
	ticketTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableLogo=");
	_buf.appendUint(tableLogo);
	_buf.append(',');
	_buf.append("finalTableText=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, finalTableText);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("lobbyRestricted=");
	_buf.appendUint(lobbyRestricted);
	_buf.append(',');
	_buf.append("fppFraction=");
	_buf.appendUint(fppFraction);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("rebuyFppReward=");
	_buf.appendUint(rebuyFppReward);
	_buf.append(',');
	_buf.append("addOnFppReward=");
	_buf.appendUint(addOnFppReward);
	_buf.append(',');
	_buf.append("fppRewardPercent=");
	_buf.appendUint(fppRewardPercent);
	_buf.append(',');
	_buf.append("nPublishLobbyPlayersLess=");
	_buf.appendUint(nPublishLobbyPlayersLess);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendUint(bounty);
	_buf.append(',');
	_buf.append("fallbackSatelliteTargets=");
	fallbackSatelliteTargets.toTraceString(_buf);
	_buf.append(',');
	_buf.append("teamProBounties=");
	teamProBounties.toTraceString(_buf);
	_buf.append(',');
	_buf.append("bountyMultipliers=");
	bountyMultipliers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("publPropFlag=");
	_buf.appendUint(publPropFlag);
	_buf.append(',');
	_buf.append("multiDayTournProps=");
	_buf.appendUint(multiDayTournProps);
	_buf.append(',');
	_buf.append("multiDayTournDayOneStopValue=");
	_buf.appendUint(multiDayTournDayOneStopValue);
	_buf.append(',');
	_buf.append("multiDayTournDayTwoStartMinutes=");
	_buf.appendUint(multiDayTournDayTwoStartMinutes);
	_buf.append(',');
	_buf.append("multiDayTournDayTwoStarts=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, multiDayTournDayTwoStarts);
	_buf.append(',');
	_buf.append("satelliteTargetReference=");
	_buf.append(satelliteTargetReference);
	_buf.append(',');
	_buf.append("satelliteTargetReferenceLock=");
	_buf.appendUint(satelliteTargetReferenceLock);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("timedTournType=");
	_buf.appendUint(timedTournType);
	_buf.append(',');
	_buf.append("timedTournLevelsOrMinutes=");
	_buf.appendUint(timedTournLevelsOrMinutes);
	_buf.append(',');
	_buf.append("timedTournPayoutStructure=");
	_buf.appendUint(timedTournPayoutStructure);
	_buf.append(',');
	_buf.append("_obsolete_3=");
	_buf.appendUint(_obsolete_3);
	_buf.append(',');
	_buf.append("fppRewards=");
	fppRewards.toTraceString(_buf);
	_buf.append(',');
	_buf.append("speedDisplay=");
	_buf.appendUint(speedDisplay);
	_buf.append(',');
	_buf.append("tournBrand=");
	_buf.append(tournBrand);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("blitzNormalDealingThreshold=");
	_buf.appendUint(blitzNormalDealingThreshold);
	_buf.append(',');
	_buf.append("_obsolete_4=");
	_buf.appendUint(_obsolete_4);
	_buf.append(',');
	_buf.append("progressiveKnockout=");
	_buf.appendUint(progressiveKnockout);
	_buf.append(',');
	_buf.append("tableText=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, tableText);
	_buf.append(',');
	_buf.append("reEntryAllowed=");
	_buf.appendUint(reEntryAllowed);
	_buf.append(',');
	_buf.append("tournMask=");
	_buf.appendUint(tournMask);
	_buf.append(',');
	_buf.append("tournMask2=");
	_buf.appendUint(tournMask2);
	_buf.append(',');
	_buf.append("tournMask3=");
	_buf.appendUint(tournMask3);
	_buf.append(',');
	_buf.append("tournMask4=");
	_buf.appendUint(tournMask4);
	_buf.append(',');
	_buf.append("internalReference=");
	_buf.append(internalReference);
	_buf.append(',');
	_buf.append("favoriteReference=");
	_buf.append(favoriteReference);
	_buf.append(',');
	_buf.append("ticketPrice=");
	_buf.appendInt64(ticketPrice);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append(',');
	_buf.append("cannotUnregisterFromTarget=");
	_buf.appendUint(cannotUnregisterFromTarget);
	_buf.append(',');
	_buf.append("initialStacks=");
	_buf.appendUint(initialStacks);
	_buf.append(',');
	_buf.append("singleStackChips=");
	_buf.appendUint(singleStackChips);
	_buf.append(',');
	_buf.append("forceReloadAllStacksInLevel=");
	_buf.appendUint(forceReloadAllStacksInLevel);
	_buf.append(',');
	_buf.append("forceReloadAllStacksInMinutes=");
	_buf.appendUint(forceReloadAllStacksInMinutes);
	_buf.append(',');
	_buf.append("reloadStacksOnlyWhenEmpty=");
	_buf.appendUint(reloadStacksOnlyWhenEmpty);
	_buf.append(',');
	_buf.append("targetWhenStarts=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, targetWhenStarts);
	_buf.append(',');
	_buf.append("admission=");
	_buf.append(admission);
	_buf.append(',');
	_buf.append("siteMask=");
	_buf.appendUint(siteMask);
	_buf.append(',');
	_buf.append("publStartLevel=");
	_buf.appendUint(publStartLevel);
	_buf.append(',');
	_buf.append("tournMask5=");
	_buf.appendUint(tournMask5);
	_buf.append(',');
	_buf.append("tournMask6=");
	_buf.appendUint(tournMask6);
	_buf.append(',');
	_buf.append("dealExclusionType=");
	_buf.appendUint(dealExclusionType);
	_buf.append(',');
	_buf.append("dealExclusionValue=");
	_buf.appendUint(dealExclusionValue);
	_buf.append(',');
	_buf.append("timedTournPlayersPercent=");
	_buf.appendUint(timedTournPlayersPercent);
	_buf.append(',');
	_buf.append("_obsolete_5=");
	_buf.appendUint(_obsolete_5);
	_buf.append(',');
	_buf.append("spinGoStartDelay=");
	_buf.appendUint(spinGoStartDelay);
	_buf.append(',');
	_buf.append("rmPmLobby=");
	_buf.appendUint(rmPmLobby);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("playerKnockOutAddOn=");
	_buf.appendUint(playerKnockOutAddOn);
	_buf.append(',');
	_buf.append("totalKnockOutAddOn=");
	_buf.appendUint(totalKnockOutAddOn);
	_buf.append(',');
	_buf.append("knockOutAddOnProgressive=");
	_buf.appendUint(knockOutAddOnProgressive);
	_buf.append(',');
	_buf.append("sitGoStarterGameId=");
	_buf.appendUint(sitGoStarterGameId);
	_buf.append(',');
	_buf.append("numStandardButton=");
	_buf.appendUint(numStandardButton);
	_buf.append(',');
	_buf.append("lateRegDelta=");
	_buf.appendInt(lateRegDelta);
	_buf.append(',');
	_buf.append("finalTablePlusOne=");
	_buf.appendInt(finalTablePlusOne);
	_buf.append(',');
	_buf.append("multidayIndex=");
	_buf.appendUint(multidayIndex);
	_buf.append(',');
	_buf.append("multiDayInfo=");
	multiDayInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	_buf.append(criteria);
	_buf.append(',');
	_buf.append("groupReference=");
	_buf.append(groupReference);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_Static::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournamentId);
	_msg.composeUINT32(buyIn);
	_msg.composeUINT32(rake);
	_msg.composeUINT32(startingChips);
	_msg.composeUINT32(maxPlayers);
	_msg.composeUINT32(playersPerTable);
	_msg.composeBYTE(gameType);
	_msg.composeBOOL(isHiLo);
	_msg.composeSrvTime(startingTime);
	_msg.composeSrvTime(registrationStarts);
	_msg.composeSrvTime(registrationEnds);
	_msg.composeSrvTime(seatingStarts);
	_msg.composeUINT32(minPlayers);
	_msg.composeBYTE(restricted);
	_msg.composeUINT32(fppReward);
	_msg.composeUINT32(fppBuyIn);
	_msg.composeBOOL(isRestricted);
	_msg.composeBOOL(isPwdProtected);
	_msg.composeString(name);
	_msg.composeUINT32(numRebuys);
	_msg.composeUINT32(rebuyChips);
	_msg.composeUINT32(_obsolete_1);
	_msg.composeUINT32(rebuyMaxChips);
	_msg.composeUINT32(numAddOns);
	_msg.composeUINT32(addOnChips);
	_msg.composeUINT32(_obsolete_2);
	_msg.composeUINT32(addOnMaxChips);
	_msg.composeUINT32(scriptPrizeAddOn);
	_msg.composeUINT32(guaranteedPrizePool);
	_msg.composeUINT32(tournFlags);
	_msg.composeUINT16(maxAllins);
	_msg.composeBYTE(awardSchema);
	_msg.composeUINT32(timeBank);
	_msg.composeUINT32(unregistrationEnds_t);
	_msg.composeUINT32(satelliteTarget);
	_msg.composeUINT32(satelliteTargetBuyIn);
	_msg.composeUINT32(rebuyFppPrice);
	_msg.composeUINT32(addOnFppPrice);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeUINT32(startingTime_t);
	_msg.composeUINT32(registrationStarts_t);
	_msg.composeUINT32(registrationEnds_t);
	_msg.composeUINT32(seatingStarts_t);
	_msg.composeUINT32(tournFlagsServInt);
	_msg.composeUINT32(tournProp2);
	ticketTypes.composeMsg(_msg);
	_msg.composeUINT32(tableLogo);
	finalTableText.compose(_msg);
	_msg.composeUINT16(chatLang);
	_msg.composeUINT32(lobbyRestricted);
	_msg.composeUINT32(fppFraction);
	_msg.composeString(currency);
	_msg.composeUINT32(rebuyFppReward);
	_msg.composeUINT32(addOnFppReward);
	_msg.composeBYTE(fppRewardPercent);
	_msg.composeUINT32(nPublishLobbyPlayersLess);
	_msg.composeUINT32(bounty);
	fallbackSatelliteTargets.composeMsg(_msg);
	CommMsgBody _msg0;
	teamProBounties.composeMsg(_msg0);
	bountyMultipliers.composeMsg(_msg0);
	_msg.composeMsgBody(_msg0);
	_msg.composeBYTE(publPropFlag);
	_msg.composeUINT32(multiDayTournProps);
	_msg.composeUINT32(multiDayTournDayOneStopValue);
	_msg.composeUINT32(multiDayTournDayTwoStartMinutes);
	_msg.composeSrvTime(multiDayTournDayTwoStarts);
	_msg.composeString(satelliteTargetReference);
	_msg.composeUINT16(satelliteTargetReferenceLock);
	_msg.composeUINT32(clubId);
	_msg.composeBYTE(timedTournType);
	_msg.composeUINT16(timedTournLevelsOrMinutes);
	_msg.composeBYTE(timedTournPayoutStructure);
	_msg.composeBOOL(_obsolete_3);
	fppRewards.composeMsg(_msg);
	_msg.composeBYTE(speedDisplay);
	_msg.composeString(tournBrand);
	_msg.composeUINT32(scalePM);
	_msg.composeUINT32(blitzNormalDealingThreshold);
	_msg.composeBOOL(_obsolete_4);
	_msg.composeBYTE(progressiveKnockout);
	tableText.compose(_msg);
	_msg.composeUINT16(reEntryAllowed);
	_msg.composeUINT32(tournMask);
	_msg.composeUINT32(tournMask2);
	_msg.composeUINT32(tournMask3);
	_msg.composeUINT32(tournMask4);
	_msg.composeString(internalReference);
	_msg.composeString(favoriteReference);
	_msg.composeINT64(ticketPrice);
	_msg.composeUINT64(tournFlags2);
	_msg.composeBOOL(cannotUnregisterFromTarget);
	CommMsgBody _msg1;
	_msg1.composeUINT32(initialStacks);
	_msg1.composeUINT32(singleStackChips);
	_msg1.composeUINT32(forceReloadAllStacksInLevel);
	_msg1.composeUINT32(forceReloadAllStacksInMinutes);
	_msg1.composeBOOL(reloadStacksOnlyWhenEmpty);
	_msg.composeMsgBody(_msg1);
	_msg.composeSrvTime(targetWhenStarts);
	_msg.composeString(admission);
	_msg.composeUINT32(siteMask);
	_msg.composeUINT32(publStartLevel);
	_msg.composeUINT32(tournMask5);
	_msg.composeUINT32(tournMask6);
	_msg.composeBYTE(dealExclusionType);
	_msg.composeUINT32(dealExclusionValue);
	_msg.composeBYTE(timedTournPlayersPercent);
	_msg.composeUINT32(_obsolete_5);
	_msg.composeUINT32(spinGoStartDelay);
	_msg.composeBYTE(rmPmLobby);
	_msg.composeUINT32(brandMask);
	_msg.composeUINT32(playerKnockOutAddOn);
	_msg.composeUINT32(totalKnockOutAddOn);
	_msg.composeBYTE(knockOutAddOnProgressive);
	_msg.composeUINT32(sitGoStarterGameId);
	_msg.composeUINT32(numStandardButton);
	_msg.composeINT32(lateRegDelta);
	_msg.composeINT32(finalTablePlusOne);
	_msg.composeUINT32(multidayIndex);
	multiDayInfo.composeMsg(_msg);
	_msg.composeString(criteria);
	_msg.composeString(groupReference);
}

void MTLobbyCli::publication::TournSubscr_Static::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournamentId);
	_parser.parseUINT32(buyIn);
	_parser.parseUINT32(rake);
	_parser.parseUINT32(startingChips);
	_parser.parseUINT32(maxPlayers);
	_parser.parseUINT32(playersPerTable);
	_parser.parseBYTE(gameType);
	_parser.parseBOOL(isHiLo);
	_parser.parseSrvTime(startingTime);
	_parser.parseSrvTime(registrationStarts);
	_parser.parseSrvTime(registrationEnds);
	_parser.parseSrvTime(seatingStarts);
	_parser.parseUINT32(minPlayers);
	_parser.parseBYTE(restricted);
	_parser.parseUINT32(fppReward);
	_parser.parseUINT32(fppBuyIn);
	_parser.parseBOOL(isRestricted);
	_parser.parseBOOL(isPwdProtected);
	_parser.parseStringP(name);
	_parser.parseUINT32(numRebuys);
	_parser.parseUINT32(rebuyChips);
	_parser.parseUINT32(_obsolete_1);
	_parser.parseUINT32(rebuyMaxChips);
	_parser.parseUINT32(numAddOns);
	_parser.parseUINT32(addOnChips);
	_parser.parseUINT32(_obsolete_2);
	_parser.parseUINT32(addOnMaxChips);
	_parser.parseUINT32(scriptPrizeAddOn);
	_parser.parseUINT32(guaranteedPrizePool);
	_parser.parseUINT32(tournFlags);
	_parser.parseUINT16(maxAllins);
	_parser.parseBYTE(awardSchema);
	_parser.parseUINT32(timeBank);
	_parser.parseUINT32(unregistrationEnds_t);
	_parser.parseUINT32(satelliteTarget);
	_parser.parseUINT32(satelliteTargetBuyIn);
	_parser.parseUINT32(rebuyFppPrice);
	_parser.parseUINT32(addOnFppPrice);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseUINT32(startingTime_t);
	_parser.parseUINT32(registrationStarts_t);
	_parser.parseUINT32(registrationEnds_t);
	_parser.parseUINT32(seatingStarts_t);
	_parser.parseUINT32(tournFlagsServInt);
	_parser.parseUINT32(tournProp2);
	ticketTypes.parseMsg(_parser);
	_parser.parseUINT32(tableLogo);
	finalTableText.parse(_parser);
	_parser.parseUINT16(chatLang);
	_parser.parseUINT32(lobbyRestricted);
	_parser.parseUINT32(fppFraction);
	_parser.parseStringP(currency);
	_parser.parseUINT32(rebuyFppReward);
	_parser.parseUINT32(addOnFppReward);
	_parser.parseBYTE(fppRewardPercent);
	_parser.parseUINT32(nPublishLobbyPlayersLess);
	_parser.parseUINT32(bounty);
	fallbackSatelliteTargets.parseMsg(_parser);
	parseAnonymousMsgBody0(_parser);
	_parser.parseBYTE(publPropFlag);
	_parser.parseUINT32(multiDayTournProps);
	_parser.parseUINT32(multiDayTournDayOneStopValue);
	_parser.parseUINT32(multiDayTournDayTwoStartMinutes);
	_parser.parseSrvTime(multiDayTournDayTwoStarts);
	_parser.parseStringP(satelliteTargetReference);
	_parser.parseUINT16(satelliteTargetReferenceLock);
	_parser.parseUINT32(clubId);
	_parser.parseBYTE(timedTournType);
	_parser.parseUINT16(timedTournLevelsOrMinutes);
	_parser.parseBYTE(timedTournPayoutStructure);
	_parser.parseBOOL(_obsolete_3);
	fppRewards.parseMsg(_parser);
	_parser.parseBYTE(speedDisplay);
	_parser.parseStringP(tournBrand);
	_parser.parseUINT32(scalePM);
	_parser.parseUINT32(blitzNormalDealingThreshold);
	_parser.parseBOOL(_obsolete_4);
	_parser.parseBYTE(progressiveKnockout);
	tableText.parse(_parser);
	_parser.parseUINT16(reEntryAllowed);
	_parser.parseUINT32(tournMask);
	_parser.parseUINT32(tournMask2);
	_parser.parseUINT32(tournMask3);
	_parser.parseUINT32(tournMask4);
	_parser.parseStringP(internalReference);
	_parser.parseStringP(favoriteReference);
	_parser.parseINT64(ticketPrice);
	_parser.parseUINT64(tournFlags2);
	_parser.parseBOOL(cannotUnregisterFromTarget);
	parseAnonymousMsgBody1(_parser);
	_parser.parseSrvTime(targetWhenStarts);
	_parser.parseStringP(admission);
	_parser.parseUINT32(siteMask);
	_parser.parseUINT32(publStartLevel);
	_parser.parseUINT32(tournMask5);
	_parser.parseUINT32(tournMask6);
	_parser.parseBYTE(dealExclusionType);
	_parser.parseUINT32(dealExclusionValue);
	_parser.parseBYTE(timedTournPlayersPercent);
	_parser.parseUINT32(_obsolete_5);
	_parser.parseUINT32(spinGoStartDelay);
	_parser.parseBYTE(rmPmLobby);
	_parser.parseUINT32(brandMask);
	_parser.parseUINT32(playerKnockOutAddOn);
	_parser.parseUINT32(totalKnockOutAddOn);
	_parser.parseBYTE(knockOutAddOnProgressive);
	_parser.parseUINT32(sitGoStarterGameId);
	_parser.parseUINT32(numStandardButton);
	_parser.parseINT32(lateRegDelta);
	_parser.parseINT32(finalTablePlusOne);
	_parser.parseUINT32(multidayIndex);
	multiDayInfo.parseMsg(_parser);
	_parser.parseStringP(criteria);
	_parser.parseStringP(groupReference);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_Static::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 tournamentId; _parser.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 startingChips; _parser.parseUINT32(startingChips);
	AtfValidator::validateInt(_descr, "startingChips", startingChips, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 playersPerTable; _parser.parseUINT32(playersPerTable);
	AtfValidator::validateInt(_descr, "playersPerTable", playersPerTable, _checker, __FILE__, __LINE__);
	BYTE gameType; _parser.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	SrvTime startingTime; _parser.parseSrvTime(startingTime);
	AtfValidator::validateSrvDateTime(_descr, "startingTime", startingTime, _checker, __FILE__, __LINE__);
	SrvTime registrationStarts; _parser.parseSrvTime(registrationStarts);
	AtfValidator::validateSrvDateTime(_descr, "registrationStarts", registrationStarts, _checker, __FILE__, __LINE__);
	SrvTime registrationEnds; _parser.parseSrvTime(registrationEnds);
	AtfValidator::validateSrvDateTime(_descr, "registrationEnds", registrationEnds, _checker, __FILE__, __LINE__);
	SrvTime seatingStarts; _parser.parseSrvTime(seatingStarts);
	AtfValidator::validateSrvDateTime(_descr, "seatingStarts", seatingStarts, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	BYTE restricted; _parser.parseBYTE(restricted);
	AtfValidator::validateInt(_descr, "restricted", restricted, _checker, __FILE__, __LINE__);
	UINT32 fppReward; _parser.parseUINT32(fppReward);
	AtfValidator::validateInt(_descr, "fppReward", fppReward, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	bool isRestricted; _parser.parseBOOL(isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	bool isPwdProtected; _parser.parseBOOL(isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	UINT32 numRebuys; _parser.parseUINT32(numRebuys);
	AtfValidator::validateInt(_descr, "numRebuys", numRebuys, _checker, __FILE__, __LINE__);
	UINT32 rebuyChips; _parser.parseUINT32(rebuyChips);
	AtfValidator::validateInt(_descr, "rebuyChips", rebuyChips, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_1; _parser.parseUINT32(_obsolete_1);
	AtfValidator::validateInt(_descr, "_obsolete_1", _obsolete_1, _checker, __FILE__, __LINE__);
	UINT32 rebuyMaxChips; _parser.parseUINT32(rebuyMaxChips);
	AtfValidator::validateInt(_descr, "rebuyMaxChips", rebuyMaxChips, _checker, __FILE__, __LINE__);
	UINT32 numAddOns; _parser.parseUINT32(numAddOns);
	AtfValidator::validateInt(_descr, "numAddOns", numAddOns, _checker, __FILE__, __LINE__);
	UINT32 addOnChips; _parser.parseUINT32(addOnChips);
	AtfValidator::validateInt(_descr, "addOnChips", addOnChips, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_2; _parser.parseUINT32(_obsolete_2);
	AtfValidator::validateInt(_descr, "_obsolete_2", _obsolete_2, _checker, __FILE__, __LINE__);
	UINT32 addOnMaxChips; _parser.parseUINT32(addOnMaxChips);
	AtfValidator::validateInt(_descr, "addOnMaxChips", addOnMaxChips, _checker, __FILE__, __LINE__);
	UINT32 scriptPrizeAddOn; _parser.parseUINT32(scriptPrizeAddOn);
	AtfValidator::validateInt(_descr, "scriptPrizeAddOn", scriptPrizeAddOn, _checker, __FILE__, __LINE__);
	UINT32 guaranteedPrizePool; _parser.parseUINT32(guaranteedPrizePool);
	AtfValidator::validateInt(_descr, "guaranteedPrizePool", guaranteedPrizePool, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	UINT16 maxAllins; _parser.parseUINT16(maxAllins);
	AtfValidator::validateInt(_descr, "maxAllins", maxAllins, _checker, __FILE__, __LINE__);
	BYTE awardSchema; _parser.parseBYTE(awardSchema);
	AtfValidator::validateInt(_descr, "awardSchema", awardSchema, _checker, __FILE__, __LINE__);
	UINT32 timeBank; _parser.parseUINT32(timeBank);
	AtfValidator::validateInt(_descr, "timeBank", timeBank, _checker, __FILE__, __LINE__);
	UINT32 unregistrationEnds_t; _parser.parseUINT32(unregistrationEnds_t);
	AtfValidator::validateInt(_descr, "unregistrationEnds_t", unregistrationEnds_t, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _parser.parseUINT32(satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	UINT32 satelliteTargetBuyIn; _parser.parseUINT32(satelliteTargetBuyIn);
	AtfValidator::validateInt(_descr, "satelliteTargetBuyIn", satelliteTargetBuyIn, _checker, __FILE__, __LINE__);
	UINT32 rebuyFppPrice; _parser.parseUINT32(rebuyFppPrice);
	AtfValidator::validateInt(_descr, "rebuyFppPrice", rebuyFppPrice, _checker, __FILE__, __LINE__);
	UINT32 addOnFppPrice; _parser.parseUINT32(addOnFppPrice);
	AtfValidator::validateInt(_descr, "addOnFppPrice", addOnFppPrice, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 startingTime_t; _parser.parseUINT32(startingTime_t);
	AtfValidator::validateInt(_descr, "startingTime_t", startingTime_t, _checker, __FILE__, __LINE__);
	UINT32 registrationStarts_t; _parser.parseUINT32(registrationStarts_t);
	AtfValidator::validateInt(_descr, "registrationStarts_t", registrationStarts_t, _checker, __FILE__, __LINE__);
	UINT32 registrationEnds_t; _parser.parseUINT32(registrationEnds_t);
	AtfValidator::validateInt(_descr, "registrationEnds_t", registrationEnds_t, _checker, __FILE__, __LINE__);
	UINT32 seatingStarts_t; _parser.parseUINT32(seatingStarts_t);
	AtfValidator::validateInt(_descr, "seatingStarts_t", seatingStarts_t, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _parser.parseUINT32(tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT32 tournProp2; _parser.parseUINT32(tournProp2);
	AtfValidator::validateInt(_descr, "tournProp2", tournProp2, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTicketTypes = ThinAtf::LAtfVector< P_TicketType , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "ticketTypes", szTicketTypes, _checker, __FILE__, __LINE__);
	UINT32 tableLogo; _parser.parseUINT32(tableLogo);
	AtfValidator::validateInt(_descr, "tableLogo", tableLogo, _checker, __FILE__, __LINE__);
	I18nPString finalTableText; finalTableText.parse(_parser);
	UINT16 chatLang; _parser.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	UINT32 lobbyRestricted; _parser.parseUINT32(lobbyRestricted);
	AtfValidator::validateInt(_descr, "lobbyRestricted", lobbyRestricted, _checker, __FILE__, __LINE__);
	UINT32 fppFraction; _parser.parseUINT32(fppFraction);
	AtfValidator::validateInt(_descr, "fppFraction", fppFraction, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 rebuyFppReward; _parser.parseUINT32(rebuyFppReward);
	AtfValidator::validateInt(_descr, "rebuyFppReward", rebuyFppReward, _checker, __FILE__, __LINE__);
	UINT32 addOnFppReward; _parser.parseUINT32(addOnFppReward);
	AtfValidator::validateInt(_descr, "addOnFppReward", addOnFppReward, _checker, __FILE__, __LINE__);
	BYTE fppRewardPercent; _parser.parseBYTE(fppRewardPercent);
	AtfValidator::validateInt(_descr, "fppRewardPercent", fppRewardPercent, _checker, __FILE__, __LINE__);
	UINT32 nPublishLobbyPlayersLess; _parser.parseUINT32(nPublishLobbyPlayersLess);
	AtfValidator::validateInt(_descr, "nPublishLobbyPlayersLess", nPublishLobbyPlayersLess, _checker, __FILE__, __LINE__);
	UINT32 bounty; _parser.parseUINT32(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	int szFallbackSatelliteTargets = ThinAtf::LAtfVector< UINT32 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("fallbackSatelliteTargets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "fallbackSatelliteTargets", szFallbackSatelliteTargets, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE publPropFlag; _parser.parseBYTE(publPropFlag);
	AtfValidator::validateInt(_descr, "publPropFlag", publPropFlag, _checker, __FILE__, __LINE__);
	UINT32 multiDayTournProps; _parser.parseUINT32(multiDayTournProps);
	AtfValidator::validateInt(_descr, "multiDayTournProps", multiDayTournProps, _checker, __FILE__, __LINE__);
	UINT32 multiDayTournDayOneStopValue; _parser.parseUINT32(multiDayTournDayOneStopValue);
	AtfValidator::validateInt(_descr, "multiDayTournDayOneStopValue", multiDayTournDayOneStopValue, _checker, __FILE__, __LINE__);
	UINT32 multiDayTournDayTwoStartMinutes; _parser.parseUINT32(multiDayTournDayTwoStartMinutes);
	AtfValidator::validateInt(_descr, "multiDayTournDayTwoStartMinutes", multiDayTournDayTwoStartMinutes, _checker, __FILE__, __LINE__);
	SrvTime multiDayTournDayTwoStarts; _parser.parseSrvTime(multiDayTournDayTwoStarts);
	AtfValidator::validateSrvDateTime(_descr, "multiDayTournDayTwoStarts", multiDayTournDayTwoStarts, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "satelliteTargetReference"); size_t szSatelliteTargetReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetReference", szSatelliteTargetReference, _checker, __FILE__, __LINE__);
	UINT16 satelliteTargetReferenceLock; _parser.parseUINT16(satelliteTargetReferenceLock);
	AtfValidator::validateInt(_descr, "satelliteTargetReferenceLock", satelliteTargetReferenceLock, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	BYTE timedTournType; _parser.parseBYTE(timedTournType);
	AtfValidator::validateInt(_descr, "timedTournType", timedTournType, _checker, __FILE__, __LINE__);
	UINT16 timedTournLevelsOrMinutes; _parser.parseUINT16(timedTournLevelsOrMinutes);
	AtfValidator::validateInt(_descr, "timedTournLevelsOrMinutes", timedTournLevelsOrMinutes, _checker, __FILE__, __LINE__);
	BYTE timedTournPayoutStructure; _parser.parseBYTE(timedTournPayoutStructure);
	AtfValidator::validateInt(_descr, "timedTournPayoutStructure", timedTournPayoutStructure, _checker, __FILE__, __LINE__);
	bool _obsolete_3; _parser.parseBOOL(_obsolete_3);
	AtfValidator::validateInt(_descr, "_obsolete_3", _obsolete_3, _checker, __FILE__, __LINE__);
	int szFppRewards = ThinAtf::LAtfVector< P_FppReward , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("fppRewards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "fppRewards", szFppRewards, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _parser.parseBYTE(speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tournBrand"); size_t szTournBrand = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournBrand", szTournBrand, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 blitzNormalDealingThreshold; _parser.parseUINT32(blitzNormalDealingThreshold);
	AtfValidator::validateInt(_descr, "blitzNormalDealingThreshold", blitzNormalDealingThreshold, _checker, __FILE__, __LINE__);
	bool _obsolete_4; _parser.parseBOOL(_obsolete_4);
	AtfValidator::validateInt(_descr, "_obsolete_4", _obsolete_4, _checker, __FILE__, __LINE__);
	BYTE progressiveKnockout; _parser.parseBYTE(progressiveKnockout);
	AtfValidator::validateInt(_descr, "progressiveKnockout", progressiveKnockout, _checker, __FILE__, __LINE__);
	I18nPString tableText; tableText.parse(_parser);
	UINT16 reEntryAllowed; _parser.parseUINT16(reEntryAllowed);
	AtfValidator::validateInt(_descr, "reEntryAllowed", reEntryAllowed, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _parser.parseUINT32(tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _parser.parseUINT32(tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _parser.parseUINT32(tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _parser.parseUINT32(tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "internalReference"); size_t szInternalReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "internalReference", szInternalReference, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "favoriteReference"); size_t szFavoriteReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "favoriteReference", szFavoriteReference, _checker, __FILE__, __LINE__);
	INT64 ticketPrice; _parser.parseINT64(ticketPrice);
	AtfValidator::validateInt(_descr, "ticketPrice", ticketPrice, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	bool cannotUnregisterFromTarget; _parser.parseBOOL(cannotUnregisterFromTarget);
	AtfValidator::validateInt(_descr, "cannotUnregisterFromTarget", cannotUnregisterFromTarget, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime targetWhenStarts; _parser.parseSrvTime(targetWhenStarts);
	AtfValidator::validateSrvDateTime(_descr, "targetWhenStarts", targetWhenStarts, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "admission"); size_t szAdmission = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admission", szAdmission, _checker, __FILE__, __LINE__);
	UINT32 siteMask; _parser.parseUINT32(siteMask);
	AtfValidator::validateInt(_descr, "siteMask", siteMask, _checker, __FILE__, __LINE__);
	UINT32 publStartLevel; _parser.parseUINT32(publStartLevel);
	AtfValidator::validateInt(_descr, "publStartLevel", publStartLevel, _checker, __FILE__, __LINE__);
	UINT32 tournMask5; _parser.parseUINT32(tournMask5);
	AtfValidator::validateInt(_descr, "tournMask5", tournMask5, _checker, __FILE__, __LINE__);
	UINT32 tournMask6; _parser.parseUINT32(tournMask6);
	AtfValidator::validateInt(_descr, "tournMask6", tournMask6, _checker, __FILE__, __LINE__);
	BYTE dealExclusionType; _parser.parseBYTE(dealExclusionType);
	AtfValidator::validateInt(_descr, "dealExclusionType", dealExclusionType, _checker, __FILE__, __LINE__);
	UINT32 dealExclusionValue; _parser.parseUINT32(dealExclusionValue);
	AtfValidator::validateInt(_descr, "dealExclusionValue", dealExclusionValue, _checker, __FILE__, __LINE__);
	BYTE timedTournPlayersPercent; _parser.parseBYTE(timedTournPlayersPercent);
	AtfValidator::validateInt(_descr, "timedTournPlayersPercent", timedTournPlayersPercent, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_5; _parser.parseUINT32(_obsolete_5);
	AtfValidator::validateInt(_descr, "_obsolete_5", _obsolete_5, _checker, __FILE__, __LINE__);
	UINT32 spinGoStartDelay; _parser.parseUINT32(spinGoStartDelay);
	AtfValidator::validateInt(_descr, "spinGoStartDelay", spinGoStartDelay, _checker, __FILE__, __LINE__);
	BYTE rmPmLobby; _parser.parseBYTE(rmPmLobby);
	AtfValidator::validateInt(_descr, "rmPmLobby", rmPmLobby, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	UINT32 playerKnockOutAddOn; _parser.parseUINT32(playerKnockOutAddOn);
	AtfValidator::validateInt(_descr, "playerKnockOutAddOn", playerKnockOutAddOn, _checker, __FILE__, __LINE__);
	UINT32 totalKnockOutAddOn; _parser.parseUINT32(totalKnockOutAddOn);
	AtfValidator::validateInt(_descr, "totalKnockOutAddOn", totalKnockOutAddOn, _checker, __FILE__, __LINE__);
	BYTE knockOutAddOnProgressive; _parser.parseBYTE(knockOutAddOnProgressive);
	AtfValidator::validateInt(_descr, "knockOutAddOnProgressive", knockOutAddOnProgressive, _checker, __FILE__, __LINE__);
	UINT32 sitGoStarterGameId; _parser.parseUINT32(sitGoStarterGameId);
	AtfValidator::validateInt(_descr, "sitGoStarterGameId", sitGoStarterGameId, _checker, __FILE__, __LINE__);
	UINT32 numStandardButton; _parser.parseUINT32(numStandardButton);
	AtfValidator::validateInt(_descr, "numStandardButton", numStandardButton, _checker, __FILE__, __LINE__);
	INT32 lateRegDelta; _parser.parseINT32(lateRegDelta);
	AtfValidator::validateInt(_descr, "lateRegDelta", lateRegDelta, _checker, __FILE__, __LINE__);
	INT32 finalTablePlusOne; _parser.parseINT32(finalTablePlusOne);
	AtfValidator::validateInt(_descr, "finalTablePlusOne", finalTablePlusOne, _checker, __FILE__, __LINE__);
	UINT32 multidayIndex; _parser.parseUINT32(multidayIndex);
	AtfValidator::validateInt(_descr, "multidayIndex", multidayIndex, _checker, __FILE__, __LINE__);
	int szMultiDayInfo = ThinAtf::LAtfVector< P_MultiDayInfo , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("multiDayInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "multiDayInfo", szMultiDayInfo, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "criteria"); size_t szCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "criteria", szCriteria, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "groupReference"); size_t szGroupReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "groupReference", szGroupReference, _checker, __FILE__, __LINE__);
}

void MTLobbyCli::publication::TournSubscr_Static::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	teamProBounties.parseMsg(_parser0);
	bountyMultipliers.parseMsg(_parser0);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_Static::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szTeamProBounties = ThinAtf::LAtfVector< UINT32 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("teamProBounties"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "teamProBounties", szTeamProBounties, _checker, __FILE__, __LINE__);
	int szBountyMultipliers = ThinAtf::LAtfVector< UINT32 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("bountyMultipliers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "bountyMultipliers", szBountyMultipliers, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MTLobbyCli::publication::TournSubscr_Static::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(initialStacks);
	_parser0.parseUINT32(singleStackChips);
	_parser0.parseUINT32(forceReloadAllStacksInLevel);
	_parser0.parseUINT32(forceReloadAllStacksInMinutes);
	_parser0.parseBOOL(reloadStacksOnlyWhenEmpty);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_Static::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.parseEnded()) return;
	UINT32 initialStacks; _parser0.parseUINT32(initialStacks);
	AtfValidator::validateInt(_descr, "initialStacks", initialStacks, _checker, __FILE__, __LINE__);
	UINT32 singleStackChips; _parser0.parseUINT32(singleStackChips);
	AtfValidator::validateInt(_descr, "singleStackChips", singleStackChips, _checker, __FILE__, __LINE__);
	UINT32 forceReloadAllStacksInLevel; _parser0.parseUINT32(forceReloadAllStacksInLevel);
	AtfValidator::validateInt(_descr, "forceReloadAllStacksInLevel", forceReloadAllStacksInLevel, _checker, __FILE__, __LINE__);
	UINT32 forceReloadAllStacksInMinutes; _parser0.parseUINT32(forceReloadAllStacksInMinutes);
	AtfValidator::validateInt(_descr, "forceReloadAllStacksInMinutes", forceReloadAllStacksInMinutes, _checker, __FILE__, __LINE__);
	bool reloadStacksOnlyWhenEmpty; _parser0.parseBOOL(reloadStacksOnlyWhenEmpty);
	AtfValidator::validateInt(_descr, "reloadStacksOnlyWhenEmpty", reloadStacksOnlyWhenEmpty, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournSubscr_Betting
//=================================================================

MTLobbyCli::publication::TournSubscr_Betting::TournSubscr_Betting()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_Betting::TournSubscr_Betting(TournSubscr_Betting&& _o)
	: loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, bringIn(std::move(_o.bringIn))
	, smallBlind(std::move(_o.smallBlind))
	, structure(std::move(_o.structure))
	, ante(std::move(_o.ante))
	, blindsLevel(std::move(_o.blindsLevel))
	, nextLevelOrdinal(std::move(_o.nextLevelOrdinal))
	, nextAnte(std::move(_o.nextAnte))
	, nextSmallBlind(std::move(_o.nextSmallBlind))
	, nextLoBet(std::move(_o.nextLoBet))
	, nextHiBet(std::move(_o.nextHiBet))
	, nextBringIn(std::move(_o.nextBringIn))
	, nextLevelStart_t(std::move(_o.nextLevelStart_t))
	, nextLevelStart(std::move(_o.nextLevelStart))
	, olympicLevel(std::move(_o.olympicLevel))
	, gameType(std::move(_o.gameType))
	, limit(std::move(_o.limit))
	, isHiLo(std::move(_o.isHiLo))
{
}

MTLobbyCli::publication::TournSubscr_Betting& MTLobbyCli::publication::TournSubscr_Betting::operator=(TournSubscr_Betting&& _o)
{
	if(this != &_o)
	{
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		bringIn = std::move(_o.bringIn);
		smallBlind = std::move(_o.smallBlind);
		structure = std::move(_o.structure);
		ante = std::move(_o.ante);
		blindsLevel = std::move(_o.blindsLevel);
		nextLevelOrdinal = std::move(_o.nextLevelOrdinal);
		nextAnte = std::move(_o.nextAnte);
		nextSmallBlind = std::move(_o.nextSmallBlind);
		nextLoBet = std::move(_o.nextLoBet);
		nextHiBet = std::move(_o.nextHiBet);
		nextBringIn = std::move(_o.nextBringIn);
		nextLevelStart_t = std::move(_o.nextLevelStart_t);
		nextLevelStart = std::move(_o.nextLevelStart);
		olympicLevel = std::move(_o.olympicLevel);
		gameType = std::move(_o.gameType);
		limit = std::move(_o.limit);
		isHiLo = std::move(_o.isHiLo);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_Betting::clear()
{
	loBet = 0;
	hiBet = 0;
	bringIn = 0;
	smallBlind = 0;
	structure = 0;
	ante = 0;
	blindsLevel = 0;
	nextLevelOrdinal = 0;
	nextAnte = 0;
	nextSmallBlind = 0;
	nextLoBet = 0;
	nextHiBet = 0;
	nextBringIn = 0;
	nextLevelStart_t = 0;
	nextLevelStart.setNull();
	olympicLevel = 0;
	gameType = 0;
	limit = 0;
	isHiLo = false;
}

bool MTLobbyCli::publication::TournSubscr_Betting::equals(const TournSubscr_Betting& _o) const
{
	return loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		bringIn == _o.bringIn &&
		smallBlind == _o.smallBlind &&
		structure == _o.structure &&
		ante == _o.ante &&
		blindsLevel == _o.blindsLevel &&
		nextLevelOrdinal == _o.nextLevelOrdinal &&
		nextAnte == _o.nextAnte &&
		nextSmallBlind == _o.nextSmallBlind &&
		nextLoBet == _o.nextLoBet &&
		nextHiBet == _o.nextHiBet &&
		nextBringIn == _o.nextBringIn &&
		nextLevelStart_t == _o.nextLevelStart_t &&
		nextLevelStart.equals(_o.nextLevelStart) &&
		olympicLevel == _o.olympicLevel &&
		gameType == _o.gameType &&
		limit == _o.limit &&
		isHiLo == _o.isHiLo;
}

const char *MTLobbyCli::publication::TournSubscr_Betting::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("bringIn=");
	_buf.appendUint(bringIn);
	_buf.append(',');
	_buf.append("smallBlind=");
	_buf.appendUint(smallBlind);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("blindsLevel=");
	_buf.appendUint(blindsLevel);
	_buf.append(',');
	_buf.append("nextLevelOrdinal=");
	_buf.appendUint(nextLevelOrdinal);
	if( nextLevelOrdinal )
	{
		_buf.append(',');
		_buf.append("nextAnte=");
		_buf.appendUint(nextAnte);
		_buf.append(',');
		_buf.append("nextSmallBlind=");
		_buf.appendUint(nextSmallBlind);
		_buf.append(',');
		_buf.append("nextLoBet=");
		_buf.appendUint(nextLoBet);
		_buf.append(',');
		_buf.append("nextHiBet=");
		_buf.appendUint(nextHiBet);
		_buf.append(',');
		_buf.append("nextBringIn=");
		_buf.appendUint(nextBringIn);
		_buf.append(',');
		_buf.append("nextLevelStart_t=");
		_buf.appendUint(nextLevelStart_t);
		_buf.append(',');
		_buf.append("nextLevelStart=");
		ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, nextLevelStart);
	}
	_buf.append(',');
	_buf.append("olympicLevel=");
	_buf.appendUint(olympicLevel);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_Betting::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(loBet);
	_msg.composeUINT32(hiBet);
	_msg.composeUINT32(bringIn);
	_msg.composeUINT32(smallBlind);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(ante);
	_msg.composeBYTE(blindsLevel);
	_msg.composeBYTE(nextLevelOrdinal);
	if( nextLevelOrdinal )
	{
		_msg.composeUINT32(nextAnte);
		_msg.composeUINT32(nextSmallBlind);
		_msg.composeUINT32(nextLoBet);
		_msg.composeUINT32(nextHiBet);
		_msg.composeUINT32(nextBringIn);
		_msg.composeUINT32(nextLevelStart_t);
		_msg.composeSrvTime(nextLevelStart);
	}
	_msg.composeUINT16(olympicLevel);
	_msg.composeBYTE(gameType);
	_msg.composeBYTE(limit);
	_msg.composeBOOL(isHiLo);
}

void MTLobbyCli::publication::TournSubscr_Betting::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(loBet);
	_parser.parseUINT32(hiBet);
	_parser.parseUINT32(bringIn);
	_parser.parseUINT32(smallBlind);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(ante);
	_parser.parseBYTE(blindsLevel);
	_parser.parseBYTE(nextLevelOrdinal);
	if( nextLevelOrdinal )
	{
		_parser.parseUINT32(nextAnte);
		_parser.parseUINT32(nextSmallBlind);
		_parser.parseUINT32(nextLoBet);
		_parser.parseUINT32(nextHiBet);
		_parser.parseUINT32(nextBringIn);
		_parser.parseUINT32(nextLevelStart_t);
		_parser.parseSrvTime(nextLevelStart);
	}
	_parser.parseUINT16(olympicLevel);
	_parser.parseBYTE(gameType);
	_parser.parseBYTE(limit);
	_parser.parseBOOL(isHiLo);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_Betting::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE nextLevelOrdinal = 0;
	UINT32 loBet; _parser.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 bringIn; _parser.parseUINT32(bringIn);
	AtfValidator::validateInt(_descr, "bringIn", bringIn, _checker, __FILE__, __LINE__);
	UINT32 smallBlind; _parser.parseUINT32(smallBlind);
	AtfValidator::validateInt(_descr, "smallBlind", smallBlind, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	BYTE blindsLevel; _parser.parseBYTE(blindsLevel);
	AtfValidator::validateInt(_descr, "blindsLevel", blindsLevel, _checker, __FILE__, __LINE__);
	_parser.parseBYTE(nextLevelOrdinal);
	AtfValidator::validateInt(_descr, "nextLevelOrdinal", nextLevelOrdinal, _checker, __FILE__, __LINE__);
	if( nextLevelOrdinal )
	{
		UINT32 nextAnte; _parser.parseUINT32(nextAnte);
		AtfValidator::validateInt(_descr, "nextAnte", nextAnte, _checker, __FILE__, __LINE__);
		UINT32 nextSmallBlind; _parser.parseUINT32(nextSmallBlind);
		AtfValidator::validateInt(_descr, "nextSmallBlind", nextSmallBlind, _checker, __FILE__, __LINE__);
		UINT32 nextLoBet; _parser.parseUINT32(nextLoBet);
		AtfValidator::validateInt(_descr, "nextLoBet", nextLoBet, _checker, __FILE__, __LINE__);
		UINT32 nextHiBet; _parser.parseUINT32(nextHiBet);
		AtfValidator::validateInt(_descr, "nextHiBet", nextHiBet, _checker, __FILE__, __LINE__);
		UINT32 nextBringIn; _parser.parseUINT32(nextBringIn);
		AtfValidator::validateInt(_descr, "nextBringIn", nextBringIn, _checker, __FILE__, __LINE__);
		UINT32 nextLevelStart_t; _parser.parseUINT32(nextLevelStart_t);
		AtfValidator::validateInt(_descr, "nextLevelStart_t", nextLevelStart_t, _checker, __FILE__, __LINE__);
		SrvTime nextLevelStart; _parser.parseSrvTime(nextLevelStart);
		AtfValidator::validateSrvDateTime(_descr, "nextLevelStart", nextLevelStart, _checker, __FILE__, __LINE__);
	}
	UINT16 olympicLevel; _parser.parseUINT16(olympicLevel);
	AtfValidator::validateInt(_descr, "olympicLevel", olympicLevel, _checker, __FILE__, __LINE__);
	BYTE gameType; _parser.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	BYTE limit; _parser.parseBYTE(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Status
//=================================================================

MTLobbyCli::publication::TournSubscr_Status::TournSubscr_Status()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_Status::TournSubscr_Status(TournSubscr_Status&& _o)
	: status(std::move(_o.status))
	, newStartTimeFlightTourn(std::move(_o.newStartTimeFlightTourn))
	, minutesLateFlightTourn(std::move(_o.minutesLateFlightTourn))
	, createdBy(std::move(_o.createdBy))
	, cancelledBy(std::move(_o.cancelledBy))
	, isBlitzTourn(std::move(_o.isBlitzTourn))
	, timedTournPlayersThreshold(std::move(_o.timedTournPlayersThreshold))
	, sameLevelFlightsAvailable(std::move(_o.sameLevelFlightsAvailable))
	, nextLevelFlightsAvailable(std::move(_o.nextLevelFlightsAvailable))
	, delayedPlaceDelta(std::move(_o.delayedPlaceDelta))
	, activeFlags(std::move(_o.activeFlags))
	, isWinTheButtonTourn(std::move(_o.isWinTheButtonTourn))
{
}

MTLobbyCli::publication::TournSubscr_Status& MTLobbyCli::publication::TournSubscr_Status::operator=(TournSubscr_Status&& _o)
{
	if(this != &_o)
	{
		status = std::move(_o.status);
		newStartTimeFlightTourn = std::move(_o.newStartTimeFlightTourn);
		minutesLateFlightTourn = std::move(_o.minutesLateFlightTourn);
		createdBy = std::move(_o.createdBy);
		cancelledBy = std::move(_o.cancelledBy);
		isBlitzTourn = std::move(_o.isBlitzTourn);
		timedTournPlayersThreshold = std::move(_o.timedTournPlayersThreshold);
		sameLevelFlightsAvailable = std::move(_o.sameLevelFlightsAvailable);
		nextLevelFlightsAvailable = std::move(_o.nextLevelFlightsAvailable);
		delayedPlaceDelta = std::move(_o.delayedPlaceDelta);
		activeFlags = std::move(_o.activeFlags);
		isWinTheButtonTourn = std::move(_o.isWinTheButtonTourn);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_Status::clear()
{
	status = 0;
	newStartTimeFlightTourn.setNull();
	minutesLateFlightTourn = 0;
	createdBy.clear();
	cancelledBy.clear();
	isBlitzTourn = false;
	timedTournPlayersThreshold = 0;
	sameLevelFlightsAvailable = false;
	nextLevelFlightsAvailable = false;
	delayedPlaceDelta = 0;
	activeFlags = 0;
	isWinTheButtonTourn = false;
}

bool MTLobbyCli::publication::TournSubscr_Status::equals(const TournSubscr_Status& _o) const
{
	return status == _o.status &&
		newStartTimeFlightTourn.equals(_o.newStartTimeFlightTourn) &&
		minutesLateFlightTourn == _o.minutesLateFlightTourn &&
		createdBy.equals(_o.createdBy) &&
		cancelledBy.equals(_o.cancelledBy) &&
		isBlitzTourn == _o.isBlitzTourn &&
		timedTournPlayersThreshold == _o.timedTournPlayersThreshold &&
		sameLevelFlightsAvailable == _o.sameLevelFlightsAvailable &&
		nextLevelFlightsAvailable == _o.nextLevelFlightsAvailable &&
		delayedPlaceDelta == _o.delayedPlaceDelta &&
		activeFlags == _o.activeFlags &&
		isWinTheButtonTourn == _o.isWinTheButtonTourn;
}

const char *MTLobbyCli::publication::TournSubscr_Status::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("newStartTimeFlightTourn=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, newStartTimeFlightTourn);
	_buf.append(',');
	_buf.append("minutesLateFlightTourn=");
	_buf.appendUint(minutesLateFlightTourn);
	_buf.append(',');
	_buf.append("createdBy=");
	_buf.append(createdBy);
	_buf.append(',');
	_buf.append("cancelledBy=");
	_buf.append(cancelledBy);
	_buf.append(',');
	_buf.append("isBlitzTourn=");
	_buf.appendUint(isBlitzTourn);
	_buf.append(',');
	_buf.append("timedTournPlayersThreshold=");
	_buf.appendUint(timedTournPlayersThreshold);
	_buf.append(',');
	_buf.append("sameLevelFlightsAvailable=");
	_buf.appendUint(sameLevelFlightsAvailable);
	_buf.append(',');
	_buf.append("nextLevelFlightsAvailable=");
	_buf.appendUint(nextLevelFlightsAvailable);
	_buf.append(',');
	_buf.append("delayedPlaceDelta=");
	_buf.appendInt(delayedPlaceDelta);
	_buf.append(',');
	_buf.append("activeFlags=");
	_buf.appendUint(activeFlags);
	_buf.append(',');
	_buf.append("isWinTheButtonTourn=");
	_buf.appendUint(isWinTheButtonTourn);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_Status::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(status);
	_msg.composeSrvTime(newStartTimeFlightTourn);
	_msg.composeUINT32(minutesLateFlightTourn);
	_msg.composeString(createdBy);
	_msg.composeString(cancelledBy);
	_msg.composeBOOL(isBlitzTourn);
	_msg.composeUINT32(timedTournPlayersThreshold);
	_msg.composeBOOL(sameLevelFlightsAvailable);
	_msg.composeBOOL(nextLevelFlightsAvailable);
	_msg.composeINT32(delayedPlaceDelta);
	_msg.composeUINT32(activeFlags);
	_msg.composeBOOL(isWinTheButtonTourn);
}

void MTLobbyCli::publication::TournSubscr_Status::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(status);
	_parser.parseSrvTime(newStartTimeFlightTourn);
	_parser.parseUINT32(minutesLateFlightTourn);
	_parser.parseStringP(createdBy);
	_parser.parseStringP(cancelledBy);
	_parser.parseBOOL(isBlitzTourn);
	_parser.parseUINT32(timedTournPlayersThreshold);
	_parser.parseBOOL(sameLevelFlightsAvailable);
	_parser.parseBOOL(nextLevelFlightsAvailable);
	_parser.parseINT32(delayedPlaceDelta);
	_parser.parseUINT32(activeFlags);
	_parser.parseBOOL(isWinTheButtonTourn);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_Status::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	SrvTime newStartTimeFlightTourn; _parser.parseSrvTime(newStartTimeFlightTourn);
	AtfValidator::validateSrvDateTime(_descr, "newStartTimeFlightTourn", newStartTimeFlightTourn, _checker, __FILE__, __LINE__);
	UINT32 minutesLateFlightTourn; _parser.parseUINT32(minutesLateFlightTourn);
	AtfValidator::validateInt(_descr, "minutesLateFlightTourn", minutesLateFlightTourn, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "createdBy"); size_t szCreatedBy = strlen(_dummy);
	AtfValidator::validateInt(_descr, "createdBy", szCreatedBy, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cancelledBy"); size_t szCancelledBy = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cancelledBy", szCancelledBy, _checker, __FILE__, __LINE__);
	bool isBlitzTourn; _parser.parseBOOL(isBlitzTourn);
	AtfValidator::validateInt(_descr, "isBlitzTourn", isBlitzTourn, _checker, __FILE__, __LINE__);
	UINT32 timedTournPlayersThreshold; _parser.parseUINT32(timedTournPlayersThreshold);
	AtfValidator::validateInt(_descr, "timedTournPlayersThreshold", timedTournPlayersThreshold, _checker, __FILE__, __LINE__);
	bool sameLevelFlightsAvailable; _parser.parseBOOL(sameLevelFlightsAvailable);
	AtfValidator::validateInt(_descr, "sameLevelFlightsAvailable", sameLevelFlightsAvailable, _checker, __FILE__, __LINE__);
	bool nextLevelFlightsAvailable; _parser.parseBOOL(nextLevelFlightsAvailable);
	AtfValidator::validateInt(_descr, "nextLevelFlightsAvailable", nextLevelFlightsAvailable, _checker, __FILE__, __LINE__);
	INT32 delayedPlaceDelta; _parser.parseINT32(delayedPlaceDelta);
	AtfValidator::validateInt(_descr, "delayedPlaceDelta", delayedPlaceDelta, _checker, __FILE__, __LINE__);
	UINT32 activeFlags; _parser.parseUINT32(activeFlags);
	AtfValidator::validateInt(_descr, "activeFlags", activeFlags, _checker, __FILE__, __LINE__);
	bool isWinTheButtonTourn; _parser.parseBOOL(isWinTheButtonTourn);
	AtfValidator::validateInt(_descr, "isWinTheButtonTourn", isWinTheButtonTourn, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Break
//=================================================================

MTLobbyCli::publication::TournSubscr_Break::TournSubscr_Break()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_Break::TournSubscr_Break(TournSubscr_Break&& _o)
	: nextBreakStarts(std::move(_o.nextBreakStarts))
	, currentBreakStops(std::move(_o.currentBreakStops))
	, currentBreakDuration(std::move(_o.currentBreakDuration))
	, nextBreakStarts_t(std::move(_o.nextBreakStarts_t))
	, currentBreakStops_t(std::move(_o.currentBreakStops_t))
	, addOnEligibleBreak(std::move(_o.addOnEligibleBreak))
	, blitzTableRound(std::move(_o.blitzTableRound))
	, message(std::move(_o.message))
{
}

MTLobbyCli::publication::TournSubscr_Break& MTLobbyCli::publication::TournSubscr_Break::operator=(TournSubscr_Break&& _o)
{
	if(this != &_o)
	{
		nextBreakStarts = std::move(_o.nextBreakStarts);
		currentBreakStops = std::move(_o.currentBreakStops);
		currentBreakDuration = std::move(_o.currentBreakDuration);
		nextBreakStarts_t = std::move(_o.nextBreakStarts_t);
		currentBreakStops_t = std::move(_o.currentBreakStops_t);
		addOnEligibleBreak = std::move(_o.addOnEligibleBreak);
		blitzTableRound = std::move(_o.blitzTableRound);
		message = std::move(_o.message);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_Break::clear()
{
	nextBreakStarts.setNull();
	currentBreakStops.setNull();
	currentBreakDuration = 0;
	nextBreakStarts_t = 0;
	currentBreakStops_t = 0;
	addOnEligibleBreak = false;
	blitzTableRound = 0;
	message.clear();
}

bool MTLobbyCli::publication::TournSubscr_Break::equals(const TournSubscr_Break& _o) const
{
	return nextBreakStarts.equals(_o.nextBreakStarts) &&
		currentBreakStops.equals(_o.currentBreakStops) &&
		currentBreakDuration == _o.currentBreakDuration &&
		nextBreakStarts_t == _o.nextBreakStarts_t &&
		currentBreakStops_t == _o.currentBreakStops_t &&
		addOnEligibleBreak == _o.addOnEligibleBreak &&
		blitzTableRound == _o.blitzTableRound &&
		message.equals(_o.message);
}

const char *MTLobbyCli::publication::TournSubscr_Break::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("nextBreakStarts=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, nextBreakStarts);
	_buf.append(',');
	_buf.append("currentBreakStops=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, currentBreakStops);
	_buf.append(',');
	_buf.append("currentBreakDuration=");
	_buf.appendUint(currentBreakDuration);
	_buf.append(',');
	_buf.append("nextBreakStarts_t=");
	_buf.appendUint(nextBreakStarts_t);
	_buf.append(',');
	_buf.append("currentBreakStops_t=");
	_buf.appendUint(currentBreakStops_t);
	_buf.append(',');
	_buf.append("addOnEligibleBreak=");
	_buf.appendUint(addOnEligibleBreak);
	_buf.append(',');
	_buf.append("blitzTableRound=");
	_buf.appendUint(blitzTableRound);
	_buf.append(',');
	_buf.append("message=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, message);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_Break::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(nextBreakStarts);
	_msg.composeSrvTime(currentBreakStops);
	_msg.composeUINT32(currentBreakDuration);
	_msg.composeUINT32(nextBreakStarts_t);
	_msg.composeUINT32(currentBreakStops_t);
	_msg.composeBOOL(addOnEligibleBreak);
	_msg.composeUINT32(blitzTableRound);
	message.compose(_msg);
}

void MTLobbyCli::publication::TournSubscr_Break::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(nextBreakStarts);
	_parser.parseSrvTime(currentBreakStops);
	_parser.parseUINT32(currentBreakDuration);
	_parser.parseUINT32(nextBreakStarts_t);
	_parser.parseUINT32(currentBreakStops_t);
	_parser.parseBOOL(addOnEligibleBreak);
	_parser.parseUINT32(blitzTableRound);
	message.parse(_parser);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_Break::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	SrvTime nextBreakStarts; _parser.parseSrvTime(nextBreakStarts);
	AtfValidator::validateSrvDateTime(_descr, "nextBreakStarts", nextBreakStarts, _checker, __FILE__, __LINE__);
	SrvTime currentBreakStops; _parser.parseSrvTime(currentBreakStops);
	AtfValidator::validateSrvDateTime(_descr, "currentBreakStops", currentBreakStops, _checker, __FILE__, __LINE__);
	UINT32 currentBreakDuration; _parser.parseUINT32(currentBreakDuration);
	AtfValidator::validateInt(_descr, "currentBreakDuration", currentBreakDuration, _checker, __FILE__, __LINE__);
	UINT32 nextBreakStarts_t; _parser.parseUINT32(nextBreakStarts_t);
	AtfValidator::validateInt(_descr, "nextBreakStarts_t", nextBreakStarts_t, _checker, __FILE__, __LINE__);
	UINT32 currentBreakStops_t; _parser.parseUINT32(currentBreakStops_t);
	AtfValidator::validateInt(_descr, "currentBreakStops_t", currentBreakStops_t, _checker, __FILE__, __LINE__);
	bool addOnEligibleBreak; _parser.parseBOOL(addOnEligibleBreak);
	AtfValidator::validateInt(_descr, "addOnEligibleBreak", addOnEligibleBreak, _checker, __FILE__, __LINE__);
	UINT32 blitzTableRound; _parser.parseUINT32(blitzTableRound);
	AtfValidator::validateInt(_descr, "blitzTableRound", blitzTableRound, _checker, __FILE__, __LINE__);
	I18nPString message; message.parse(_parser);
}

//=================================================================
//                    TournSubscr_Awards
//=================================================================

MTLobbyCli::publication::TournSubscr_Awards::TournSubscr_Awards()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_Awards::TournSubscr_Awards(TournSubscr_Awards&& _o)
	: effectivePrizePool(std::move(_o.effectivePrizePool))
	, prizes(std::move(_o.prizes))
	, numTicketsWithTournId(std::move(_o.numTicketsWithTournId))
	, tickets(std::move(_o.tickets))
	, additionalPrize(std::move(_o.additionalPrize))
	, mixTournSatellite(std::move(_o.mixTournSatellite))
{
}

MTLobbyCli::publication::TournSubscr_Awards& MTLobbyCli::publication::TournSubscr_Awards::operator=(TournSubscr_Awards&& _o)
{
	if(this != &_o)
	{
		effectivePrizePool = std::move(_o.effectivePrizePool);
		prizes = std::move(_o.prizes);
		numTicketsWithTournId = std::move(_o.numTicketsWithTournId);
		tickets = std::move(_o.tickets);
		additionalPrize = std::move(_o.additionalPrize);
		mixTournSatellite = std::move(_o.mixTournSatellite);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_Awards::clear()
{
	effectivePrizePool = 0;
	prizes.clear();
	numTicketsWithTournId = 0;
	tickets.clear();
	additionalPrize = 0;
	mixTournSatellite = 0;
}

bool MTLobbyCli::publication::TournSubscr_Awards::equals(const TournSubscr_Awards& _o) const
{
	return effectivePrizePool == _o.effectivePrizePool &&
		prizes.equals(_o.prizes) &&
		numTicketsWithTournId == _o.numTicketsWithTournId &&
		tickets.equals(_o.tickets) &&
		additionalPrize == _o.additionalPrize &&
		mixTournSatellite == _o.mixTournSatellite;
}

const char *MTLobbyCli::publication::TournSubscr_Awards::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("effectivePrizePool=");
	_buf.appendUint(effectivePrizePool);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("numTicketsWithTournId=");
	_buf.appendUint(numTicketsWithTournId);
	_buf.append(',');
	_buf.append("tickets=");
	tickets.toTraceString(_buf);
	_buf.append(',');
	_buf.append("additionalPrize=");
	_buf.appendUint(additionalPrize);
	_buf.append(',');
	_buf.append("mixTournSatellite=");
	_buf.appendUint(mixTournSatellite);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_Awards::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(effectivePrizePool);
	prizes.composeMsg(_msg);
	_msg.composeUINT32(numTicketsWithTournId);
	tickets.composeMsg(_msg);
	_msg.composeUINT32(additionalPrize);
	_msg.composeBYTE(mixTournSatellite);
}

void MTLobbyCli::publication::TournSubscr_Awards::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(effectivePrizePool);
	prizes.parseMsg(_parser);
	_parser.parseUINT32(numTicketsWithTournId);
	tickets.parseMsg(_parser);
	_parser.parseUINT32(additionalPrize);
	_parser.parseBYTE(mixTournSatellite);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_Awards::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 effectivePrizePool; _parser.parseUINT32(effectivePrizePool);
	AtfValidator::validateInt(_descr, "effectivePrizePool", effectivePrizePool, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPrizes = ThinAtf::LAtfVector< UINT32 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
	UINT32 numTicketsWithTournId; _parser.parseUINT32(numTicketsWithTournId);
	AtfValidator::validateInt(_descr, "numTicketsWithTournId", numTicketsWithTournId, _checker, __FILE__, __LINE__);
	int szTickets = ThinAtf::LAtfVector< UINT32 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
	UINT32 additionalPrize; _parser.parseUINT32(additionalPrize);
	AtfValidator::validateInt(_descr, "additionalPrize", additionalPrize, _checker, __FILE__, __LINE__);
	BYTE mixTournSatellite; _parser.parseBYTE(mixTournSatellite);
	AtfValidator::validateInt(_descr, "mixTournSatellite", mixTournSatellite, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_AddOn
//=================================================================

MTLobbyCli::publication::TournSubscr_AddOn::TournSubscr_AddOn()
{
	clear();
}

void MTLobbyCli::publication::TournSubscr_AddOn::clear()
{
	waiting = 0;
}

bool MTLobbyCli::publication::TournSubscr_AddOn::equals(const TournSubscr_AddOn& _o) const
{
	return waiting == _o.waiting;
}

const char *MTLobbyCli::publication::TournSubscr_AddOn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("waiting=");
	_buf.appendUint(waiting);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_AddOn::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(waiting);
}

void MTLobbyCli::publication::TournSubscr_AddOn::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(waiting);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_AddOn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE waiting; _parser.parseBYTE(waiting);
	AtfValidator::validateInt(_descr, "waiting", waiting, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_PrizePool
//=================================================================

MTLobbyCli::publication::TournSubscr_PrizePool::TournSubscr_PrizePool()
{
	clear();
}

void MTLobbyCli::publication::TournSubscr_PrizePool::clear()
{
	numUsers = 0;
	prizePoolToPublish = 0;
	totalRebuysDone = 0;
	totalAddonsDone = 0;
	payouts = 0;
	flightIntermediatePayoutPrizePool = 0;
	flightIntermediatePayoutPerUser = 0;
}

bool MTLobbyCli::publication::TournSubscr_PrizePool::equals(const TournSubscr_PrizePool& _o) const
{
	return numUsers == _o.numUsers &&
		prizePoolToPublish == _o.prizePoolToPublish &&
		totalRebuysDone == _o.totalRebuysDone &&
		totalAddonsDone == _o.totalAddonsDone &&
		payouts == _o.payouts &&
		flightIntermediatePayoutPrizePool == _o.flightIntermediatePayoutPrizePool &&
		flightIntermediatePayoutPerUser == _o.flightIntermediatePayoutPerUser;
}

const char *MTLobbyCli::publication::TournSubscr_PrizePool::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numUsers=");
	_buf.appendUint(numUsers);
	_buf.append(',');
	_buf.append("prizePoolToPublish=");
	_buf.appendInt(prizePoolToPublish);
	_buf.append(',');
	_buf.append("totalRebuysDone=");
	_buf.appendUint(totalRebuysDone);
	_buf.append(',');
	_buf.append("totalAddonsDone=");
	_buf.appendUint(totalAddonsDone);
	_buf.append(',');
	_buf.append("payouts=");
	_buf.appendInt(payouts);
	_buf.append(',');
	_buf.append("flightIntermediatePayoutPrizePool=");
	_buf.appendInt(flightIntermediatePayoutPrizePool);
	_buf.append(',');
	_buf.append("flightIntermediatePayoutPerUser=");
	_buf.appendInt(flightIntermediatePayoutPerUser);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_PrizePool::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(numUsers);
	_msg.composeINT32(prizePoolToPublish);
	_msg.composeUINT32(totalRebuysDone);
	_msg.composeUINT32(totalAddonsDone);
	_msg.composeINT32(payouts);
	_msg.composeINT32(flightIntermediatePayoutPrizePool);
	_msg.composeINT32(flightIntermediatePayoutPerUser);
}

void MTLobbyCli::publication::TournSubscr_PrizePool::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(numUsers);
	_parser.parseINT32(prizePoolToPublish);
	_parser.parseUINT32(totalRebuysDone);
	_parser.parseUINT32(totalAddonsDone);
	_parser.parseINT32(payouts);
	_parser.parseINT32(flightIntermediatePayoutPrizePool);
	_parser.parseINT32(flightIntermediatePayoutPerUser);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_PrizePool::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 numUsers; _parser.parseUINT32(numUsers);
	AtfValidator::validateInt(_descr, "numUsers", numUsers, _checker, __FILE__, __LINE__);
	INT32 prizePoolToPublish; _parser.parseINT32(prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	UINT32 totalRebuysDone; _parser.parseUINT32(totalRebuysDone);
	AtfValidator::validateInt(_descr, "totalRebuysDone", totalRebuysDone, _checker, __FILE__, __LINE__);
	UINT32 totalAddonsDone; _parser.parseUINT32(totalAddonsDone);
	AtfValidator::validateInt(_descr, "totalAddonsDone", totalAddonsDone, _checker, __FILE__, __LINE__);
	INT32 payouts; _parser.parseINT32(payouts);
	AtfValidator::validateInt(_descr, "payouts", payouts, _checker, __FILE__, __LINE__);
	INT32 flightIntermediatePayoutPrizePool; _parser.parseINT32(flightIntermediatePayoutPrizePool);
	AtfValidator::validateInt(_descr, "flightIntermediatePayoutPrizePool", flightIntermediatePayoutPrizePool, _checker, __FILE__, __LINE__);
	INT32 flightIntermediatePayoutPerUser; _parser.parseINT32(flightIntermediatePayoutPerUser);
	AtfValidator::validateInt(_descr, "flightIntermediatePayoutPerUser", flightIntermediatePayoutPerUser, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Bounty
//=================================================================

MTLobbyCli::publication::TournSubscr_Bounty::TournSubscr_Bounty()
{
	clear();
}

void MTLobbyCli::publication::TournSubscr_Bounty::clear()
{
	minBounty = 0;
	maxBounty = 0;
	averageBounty = 0;
}

bool MTLobbyCli::publication::TournSubscr_Bounty::equals(const TournSubscr_Bounty& _o) const
{
	return minBounty == _o.minBounty &&
		maxBounty == _o.maxBounty &&
		averageBounty == _o.averageBounty;
}

const char *MTLobbyCli::publication::TournSubscr_Bounty::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minBounty=");
	_buf.appendUint(minBounty);
	_buf.append(',');
	_buf.append("maxBounty=");
	_buf.appendUint(maxBounty);
	_buf.append(',');
	_buf.append("averageBounty=");
	_buf.appendUint(averageBounty);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_Bounty::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(minBounty);
	_msg.composeUINT32(maxBounty);
	_msg.composeUINT32(averageBounty);
}

void MTLobbyCli::publication::TournSubscr_Bounty::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(minBounty);
	_parser.parseUINT32(maxBounty);
	_parser.parseUINT32(averageBounty);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_Bounty::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 minBounty; _parser.parseUINT32(minBounty);
	AtfValidator::validateInt(_descr, "minBounty", minBounty, _checker, __FILE__, __LINE__);
	UINT32 maxBounty; _parser.parseUINT32(maxBounty);
	AtfValidator::validateInt(_descr, "maxBounty", maxBounty, _checker, __FILE__, __LINE__);
	UINT32 averageBounty; _parser.parseUINT32(averageBounty);
	AtfValidator::validateInt(_descr, "averageBounty", averageBounty, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_TableBanner
//=================================================================

MTLobbyCli::publication::TournSubscr_TableBanner::TournSubscr_TableBanner()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_TableBanner::TournSubscr_TableBanner(TournSubscr_TableBanner&& _o)
	: counter(std::move(_o.counter))
	, duration(std::move(_o.duration))
	, options(std::move(_o.options))
	, banner(std::move(_o.banner))
	, when(std::move(_o.when))
	, flags(std::move(_o.flags))
	, licenseMask(std::move(_o.licenseMask))
	, observerBanner(std::move(_o.observerBanner))
{
}

MTLobbyCli::publication::TournSubscr_TableBanner& MTLobbyCli::publication::TournSubscr_TableBanner::operator=(TournSubscr_TableBanner&& _o)
{
	if(this != &_o)
	{
		counter = std::move(_o.counter);
		duration = std::move(_o.duration);
		options = std::move(_o.options);
		banner = std::move(_o.banner);
		when = std::move(_o.when);
		flags = std::move(_o.flags);
		licenseMask = std::move(_o.licenseMask);
		observerBanner = std::move(_o.observerBanner);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_TableBanner::clear()
{
	counter = 0;
	duration = 0;
	options = 0;
	banner.clear();
	when.setNull();
	flags = 0;
	licenseMask = 0;
	observerBanner.clear();
}

bool MTLobbyCli::publication::TournSubscr_TableBanner::equals(const TournSubscr_TableBanner& _o) const
{
	return counter == _o.counter &&
		duration == _o.duration &&
		options == _o.options &&
		banner.equals(_o.banner) &&
		when.equals(_o.when) &&
		flags == _o.flags &&
		licenseMask == _o.licenseMask &&
		observerBanner.equals(_o.observerBanner);
}

const char *MTLobbyCli::publication::TournSubscr_TableBanner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("counter=");
	_buf.appendUint(counter);
	_buf.append(',');
	_buf.append("duration=");
	_buf.appendUint(duration);
	_buf.append(',');
	_buf.append("options=");
	_buf.appendUint(options);
	_buf.append(',');
	_buf.append("banner=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, banner);
	_buf.append(',');
	_buf.append("when=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("licenseMask=");
	_buf.appendUint(licenseMask);
	_buf.append(',');
	_buf.append("observerBanner=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, observerBanner);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_TableBanner::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(counter);
	_msg.composeUINT16(duration);
	_msg.composeUINT32(options);
	banner.compose(_msg);
	_msg.composeSrvTime(when);
	_msg.composeUINT32(flags);
	_msg.composeUINT32(licenseMask);
	observerBanner.compose(_msg);
}

void MTLobbyCli::publication::TournSubscr_TableBanner::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(counter);
	_parser.parseUINT16(duration);
	_parser.parseUINT32(options);
	banner.parse(_parser);
	_parser.parseSrvTime(when);
	_parser.parseUINT32(flags);
	_parser.parseUINT32(licenseMask);
	observerBanner.parse(_parser);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_TableBanner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 counter; _parser.parseUINT32(counter);
	AtfValidator::validateInt(_descr, "counter", counter, _checker, __FILE__, __LINE__);
	UINT16 duration; _parser.parseUINT16(duration);
	AtfValidator::validateInt(_descr, "duration", duration, _checker, __FILE__, __LINE__);
	UINT32 options; _parser.parseUINT32(options);
	AtfValidator::validateInt(_descr, "options", options, _checker, __FILE__, __LINE__);
	I18nPString banner; banner.parse(_parser);
	SrvTime when; _parser.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 licenseMask; _parser.parseUINT32(licenseMask);
	AtfValidator::validateInt(_descr, "licenseMask", licenseMask, _checker, __FILE__, __LINE__);
	I18nPString observerBanner; observerBanner.parse(_parser);
}

//=================================================================
//                    TournSubscr_OptEarlyStart
//=================================================================

MTLobbyCli::publication::TournSubscr_OptEarlyStart::TournSubscr_OptEarlyStart()
{
	clear();
}

void MTLobbyCli::publication::TournSubscr_OptEarlyStart::clear()
{
	options = 0;
}

bool MTLobbyCli::publication::TournSubscr_OptEarlyStart::equals(const TournSubscr_OptEarlyStart& _o) const
{
	return options == _o.options;
}

const char *MTLobbyCli::publication::TournSubscr_OptEarlyStart::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("options=");
	_buf.appendUint(options);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_OptEarlyStart::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(options);
}

void MTLobbyCli::publication::TournSubscr_OptEarlyStart::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(options);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_OptEarlyStart::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE options; _parser.parseBYTE(options);
	AtfValidator::validateInt(_descr, "options", options, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_SpinGoPrize_Vector
//=================================================================

MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::TournSubscr_SpinGoPrize_Vector()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::TournSubscr_SpinGoPrize_Vector(TournSubscr_SpinGoPrize_Vector&& _o)
	: prizes(std::move(_o.prizes))
{
}

MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector& MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::operator=(TournSubscr_SpinGoPrize_Vector&& _o)
{
	if(this != &_o)
	{
		prizes = std::move(_o.prizes);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::clear()
{
	prizes.clear();
}

bool MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::equals(const TournSubscr_SpinGoPrize_Vector& _o) const
{
	return prizes.equals(_o.prizes);
}

const char *MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::composeMsg(CommMsgBody& _msg) const
{
	prizes.composeMsg(_msg);
}

void MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::parseMsg(CommMsgParser& _parser)
{
	prizes.parseMsg(_parser);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_SpinGoPrize_Vector::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szPrizes = ThinAtf::LAtfVector< UINT32 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_SpinGoPrize_TargetReference
//=================================================================

MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::TournSubscr_SpinGoPrize_TargetReference()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::TournSubscr_SpinGoPrize_TargetReference(TournSubscr_SpinGoPrize_TargetReference&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, instance(std::move(_o.instance))
	, name(std::move(_o.name))
{
}

MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference& MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::operator=(TournSubscr_SpinGoPrize_TargetReference&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		instance = std::move(_o.instance);
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::clear()
{
	tournamentId = 0;
	server.clear();
	instance.clear();
	name.clear();
}

bool MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::equals(const TournSubscr_SpinGoPrize_TargetReference& _o) const
{
	return tournamentId == _o.tournamentId &&
		server.equals(_o.server) &&
		instance.equals(_o.instance) &&
		name.equals(_o.name);
}

const char *MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint64(tournamentId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("instance=");
	_buf.append(instance);
	_buf.append(',');
	_buf.append("name=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, name);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT64(tournamentId);
	_msg.composeString(server);
	_msg.composeString(instance);
	name.compose(_msg);
}

void MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(tournamentId);
	_parser.parseStringP(server);
	_parser.parseStringP(instance);
	name.parse(_parser);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_SpinGoPrize_TargetReference::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT64 tournamentId; _parser.parseUINT64(tournamentId);
	AtfValidator::validateUint(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "instance"); size_t szInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "instance", szInstance, _checker, __FILE__, __LINE__);
	I18nPString name; name.parse(_parser);
}

//=================================================================
//                    TournSubscr_SpinGoPrize
//=================================================================

MTLobbyCli::publication::TournSubscr_SpinGoPrize::TournSubscr_SpinGoPrize()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournSubscr_SpinGoPrize::TournSubscr_SpinGoPrize(TournSubscr_SpinGoPrize&& _o)
	: spinGoLevels(std::move(_o.spinGoLevels))
	, spinGoMarker(std::move(_o.spinGoMarker))
	, tickets(std::move(_o.tickets))
	, level(std::move(_o.level))
	, targetReferences(std::move(_o.targetReferences))
	, spinGoMaxCashout(std::move(_o.spinGoMaxCashout))
	, spinGoMaxLevels(std::move(_o.spinGoMaxLevels))
	, animationType(std::move(_o.animationType))
	, animationEndTime(std::move(_o.animationEndTime))
	, isJackpot(std::move(_o.isJackpot))
	, winner(std::move(_o.winner))
	, freeBetStake(std::move(_o.freeBetStake))
	, freeBetCurrency(std::move(_o.freeBetCurrency))
	, freeBetsCampaignId(std::move(_o.freeBetsCampaignId))
{
}

MTLobbyCli::publication::TournSubscr_SpinGoPrize& MTLobbyCli::publication::TournSubscr_SpinGoPrize::operator=(TournSubscr_SpinGoPrize&& _o)
{
	if(this != &_o)
	{
		spinGoLevels = std::move(_o.spinGoLevels);
		spinGoMarker = std::move(_o.spinGoMarker);
		tickets = std::move(_o.tickets);
		level = std::move(_o.level);
		targetReferences = std::move(_o.targetReferences);
		spinGoMaxCashout = std::move(_o.spinGoMaxCashout);
		spinGoMaxLevels = std::move(_o.spinGoMaxLevels);
		animationType = std::move(_o.animationType);
		animationEndTime = std::move(_o.animationEndTime);
		isJackpot = std::move(_o.isJackpot);
		winner = std::move(_o.winner);
		freeBetStake = std::move(_o.freeBetStake);
		freeBetCurrency = std::move(_o.freeBetCurrency);
		freeBetsCampaignId = std::move(_o.freeBetsCampaignId);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournSubscr_SpinGoPrize::clear()
{
	spinGoLevels.clear();
	spinGoMarker = 0;
	tickets.clear();
	level = 0;
	targetReferences.clear();
	spinGoMaxCashout = 0;
	spinGoMaxLevels.clear();
	animationType = 0;
	animationEndTime.setNull();
	isJackpot = false;
	winner.clear();
	freeBetStake = 0;
	freeBetCurrency.clear();
	freeBetsCampaignId = 0;
}

bool MTLobbyCli::publication::TournSubscr_SpinGoPrize::equals(const TournSubscr_SpinGoPrize& _o) const
{
	return spinGoLevels.equals(_o.spinGoLevels) &&
		spinGoMarker == _o.spinGoMarker &&
		tickets.equals(_o.tickets) &&
		level == _o.level &&
		targetReferences.equals(_o.targetReferences) &&
		spinGoMaxCashout == _o.spinGoMaxCashout &&
		spinGoMaxLevels.equals(_o.spinGoMaxLevels) &&
		animationType == _o.animationType &&
		animationEndTime.equals(_o.animationEndTime) &&
		isJackpot == _o.isJackpot &&
		winner.equals(_o.winner) &&
		freeBetStake == _o.freeBetStake &&
		freeBetCurrency.equals(_o.freeBetCurrency) &&
		freeBetsCampaignId == _o.freeBetsCampaignId;
}

const char *MTLobbyCli::publication::TournSubscr_SpinGoPrize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("spinGoLevels=");
	spinGoLevels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("spinGoMarker=");
	_buf.appendInt(spinGoMarker);
	_buf.append(',');
	_buf.append("tickets=");
	tickets.toTraceString(_buf);
	_buf.append(',');
	_buf.append("level=");
	_buf.appendUint(level);
	_buf.append(',');
	_buf.append("targetReferences=");
	targetReferences.toTraceString(_buf);
	_buf.append(',');
	_buf.append("spinGoMaxCashout=");
	_buf.appendUint(spinGoMaxCashout);
	_buf.append(',');
	_buf.append("spinGoMaxLevels=");
	spinGoMaxLevels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("animationType=");
	_buf.appendUint(animationType);
	_buf.append(',');
	_buf.append("animationEndTime=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, animationEndTime);
	_buf.append(',');
	_buf.append("isJackpot=");
	_buf.appendUint(isJackpot);
	_buf.append(',');
	_buf.append("winner=");
	_buf.append(winner);
	_buf.append(',');
	_buf.append("freeBetStake=");
	_buf.appendUint(freeBetStake);
	_buf.append(',');
	_buf.append("freeBetCurrency=");
	_buf.append(freeBetCurrency);
	_buf.append(',');
	_buf.append("freeBetsCampaignId=");
	_buf.appendUint(freeBetsCampaignId);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_SpinGoPrize::composeMsg(CommMsgBody& _msg) const
{
	spinGoLevels.composeMsg(_msg);
	_msg.composeINT32(spinGoMarker);
	tickets.composeMsg(_msg);
	_msg.composeUINT32(level);
	targetReferences.composeMsg(_msg);
	_msg.composeUINT32(spinGoMaxCashout);
	spinGoMaxLevels.composeMsg(_msg);
	_msg.composeUINT32(animationType);
	_msg.composeSrvTime(animationEndTime);
	_msg.composeBOOL(isJackpot);
	_msg.composeString(winner);
	_msg.composeUINT32(freeBetStake);
	_msg.composeString(freeBetCurrency);
	_msg.composeUINT32(freeBetsCampaignId);
}

void MTLobbyCli::publication::TournSubscr_SpinGoPrize::parseMsg(CommMsgParser& _parser)
{
	spinGoLevels.parseMsg(_parser);
	_parser.parseINT32(spinGoMarker);
	tickets.parseMsg(_parser);
	_parser.parseUINT32(level);
	targetReferences.parseMsg(_parser);
	_parser.parseUINT32(spinGoMaxCashout);
	spinGoMaxLevels.parseMsg(_parser);
	_parser.parseUINT32(animationType);
	_parser.parseSrvTime(animationEndTime);
	_parser.parseBOOL(isJackpot);
	_parser.parseStringP(winner);
	_parser.parseUINT32(freeBetStake);
	_parser.parseStringP(freeBetCurrency);
	_parser.parseUINT32(freeBetsCampaignId);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_SpinGoPrize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	PString _descbuf;
	int szSpinGoLevels = ThinAtf::LAtfVector< INT64 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("spinGoLevels"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "spinGoLevels", szSpinGoLevels, _checker, __FILE__, __LINE__);
	INT32 spinGoMarker; _parser.parseINT32(spinGoMarker);
	AtfValidator::validateInt(_descr, "spinGoMarker", spinGoMarker, _checker, __FILE__, __LINE__);
	int szTickets = ThinAtf::LAtfVector< I18nPString , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
	UINT32 level; _parser.parseUINT32(level);
	AtfValidator::validateInt(_descr, "level", level, _checker, __FILE__, __LINE__);
	int szTargetReferences = ThinAtf::LAtfVector< TournSubscr_SpinGoPrize_TargetReference , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("targetReferences"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "targetReferences", szTargetReferences, _checker, __FILE__, __LINE__);
	UINT32 spinGoMaxCashout; _parser.parseUINT32(spinGoMaxCashout);
	AtfValidator::validateInt(_descr, "spinGoMaxCashout", spinGoMaxCashout, _checker, __FILE__, __LINE__);
	int szSpinGoMaxLevels = ThinAtf::LAtfVector< TournSubscr_SpinGoPrize_Vector , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("spinGoMaxLevels"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "spinGoMaxLevels", szSpinGoMaxLevels, _checker, __FILE__, __LINE__);
	UINT32 animationType; _parser.parseUINT32(animationType);
	AtfValidator::validateInt(_descr, "animationType", animationType, _checker, __FILE__, __LINE__);
	SrvTime animationEndTime; _parser.parseSrvTime(animationEndTime);
	AtfValidator::validateSrvDateTime(_descr, "animationEndTime", animationEndTime, _checker, __FILE__, __LINE__);
	bool isJackpot; _parser.parseBOOL(isJackpot);
	AtfValidator::validateInt(_descr, "isJackpot", isJackpot, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "winner"); size_t szWinner = strlen(_dummy);
	AtfValidator::validateInt(_descr, "winner", szWinner, _checker, __FILE__, __LINE__);
	UINT32 freeBetStake; _parser.parseUINT32(freeBetStake);
	AtfValidator::validateInt(_descr, "freeBetStake", freeBetStake, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "freeBetCurrency"); size_t szFreeBetCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "freeBetCurrency", szFreeBetCurrency, _checker, __FILE__, __LINE__);
	UINT32 freeBetsCampaignId; _parser.parseUINT32(freeBetsCampaignId);
	AtfValidator::validateInt(_descr, "freeBetsCampaignId", freeBetsCampaignId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_PerHand
//=================================================================

MTLobbyCli::publication::TournSubscr_PerHand::TournSubscr_PerHand()
{
	clear();
}

void MTLobbyCli::publication::TournSubscr_PerHand::clear()
{
	intervalInHands = false;
	currentHandInLevel = 0;
	totalHandsInLevel = 0;
	handsUntilAllInLevel = 0;
}

bool MTLobbyCli::publication::TournSubscr_PerHand::equals(const TournSubscr_PerHand& _o) const
{
	return intervalInHands == _o.intervalInHands &&
		currentHandInLevel == _o.currentHandInLevel &&
		totalHandsInLevel == _o.totalHandsInLevel &&
		handsUntilAllInLevel == _o.handsUntilAllInLevel;
}

const char *MTLobbyCli::publication::TournSubscr_PerHand::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("intervalInHands=");
	_buf.appendUint(intervalInHands);
	_buf.append(',');
	_buf.append("currentHandInLevel=");
	_buf.appendInt(currentHandInLevel);
	_buf.append(',');
	_buf.append("totalHandsInLevel=");
	_buf.appendInt(totalHandsInLevel);
	_buf.append(',');
	_buf.append("handsUntilAllInLevel=");
	_buf.appendInt(handsUntilAllInLevel);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_PerHand::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(intervalInHands);
	_msg.composeINT32(currentHandInLevel);
	_msg.composeINT32(totalHandsInLevel);
	_msg.composeINT32(handsUntilAllInLevel);
}

void MTLobbyCli::publication::TournSubscr_PerHand::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(intervalInHands);
	_parser.parseINT32(currentHandInLevel);
	_parser.parseINT32(totalHandsInLevel);
	_parser.parseINT32(handsUntilAllInLevel);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_PerHand::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool intervalInHands; _parser.parseBOOL(intervalInHands);
	AtfValidator::validateInt(_descr, "intervalInHands", intervalInHands, _checker, __FILE__, __LINE__);
	INT32 currentHandInLevel; _parser.parseINT32(currentHandInLevel);
	AtfValidator::validateInt(_descr, "currentHandInLevel", currentHandInLevel, _checker, __FILE__, __LINE__);
	INT32 totalHandsInLevel; _parser.parseINT32(totalHandsInLevel);
	AtfValidator::validateInt(_descr, "totalHandsInLevel", totalHandsInLevel, _checker, __FILE__, __LINE__);
	INT32 handsUntilAllInLevel; _parser.parseINT32(handsUntilAllInLevel);
	AtfValidator::validateInt(_descr, "handsUntilAllInLevel", handsUntilAllInLevel, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_SpinGoSpinner
//=================================================================

MTLobbyCli::publication::TournSubscr_SpinGoSpinner::TournSubscr_SpinGoSpinner()
{
	clear();
}

void MTLobbyCli::publication::TournSubscr_SpinGoSpinner::clear()
{
	time.setNull();
	choice = 0;
	spinner1 = 0;
	spinner2 = 0;
	spinner3 = 0;
	cashout = 0;
	timeout = false;
}

bool MTLobbyCli::publication::TournSubscr_SpinGoSpinner::equals(const TournSubscr_SpinGoSpinner& _o) const
{
	return time.equals(_o.time) &&
		choice == _o.choice &&
		spinner1 == _o.spinner1 &&
		spinner2 == _o.spinner2 &&
		spinner3 == _o.spinner3 &&
		cashout == _o.cashout &&
		timeout == _o.timeout;
}

const char *MTLobbyCli::publication::TournSubscr_SpinGoSpinner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("time=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, time);
	_buf.append(',');
	_buf.append("choice=");
	_buf.appendUint(choice);
	_buf.append(',');
	_buf.append("spinner1=");
	_buf.appendUint(spinner1);
	_buf.append(',');
	_buf.append("spinner2=");
	_buf.appendUint(spinner2);
	_buf.append(',');
	_buf.append("spinner3=");
	_buf.appendUint(spinner3);
	_buf.append(',');
	_buf.append("cashout=");
	_buf.appendUint(cashout);
	_buf.append(',');
	_buf.append("timeout=");
	_buf.appendUint(timeout);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournSubscr_SpinGoSpinner::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(time);
	_msg.composeUINT32(choice);
	_msg.composeUINT32(spinner1);
	_msg.composeUINT32(spinner2);
	_msg.composeUINT32(spinner3);
	_msg.composeUINT32(cashout);
	_msg.composeBOOL(timeout);
}

void MTLobbyCli::publication::TournSubscr_SpinGoSpinner::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(time);
	_parser.parseUINT32(choice);
	_parser.parseUINT32(spinner1);
	_parser.parseUINT32(spinner2);
	_parser.parseUINT32(spinner3);
	_parser.parseUINT32(cashout);
	_parser.parseBOOL(timeout);
}

/*static*/ void MTLobbyCli::publication::TournSubscr_SpinGoSpinner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	SrvTime time; _parser.parseSrvTime(time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	UINT32 choice; _parser.parseUINT32(choice);
	AtfValidator::validateInt(_descr, "choice", choice, _checker, __FILE__, __LINE__);
	UINT32 spinner1; _parser.parseUINT32(spinner1);
	AtfValidator::validateInt(_descr, "spinner1", spinner1, _checker, __FILE__, __LINE__);
	UINT32 spinner2; _parser.parseUINT32(spinner2);
	AtfValidator::validateInt(_descr, "spinner2", spinner2, _checker, __FILE__, __LINE__);
	UINT32 spinner3; _parser.parseUINT32(spinner3);
	AtfValidator::validateInt(_descr, "spinner3", spinner3, _checker, __FILE__, __LINE__);
	UINT32 cashout; _parser.parseUINT32(cashout);
	AtfValidator::validateInt(_descr, "cashout", cashout, _checker, __FILE__, __LINE__);
	bool timeout; _parser.parseBOOL(timeout);
	AtfValidator::validateInt(_descr, "timeout", timeout, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Prize_Winner
//=================================================================

MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::TournExtraSubscr_Prize_Winner()
{
	clear();
}

void MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::clear()
{
	amount = 0;
	percent = 0;
}

bool MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::equals(const TournExtraSubscr_Prize_Winner& _o) const
{
	return amount == _o.amount &&
		percent == _o.percent;
}

const char *MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("amount=");
	_buf.appendUint(amount);
	_buf.append(',');
	_buf.append("percent=");
	_buf.appendUint(percent);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(amount);
	_msg.composeBYTE(percent);
}

void MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(amount);
	_parser.parseBYTE(percent);
}

/*static*/ void MTLobbyCli::publication::TournExtraSubscr_Prize_Winner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 amount; _parser.parseUINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	BYTE percent; _parser.parseBYTE(percent);
	AtfValidator::validateInt(_descr, "percent", percent, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Prize_Prize
//=================================================================

MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::TournExtraSubscr_Prize_Prize()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::TournExtraSubscr_Prize_Prize(TournExtraSubscr_Prize_Prize&& _o)
	: min(std::move(_o.min))
	, max(std::move(_o.max))
	, numTickets(std::move(_o.numTickets))
	, winners(std::move(_o.winners))
{
}

MTLobbyCli::publication::TournExtraSubscr_Prize_Prize& MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::operator=(TournExtraSubscr_Prize_Prize&& _o)
{
	if(this != &_o)
	{
		min = std::move(_o.min);
		max = std::move(_o.max);
		numTickets = std::move(_o.numTickets);
		winners = std::move(_o.winners);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::clear()
{
	min = 0;
	max = 0;
	numTickets = 0;
	winners.clear();
}

bool MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::equals(const TournExtraSubscr_Prize_Prize& _o) const
{
	return min == _o.min &&
		max == _o.max &&
		numTickets == _o.numTickets &&
		winners.equals(_o.winners);
}

const char *MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("min=");
	_buf.appendUint(min);
	_buf.append(',');
	_buf.append("max=");
	_buf.appendUint(max);
	_buf.append(',');
	_buf.append("numTickets=");
	_buf.appendUint(numTickets);
	_buf.append(',');
	_buf.append("winners=");
	winners.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(min);
	_msg.composeUINT32(max);
	_msg.composeUINT32(numTickets);
	winners.composeMsg(_msg);
}

void MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(min);
	_parser.parseUINT32(max);
	_parser.parseUINT32(numTickets);
	winners.parseMsg(_parser);
}

/*static*/ void MTLobbyCli::publication::TournExtraSubscr_Prize_Prize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 min; _parser.parseUINT32(min);
	AtfValidator::validateInt(_descr, "min", min, _checker, __FILE__, __LINE__);
	UINT32 max; _parser.parseUINT32(max);
	AtfValidator::validateInt(_descr, "max", max, _checker, __FILE__, __LINE__);
	UINT32 numTickets; _parser.parseUINT32(numTickets);
	AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szWinners = ThinAtf::LAtfVector< TournExtraSubscr_Prize_Winner , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("winners"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "winners", szWinners, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Prize
//=================================================================

MTLobbyCli::publication::TournExtraSubscr_Prize::TournExtraSubscr_Prize()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournExtraSubscr_Prize::TournExtraSubscr_Prize(TournExtraSubscr_Prize&& _o)
	: zero(std::move(_o.zero))
	, creditPlayer(std::move(_o.creditPlayer))
	, returnBuyInValue(std::move(_o.returnBuyInValue))
	, rebuyPrice(std::move(_o.rebuyPrice))
	, rebuyRake(std::move(_o.rebuyRake))
	, addOnPrice(std::move(_o.addOnPrice))
	, addOnRake(std::move(_o.addOnRake))
	, prizes(std::move(_o.prizes))
{
}

MTLobbyCli::publication::TournExtraSubscr_Prize& MTLobbyCli::publication::TournExtraSubscr_Prize::operator=(TournExtraSubscr_Prize&& _o)
{
	if(this != &_o)
	{
		zero = std::move(_o.zero);
		creditPlayer = std::move(_o.creditPlayer);
		returnBuyInValue = std::move(_o.returnBuyInValue);
		rebuyPrice = std::move(_o.rebuyPrice);
		rebuyRake = std::move(_o.rebuyRake);
		addOnPrice = std::move(_o.addOnPrice);
		addOnRake = std::move(_o.addOnRake);
		prizes = std::move(_o.prizes);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournExtraSubscr_Prize::clear()
{
	zero = 0;
	creditPlayer = 0;
	returnBuyInValue = 0;
	rebuyPrice = 0;
	rebuyRake = 0;
	addOnPrice = 0;
	addOnRake = 0;
	prizes.clear();
}

bool MTLobbyCli::publication::TournExtraSubscr_Prize::equals(const TournExtraSubscr_Prize& _o) const
{
	return zero == _o.zero &&
		creditPlayer == _o.creditPlayer &&
		returnBuyInValue == _o.returnBuyInValue &&
		rebuyPrice == _o.rebuyPrice &&
		rebuyRake == _o.rebuyRake &&
		addOnPrice == _o.addOnPrice &&
		addOnRake == _o.addOnRake &&
		prizes.equals(_o.prizes);
}

const char *MTLobbyCli::publication::TournExtraSubscr_Prize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("zero=");
	_buf.appendUint(zero);
	_buf.append(',');
	_buf.append("creditPlayer=");
	_buf.appendUint(creditPlayer);
	_buf.append(',');
	_buf.append("returnBuyInValue=");
	_buf.appendUint(returnBuyInValue);
	_buf.append(',');
	_buf.append("rebuyPrice=");
	_buf.appendUint(rebuyPrice);
	_buf.append(',');
	_buf.append("rebuyRake=");
	_buf.appendUint(rebuyRake);
	_buf.append(',');
	_buf.append("addOnPrice=");
	_buf.appendUint(addOnPrice);
	_buf.append(',');
	_buf.append("addOnRake=");
	_buf.appendUint(addOnRake);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournExtraSubscr_Prize::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(zero);
	_msg.composeUINT32(creditPlayer);
	_msg.composeUINT32(returnBuyInValue);
	_msg.composeUINT32(rebuyPrice);
	_msg.composeUINT32(rebuyRake);
	_msg.composeUINT32(addOnPrice);
	_msg.composeUINT32(addOnRake);
	prizes.composeMsg(_msg);
}

void MTLobbyCli::publication::TournExtraSubscr_Prize::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(zero);
	_parser.parseUINT32(creditPlayer);
	_parser.parseUINT32(returnBuyInValue);
	_parser.parseUINT32(rebuyPrice);
	_parser.parseUINT32(rebuyRake);
	_parser.parseUINT32(addOnPrice);
	_parser.parseUINT32(addOnRake);
	prizes.parseMsg(_parser);
}

/*static*/ void MTLobbyCli::publication::TournExtraSubscr_Prize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 zero; _parser.parseUINT32(zero);
	AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
	UINT32 creditPlayer; _parser.parseUINT32(creditPlayer);
	AtfValidator::validateInt(_descr, "creditPlayer", creditPlayer, _checker, __FILE__, __LINE__);
	UINT32 returnBuyInValue; _parser.parseUINT32(returnBuyInValue);
	AtfValidator::validateInt(_descr, "returnBuyInValue", returnBuyInValue, _checker, __FILE__, __LINE__);
	UINT32 rebuyPrice; _parser.parseUINT32(rebuyPrice);
	AtfValidator::validateInt(_descr, "rebuyPrice", rebuyPrice, _checker, __FILE__, __LINE__);
	UINT32 rebuyRake; _parser.parseUINT32(rebuyRake);
	AtfValidator::validateInt(_descr, "rebuyRake", rebuyRake, _checker, __FILE__, __LINE__);
	UINT32 addOnPrice; _parser.parseUINT32(addOnPrice);
	AtfValidator::validateInt(_descr, "addOnPrice", addOnPrice, _checker, __FILE__, __LINE__);
	UINT32 addOnRake; _parser.parseUINT32(addOnRake);
	AtfValidator::validateInt(_descr, "addOnRake", addOnRake, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPrizes = ThinAtf::LAtfVector< TournExtraSubscr_Prize_Prize , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Rake_SitesPerCountry
//=================================================================

MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::TournExtraSubscr_Rake_SitesPerCountry()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::TournExtraSubscr_Rake_SitesPerCountry(TournExtraSubscr_Rake_SitesPerCountry&& _o)
	: country(std::move(_o.country))
	, sites(std::move(_o.sites))
{
}

MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry& MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::operator=(TournExtraSubscr_Rake_SitesPerCountry&& _o)
{
	if(this != &_o)
	{
		country = std::move(_o.country);
		sites = std::move(_o.sites);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::clear()
{
	country.clear();
	sites = 0;
}

bool MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::equals(const TournExtraSubscr_Rake_SitesPerCountry& _o) const
{
	return country.equals(_o.country) &&
		sites == _o.sites;
}

const char *MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("sites=");
	_buf.appendUint(sites);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(country);
	_msg.composeUINT32(sites);
}

void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(country);
	_parser.parseUINT32(sites);
}

/*static*/ void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountry::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	UINT32 sites; _parser.parseUINT32(sites);
	AtfValidator::validateInt(_descr, "sites", sites, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Rake_SitesPerCountryEx
//=================================================================

MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::TournExtraSubscr_Rake_SitesPerCountryEx()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::TournExtraSubscr_Rake_SitesPerCountryEx(TournExtraSubscr_Rake_SitesPerCountryEx&& _o)
	: country(std::move(_o.country))
	, sitesEx(std::move(_o.sitesEx))
{
}

MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx& MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::operator=(TournExtraSubscr_Rake_SitesPerCountryEx&& _o)
{
	if(this != &_o)
	{
		country = std::move(_o.country);
		sitesEx = std::move(_o.sitesEx);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::clear()
{
	country.clear();
	sitesEx.clear();
}

bool MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::equals(const TournExtraSubscr_Rake_SitesPerCountryEx& _o) const
{
	return country.equals(_o.country) &&
		sitesEx.equals(_o.sitesEx);
}

const char *MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("sitesEx=");
	sitesEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(country);
	sitesEx.composeMsg(_msg);
}

void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(country);
	sitesEx.parseMsg(_parser);
}

/*static*/ void MTLobbyCli::publication::TournExtraSubscr_Rake_SitesPerCountryEx::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PBitmask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sitesEx"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    TournExtraSubscr_Rake
//=================================================================

MTLobbyCli::publication::TournExtraSubscr_Rake::TournExtraSubscr_Rake()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournExtraSubscr_Rake::TournExtraSubscr_Rake(TournExtraSubscr_Rake&& _o)
	: sites4AllCountries(std::move(_o.sites4AllCountries))
	, sitesNoRake(std::move(_o.sitesNoRake))
	, sitesPerCountry(std::move(_o.sitesPerCountry))
	, sites4AllCountriesEx(std::move(_o.sites4AllCountriesEx))
	, sitesNoRakeEx(std::move(_o.sitesNoRakeEx))
	, sitesPerCountryEx(std::move(_o.sitesPerCountryEx))
{
}

MTLobbyCli::publication::TournExtraSubscr_Rake& MTLobbyCli::publication::TournExtraSubscr_Rake::operator=(TournExtraSubscr_Rake&& _o)
{
	if(this != &_o)
	{
		sites4AllCountries = std::move(_o.sites4AllCountries);
		sitesNoRake = std::move(_o.sitesNoRake);
		sitesPerCountry = std::move(_o.sitesPerCountry);
		sites4AllCountriesEx = std::move(_o.sites4AllCountriesEx);
		sitesNoRakeEx = std::move(_o.sitesNoRakeEx);
		sitesPerCountryEx = std::move(_o.sitesPerCountryEx);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournExtraSubscr_Rake::clear()
{
	sites4AllCountries = UINT_MAX;
	sitesNoRake = 0;
	sitesPerCountry.clear();
	sites4AllCountriesEx.clear();
	sitesNoRakeEx.clear();
	sitesPerCountryEx.clear();
}

bool MTLobbyCli::publication::TournExtraSubscr_Rake::equals(const TournExtraSubscr_Rake& _o) const
{
	return sites4AllCountries == _o.sites4AllCountries &&
		sitesNoRake == _o.sitesNoRake &&
		sitesPerCountry.equals(_o.sitesPerCountry) &&
		sites4AllCountriesEx.equals(_o.sites4AllCountriesEx) &&
		sitesNoRakeEx.equals(_o.sitesNoRakeEx) &&
		sitesPerCountryEx.equals(_o.sitesPerCountryEx);
}

const char *MTLobbyCli::publication::TournExtraSubscr_Rake::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sites4AllCountries=");
	_buf.appendUint(sites4AllCountries);
	_buf.append(',');
	_buf.append("sitesNoRake=");
	_buf.appendUint(sitesNoRake);
	_buf.append(',');
	_buf.append("sitesPerCountry=");
	sitesPerCountry.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sites4AllCountriesEx=");
	sites4AllCountriesEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sitesNoRakeEx=");
	sitesNoRakeEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sitesPerCountryEx=");
	sitesPerCountryEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournExtraSubscr_Rake::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(sites4AllCountries);
	_msg.composeUINT32(sitesNoRake);
	sitesPerCountry.composeMsg(_msg);
	sites4AllCountriesEx.composeMsg(_msg);
	sitesNoRakeEx.composeMsg(_msg);
	sitesPerCountryEx.composeMsg(_msg);
}

void MTLobbyCli::publication::TournExtraSubscr_Rake::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sites4AllCountries);
	_parser.parseUINT32(sitesNoRake);
	sitesPerCountry.parseMsg(_parser);
	sites4AllCountriesEx.parseMsg(_parser);
	sitesNoRakeEx.parseMsg(_parser);
	sitesPerCountryEx.parseMsg(_parser);
}

/*static*/ void MTLobbyCli::publication::TournExtraSubscr_Rake::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 sites4AllCountries; _parser.parseUINT32(sites4AllCountries);
	AtfValidator::validateInt(_descr, "sites4AllCountries", sites4AllCountries, _checker, __FILE__, __LINE__);
	UINT32 sitesNoRake; _parser.parseUINT32(sitesNoRake);
	AtfValidator::validateInt(_descr, "sitesNoRake", sitesNoRake, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSitesPerCountry = ThinAtf::LAtfVector< TournExtraSubscr_Rake_SitesPerCountry , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sitesPerCountry"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sitesPerCountry", szSitesPerCountry, _checker, __FILE__, __LINE__);
	PBitmask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sites4AllCountriesEx"), _fieldsWithUnparsedContent);
	PBitmask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sitesNoRakeEx"), _fieldsWithUnparsedContent);
	int szSitesPerCountryEx = ThinAtf::LAtfVector< TournExtraSubscr_Rake_SitesPerCountryEx , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sitesPerCountryEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sitesPerCountryEx", szSitesPerCountryEx, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournI18nSubscr_Name
//=================================================================

MTLobbyCli::publication::TournI18nSubscr_Name::TournI18nSubscr_Name()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::publication::TournI18nSubscr_Name::TournI18nSubscr_Name(TournI18nSubscr_Name&& _o)
	: name(std::move(_o.name))
{
}

MTLobbyCli::publication::TournI18nSubscr_Name& MTLobbyCli::publication::TournI18nSubscr_Name::operator=(TournI18nSubscr_Name&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void MTLobbyCli::publication::TournI18nSubscr_Name::clear()
{
	name.clear();
}

bool MTLobbyCli::publication::TournI18nSubscr_Name::equals(const TournI18nSubscr_Name& _o) const
{
	return name.equals(_o.name);
}

const char *MTLobbyCli::publication::TournI18nSubscr_Name::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::publication::TournI18nSubscr_Name::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(name);
}

void MTLobbyCli::publication::TournI18nSubscr_Name::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
}

/*static*/ void MTLobbyCli::publication::TournI18nSubscr_Name::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CurrencyContextStruct
//=================================================================

MTLobbyCli::cli::CurrencyContextStruct::CurrencyContextStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::CurrencyContextStruct::CurrencyContextStruct(CurrencyContextStruct&& _o)
	: srvTime(std::move(_o.srvTime))
	, convRatesAndMargins(std::move(_o.convRatesAndMargins))
{
}

MTLobbyCli::cli::CurrencyContextStruct& MTLobbyCli::cli::CurrencyContextStruct::operator=(CurrencyContextStruct&& _o)
{
	if(this != &_o)
	{
		srvTime = std::move(_o.srvTime);
		convRatesAndMargins = std::move(_o.convRatesAndMargins);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::CurrencyContextStruct::clear()
{
	srvTime.setNull();
	convRatesAndMargins.clear();
}

bool MTLobbyCli::cli::CurrencyContextStruct::equals(const CurrencyContextStruct& _o) const
{
	return srvTime.equals(_o.srvTime) &&
		convRatesAndMargins.equals(_o.convRatesAndMargins);
}

const char *MTLobbyCli::cli::CurrencyContextStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("srvTime=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, srvTime);
	_buf.append(',');
	_buf.append("convRatesAndMargins=");
	convRatesAndMargins.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::cli::CurrencyContextStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CurrencyContextStruct())) // not empty
	{
		_body.composeSrvTime(srvTime);
		convRatesAndMargins.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MTLobbyCli::cli::CurrencyContextStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseSrvTime(srvTime);
	convRatesAndMargins.parseMsg(_parser0);
}

/*static*/ void MTLobbyCli::cli::CurrencyContextStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.parseEnded()) return;
	SrvTime srvTime; _parser0.parseSrvTime(srvTime);
	AtfValidator::validateSrvDateTime(_descr, "srvTime", srvTime, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szConvRatesAndMargins = ThinAtf::LAtfVector< CommonThin::AtfShared::ConvRatesAndMarginsStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("convRatesAndMargins"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "convRatesAndMargins", szConvRatesAndMargins, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    OneAccountStruct
//=================================================================

MTLobbyCli::cli::OneAccountStruct::OneAccountStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::OneAccountStruct::OneAccountStruct(OneAccountStruct&& _o)
	: currency(std::move(_o.currency))
	, convRate(std::move(_o.convRate))
	, chips(std::move(_o.chips))
	, tChips(std::move(_o.tChips))
	, chipsDst(std::move(_o.chipsDst))
	, tChipsDst(std::move(_o.tChipsDst))
{
}

MTLobbyCli::cli::OneAccountStruct& MTLobbyCli::cli::OneAccountStruct::operator=(OneAccountStruct&& _o)
{
	if(this != &_o)
	{
		currency = std::move(_o.currency);
		convRate = std::move(_o.convRate);
		chips = std::move(_o.chips);
		tChips = std::move(_o.tChips);
		chipsDst = std::move(_o.chipsDst);
		tChipsDst = std::move(_o.tChipsDst);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::OneAccountStruct::clear()
{
	currency.clear();
	convRate = 0;
	chips = 0;
	tChips = 0;
	chipsDst = 0;
	tChipsDst = 0;
}

bool MTLobbyCli::cli::OneAccountStruct::equals(const OneAccountStruct& _o) const
{
	return currency.equals(_o.currency) &&
		convRate == _o.convRate &&
		chips == _o.chips &&
		tChips == _o.tChips &&
		chipsDst == _o.chipsDst &&
		tChipsDst == _o.tChipsDst;
}

const char *MTLobbyCli::cli::OneAccountStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("convRate=");
	_buf.appendInt64(convRate);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt(chips);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("chipsDst=");
	_buf.appendInt(chipsDst);
	_buf.append(',');
	_buf.append("tChipsDst=");
	_buf.appendInt(tChipsDst);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::cli::OneAccountStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(OneAccountStruct())) // not empty
	{
		_body.composeString(currency);
		_body.composeINT64(convRate);
		_body.composeINT32(chips);
		_body.composeINT32(tChips);
		_body.composeINT32(chipsDst);
		_body.composeINT32(tChipsDst);
	}

	_msg.composeMsgBody(_body);
}

void MTLobbyCli::cli::OneAccountStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(convRate);
	_parser0.parseINT32(chips);
	_parser0.parseINT32(tChips);
	_parser0.parseINT32(chipsDst);
	_parser0.parseINT32(tChipsDst);
}

/*static*/ void MTLobbyCli::cli::OneAccountStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 convRate; _parser0.parseINT64(convRate);
	AtfValidator::validateInt(_descr, "convRate", convRate, _checker, __FILE__, __LINE__);
	INT32 chips; _parser0.parseINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT32 tChips; _parser0.parseINT32(tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	INT32 chipsDst; _parser0.parseINT32(chipsDst);
	AtfValidator::validateInt(_descr, "chipsDst", chipsDst, _checker, __FILE__, __LINE__);
	INT32 tChipsDst; _parser0.parseINT32(tChipsDst);
	AtfValidator::validateInt(_descr, "tChipsDst", tChipsDst, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ClientCurrencyContext
//=================================================================

MTLobbyCli::cli::ClientCurrencyContext::ClientCurrencyContext()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::ClientCurrencyContext::ClientCurrencyContext(ClientCurrencyContext&& _o)
	: currencyDst(std::move(_o.currencyDst))
	, availForSpendingDst(std::move(_o.availForSpendingDst))
	, unclearedDst(std::move(_o.unclearedDst))
	, oneAcct(std::move(_o.oneAcct))
	, flags(std::move(_o.flags))
	, flags2(std::move(_o.flags2))
	, userRollId(std::move(_o.userRollId))
	, rollAmount(std::move(_o.rollAmount))
	, availWithoutConv(std::move(_o.availWithoutConv))
{
}

MTLobbyCli::cli::ClientCurrencyContext& MTLobbyCli::cli::ClientCurrencyContext::operator=(ClientCurrencyContext&& _o)
{
	if(this != &_o)
	{
		currencyDst = std::move(_o.currencyDst);
		availForSpendingDst = std::move(_o.availForSpendingDst);
		unclearedDst = std::move(_o.unclearedDst);
		oneAcct = std::move(_o.oneAcct);
		flags = std::move(_o.flags);
		flags2 = std::move(_o.flags2);
		userRollId = std::move(_o.userRollId);
		rollAmount = std::move(_o.rollAmount);
		availWithoutConv = std::move(_o.availWithoutConv);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::ClientCurrencyContext::clear()
{
	currencyDst.clear();
	availForSpendingDst = 0;
	unclearedDst = 0;
	oneAcct.clear();
	flags = 0;
	flags2 = 0;
	userRollId = 0;
	rollAmount = 0;
	availWithoutConv = 0;
}

bool MTLobbyCli::cli::ClientCurrencyContext::equals(const ClientCurrencyContext& _o) const
{
	return currencyDst.equals(_o.currencyDst) &&
		availForSpendingDst == _o.availForSpendingDst &&
		unclearedDst == _o.unclearedDst &&
		oneAcct.equals(_o.oneAcct) &&
		flags == _o.flags &&
		flags2 == _o.flags2 &&
		userRollId == _o.userRollId &&
		rollAmount == _o.rollAmount &&
		availWithoutConv == _o.availWithoutConv;
}

const char *MTLobbyCli::cli::ClientCurrencyContext::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currencyDst=");
	_buf.append(currencyDst);
	_buf.append(',');
	_buf.append("availForSpendingDst=");
	_buf.appendInt(availForSpendingDst);
	_buf.append(',');
	_buf.append("unclearedDst=");
	_buf.appendInt(unclearedDst);
	_buf.append(',');
	_buf.append("oneAcct=");
	oneAcct.toTraceString(_buf);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("userRollId=");
	_buf.appendUint(userRollId);
	_buf.append(',');
	_buf.append("rollAmount=");
	_buf.appendInt(rollAmount);
	_buf.append(',');
	_buf.append("availWithoutConv=");
	_buf.appendInt(availWithoutConv);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::cli::ClientCurrencyContext::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ClientCurrencyContext())) // not empty
	{
		_body.composeString(currencyDst);
		_body.composeINT32(availForSpendingDst);
		_body.composeINT32(unclearedDst);
		oneAcct.composeMsg(_body);
		_body.composeUINT32(flags);
		_body.composeUINT64(flags2);
		_body.composeUINT32(userRollId);
		_body.composeINT32(rollAmount);
		_body.composeINT32(availWithoutConv);
	}

	_msg.composeMsgBody(_body);
}

void MTLobbyCli::cli::ClientCurrencyContext::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currencyDst);
	_parser0.parseINT32(availForSpendingDst);
	_parser0.parseINT32(unclearedDst);
	oneAcct.parseMsg(_parser0);
	_parser0.parseUINT32(flags);
	_parser0.parseUINT64(flags2);
	_parser0.parseUINT32(userRollId);
	_parser0.parseINT32(rollAmount);
	_parser0.parseINT32(availWithoutConv);
}

/*static*/ void MTLobbyCli::cli::ClientCurrencyContext::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currencyDst"); size_t szCurrencyDst = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currencyDst", szCurrencyDst, _checker, __FILE__, __LINE__);
	INT32 availForSpendingDst; _parser0.parseINT32(availForSpendingDst);
	AtfValidator::validateInt(_descr, "availForSpendingDst", availForSpendingDst, _checker, __FILE__, __LINE__);
	INT32 unclearedDst; _parser0.parseINT32(unclearedDst);
	AtfValidator::validateInt(_descr, "unclearedDst", unclearedDst, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szOneAcct = ThinAtf::LAtfVector< OneAccountStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("oneAcct"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "oneAcct", szOneAcct, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser0.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	UINT32 userRollId; _parser0.parseUINT32(userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
	INT32 rollAmount; _parser0.parseINT32(rollAmount);
	AtfValidator::validateInt(_descr, "rollAmount", rollAmount, _checker, __FILE__, __LINE__);
	INT32 availWithoutConv; _parser0.parseINT32(availWithoutConv);
	AtfValidator::validateInt(_descr, "availWithoutConv", availWithoutConv, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserTicketData
//=================================================================

MTLobbyCli::cli::UserTicketData::UserTicketData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::UserTicketData::UserTicketData(UserTicketData&& _o)
	: admissionId(std::move(_o.admissionId))
	, totalCount(std::move(_o.totalCount))
	, reserved(std::move(_o.reserved))
{
}

MTLobbyCli::cli::UserTicketData& MTLobbyCli::cli::UserTicketData::operator=(UserTicketData&& _o)
{
	if(this != &_o)
	{
		admissionId = std::move(_o.admissionId);
		totalCount = std::move(_o.totalCount);
		reserved = std::move(_o.reserved);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::UserTicketData::clear()
{
	admissionId.clear();
	totalCount = 0;
	reserved = 0;
}

bool MTLobbyCli::cli::UserTicketData::equals(const UserTicketData& _o) const
{
	return admissionId.equals(_o.admissionId) &&
		totalCount == _o.totalCount &&
		reserved == _o.reserved;
}

const char *MTLobbyCli::cli::UserTicketData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("totalCount=");
	_buf.appendUint(totalCount);
	_buf.append(',');
	_buf.append("reserved=");
	_buf.appendUint(reserved);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::cli::UserTicketData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(admissionId);
	_msg.composeUINT32(totalCount);
	_msg.composeUINT32(reserved);
}

void MTLobbyCli::cli::UserTicketData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(admissionId);
	_parser.parseUINT32(totalCount);
	_parser.parseUINT32(reserved);
}

/*static*/ void MTLobbyCli::cli::UserTicketData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	UINT32 totalCount; _parser.parseUINT32(totalCount);
	AtfValidator::validateInt(_descr, "totalCount", totalCount, _checker, __FILE__, __LINE__);
	UINT32 reserved; _parser.parseUINT32(reserved);
	AtfValidator::validateInt(_descr, "reserved", reserved, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MTL_LOBBY_WHERE_IS_PLAYER
//=================================================================

MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::Protocol_MTL_LOBBY_WHERE_IS_PLAYER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::Protocol_MTL_LOBBY_WHERE_IS_PLAYER(Protocol_MTL_LOBBY_WHERE_IS_PLAYER&& _o)
	: userName(std::move(_o.userName))
{
}

MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER& MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::operator=(Protocol_MTL_LOBBY_WHERE_IS_PLAYER&& _o)
{
	if(this != &_o)
	{
		userName = std::move(_o.userName);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::clear()
{
	userName.clear();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::equals(const Protocol_MTL_LOBBY_WHERE_IS_PLAYER& _o) const
{
	return userName.equals(_o.userName);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_WHERE_IS_PLAYER).append(")");
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userName);
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userName);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY
//=================================================================

MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY(Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, place(std::move(_o.place))
	, tableServer(std::move(_o.tableServer))
	, tableObject(std::move(_o.tableObject))
	, flags(std::move(_o.flags))
	, errDescr(std::move(_o.errDescr))
{
}

MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY& MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::operator=(Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		place = std::move(_o.place);
		tableServer = std::move(_o.tableServer);
		tableObject = std::move(_o.tableObject);
		flags = std::move(_o.flags);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::clear()
{
	errCode = 0;
	place = 0;
	tableServer.clear();
	tableObject.clear();
	flags = false;
	errDescr.clear();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::equals(const Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		place == _o.place &&
		tableServer.equals(_o.tableServer) &&
		tableObject.equals(_o.tableObject) &&
		flags == _o.flags &&
		errDescr.equals(_o.errDescr);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_WHERE_IS_PLAYER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_buf.append(',');
		_buf.append("place=");
		_buf.appendUint(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_buf.append(',');
		_buf.append("tableServer=");
		_buf.append(tableServer);
		_buf.append(',');
		_buf.append("tableObject=");
		_buf.append(tableObject);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
	}
	else
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_msg.composeUINT32(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_msg.composeString(tableServer);
		_msg.composeString(tableObject);
		_msg.composeBOOL(flags);
	}
	else
	{
		_msg.composeString(errDescr);
	}
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_parser.parseUINT32(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_parser.parseStringP(tableServer);
		_parser.parseStringP(tableObject);
		_parser.parseBOOL(flags);
	}
	else
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode == WHERE_IS_PLACE )
	{
		UINT32 place; _parser.parseUINT32(place);
		AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_parser.parseStringN(_dummy, 0, "tableServer"); size_t szTableServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableServer", szTableServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tableObject"); size_t szTableObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableObject", szTableObject, _checker, __FILE__, __LINE__);
		bool flags; _parser.parseBOOL(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS
//=================================================================

MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS&& _o)
	: userName(std::move(_o.userName))
{
}

MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS& MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::operator=(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS&& _o)
{
	if(this != &_o)
	{
		userName = std::move(_o.userName);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::clear()
{
	userName.clear();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::equals(const Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS& _o) const
{
	return userName.equals(_o.userName);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS).append(")");
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userName);
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userName);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY
//=================================================================

MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, reply(std::move(_o.reply))
{
}

MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY& MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::operator=(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		reply = std::move(_o.reply);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	reply.clear();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::equals(const Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		reply.equals(_o.reply);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("reply=");
		reply.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		reply.composeMsg(_msg);
	}
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		reply.parseMsg(_parser);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserStatsReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_REG_INFO
//=================================================================

MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::Protocol_MSG_LOBBY_TOURN_REG_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::Protocol_MSG_LOBBY_TOURN_REG_INFO(Protocol_MSG_LOBBY_TOURN_REG_INFO&& _o)
	: userId(std::move(_o.userId))
	, tournId(std::move(_o.tournId))
	, tournRegInfoFlags(std::move(_o.tournRegInfoFlags))
{
}

MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO& MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::operator=(Protocol_MSG_LOBBY_TOURN_REG_INFO&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		tournId = std::move(_o.tournId);
		tournRegInfoFlags = std::move(_o.tournRegInfoFlags);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::clear()
{
	userId.clear();
	tournId = 0;
	tournRegInfoFlags = 0;
}

bool MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::equals(const Protocol_MSG_LOBBY_TOURN_REG_INFO& _o) const
{
	return userId.equals(_o.userId) &&
		tournId == _o.tournId &&
		tournRegInfoFlags == _o.tournRegInfoFlags;
}

const char *MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_REG_INFO).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("tournRegInfoFlags=");
	_buf.appendUint(tournRegInfoFlags);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(tournId);
	_msg.composeUINT32(tournRegInfoFlags);
}

void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(tournId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(tournRegInfoFlags);
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 tournRegInfoFlags; _parser.parseUINT32(tournRegInfoFlags);
	AtfValidator::validateIntMax(_descr, "tournRegInfoFlags", tournRegInfoFlags, static_cast<UINT32>(TournRegInfoFlags::eTournRegInfoFlags_Last), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY
//=================================================================

MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY(Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, currency(std::move(_o.currency))
	, buyInAndRake(std::move(_o.buyInAndRake))
	, enoughMoneyInOtherCurrency(std::move(_o.enoughMoneyInOtherCurrency))
	, tournSpendLimit(std::move(_o.tournSpendLimit))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, fpp(std::move(_o.fpp))
	, admissionId(std::move(_o.admissionId))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, isPwdProtected(std::move(_o.isPwdProtected))
	, userChips(std::move(_o.userChips))
	, userPlayChips(std::move(_o.userPlayChips))
	, userFpp(std::move(_o.userFpp))
	, numTickets(std::move(_o.numTickets))
	, tChips(std::move(_o.tChips))
	, wChips(std::move(_o.wChips))
	, preRegMsg(std::move(_o.preRegMsg))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, currencyContext(std::move(_o.currencyContext))
	, clientCurrencyContext(std::move(_o.clientCurrencyContext))
	, whenStartAbs(std::move(_o.whenStartAbs))
	, tournName(std::move(_o.tournName))
	, playChips64(std::move(_o.playChips64))
	, scalePM(std::move(_o.scalePM))
	, speed(std::move(_o.speed))
	, minPlayers(std::move(_o.minPlayers))
	, maxPlayers(std::move(_o.maxPlayers))
	, maxPerTable(std::move(_o.maxPerTable))
	, tournFlags(std::move(_o.tournFlags))
	, knockout(std::move(_o.knockout))
	, isProportional(std::move(_o.isProportional))
	, admPrice(std::move(_o.admPrice))
	, effectiveAdmissions(std::move(_o.effectiveAdmissions))
	, tournFlags2(std::move(_o.tournFlags2))
{
}

MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY& MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::operator=(Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		currency = std::move(_o.currency);
		buyInAndRake = std::move(_o.buyInAndRake);
		enoughMoneyInOtherCurrency = std::move(_o.enoughMoneyInOtherCurrency);
		tournSpendLimit = std::move(_o.tournSpendLimit);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		fpp = std::move(_o.fpp);
		admissionId = std::move(_o.admissionId);
		isPlayMoney = std::move(_o.isPlayMoney);
		isPwdProtected = std::move(_o.isPwdProtected);
		userChips = std::move(_o.userChips);
		userPlayChips = std::move(_o.userPlayChips);
		userFpp = std::move(_o.userFpp);
		numTickets = std::move(_o.numTickets);
		tChips = std::move(_o.tChips);
		wChips = std::move(_o.wChips);
		preRegMsg = std::move(_o.preRegMsg);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		currencyContext = std::move(_o.currencyContext);
		clientCurrencyContext = std::move(_o.clientCurrencyContext);
		whenStartAbs = std::move(_o.whenStartAbs);
		tournName = std::move(_o.tournName);
		playChips64 = std::move(_o.playChips64);
		scalePM = std::move(_o.scalePM);
		speed = std::move(_o.speed);
		minPlayers = std::move(_o.minPlayers);
		maxPlayers = std::move(_o.maxPlayers);
		maxPerTable = std::move(_o.maxPerTable);
		tournFlags = std::move(_o.tournFlags);
		knockout = std::move(_o.knockout);
		isProportional = std::move(_o.isProportional);
		admPrice = std::move(_o.admPrice);
		effectiveAdmissions = std::move(_o.effectiveAdmissions);
		tournFlags2 = std::move(_o.tournFlags2);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	currency.clear();
	buyInAndRake = 0;
	enoughMoneyInOtherCurrency = false;
	tournSpendLimit.clear();
	buyIn = 0;
	rake = 0;
	fpp = 0;
	admissionId.clear();
	isPlayMoney = 0;
	isPwdProtected = 0;
	userChips = 0;
	userPlayChips = 0;
	userFpp = 0;
	numTickets = 0;
	tChips = 0;
	wChips = 0;
	preRegMsg.clear();
	game = 0;
	isHiLo = 0;
	structure = 0;
	currencyContext.clear();
	clientCurrencyContext.clear();
	whenStartAbs.setNull();
	tournName.clear();
	playChips64 = 0;
	scalePM = 0;
	speed = 0;
	minPlayers = 0;
	maxPlayers = 0;
	maxPerTable = 0;
	tournFlags = 0;
	knockout = 0;
	isProportional = false;
	admPrice = 0;
	effectiveAdmissions.clear();
	tournFlags2 = 0;
}

bool MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::equals(const Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		currency.equals(_o.currency) &&
		buyInAndRake == _o.buyInAndRake &&
		enoughMoneyInOtherCurrency == _o.enoughMoneyInOtherCurrency &&
		tournSpendLimit.equals(_o.tournSpendLimit) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		fpp == _o.fpp &&
		admissionId.equals(_o.admissionId) &&
		isPlayMoney == _o.isPlayMoney &&
		isPwdProtected == _o.isPwdProtected &&
		userChips == _o.userChips &&
		userPlayChips == _o.userPlayChips &&
		userFpp == _o.userFpp &&
		numTickets == _o.numTickets &&
		tChips == _o.tChips &&
		wChips == _o.wChips &&
		preRegMsg.equals(_o.preRegMsg) &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		currencyContext.equals(_o.currencyContext) &&
		clientCurrencyContext.equals(_o.clientCurrencyContext) &&
		whenStartAbs.equals(_o.whenStartAbs) &&
		tournName.equals(_o.tournName) &&
		playChips64 == _o.playChips64 &&
		scalePM == _o.scalePM &&
		speed == _o.speed &&
		minPlayers == _o.minPlayers &&
		maxPlayers == _o.maxPlayers &&
		maxPerTable == _o.maxPerTable &&
		tournFlags == _o.tournFlags &&
		knockout == _o.knockout &&
		isProportional == _o.isProportional &&
		admPrice == _o.admPrice &&
		effectiveAdmissions.equals(_o.effectiveAdmissions) &&
		tournFlags2 == _o.tournFlags2;
}

const char *MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_REG_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode == TOURN_SPEND_LIMIT_EXCEEDED)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("buyInAndRake=");
		_buf.appendUint(buyInAndRake);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
		_buf.append(',');
		_buf.append("tournSpendLimit=");
		tournSpendLimit.toTraceString(_buf);
	}
	else if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("buyInAndRake=");
		_buf.appendUint(buyInAndRake);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
	}
	else
	{
		_buf.append(',');
		_buf.append("buyIn=");
		_buf.appendUint(buyIn);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendUint(rake);
		_buf.append(',');
		_buf.append("fpp=");
		_buf.appendUint(fpp);
		_buf.append(',');
		_buf.append("admissionId=");
		_buf.append(admissionId);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("isPwdProtected=");
		_buf.appendUint(isPwdProtected);
		_buf.append(',');
		_buf.append("userChips=");
		_buf.appendUint(userChips);
		_buf.append(',');
		_buf.append("userPlayChips=");
		_buf.appendUint(userPlayChips);
		_buf.append(',');
		_buf.append("userFpp=");
		_buf.appendUint(userFpp);
		_buf.append(',');
		_buf.append("numTickets=");
		_buf.appendUint(numTickets);
		_buf.append(',');
		_buf.append("tChips=");
		_buf.appendUint(tChips);
		_buf.append(',');
		_buf.append("wChips=");
		_buf.appendUint(wChips);
		_buf.append(',');
		_buf.append("preRegMsg=");
		_buf.append(preRegMsg);
		_buf.append(',');
		_buf.append("game=");
		_buf.appendUint(game);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
		_buf.append(',');
		_buf.append("currencyContext=");
		currencyContext.toTraceString(_buf);
		_buf.append(',');
		_buf.append("clientCurrencyContext=");
		clientCurrencyContext.toTraceString(_buf);
		_buf.append(',');
		_buf.append("whenStartAbs=");
		ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStartAbs);
		_buf.append(',');
		_buf.append("tournName=");
		_buf.append(tournName);
		_buf.append(',');
		_buf.append("playChips64=");
		_buf.appendUint64(playChips64);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendInt(scalePM);
		_buf.append(',');
		_buf.append("speed=");
		_buf.appendUint(speed);
		_buf.append(',');
		_buf.append("minPlayers=");
		_buf.appendUint(minPlayers);
		_buf.append(',');
		_buf.append("maxPlayers=");
		_buf.appendUint(maxPlayers);
		_buf.append(',');
		_buf.append("maxPerTable=");
		_buf.appendUint(maxPerTable);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("knockout=");
		_buf.appendUint(knockout);
		_buf.append(',');
		_buf.append("isProportional=");
		_buf.appendUint(isProportional);
		_buf.append(',');
		_buf.append("admPrice=");
		_buf.appendInt64(admPrice);
		_buf.append(',');
		_buf.append("effectiveAdmissions=");
		effectiveAdmissions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournFlags2=");
		_buf.appendInt64(tournFlags2);
		_buf.append(',');
		_buf.append("tournSpendLimit=");
		tournSpendLimit.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode == TOURN_SPEND_LIMIT_EXCEEDED)
	{
		_msg.composeString(errDescr);
		_msg.composeString(currency);
		_msg.composeUINT32(buyInAndRake);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
		tournSpendLimit.composeMsg(_msg);
	}
	else if( errCode )
	{
		_msg.composeString(errDescr);
		_msg.composeString(currency);
		_msg.composeUINT32(buyInAndRake);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
	}
	else
	{
		_msg.composeUINT32(buyIn);
		_msg.composeUINT32(rake);
		_msg.composeUINT32(fpp);
		_msg.composeString(admissionId);
		_msg.composeBYTE(isPlayMoney);
		_msg.composeBYTE(isPwdProtected);
		_msg.composeUINT32(userChips);
		_msg.composeUINT32(userPlayChips);
		_msg.composeUINT32(userFpp);
		_msg.composeUINT32(numTickets);
		_msg.composeUINT32(tChips);
		_msg.composeUINT32(wChips);
		_msg.composeString(preRegMsg);
		_msg.composeBYTE(game);
		_msg.composeBYTE(isHiLo);
		_msg.composeBYTE(structure);
		_msg.composeString(currency);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
		_msg.composeMsgBody(currencyContext);
		_msg.composeMsgBody(clientCurrencyContext);
		_msg.composeSrvTime(whenStartAbs);
		_msg.composeString(tournName);
		_msg.composeUINT64(playChips64);
		_msg.composeINT32(scalePM);
		_msg.composeBYTE(speed);
		_msg.composeUINT32(minPlayers);
		_msg.composeUINT32(maxPlayers);
		_msg.composeBYTE(maxPerTable);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT32(knockout);
		_msg.composeBOOL(isProportional);
		_msg.composeINT64(admPrice);
		effectiveAdmissions.composeMsg(_msg);
		_msg.composeINT64(tournFlags2);
		tournSpendLimit.composeMsg(_msg);
	}
}

void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode == TOURN_SPEND_LIMIT_EXCEEDED)
	{
		_parser.parseStringP(errDescr);
		_parser.parseStringP(currency);
		_parser.parseUINT32(buyInAndRake);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
		tournSpendLimit.parseMsg(_parser);
	}
	else if( errCode )
	{
		_parser.parseStringP(errDescr);
		_parser.parseStringP(currency);
		_parser.parseUINT32(buyInAndRake);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
	}
	else
	{
		_parser.parseUINT32(buyIn);
		_parser.parseUINT32(rake);
		_parser.parseUINT32(fpp);
		_parser.parseStringP(admissionId);
		_parser.parseBYTE(isPlayMoney);
		_parser.parseBYTE(isPwdProtected);
		_parser.parseUINT32(userChips);
		_parser.parseUINT32(userPlayChips);
		_parser.parseUINT32(userFpp);
		_parser.parseUINT32(numTickets);
		_parser.parseUINT32(tChips);
		_parser.parseUINT32(wChips);
		_parser.parseStringP(preRegMsg);
		_parser.parseBYTE(game);
		_parser.parseBYTE(isHiLo);
		_parser.parseBYTE(structure);
		_parser.parseStringP(currency);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
		_parser.parseMsgBody(currencyContext);
		_parser.parseMsgBody(clientCurrencyContext);
		_parser.parseSrvTime(whenStartAbs);
		_parser.parseStringP(tournName);
		_parser.parseUINT64(playChips64);
		_parser.parseINT32(scalePM);
		_parser.parseBYTE(speed);
		_parser.parseUINT32(minPlayers);
		_parser.parseUINT32(maxPlayers);
		_parser.parseBYTE(maxPerTable);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT32(knockout);
		_parser.parseBOOL(isProportional);
		_parser.parseINT64(admPrice);
		effectiveAdmissions.parseMsg(_parser);
		_parser.parseINT64(tournFlags2);
		if(_parser.parseEnded()) return;
		tournSpendLimit.parseMsg(_parser);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode == TOURN_SPEND_LIMIT_EXCEEDED)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		UINT32 buyInAndRake; _parser.parseUINT32(buyInAndRake);
		AtfValidator::validateInt(_descr, "buyInAndRake", buyInAndRake, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		PString _descbuf;
		TournSpendLimit::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSpendLimit"), _fieldsWithUnparsedContent);
	}
	else if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		UINT32 buyInAndRake; _parser.parseUINT32(buyInAndRake);
		AtfValidator::validateInt(_descr, "buyInAndRake", buyInAndRake, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 buyIn; _parser.parseUINT32(buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		UINT32 rake; _parser.parseUINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 fpp; _parser.parseUINT32(fpp);
		AtfValidator::validateInt(_descr, "fpp", fpp, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
		BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		BYTE isPwdProtected; _parser.parseBYTE(isPwdProtected);
		AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
		UINT32 userChips; _parser.parseUINT32(userChips);
		AtfValidator::validateInt(_descr, "userChips", userChips, _checker, __FILE__, __LINE__);
		UINT32 userPlayChips; _parser.parseUINT32(userPlayChips);
		AtfValidator::validateInt(_descr, "userPlayChips", userPlayChips, _checker, __FILE__, __LINE__);
		UINT32 userFpp; _parser.parseUINT32(userFpp);
		AtfValidator::validateInt(_descr, "userFpp", userFpp, _checker, __FILE__, __LINE__);
		UINT32 numTickets; _parser.parseUINT32(numTickets);
		AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
		UINT32 tChips; _parser.parseUINT32(tChips);
		AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
		UINT32 wChips; _parser.parseUINT32(wChips);
		AtfValidator::validateInt(_descr, "wChips", wChips, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "preRegMsg"); size_t szPreRegMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "preRegMsg", szPreRegMsg, _checker, __FILE__, __LINE__);
		BYTE game; _parser.parseBYTE(game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _parser.parseBYTE(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
		AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
		size_t szClientCurrencyContext; _parser.skipMsgBody(szClientCurrencyContext);  /*clientCurrencyContext*/
		AtfValidator::validateInt(_descr, "clientCurrencyContext", szClientCurrencyContext, _checker, __FILE__, __LINE__);
		SrvTime whenStartAbs; _parser.parseSrvTime(whenStartAbs);
		AtfValidator::validateSrvDateTime(_descr, "whenStartAbs", whenStartAbs, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tournName"); size_t szTournName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournName", szTournName, _checker, __FILE__, __LINE__);
		UINT64 playChips64; _parser.parseUINT64(playChips64);
		AtfValidator::validateUint(_descr, "playChips64", playChips64, _checker, __FILE__, __LINE__);
		INT32 scalePM; _parser.parseINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE speed; _parser.parseBYTE(speed);
		AtfValidator::validateInt(_descr, "speed", speed, _checker, __FILE__, __LINE__);
		UINT32 minPlayers; _parser.parseUINT32(minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		UINT32 maxPlayers; _parser.parseUINT32(maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		BYTE maxPerTable; _parser.parseBYTE(maxPerTable);
		AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 knockout; _parser.parseUINT32(knockout);
		AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
		bool isProportional; _parser.parseBOOL(isProportional);
		AtfValidator::validateInt(_descr, "isProportional", isProportional, _checker, __FILE__, __LINE__);
		INT64 admPrice; _parser.parseINT64(admPrice);
		AtfValidator::validateInt(_descr, "admPrice", admPrice, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szEffectiveAdmissions = ThinAtf::LAtfVector< UserTicketData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("effectiveAdmissions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "effectiveAdmissions", szEffectiveAdmissions, _checker, __FILE__, __LINE__);
		INT64 tournFlags2; _parser.parseINT64(tournFlags2);
		AtfValidator::validateInt(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		TournSpendLimit::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSpendLimit"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_REGISTER_USER
//=================================================================

MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::Protocol_MTL_LOBBY_REGISTER_USER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::Protocol_MTL_LOBBY_REGISTER_USER(Protocol_MTL_LOBBY_REGISTER_USER&& _o)
	: userName(std::move(_o.userName))
	, buyInRM(std::move(_o.buyInRM))
	, buyInPlay(std::move(_o.buyInPlay))
	, buyInFpp(std::move(_o.buyInFpp))
	, tournPwd(std::move(_o.tournPwd))
	, useTicket(std::move(_o.useTicket))
	, buyInT(std::move(_o.buyInT))
	, buyInW(std::move(_o.buyInW))
	, currencyContext(std::move(_o.currencyContext))
	, currency(std::move(_o.currency))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, structure(std::move(_o.structure))
	, startTime(std::move(_o.startTime))
	, clientRegFlags(std::move(_o.clientRegFlags))
{
}

MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER& MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::operator=(Protocol_MTL_LOBBY_REGISTER_USER&& _o)
{
	if(this != &_o)
	{
		userName = std::move(_o.userName);
		buyInRM = std::move(_o.buyInRM);
		buyInPlay = std::move(_o.buyInPlay);
		buyInFpp = std::move(_o.buyInFpp);
		tournPwd = std::move(_o.tournPwd);
		useTicket = std::move(_o.useTicket);
		buyInT = std::move(_o.buyInT);
		buyInW = std::move(_o.buyInW);
		currencyContext = std::move(_o.currencyContext);
		currency = std::move(_o.currency);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		structure = std::move(_o.structure);
		startTime = std::move(_o.startTime);
		clientRegFlags = std::move(_o.clientRegFlags);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::clear()
{
	userName.clear();
	buyInRM = 0;
	buyInPlay = 0;
	buyInFpp = 0;
	tournPwd.clear();
	useTicket = 0;
	buyInT = 0;
	buyInW = 0;
	currencyContext.clear();
	currency.clear();
	game = 0;
	hiLo = 0;
	structure = 0;
	startTime.setNull();
	clientRegFlags = 0;
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::equals(const Protocol_MTL_LOBBY_REGISTER_USER& _o) const
{
	return userName.equals(_o.userName) &&
		buyInRM == _o.buyInRM &&
		buyInPlay == _o.buyInPlay &&
		buyInFpp == _o.buyInFpp &&
		tournPwd.equals(_o.tournPwd) &&
		useTicket == _o.useTicket &&
		buyInT == _o.buyInT &&
		buyInW == _o.buyInW &&
		currencyContext.equals(_o.currencyContext) &&
		currency.equals(_o.currency) &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		startTime.equals(_o.startTime) &&
		clientRegFlags == _o.clientRegFlags;
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_REGISTER_USER).append(")");
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	_buf.append(',');
	_buf.append("buyInRM=");
	_buf.appendInt(buyInRM);
	_buf.append(',');
	_buf.append("buyInPlay=");
	_buf.appendInt(buyInPlay);
	_buf.append(',');
	_buf.append("buyInFpp=");
	_buf.appendInt(buyInFpp);
	_buf.append(',');
	_buf.append("tournPwd=");
	_buf.append(tournPwd);
	_buf.append(',');
	_buf.append("useTicket=");
	_buf.appendUint(useTicket);
	_buf.append(',');
	_buf.append("buyInT=");
	_buf.appendInt(buyInT);
	_buf.append(',');
	_buf.append("buyInW=");
	_buf.appendInt(buyInW);
	_buf.append(',');
	_buf.append("currencyContext=");
	currencyContext.toTraceString(_buf);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("startTime=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, startTime);
	_buf.append(',');
	_buf.append("clientRegFlags=");
	_buf.appendUint(clientRegFlags);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userName);
	_msg.composeINT32(buyInRM);
	_msg.composeINT32(buyInPlay);
	_msg.composeINT32(buyInFpp);
	_msg.composeString(tournPwd);
	_msg.composeBYTE(useTicket);
	_msg.composeINT32(buyInT);
	_msg.composeINT32(buyInW);
	_msg.composeMsgBody(currencyContext);
	_msg.composeString(currency);
	_msg.composeBYTE(game);
	_msg.composeBYTE(hiLo);
	_msg.composeBYTE(structure);
	_msg.composeSrvTime(startTime);
	_msg.composeUINT32(clientRegFlags);
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userName);
	_parser.parseINT32(buyInRM);
	_parser.parseINT32(buyInPlay);
	_parser.parseINT32(buyInFpp);
	_parser.parseStringP(tournPwd);
	_parser.parseBYTE(useTicket);
	_parser.parseINT32(buyInT);
	_parser.parseINT32(buyInW);
	_parser.parseMsgBody(currencyContext);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(currency);
	_parser.parseBYTE(game);
	_parser.parseBYTE(hiLo);
	_parser.parseBYTE(structure);
	_parser.parseSrvTime(startTime);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(clientRegFlags);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_REGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	INT32 buyInRM; _parser.parseINT32(buyInRM);
	AtfValidator::validateIntRange(_descr, "buyInRM", buyInRM, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 buyInPlay; _parser.parseINT32(buyInPlay);
	AtfValidator::validateIntRange(_descr, "buyInPlay", buyInPlay, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 buyInFpp; _parser.parseINT32(buyInFpp);
	AtfValidator::validateIntRange(_descr, "buyInFpp", buyInFpp, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tournPwd"); size_t szTournPwd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tournPwd", szTournPwd, 100, _checker, __FILE__, __LINE__);
	BYTE useTicket; _parser.parseBYTE(useTicket);
	AtfValidator::validateInt(_descr, "useTicket", useTicket, _checker, __FILE__, __LINE__);
	INT32 buyInT; _parser.parseINT32(buyInT);
	AtfValidator::validateIntRange(_descr, "buyInT", buyInT, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 buyInW; _parser.parseINT32(buyInW);
	AtfValidator::validateIntRange(_descr, "buyInW", buyInW, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 5, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser.parseBYTE(hiLo);
	AtfValidator::validateInt(_descr, "hiLo", hiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	SrvTime startTime; _parser.parseSrvTime(startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 clientRegFlags; _parser.parseUINT32(clientRegFlags);
	AtfValidator::validateInt(_descr, "clientRegFlags", clientRegFlags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_REGISTER_USER_REPLY
//=================================================================

MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::Protocol_MTL_LOBBY_REGISTER_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::Protocol_MTL_LOBBY_REGISTER_USER_REPLY(Protocol_MTL_LOBBY_REGISTER_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, maxAllins(std::move(_o.maxAllins))
	, registrationMsg(std::move(_o.registrationMsg))
	, seatsAvailable(std::move(_o.seatsAvailable))
	, serverName(std::move(_o.serverName))
	, socialToken(std::move(_o.socialToken))
	, clientNotification(std::move(_o.clientNotification))
{
}

MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY& MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::operator=(Protocol_MTL_LOBBY_REGISTER_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		maxAllins = std::move(_o.maxAllins);
		registrationMsg = std::move(_o.registrationMsg);
		seatsAvailable = std::move(_o.seatsAvailable);
		serverName = std::move(_o.serverName);
		socialToken = std::move(_o.socialToken);
		clientNotification = std::move(_o.clientNotification);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	maxAllins = 0;
	registrationMsg.clear();
	seatsAvailable = false;
	serverName.clear();
	socialToken.clear();
	clientNotification.clear();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::equals(const Protocol_MTL_LOBBY_REGISTER_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		maxAllins == _o.maxAllins &&
		registrationMsg.equals(_o.registrationMsg) &&
		seatsAvailable == _o.seatsAvailable &&
		serverName.equals(_o.serverName) &&
		socialToken.equals(_o.socialToken) &&
		clientNotification.equals(_o.clientNotification);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_REGISTER_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	if( !errCode )
	{
		_buf.append(',');
		_buf.append("maxAllins=");
		_buf.appendInt(maxAllins);
		_buf.append(',');
		_buf.append("registrationMsg=");
		_buf.append(registrationMsg);
		_buf.append(',');
		_buf.append("seatsAvailable=");
		_buf.appendUint(seatsAvailable);
		_buf.append(',');
		_buf.append("serverName=");
		_buf.append(serverName);
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("clientNotification=");
		_buf.append(clientNotification);
	}
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
	if( !errCode )
	{
		_msg.composeINT16(maxAllins);
		_msg.composeString(registrationMsg);
		_msg.composeBOOL(seatsAvailable);
		_msg.composeString(serverName);
		_msg.composeString(socialToken);
		_msg.composeString(clientNotification);
	}
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
	if( !errCode )
	{
		if(_parser.parseEnded()) return;
		_parser.parseINT16(maxAllins);
		_parser.parseStringP(registrationMsg);
		_parser.parseBOOL(seatsAvailable);
		_parser.parseStringP(serverName);
		_parser.parseStringP(socialToken);
		_parser.parseStringP(clientNotification);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_REGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	if( !errCode )
	{
		if(_parser.parseEnded()) return;
		INT16 maxAllins; _parser.parseINT16(maxAllins);
		AtfValidator::validateInt(_descr, "maxAllins", maxAllins, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "registrationMsg"); size_t szRegistrationMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "registrationMsg", szRegistrationMsg, _checker, __FILE__, __LINE__);
		bool seatsAvailable; _parser.parseBOOL(seatsAvailable);
		AtfValidator::validateInt(_descr, "seatsAvailable", seatsAvailable, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverName"); size_t szServerName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverName", szServerName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "clientNotification"); size_t szClientNotification = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clientNotification", szClientNotification, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_UNREGISTER_USER
//=================================================================

MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::Protocol_MTL_LOBBY_UNREGISTER_USER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::Protocol_MTL_LOBBY_UNREGISTER_USER(Protocol_MTL_LOBBY_UNREGISTER_USER&& _o)
	: tournId(std::move(_o.tournId))
	, userName(std::move(_o.userName))
{
}

MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER& MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::operator=(Protocol_MTL_LOBBY_UNREGISTER_USER&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		userName = std::move(_o.userName);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::clear()
{
	tournId = 0;
	userName.clear();
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::equals(const Protocol_MTL_LOBBY_UNREGISTER_USER& _o) const
{
	return tournId == _o.tournId &&
		userName.equals(_o.userName);
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_UNREGISTER_USER).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournId);
	_msg.composeString(userName);
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
	_parser.parseStringP(userName);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_UNREGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY
//=================================================================

MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY(Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, refund(std::move(_o.refund))
	, refundPlay(std::move(_o.refundPlay))
	, refundFpp(std::move(_o.refundFpp))
	, refundTChips(std::move(_o.refundTChips))
	, refundWChips(std::move(_o.refundWChips))
	, tournamentCurrency(std::move(_o.tournamentCurrency))
	, refundCurrency(std::move(_o.refundCurrency))
	, refundPlay64(std::move(_o.refundPlay64))
{
}

MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY& MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::operator=(Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		refund = std::move(_o.refund);
		refundPlay = std::move(_o.refundPlay);
		refundFpp = std::move(_o.refundFpp);
		refundTChips = std::move(_o.refundTChips);
		refundWChips = std::move(_o.refundWChips);
		tournamentCurrency = std::move(_o.tournamentCurrency);
		refundCurrency = std::move(_o.refundCurrency);
		refundPlay64 = std::move(_o.refundPlay64);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	refund = 0;
	refundPlay = 0;
	refundFpp = 0;
	refundTChips = 0;
	refundWChips = 0;
	tournamentCurrency.clear();
	refundCurrency.clear();
	refundPlay64 = 0;
}

bool MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::equals(const Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		refund == _o.refund &&
		refundPlay == _o.refundPlay &&
		refundFpp == _o.refundFpp &&
		refundTChips == _o.refundTChips &&
		refundWChips == _o.refundWChips &&
		tournamentCurrency.equals(_o.tournamentCurrency) &&
		refundCurrency.equals(_o.refundCurrency) &&
		refundPlay64 == _o.refundPlay64;
}

const char *MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_UNREGISTER_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	if( !errCode )
	{
		_buf.append(',');
		_buf.append("refund=");
		_buf.appendUint(refund);
		_buf.append(',');
		_buf.append("refundPlay=");
		_buf.appendInt(refundPlay);
		_buf.append(',');
		_buf.append("refundFpp=");
		_buf.appendUint(refundFpp);
		_buf.append(',');
		_buf.append("refundTChips=");
		_buf.appendUint(refundTChips);
		_buf.append(',');
		_buf.append("refundWChips=");
		_buf.appendUint(refundWChips);
		_buf.append(',');
		_buf.append("tournamentCurrency=");
		_buf.append(tournamentCurrency);
		_buf.append(',');
		_buf.append("refundCurrency=");
		_buf.append(refundCurrency);
		_buf.append(',');
		_buf.append("refundPlay64=");
		_buf.appendUint64(refundPlay64);
	}
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
	if( !errCode )
	{
		_msg.composeUINT32(refund);
		_msg.composeINT32(refundPlay);
		_msg.composeUINT32(refundFpp);
		_msg.composeUINT32(refundTChips);
		_msg.composeUINT32(refundWChips);
		_msg.composeString(tournamentCurrency);
		_msg.composeString(refundCurrency);
		_msg.composeUINT64(refundPlay64);
	}
}

void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
	if( !errCode )
	{
		_parser.parseUINT32(refund);
		_parser.parseINT32(refundPlay);
		_parser.parseUINT32(refundFpp);
		_parser.parseUINT32(refundTChips);
		_parser.parseUINT32(refundWChips);
		_parser.parseStringP(tournamentCurrency);
		_parser.parseStringP(refundCurrency);
		_parser.parseUINT64(refundPlay64);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_UNREGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	if( !errCode )
	{
		UINT32 refund; _parser.parseUINT32(refund);
		AtfValidator::validateInt(_descr, "refund", refund, _checker, __FILE__, __LINE__);
		INT32 refundPlay; _parser.parseINT32(refundPlay);
		AtfValidator::validateInt(_descr, "refundPlay", refundPlay, _checker, __FILE__, __LINE__);
		UINT32 refundFpp; _parser.parseUINT32(refundFpp);
		AtfValidator::validateInt(_descr, "refundFpp", refundFpp, _checker, __FILE__, __LINE__);
		UINT32 refundTChips; _parser.parseUINT32(refundTChips);
		AtfValidator::validateInt(_descr, "refundTChips", refundTChips, _checker, __FILE__, __LINE__);
		UINT32 refundWChips; _parser.parseUINT32(refundWChips);
		AtfValidator::validateInt(_descr, "refundWChips", refundWChips, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tournamentCurrency"); size_t szTournamentCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournamentCurrency", szTournamentCurrency, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "refundCurrency"); size_t szRefundCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "refundCurrency", szRefundCurrency, _checker, __FILE__, __LINE__);
		UINT64 refundPlay64; _parser.parseUINT64(refundPlay64);
		AtfValidator::validateUint(_descr, "refundPlay64", refundPlay64, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ChipGraphRequest
//=================================================================

MTLobbyCli::cli::ChipGraphRequest::ChipGraphRequest()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::ChipGraphRequest::ChipGraphRequest(ChipGraphRequest&& _o)
	: name(std::move(_o.name))
	, time(std::move(_o.time))
{
}

MTLobbyCli::cli::ChipGraphRequest& MTLobbyCli::cli::ChipGraphRequest::operator=(ChipGraphRequest&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		time = std::move(_o.time);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::ChipGraphRequest::clear()
{
	name.clear();
	time = 0;
}

bool MTLobbyCli::cli::ChipGraphRequest::equals(const ChipGraphRequest& _o) const
{
	return name.equals(_o.name) &&
		time == _o.time;
}

const char *MTLobbyCli::cli::ChipGraphRequest::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("time=");
	_buf.appendUint(time);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::cli::ChipGraphRequest::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ChipGraphRequest())) // not empty
	{
		_body.composeString(name);
		_body.composeUINT32(time);
	}

	_msg.composeMsgBody(_body);
}

void MTLobbyCli::cli::ChipGraphRequest::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(name);
	_parser0.parseUINT32(time);
}

/*static*/ void MTLobbyCli::cli::ChipGraphRequest::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, 20, _checker, __FILE__, __LINE__);
	UINT32 time; _parser0.parseUINT32(time);
	AtfValidator::validateInt(_descr, "time", time, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ChipGraphData
//=================================================================

MTLobbyCli::cli::ChipGraphData::ChipGraphData()
{
	clear();
}

void MTLobbyCli::cli::ChipGraphData::clear()
{
	time = 0;
	val = 0;
}

bool MTLobbyCli::cli::ChipGraphData::equals(const ChipGraphData& _o) const
{
	return time == _o.time &&
		val == _o.val;
}

const char *MTLobbyCli::cli::ChipGraphData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("time=");
	_buf.appendUint(time);
	_buf.append(',');
	_buf.append("val=");
	_buf.appendUint(val);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::cli::ChipGraphData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(time);
	_msg.composeUINT32(val);
}

void MTLobbyCli::cli::ChipGraphData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(time);
	_parser.parseUINT32(val);
}

/*static*/ void MTLobbyCli::cli::ChipGraphData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 time; _parser.parseUINT32(time);
	AtfValidator::validateInt(_descr, "time", time, _checker, __FILE__, __LINE__);
	UINT32 val; _parser.parseUINT32(val);
	AtfValidator::validateInt(_descr, "val", val, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ChipGraphReply
//=================================================================

MTLobbyCli::cli::ChipGraphReply::ChipGraphReply()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::ChipGraphReply::ChipGraphReply(ChipGraphReply&& _o)
	: name(std::move(_o.name))
	, data(std::move(_o.data))
{
}

MTLobbyCli::cli::ChipGraphReply& MTLobbyCli::cli::ChipGraphReply::operator=(ChipGraphReply&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		data = std::move(_o.data);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::ChipGraphReply::clear()
{
	name.clear();
	data.clear();
}

bool MTLobbyCli::cli::ChipGraphReply::equals(const ChipGraphReply& _o) const
{
	return name.equals(_o.name) &&
		data.equals(_o.data);
}

const char *MTLobbyCli::cli::ChipGraphReply::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("data=");
	data.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::cli::ChipGraphReply::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ChipGraphReply())) // not empty
	{
		_body.composeString(name);
		data.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MTLobbyCli::cli::ChipGraphReply::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(name);
	data.parseMsg(_parser0);
}

/*static*/ void MTLobbyCli::cli::ChipGraphReply::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szData = ThinAtf::LAtfVector< ChipGraphData, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("data"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "data", szData, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MTL_GET_CHIP_GRAPH_DATA
//=================================================================

MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::Protocol_MTL_GET_CHIP_GRAPH_DATA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::Protocol_MTL_GET_CHIP_GRAPH_DATA(Protocol_MTL_GET_CHIP_GRAPH_DATA&& _o)
	: requestData(std::move(_o.requestData))
{
}

MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA& MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::operator=(Protocol_MTL_GET_CHIP_GRAPH_DATA&& _o)
{
	if(this != &_o)
	{
		requestData = std::move(_o.requestData);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::clear()
{
	requestData.clear();
}

bool MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::equals(const Protocol_MTL_GET_CHIP_GRAPH_DATA& _o) const
{
	return requestData.equals(_o.requestData);
}

const char *MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_GET_CHIP_GRAPH_DATA).append(")");
	_buf.append(',');
	_buf.append("requestData=");
	requestData.toTraceString(_buf);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::composeMsg(CommMsgBody& _msg) const
{
	requestData.composeMsg(_msg);
}

void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::parseMsg(CommMsgParser& _parser)
{
	requestData.parseMsg(_parser);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_GET_CHIP_GRAPH_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szRequestData = ThinAtf::LAtfVector< ChipGraphRequest, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("requestData"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "requestData", szRequestData, 500, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY
//=================================================================

MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY(Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY&& _o)
	: n(std::move(_o.n))
	, hockeyTime(std::move(_o.hockeyTime))
	, chipGraphData(std::move(_o.chipGraphData))
{
}

MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY& MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::operator=(Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY&& _o)
{
	if(this != &_o)
	{
		n = std::move(_o.n);
		hockeyTime = std::move(_o.hockeyTime);
		chipGraphData = std::move(_o.chipGraphData);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::clear()
{
	n = 0;
	hockeyTime = 0;
	chipGraphData.clear();
}

bool MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::equals(const Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY& _o) const
{
	return n == _o.n &&
		hockeyTime == _o.hockeyTime &&
		chipGraphData.equals(_o.chipGraphData);
}

const char *MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_GET_CHIP_GRAPH_DATA_REPLY).append(")");
	_buf.append(',');
	_buf.append("n=");
	_buf.appendUint(n);
	_buf.append(',');
	_buf.append("hockeyTime=");
	_buf.appendUint(hockeyTime);
	_buf.append(',');
	_buf.append("chipGraphData=");
	chipGraphData.toTraceString(_buf);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(n);
	_msg.composeUINT32(hockeyTime);
	_msg.composeMsgBody(chipGraphData);
}

void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(n);
	_parser.parseUINT32(hockeyTime);
	_parser.parseMsgBody(chipGraphData);
}

/*static*/ void MTLobbyCli::cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_GET_CHIP_GRAPH_DATA_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 n; _parser.parseUINT32(n);
	AtfValidator::validateInt(_descr, "n", n, _checker, __FILE__, __LINE__);
	UINT32 hockeyTime; _parser.parseUINT32(hockeyTime);
	AtfValidator::validateInt(_descr, "hockeyTime", hockeyTime, _checker, __FILE__, __LINE__);
	size_t szChipGraphData; _parser.skipMsgBody(szChipGraphData);  /*chipGraphData*/
	AtfValidator::validateInt(_descr, "chipGraphData", szChipGraphData, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS
//=================================================================

MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS()
{
	clear();
}

void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::clear()
{
	tournId = 0;
}

bool MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::equals(const Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS& _o) const
{
	return tournId == _o.tournId;
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MTL_GET_SAME_LEVEL_FLIGHTS).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournId);
}

void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MTL_GET_SAME_LEVEL_FLIGHTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TGMFlightData
//=================================================================

MTLobbyCli::cli::TGMFlightData::TGMFlightData()
{
	clear();
}

void MTLobbyCli::cli::TGMFlightData::clear()
{
	tournId = 0;
	startTime.setNull();
	numUsers = 0;
}

bool MTLobbyCli::cli::TGMFlightData::equals(const TGMFlightData& _o) const
{
	return tournId == _o.tournId &&
		startTime.equals(_o.startTime) &&
		numUsers == _o.numUsers;
}

const char *MTLobbyCli::cli::TGMFlightData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("startTime=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, startTime);
	_buf.append(',');
	_buf.append("numUsers=");
	_buf.appendUint(numUsers);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::cli::TGMFlightData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournId);
	_msg.composeSrvTime(startTime);
	_msg.composeUINT32(numUsers);
}

void MTLobbyCli::cli::TGMFlightData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
	_parser.parseSrvTime(startTime);
	_parser.parseUINT32(numUsers);
}

/*static*/ void MTLobbyCli::cli::TGMFlightData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	SrvTime startTime; _parser.parseSrvTime(startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	UINT32 numUsers; _parser.parseUINT32(numUsers);
	AtfValidator::validateInt(_descr, "numUsers", numUsers, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY
//=================================================================

MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY(Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, numLevels(std::move(_o.numLevels))
	, flightData(std::move(_o.flightData))
{
}

MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY& MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::operator=(Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		numLevels = std::move(_o.numLevels);
		flightData = std::move(_o.flightData);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	numLevels = 0;
	flightData.clear();
}

bool MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::equals(const Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		numLevels == _o.numLevels &&
		flightData.equals(_o.flightData);
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("numLevels=");
		_buf.appendUint(numLevels);
		_buf.append(',');
		_buf.append("flightData=");
		flightData.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(numLevels);
		flightData.composeMsg(_msg);
	}
}

void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(numLevels);
		flightData.parseMsg(_parser);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 numLevels; _parser.parseUINT32(numLevels);
		AtfValidator::validateInt(_descr, "numLevels", numLevels, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szFlightData = ThinAtf::LAtfVector< TGMFlightData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("flightData"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "flightData", szFlightData, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MTL_CHANGE_FLIGHT
//=================================================================

MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::Protocol_MSG_MTL_CHANGE_FLIGHT()
{
	clear();
}

void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::clear()
{
	tournId = 0;
}

bool MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::equals(const Protocol_MSG_MTL_CHANGE_FLIGHT& _o) const
{
	return tournId == _o.tournId;
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MTL_CHANGE_FLIGHT).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournId);
}

void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MTL_CHANGE_FLIGHT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY
//=================================================================

MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY(Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY& MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::operator=(Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::equals(const Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MTL_CHANGE_FLIGHT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void MTLobbyCli::cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MTL_CHANGE_FLIGHT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    LightTournData
//=================================================================

MTLobbyCli::cli::LightTournData::LightTournData()
{
	clear();
}

void MTLobbyCli::cli::LightTournData::clear()
{
	status = 0;
	whenStart.setNull();
	prizePoolToPublish = 0;
	prizePoolUnit = 0;
	prizePoolMoneyToPublish = 0;
	numUsersReg = 0;
}

bool MTLobbyCli::cli::LightTournData::equals(const LightTournData& _o) const
{
	return status == _o.status &&
		whenStart.equals(_o.whenStart) &&
		prizePoolToPublish == _o.prizePoolToPublish &&
		prizePoolUnit == _o.prizePoolUnit &&
		prizePoolMoneyToPublish == _o.prizePoolMoneyToPublish &&
		numUsersReg == _o.numUsersReg;
}

const char *MTLobbyCli::cli::LightTournData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("whenStart=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("prizePoolToPublish=");
	_buf.appendInt(prizePoolToPublish);
	_buf.append(',');
	_buf.append("prizePoolUnit=");
	_buf.appendUint(prizePoolUnit);
	_buf.append(',');
	_buf.append("prizePoolMoneyToPublish=");
	_buf.appendInt(prizePoolMoneyToPublish);
	_buf.append(',');
	_buf.append("numUsersReg=");
	_buf.appendUint(numUsersReg);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::cli::LightTournData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(status);
	_msg.composeSrvTime(whenStart);
	_msg.composeINT32(prizePoolToPublish);
	_msg.composeBYTE(prizePoolUnit);
	_msg.composeINT32(prizePoolMoneyToPublish);
	_msg.composeUINT32(numUsersReg);
}

void MTLobbyCli::cli::LightTournData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(status);
	_parser.parseSrvTime(whenStart);
	_parser.parseINT32(prizePoolToPublish);
	_parser.parseBYTE(prizePoolUnit);
	_parser.parseINT32(prizePoolMoneyToPublish);
	_parser.parseUINT32(numUsersReg);
}

/*static*/ void MTLobbyCli::cli::LightTournData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	SrvTime whenStart; _parser.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	INT32 prizePoolToPublish; _parser.parseINT32(prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	BYTE prizePoolUnit; _parser.parseBYTE(prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	INT32 prizePoolMoneyToPublish; _parser.parseINT32(prizePoolMoneyToPublish);
	AtfValidator::validateInt(_descr, "prizePoolMoneyToPublish", prizePoolMoneyToPublish, _checker, __FILE__, __LINE__);
	UINT32 numUsersReg; _parser.parseUINT32(numUsersReg);
	AtfValidator::validateInt(_descr, "numUsersReg", numUsersReg, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MTL_LOBBY_WHERE_IS_PLAYER
//=================================================================

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::Protocol_MTL_LOBBY_WHERE_IS_PLAYER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::Protocol_MTL_LOBBY_WHERE_IS_PLAYER(Protocol_MTL_LOBBY_WHERE_IS_PLAYER&& _o)
	: userName(std::move(_o.userName))
{
}

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER& MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::operator=(Protocol_MTL_LOBBY_WHERE_IS_PLAYER&& _o)
{
	if(this != &_o)
	{
		userName = std::move(_o.userName);
	}
	return *this;
}

#endif

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::clear()
{
	userName.clear();
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::equals(const Protocol_MTL_LOBBY_WHERE_IS_PLAYER& _o) const
{
	return userName.equals(_o.userName);
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_WHERE_IS_PLAYER).append(")");
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userName);
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userName);
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY
//=================================================================

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY(Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, place(std::move(_o.place))
	, tableServer(std::move(_o.tableServer))
	, tableObject(std::move(_o.tableObject))
	, flags(std::move(_o.flags))
	, errDescr(std::move(_o.errDescr))
{
}

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY& MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::operator=(Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		place = std::move(_o.place);
		tableServer = std::move(_o.tableServer);
		tableObject = std::move(_o.tableObject);
		flags = std::move(_o.flags);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::clear()
{
	errCode = 0;
	place = 0;
	tableServer.clear();
	tableObject.clear();
	flags = false;
	errDescr.clear();
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::equals(const Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		place == _o.place &&
		tableServer.equals(_o.tableServer) &&
		tableObject.equals(_o.tableObject) &&
		flags == _o.flags &&
		errDescr.equals(_o.errDescr);
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_WHERE_IS_PLAYER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_buf.append(',');
		_buf.append("place=");
		_buf.appendUint(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_buf.append(',');
		_buf.append("tableServer=");
		_buf.append(tableServer);
		_buf.append(',');
		_buf.append("tableObject=");
		_buf.append(tableObject);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
	}
	else
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_msg.composeUINT32(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_msg.composeString(tableServer);
		_msg.composeString(tableObject);
		_msg.composeBOOL(flags);
	}
	else
	{
		_msg.composeString(errDescr);
	}
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_parser.parseUINT32(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_parser.parseStringP(tableServer);
		_parser.parseStringP(tableObject);
		_parser.parseBOOL(flags);
	}
	else
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode == WHERE_IS_PLACE )
	{
		UINT32 place; _parser.parseUINT32(place);
		AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_parser.parseStringN(_dummy, 0, "tableServer"); size_t szTableServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableServer", szTableServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tableObject"); size_t szTableObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableObject", szTableObject, _checker, __FILE__, __LINE__);
		bool flags; _parser.parseBOOL(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS
//=================================================================

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS&& _o)
	: userName(std::move(_o.userName))
{
}

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS& MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::operator=(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS&& _o)
{
	if(this != &_o)
	{
		userName = std::move(_o.userName);
	}
	return *this;
}

#endif

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::clear()
{
	userName.clear();
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::equals(const Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS& _o) const
{
	return userName.equals(_o.userName);
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS).append(")");
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userName);
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userName);
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY
//=================================================================

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, reply(std::move(_o.reply))
{
}

MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY& MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::operator=(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		reply = std::move(_o.reply);
	}
	return *this;
}

#endif

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	reply.clear();
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::equals(const Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		reply.equals(_o.reply);
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("reply=");
		reply.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		reply.composeMsg(_msg);
	}
}

void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		reply.parseMsg(_parser);
	}
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserStatsReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SnapshotStruct
//=================================================================

MTLobbyCli::unauth_cli::SnapshotStruct::SnapshotStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::unauth_cli::SnapshotStruct::SnapshotStruct(SnapshotStruct&& _o)
	: player0(std::move(_o.player0))
	, player1(std::move(_o.player1))
{
}

MTLobbyCli::unauth_cli::SnapshotStruct& MTLobbyCli::unauth_cli::SnapshotStruct::operator=(SnapshotStruct&& _o)
{
	if(this != &_o)
	{
		player0 = std::move(_o.player0);
		player1 = std::move(_o.player1);
	}
	return *this;
}

#endif

void MTLobbyCli::unauth_cli::SnapshotStruct::clear()
{
	player0.clear();
	player1.clear();
}

bool MTLobbyCli::unauth_cli::SnapshotStruct::equals(const SnapshotStruct& _o) const
{
	return player0.equals(_o.player0) &&
		player1.equals(_o.player1);
}

const char *MTLobbyCli::unauth_cli::SnapshotStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("player0=");
	_buf.append(player0);
	_buf.append(',');
	_buf.append("player1=");
	_buf.append(player1);
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::SnapshotStruct::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(player0);
	_msg.composeString(player1);
}

void MTLobbyCli::unauth_cli::SnapshotStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(player0);
	_parser.parseStringP(player1);
}

/*static*/ void MTLobbyCli::unauth_cli::SnapshotStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "player0"); size_t szPlayer0 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "player0", szPlayer0, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "player1"); size_t szPlayer1 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "player1", szPlayer1, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT
//=================================================================

MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT()
{
	clear();
}

void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::clear()
{
}

bool MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::equals(const Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT& _o) const
{
	return true;
}

const char *MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_OLYMPIC_SNAPSHOT).append(")");
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::composeMsg(CommMsgBody& _msg) const
{
}

void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_OLYMPIC_SNAPSHOT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY
//=================================================================

MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY(Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, snapshotOk(std::move(_o.snapshotOk))
	, snapshotData(std::move(_o.snapshotData))
{
}

MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY& MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::operator=(Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		snapshotOk = std::move(_o.snapshotOk);
		snapshotData = std::move(_o.snapshotData);
	}
	return *this;
}

#endif

void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	snapshotOk = 0;
	snapshotData.clear();
}

bool MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::equals(const Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		snapshotOk == _o.snapshotOk &&
		snapshotData.equals(_o.snapshotData);
}

const char *MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("snapshotOk=");
		_buf.appendInt(snapshotOk);
		_buf.append(',');
		_buf.append("snapshotData=");
		snapshotData.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeINT16(snapshotOk);
		snapshotData.composeMsg(_msg);
	}
}

void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseINT16(snapshotOk);
		snapshotData.parseMsg(_parser);
	}
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT16 snapshotOk; _parser.parseINT16(snapshotOk);
		AtfValidator::validateInt(_descr, "snapshotOk", snapshotOk, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szSnapshotData = ThinAtf::LAtfVector< SnapshotStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("snapshotData"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "snapshotData", szSnapshotData, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_TOURN_TEXT_INFO
//=================================================================

MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::Protocol_MTL_TOURN_TEXT_INFO()
{
	clear();
}

void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::clear()
{
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::equals(const Protocol_MTL_TOURN_TEXT_INFO& _o) const
{
	return true;
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_TOURN_TEXT_INFO).append(")");
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::composeMsg(CommMsgBody& _msg) const
{
}

void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_TOURN_TEXT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_TOURN_TEXT_INFO_REPLY
//=================================================================

MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::Protocol_MTL_TOURN_TEXT_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::Protocol_MTL_TOURN_TEXT_INFO_REPLY(Protocol_MTL_TOURN_TEXT_INFO_REPLY&& _o)
	: name(std::move(_o.name))
	, messageBoardText(std::move(_o.messageBoardText))
{
}

MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY& MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::operator=(Protocol_MTL_TOURN_TEXT_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		messageBoardText = std::move(_o.messageBoardText);
	}
	return *this;
}

#endif

void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::clear()
{
	name.clear();
	messageBoardText.clear();
}

bool MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::equals(const Protocol_MTL_TOURN_TEXT_INFO_REPLY& _o) const
{
	return name.equals(_o.name) &&
		messageBoardText.equals(_o.messageBoardText);
}

const char *MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_TOURN_TEXT_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("name=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, name);
	_buf.append(',');
	_buf.append("messageBoardText=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, messageBoardText);
	return _buf.c_str();
}

void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	name.compose(_msg);
	messageBoardText.compose(_msg);
}

void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	name.parse(_parser);
	messageBoardText.parse(_parser);
}

/*static*/ void MTLobbyCli::unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_TOURN_TEXT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	I18nPString name; name.parse(_parser);
	I18nPString messageBoardText; messageBoardText.parse(_parser);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_WHERE_IS_PLAYER
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::Protocol_MTL_LOBBY_WHERE_IS_PLAYER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::Protocol_MTL_LOBBY_WHERE_IS_PLAYER(Protocol_MTL_LOBBY_WHERE_IS_PLAYER&& _o)
	: userName(std::move(_o.userName))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER& MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::operator=(Protocol_MTL_LOBBY_WHERE_IS_PLAYER&& _o)
{
	if(this != &_o)
	{
		userName = std::move(_o.userName);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::clear()
{
	userName.clear();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::equals(const Protocol_MTL_LOBBY_WHERE_IS_PLAYER& _o) const
{
	return userName.equals(_o.userName);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_WHERE_IS_PLAYER).append(")");
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userName);
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userName);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY(Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, place(std::move(_o.place))
	, tableServer(std::move(_o.tableServer))
	, tableObject(std::move(_o.tableObject))
	, flags(std::move(_o.flags))
	, errDescr(std::move(_o.errDescr))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY& MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::operator=(Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		place = std::move(_o.place);
		tableServer = std::move(_o.tableServer);
		tableObject = std::move(_o.tableObject);
		flags = std::move(_o.flags);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::clear()
{
	errCode = 0;
	place = 0;
	tableServer.clear();
	tableObject.clear();
	flags = false;
	errDescr.clear();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::equals(const Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		place == _o.place &&
		tableServer.equals(_o.tableServer) &&
		tableObject.equals(_o.tableObject) &&
		flags == _o.flags &&
		errDescr.equals(_o.errDescr);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_WHERE_IS_PLAYER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_buf.append(',');
		_buf.append("place=");
		_buf.appendUint(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_buf.append(',');
		_buf.append("tableServer=");
		_buf.append(tableServer);
		_buf.append(',');
		_buf.append("tableObject=");
		_buf.append(tableObject);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
	}
	else
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_msg.composeUINT32(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_msg.composeString(tableServer);
		_msg.composeString(tableObject);
		_msg.composeBOOL(flags);
	}
	else
	{
		_msg.composeString(errDescr);
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode == WHERE_IS_PLACE )
	{
		_parser.parseUINT32(place);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_parser.parseStringP(tableServer);
		_parser.parseStringP(tableObject);
		_parser.parseBOOL(flags);
	}
	else
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_WHERE_IS_PLAYER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode == WHERE_IS_PLACE )
	{
		UINT32 place; _parser.parseUINT32(place);
		AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	}
	else if( errCode == WHERE_IS_PLAYING )
	{
		_parser.parseStringN(_dummy, 0, "tableServer"); size_t szTableServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableServer", szTableServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tableObject"); size_t szTableObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableObject", szTableObject, _checker, __FILE__, __LINE__);
		bool flags; _parser.parseBOOL(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS&& _o)
	: userName(std::move(_o.userName))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS& MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::operator=(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS&& _o)
{
	if(this != &_o)
	{
		userName = std::move(_o.userName);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::clear()
{
	userName.clear();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::equals(const Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS& _o) const
{
	return userName.equals(_o.userName);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS).append(")");
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userName);
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userName);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, reply(std::move(_o.reply))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY& MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::operator=(Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		reply = std::move(_o.reply);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	reply.clear();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::equals(const Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		reply.equals(_o.reply);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("reply=");
		reply.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		reply.composeMsg(_msg);
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		reply.parseMsg(_parser);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserStatsReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_CLI_GOTO_TABLE
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::Protocol_MTL_CLI_GOTO_TABLE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::Protocol_MTL_CLI_GOTO_TABLE(Protocol_MTL_CLI_GOTO_TABLE&& _o)
	: server(std::move(_o.server))
	, instance(std::move(_o.instance))
	, playMoney(std::move(_o.playMoney))
	, currency(std::move(_o.currency))
	, chips(std::move(_o.chips))
	, sittingIn(std::move(_o.sittingIn))
	, seat(std::move(_o.seat))
	, reconnect(std::move(_o.reconnect))
	, handId(std::move(_o.handId))
	, stat(std::move(_o.stat))
	, action(std::move(_o.action))
	, rebuys(std::move(_o.rebuys))
	, timeout(std::move(_o.timeout))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE& MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::operator=(Protocol_MTL_CLI_GOTO_TABLE&& _o)
{
	if(this != &_o)
	{
		server = std::move(_o.server);
		instance = std::move(_o.instance);
		playMoney = std::move(_o.playMoney);
		currency = std::move(_o.currency);
		chips = std::move(_o.chips);
		sittingIn = std::move(_o.sittingIn);
		seat = std::move(_o.seat);
		reconnect = std::move(_o.reconnect);
		handId = std::move(_o.handId);
		stat = std::move(_o.stat);
		action = std::move(_o.action);
		rebuys = std::move(_o.rebuys);
		timeout = std::move(_o.timeout);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::clear()
{
	server.clear();
	instance.clear();
	playMoney = false;
	currency.clear();
	chips = 0;
	sittingIn = false;
	seat = 0;
	reconnect = false;
	handId = 0;
	stat = 0;
	action = '0';
	rebuys = 0;
	timeout = 0;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::equals(const Protocol_MTL_CLI_GOTO_TABLE& _o) const
{
	return server.equals(_o.server) &&
		instance.equals(_o.instance) &&
		playMoney == _o.playMoney &&
		currency.equals(_o.currency) &&
		chips == _o.chips &&
		sittingIn == _o.sittingIn &&
		seat == _o.seat &&
		reconnect == _o.reconnect &&
		handId == _o.handId &&
		stat == _o.stat &&
		action == _o.action &&
		rebuys == _o.rebuys &&
		timeout == _o.timeout;
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_CLI_GOTO_TABLE).append(")");
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("instance=");
	_buf.append(instance);
	_buf.append(',');
	_buf.append("playMoney=");
	_buf.appendUint(playMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendUint(chips);
	_buf.append(',');
	_buf.append("sittingIn=");
	_buf.appendUint(sittingIn);
	_buf.append(',');
	_buf.append("seat=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("reconnect=");
	_buf.appendUint(reconnect);
	_buf.append(',');
	_buf.append("handId=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("stat=");
	_buf.appendUint(stat);
	_buf.append(',');
	_buf.append("action=");
	_buf.append(action);
	_buf.append(',');
	_buf.append("rebuys=");
	_buf.appendUint(rebuys);
	_buf.append(',');
	_buf.append("timeout=");
	_buf.appendInt(timeout);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(server);
	_msg.composeString(instance);
	_msg.composeBOOL(playMoney);
	_msg.composeString(currency);
	_msg.composeUINT32(chips);
	_msg.composeBOOL(sittingIn);
	_msg.composeINT8(seat);
	_msg.composeBOOL(reconnect);
	_msg.composeUINT64(handId);
	_msg.composeUINT32(stat);
	_msg.composeINT8(action);
	_msg.composeUINT16(rebuys);
	_msg.composeINT32(timeout);
}

void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(server);
	_parser.parseStringP(instance);
	_parser.parseBOOL(playMoney);
	_parser.parseStringP(currency);
	_parser.parseUINT32(chips);
	_parser.parseBOOL(sittingIn);
	_parser.parseINT8(seat);
	_parser.parseBOOL(reconnect);
	_parser.parseUINT64(handId);
	_parser.parseUINT32(stat);
	{ INT8 _n; _parser.parseINT8(_n); action = _n; }
	_parser.parseUINT16(rebuys);
	_parser.parseINT32(timeout);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_TABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_CLI_GOTO_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "instance"); size_t szInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "instance", szInstance, _checker, __FILE__, __LINE__);
	bool playMoney; _parser.parseBOOL(playMoney);
	AtfValidator::validateInt(_descr, "playMoney", playMoney, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 chips; _parser.parseUINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	bool sittingIn; _parser.parseBOOL(sittingIn);
	AtfValidator::validateInt(_descr, "sittingIn", sittingIn, _checker, __FILE__, __LINE__);
	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	bool reconnect; _parser.parseBOOL(reconnect);
	AtfValidator::validateInt(_descr, "reconnect", reconnect, _checker, __FILE__, __LINE__);
	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	UINT32 stat; _parser.parseUINT32(stat);
	AtfValidator::validateInt(_descr, "stat", stat, _checker, __FILE__, __LINE__);
	char action; { INT8 _n; _parser.parseINT8(_n); action = _n; }
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	UINT16 rebuys; _parser.parseUINT16(rebuys);
	AtfValidator::validateInt(_descr, "rebuys", rebuys, _checker, __FILE__, __LINE__);
	INT32 timeout; _parser.parseINT32(timeout);
	AtfValidator::validateInt(_descr, "timeout", timeout, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_SITIN
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::Protocol_MTL_USER_SITIN()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::clear()
{
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::equals(const Protocol_MTL_USER_SITIN& _o) const
{
	return true;
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_SITIN).append(")");
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::composeMsg(CommMsgBody& _msg) const
{
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_SITIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_SITIN_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::Protocol_MTL_USER_SITIN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::Protocol_MTL_USER_SITIN_REPLY(Protocol_MTL_USER_SITIN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tableServer(std::move(_o.tableServer))
	, tableObject(std::move(_o.tableObject))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, chips(std::move(_o.chips))
	, sittingIn(std::move(_o.sittingIn))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY& MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::operator=(Protocol_MTL_USER_SITIN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tableServer = std::move(_o.tableServer);
		tableObject = std::move(_o.tableObject);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		chips = std::move(_o.chips);
		sittingIn = std::move(_o.sittingIn);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tableServer.clear();
	tableObject.clear();
	isPlayMoney = false;
	currency.clear();
	chips = 0;
	sittingIn = false;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::equals(const Protocol_MTL_USER_SITIN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		tableServer.equals(_o.tableServer) &&
		tableObject.equals(_o.tableObject) &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		chips == _o.chips &&
		sittingIn == _o.sittingIn;
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_SITIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tableServer=");
		_buf.append(tableServer);
		_buf.append(',');
		_buf.append("tableObject=");
		_buf.append(tableObject);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("chips=");
		_buf.appendUint(chips);
		_buf.append(',');
		_buf.append("sittingIn=");
		_buf.appendUint(sittingIn);
	}
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(tableServer);
		_msg.composeString(tableObject);
		_msg.composeBOOL(isPlayMoney);
		_msg.composeString(currency);
		_msg.composeUINT32(chips);
		_msg.composeBOOL(sittingIn);
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(tableServer);
		_parser.parseStringP(tableObject);
		_parser.parseBOOL(isPlayMoney);
		_parser.parseStringP(currency);
		_parser.parseUINT32(chips);
		_parser.parseBOOL(sittingIn);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_SITIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "tableServer"); size_t szTableServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableServer", szTableServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tableObject"); size_t szTableObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableObject", szTableObject, _checker, __FILE__, __LINE__);
		bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		UINT32 chips; _parser.parseUINT32(chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		bool sittingIn; _parser.parseBOOL(sittingIn);
		AtfValidator::validateInt(_descr, "sittingIn", sittingIn, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_SITOUT
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::Protocol_MTL_USER_SITOUT()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::clear()
{
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::equals(const Protocol_MTL_USER_SITOUT& _o) const
{
	return true;
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_SITOUT).append(")");
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::composeMsg(CommMsgBody& _msg) const
{
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_SITOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_SITOUT_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::Protocol_MTL_USER_SITOUT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::Protocol_MTL_USER_SITOUT_REPLY(Protocol_MTL_USER_SITOUT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY& MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::operator=(Protocol_MTL_USER_SITOUT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::equals(const Protocol_MTL_USER_SITOUT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_SITOUT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_SITOUT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_SITOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    P_HomeGamesTourn
//=================================================================

MTLobbyCli::perm_cli::P_HomeGamesTourn::P_HomeGamesTourn()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::P_HomeGamesTourn::P_HomeGamesTourn(P_HomeGamesTourn&& _o)
	: available(std::move(_o.available))
	, startTime(std::move(_o.startTime))
	, clubId(std::move(_o.clubId))
	, clubName(std::move(_o.clubName))
	, tournId(std::move(_o.tournId))
	, name(std::move(_o.name))
	, gameType(std::move(_o.gameType))
	, isHiLo(std::move(_o.isHiLo))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, bounty(std::move(_o.bounty))
	, players(std::move(_o.players))
	, registered(std::move(_o.registered))
	, limit(std::move(_o.limit))
	, currency(std::move(_o.currency))
	, playMoney(std::move(_o.playMoney))
	, playersPerTable(std::move(_o.playersPerTable))
	, state(std::move(_o.state))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
{
}

MTLobbyCli::perm_cli::P_HomeGamesTourn& MTLobbyCli::perm_cli::P_HomeGamesTourn::operator=(P_HomeGamesTourn&& _o)
{
	if(this != &_o)
	{
		available = std::move(_o.available);
		startTime = std::move(_o.startTime);
		clubId = std::move(_o.clubId);
		clubName = std::move(_o.clubName);
		tournId = std::move(_o.tournId);
		name = std::move(_o.name);
		gameType = std::move(_o.gameType);
		isHiLo = std::move(_o.isHiLo);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		bounty = std::move(_o.bounty);
		players = std::move(_o.players);
		registered = std::move(_o.registered);
		limit = std::move(_o.limit);
		currency = std::move(_o.currency);
		playMoney = std::move(_o.playMoney);
		playersPerTable = std::move(_o.playersPerTable);
		state = std::move(_o.state);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::P_HomeGamesTourn::clear()
{
	available = 0;
	startTime.setNull();
	clubId = 0;
	clubName.clear();
	tournId = 0;
	name.clear();
	gameType = 0;
	isHiLo = false;
	buyIn = 0;
	rake = 0;
	bounty = 0;
	players = 0;
	registered = false;
	limit = 0;
	currency.clear();
	playMoney = false;
	playersPerTable = 0;
	state = 0;
	server.clear();
	serverObject.clear();
}

bool MTLobbyCli::perm_cli::P_HomeGamesTourn::equals(const P_HomeGamesTourn& _o) const
{
	return available == _o.available &&
		startTime.equals(_o.startTime) &&
		clubId == _o.clubId &&
		clubName.equals(_o.clubName) &&
		tournId == _o.tournId &&
		name.equals(_o.name) &&
		gameType == _o.gameType &&
		isHiLo == _o.isHiLo &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		bounty == _o.bounty &&
		players == _o.players &&
		registered == _o.registered &&
		limit == _o.limit &&
		currency.equals(_o.currency) &&
		playMoney == _o.playMoney &&
		playersPerTable == _o.playersPerTable &&
		state == _o.state &&
		server.equals(_o.server) &&
		serverObject.equals(_o.serverObject);
}

const char *MTLobbyCli::perm_cli::P_HomeGamesTourn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("available=");
	_buf.appendUint(available);
	if( available )
	{
		_buf.append(',');
		_buf.append("startTime=");
		ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, startTime);
		_buf.append(',');
		_buf.append("clubId=");
		_buf.appendUint(clubId);
		_buf.append(',');
		_buf.append("clubName=");
		_buf.append(clubName);
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("name=");
		_buf.append(name);
		_buf.append(',');
		_buf.append("gameType=");
		_buf.appendUint(gameType);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("buyIn=");
		_buf.appendUint(buyIn);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendUint(rake);
		_buf.append(',');
		_buf.append("bounty=");
		_buf.appendUint(bounty);
		_buf.append(',');
		_buf.append("players=");
		_buf.appendUint(players);
		_buf.append(',');
		_buf.append("registered=");
		_buf.appendUint(registered);
		_buf.append(',');
		_buf.append("limit=");
		_buf.appendUint(limit);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("playMoney=");
		_buf.appendUint(playMoney);
		_buf.append(',');
		_buf.append("playersPerTable=");
		_buf.appendUint(playersPerTable);
		_buf.append(',');
		_buf.append("state=");
		_buf.appendUint(state);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
	}
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::P_HomeGamesTourn::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(available);
	if( available )
	{
		_msg.composeSrvTime(startTime);
		_msg.composeUINT32(clubId);
		_msg.composeString(clubName);
		_msg.composeUINT32(tournId);
		_msg.composeString(name);
		_msg.composeBYTE(gameType);
		_msg.composeBOOL(isHiLo);
		_msg.composeUINT32(buyIn);
		_msg.composeUINT32(rake);
		_msg.composeUINT32(bounty);
		_msg.composeUINT32(players);
		_msg.composeBOOL(registered);
		_msg.composeBYTE(limit);
		_msg.composeString(currency);
		_msg.composeBOOL(playMoney);
		_msg.composeUINT32(playersPerTable);
		_msg.composeUINT32(state);
		_msg.composeString(server);
		_msg.composeString(serverObject);
	}
}

void MTLobbyCli::perm_cli::P_HomeGamesTourn::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(available);
	if( available )
	{
		_parser.parseSrvTime(startTime);
		_parser.parseUINT32(clubId);
		_parser.parseStringP(clubName);
		_parser.parseUINT32(tournId);
		_parser.parseStringP(name);
		_parser.parseBYTE(gameType);
		_parser.parseBOOL(isHiLo);
		_parser.parseUINT32(buyIn);
		_parser.parseUINT32(rake);
		_parser.parseUINT32(bounty);
		_parser.parseUINT32(players);
		_parser.parseBOOL(registered);
		_parser.parseBYTE(limit);
		_parser.parseStringP(currency);
		_parser.parseBOOL(playMoney);
		_parser.parseUINT32(playersPerTable);
		_parser.parseUINT32(state);
		_parser.parseStringP(server);
		_parser.parseStringP(serverObject);
	}
}

/*static*/ void MTLobbyCli::perm_cli::P_HomeGamesTourn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 available = 0;
	_parser.parseUINT32(available);
	AtfValidator::validateInt(_descr, "available", available, _checker, __FILE__, __LINE__);
	if( available )
	{
		SrvTime startTime; _parser.parseSrvTime(startTime);
		AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
		UINT32 clubId; _parser.parseUINT32(clubId);
		AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
		BYTE gameType; _parser.parseBYTE(gameType);
		AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
		bool isHiLo; _parser.parseBOOL(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		UINT32 buyIn; _parser.parseUINT32(buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		UINT32 rake; _parser.parseUINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 bounty; _parser.parseUINT32(bounty);
		AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
		UINT32 players; _parser.parseUINT32(players);
		AtfValidator::validateInt(_descr, "players", players, _checker, __FILE__, __LINE__);
		bool registered; _parser.parseBOOL(registered);
		AtfValidator::validateInt(_descr, "registered", registered, _checker, __FILE__, __LINE__);
		BYTE limit; _parser.parseBYTE(limit);
		AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool playMoney; _parser.parseBOOL(playMoney);
		AtfValidator::validateInt(_descr, "playMoney", playMoney, _checker, __FILE__, __LINE__);
		UINT32 playersPerTable; _parser.parseUINT32(playersPerTable);
		AtfValidator::validateInt(_descr, "playersPerTable", playersPerTable, _checker, __FILE__, __LINE__);
		UINT32 state; _parser.parseUINT32(state);
		AtfValidator::validateInt(_descr, "state", state, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    P_FlightTourn
//=================================================================

MTLobbyCli::perm_cli::P_FlightTourn::P_FlightTourn()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::P_FlightTourn::P_FlightTourn(P_FlightTourn&& _o)
	: available(std::move(_o.available))
	, name(std::move(_o.name))
	, server(std::move(_o.server))
{
}

MTLobbyCli::perm_cli::P_FlightTourn& MTLobbyCli::perm_cli::P_FlightTourn::operator=(P_FlightTourn&& _o)
{
	if(this != &_o)
	{
		available = std::move(_o.available);
		name = std::move(_o.name);
		server = std::move(_o.server);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::P_FlightTourn::clear()
{
	available = false;
	name.clear();
	server.clear();
}

bool MTLobbyCli::perm_cli::P_FlightTourn::equals(const P_FlightTourn& _o) const
{
	return available == _o.available &&
		name.equals(_o.name) &&
		server.equals(_o.server);
}

const char *MTLobbyCli::perm_cli::P_FlightTourn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("available=");
	_buf.appendUint(available);
	if( available )
	{
		_buf.append(',');
		_buf.append("name=");
		ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, name);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
	}
	_buf.append('}');
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::P_FlightTourn::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(available);
	if( available )
	{
		name.compose(_msg);
		_msg.composeString(server);
	}
}

void MTLobbyCli::perm_cli::P_FlightTourn::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(available);
	if( available )
	{
		name.parse(_parser);
		_parser.parseStringP(server);
	}
}

/*static*/ void MTLobbyCli::perm_cli::P_FlightTourn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	bool available = false;
	_parser.parseBOOL(available);
	AtfValidator::validateInt(_descr, "available", available, _checker, __FILE__, __LINE__);
	if( available )
	{
		I18nPString name; name.parse(_parser);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                Protocol_MTL_CLI_GOTO_FINISH
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::Protocol_MTL_CLI_GOTO_FINISH()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::Protocol_MTL_CLI_GOTO_FINISH(Protocol_MTL_CLI_GOTO_FINISH&& _o)
	: place(std::move(_o.place))
	, message(std::move(_o.message))
	, socialToken(std::move(_o.socialToken))
	, nextHomeGamesTourn(std::move(_o.nextHomeGamesTourn))
	, nextFlightTourn(std::move(_o.nextFlightTourn))
	, ownBounty(std::move(_o.ownBounty))
	, flags(std::move(_o.flags))
	, award(std::move(_o.award))
	, bountyWon(std::move(_o.bountyWon))
	, reEntryDeadline(std::move(_o.reEntryDeadline))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH& MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::operator=(Protocol_MTL_CLI_GOTO_FINISH&& _o)
{
	if(this != &_o)
	{
		place = std::move(_o.place);
		message = std::move(_o.message);
		socialToken = std::move(_o.socialToken);
		nextHomeGamesTourn = std::move(_o.nextHomeGamesTourn);
		nextFlightTourn = std::move(_o.nextFlightTourn);
		ownBounty = std::move(_o.ownBounty);
		flags = std::move(_o.flags);
		award = std::move(_o.award);
		bountyWon = std::move(_o.bountyWon);
		reEntryDeadline = std::move(_o.reEntryDeadline);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::clear()
{
	place = 0;
	message.clear();
	socialToken.clear();
	nextHomeGamesTourn.clear();
	nextFlightTourn.clear();
	ownBounty = 0;
	flags = 0;
	award = 0;
	bountyWon = 0;
	reEntryDeadline.setNull();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::equals(const Protocol_MTL_CLI_GOTO_FINISH& _o) const
{
	return place == _o.place &&
		message.equals(_o.message) &&
		socialToken.equals(_o.socialToken) &&
		nextHomeGamesTourn.equals(_o.nextHomeGamesTourn) &&
		nextFlightTourn.equals(_o.nextFlightTourn) &&
		ownBounty == _o.ownBounty &&
		flags == _o.flags &&
		award == _o.award &&
		bountyWon == _o.bountyWon &&
		reEntryDeadline.equals(_o.reEntryDeadline);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_CLI_GOTO_FINISH).append(")");
	_buf.append(',');
	_buf.append("place=");
	_buf.appendUint(place);
	_buf.append(',');
	_buf.append("message=");
	_buf.append(message);
	_buf.append(',');
	_buf.append("socialToken=");
	_buf.append(socialToken);
	_buf.append(',');
	_buf.append("nextHomeGamesTourn=");
	nextHomeGamesTourn.toTraceString(_buf);
	_buf.append(',');
	_buf.append("nextFlightTourn=");
	nextFlightTourn.toTraceString(_buf);
	_buf.append(',');
	_buf.append("ownBounty=");
	_buf.appendUint(ownBounty);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("award=");
	_buf.appendUint(award);
	_buf.append(',');
	_buf.append("bountyWon=");
	_buf.appendUint(bountyWon);
	_buf.append(',');
	_buf.append("reEntryDeadline=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, reEntryDeadline);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(place);
	_msg.composeString(message);
	_msg.composeString(socialToken);
	nextHomeGamesTourn.composeMsg(_msg);
	nextFlightTourn.composeMsg(_msg);
	_msg.composeUINT32(ownBounty);
	_msg.composeUINT32(flags);
	_msg.composeUINT32(award);
	_msg.composeUINT32(bountyWon);
	_msg.composeSrvTime(reEntryDeadline);
}

void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(place);
	_parser.parseStringP(message);
	_parser.parseStringP(socialToken);
	nextHomeGamesTourn.parseMsg(_parser);
	nextFlightTourn.parseMsg(_parser);
	_parser.parseUINT32(ownBounty);
	_parser.parseUINT32(flags);
	_parser.parseUINT32(award);
	_parser.parseUINT32(bountyWon);
	if(_parser.parseEnded()) return;
	_parser.parseSrvTime(reEntryDeadline);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_CLI_GOTO_FINISH::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_CLI_GOTO_FINISH";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 place; _parser.parseUINT32(place);
	AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "message"); size_t szMessage = strlen(_dummy);
	AtfValidator::validateInt(_descr, "message", szMessage, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
	AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
	PString _descbuf;
	P_HomeGamesTourn::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("nextHomeGamesTourn"), _fieldsWithUnparsedContent);
	P_FlightTourn::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("nextFlightTourn"), _fieldsWithUnparsedContent);
	UINT32 ownBounty; _parser.parseUINT32(ownBounty);
	AtfValidator::validateInt(_descr, "ownBounty", ownBounty, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 award; _parser.parseUINT32(award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	UINT32 bountyWon; _parser.parseUINT32(bountyWon);
	AtfValidator::validateInt(_descr, "bountyWon", bountyWon, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	SrvTime reEntryDeadline; _parser.parseSrvTime(reEntryDeadline);
	AtfValidator::validateSrvDateTime(_descr, "reEntryDeadline", reEntryDeadline, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_REBUY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::Protocol_MTL_USER_REBUY()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::clear()
{
	numRebuys = 0;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::equals(const Protocol_MTL_USER_REBUY& _o) const
{
	return numRebuys == _o.numRebuys;
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_REBUY).append(")");
	_buf.append(',');
	_buf.append("numRebuys=");
	_buf.appendUint(numRebuys);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(numRebuys);
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(numRebuys);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_REBUY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	BYTE numRebuys; _parser.parseBYTE(numRebuys);
	AtfValidator::validateIntMax(_descr, "numRebuys", numRebuys, 10, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_REBUY_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::Protocol_MTL_USER_REBUY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::Protocol_MTL_USER_REBUY_REPLY(Protocol_MTL_USER_REBUY_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, errMsgBody(std::move(_o.errMsgBody))
	, chipsRecieved(std::move(_o.chipsRecieved))
	, realMoneySpent(std::move(_o.realMoneySpent))
	, playMoneySpent(std::move(_o.playMoneySpent))
	, fppSpent(std::move(_o.fppSpent))
	, tChipsSpent(std::move(_o.tChipsSpent))
	, wMoneySpent(std::move(_o.wMoneySpent))
	, isAamsTicket(std::move(_o.isAamsTicket))
	, aamsTicket(std::move(_o.aamsTicket))
	, playChipsSpent64(std::move(_o.playChipsSpent64))
	, rebuysDone(std::move(_o.rebuysDone))
	, addonsDone(std::move(_o.addonsDone))
	, rebuysRemaining(std::move(_o.rebuysRemaining))
	, tournSpendLimit(std::move(_o.tournSpendLimit))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY& MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::operator=(Protocol_MTL_USER_REBUY_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		errMsgBody = std::move(_o.errMsgBody);
		chipsRecieved = std::move(_o.chipsRecieved);
		realMoneySpent = std::move(_o.realMoneySpent);
		playMoneySpent = std::move(_o.playMoneySpent);
		fppSpent = std::move(_o.fppSpent);
		tChipsSpent = std::move(_o.tChipsSpent);
		wMoneySpent = std::move(_o.wMoneySpent);
		isAamsTicket = std::move(_o.isAamsTicket);
		aamsTicket = std::move(_o.aamsTicket);
		playChipsSpent64 = std::move(_o.playChipsSpent64);
		rebuysDone = std::move(_o.rebuysDone);
		addonsDone = std::move(_o.addonsDone);
		rebuysRemaining = std::move(_o.rebuysRemaining);
		tournSpendLimit = std::move(_o.tournSpendLimit);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	errMsgBody.clear();
	chipsRecieved = 0;
	realMoneySpent = 0;
	playMoneySpent = 0;
	fppSpent = 0;
	tChipsSpent = 0;
	wMoneySpent = 0;
	isAamsTicket = 0;
	aamsTicket.clear();
	playChipsSpent64 = 0;
	rebuysDone = 0;
	addonsDone = 0;
	rebuysRemaining = 0;
	tournSpendLimit.clear();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::equals(const Protocol_MTL_USER_REBUY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		errMsgBody.equals(_o.errMsgBody) &&
		chipsRecieved == _o.chipsRecieved &&
		realMoneySpent == _o.realMoneySpent &&
		playMoneySpent == _o.playMoneySpent &&
		fppSpent == _o.fppSpent &&
		tChipsSpent == _o.tChipsSpent &&
		wMoneySpent == _o.wMoneySpent &&
		isAamsTicket == _o.isAamsTicket &&
		aamsTicket.equals(_o.aamsTicket) &&
		playChipsSpent64 == _o.playChipsSpent64 &&
		rebuysDone == _o.rebuysDone &&
		addonsDone == _o.addonsDone &&
		rebuysRemaining == _o.rebuysRemaining &&
		tournSpendLimit.equals(_o.tournSpendLimit);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_REBUY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("errMsgBody=");
		errMsgBody.toTraceString(_buf);
	}
	else
	{
		_buf.append(',');
		_buf.append("chipsRecieved=");
		_buf.appendUint(chipsRecieved);
		_buf.append(',');
		_buf.append("realMoneySpent=");
		_buf.appendUint(realMoneySpent);
		_buf.append(',');
		_buf.append("playMoneySpent=");
		_buf.appendUint(playMoneySpent);
		_buf.append(',');
		_buf.append("fppSpent=");
		_buf.appendUint(fppSpent);
		_buf.append(',');
		_buf.append("tChipsSpent=");
		_buf.appendUint(tChipsSpent);
		_buf.append(',');
		_buf.append("wMoneySpent=");
		_buf.appendUint(wMoneySpent);
		_buf.append(',');
		_buf.append("isAamsTicket=");
		_buf.appendUint(isAamsTicket);
		_buf.append(',');
		_buf.append("aamsTicket=");
		_buf.append(aamsTicket);
		_buf.append(',');
		_buf.append("playChipsSpent64=");
		_buf.appendInt64(playChipsSpent64);
		_buf.append(',');
		_buf.append("rebuysDone=");
		_buf.appendUint(rebuysDone);
		_buf.append(',');
		_buf.append("addonsDone=");
		_buf.appendUint(addonsDone);
		_buf.append(',');
		_buf.append("rebuysRemaining=");
		_buf.appendInt(rebuysRemaining);
		_buf.append(',');
		_buf.append("tournSpendLimit=");
		tournSpendLimit.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
		_msg.composeMsgBody(errMsgBody);
	}
	else
	{
		_msg.composeUINT32(chipsRecieved);
		_msg.composeUINT32(realMoneySpent);
		_msg.composeUINT32(playMoneySpent);
		_msg.composeUINT32(fppSpent);
		_msg.composeUINT32(tChipsSpent);
		_msg.composeUINT32(wMoneySpent);
		_msg.composeUINT32(isAamsTicket);
		_msg.composeString(aamsTicket);
		_msg.composeINT64(playChipsSpent64);
		_msg.composeUINT16(rebuysDone);
		_msg.composeUINT16(addonsDone);
		_msg.composeINT16(rebuysRemaining);
		tournSpendLimit.composeMsg(_msg);
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
		_parser.parseMsgBody(errMsgBody);
	}
	else
	{
		_parser.parseUINT32(chipsRecieved);
		_parser.parseUINT32(realMoneySpent);
		_parser.parseUINT32(playMoneySpent);
		_parser.parseUINT32(fppSpent);
		_parser.parseUINT32(tChipsSpent);
		_parser.parseUINT32(wMoneySpent);
		_parser.parseUINT32(isAamsTicket);
		_parser.parseStringP(aamsTicket);
		_parser.parseINT64(playChipsSpent64);
		_parser.parseUINT16(rebuysDone);
		_parser.parseUINT16(addonsDone);
		_parser.parseINT16(rebuysRemaining);
		if(_parser.parseEnded()) return;
		tournSpendLimit.parseMsg(_parser);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_REBUY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_REBUY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errCode = 0;
	_parser.parseBYTE(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		size_t szErrMsgBody; _parser.skipMsgBody(szErrMsgBody);  /*errMsgBody*/
		AtfValidator::validateInt(_descr, "errMsgBody", szErrMsgBody, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 chipsRecieved; _parser.parseUINT32(chipsRecieved);
		AtfValidator::validateInt(_descr, "chipsRecieved", chipsRecieved, _checker, __FILE__, __LINE__);
		UINT32 realMoneySpent; _parser.parseUINT32(realMoneySpent);
		AtfValidator::validateInt(_descr, "realMoneySpent", realMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 playMoneySpent; _parser.parseUINT32(playMoneySpent);
		AtfValidator::validateInt(_descr, "playMoneySpent", playMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 fppSpent; _parser.parseUINT32(fppSpent);
		AtfValidator::validateInt(_descr, "fppSpent", fppSpent, _checker, __FILE__, __LINE__);
		UINT32 tChipsSpent; _parser.parseUINT32(tChipsSpent);
		AtfValidator::validateInt(_descr, "tChipsSpent", tChipsSpent, _checker, __FILE__, __LINE__);
		UINT32 wMoneySpent; _parser.parseUINT32(wMoneySpent);
		AtfValidator::validateInt(_descr, "wMoneySpent", wMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 isAamsTicket; _parser.parseUINT32(isAamsTicket);
		AtfValidator::validateInt(_descr, "isAamsTicket", isAamsTicket, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "aamsTicket"); size_t szAamsTicket = strlen(_dummy);
		AtfValidator::validateInt(_descr, "aamsTicket", szAamsTicket, _checker, __FILE__, __LINE__);
		INT64 playChipsSpent64; _parser.parseINT64(playChipsSpent64);
		AtfValidator::validateInt(_descr, "playChipsSpent64", playChipsSpent64, _checker, __FILE__, __LINE__);
		UINT16 rebuysDone; _parser.parseUINT16(rebuysDone);
		AtfValidator::validateInt(_descr, "rebuysDone", rebuysDone, _checker, __FILE__, __LINE__);
		UINT16 addonsDone; _parser.parseUINT16(addonsDone);
		AtfValidator::validateInt(_descr, "addonsDone", addonsDone, _checker, __FILE__, __LINE__);
		INT16 rebuysRemaining; _parser.parseINT16(rebuysRemaining);
		AtfValidator::validateInt(_descr, "rebuysRemaining", rebuysRemaining, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		PString _descbuf;
		TournSpendLimit::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSpendLimit"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_ADDON
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::Protocol_MTL_USER_ADDON()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::clear()
{
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::equals(const Protocol_MTL_USER_ADDON& _o) const
{
	return true;
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_ADDON).append(")");
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::composeMsg(CommMsgBody& _msg) const
{
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_ADDON";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_ADDON_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::Protocol_MTL_USER_ADDON_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::Protocol_MTL_USER_ADDON_REPLY(Protocol_MTL_USER_ADDON_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, errMsgBody(std::move(_o.errMsgBody))
	, chipsRecieved(std::move(_o.chipsRecieved))
	, realMoneySpent(std::move(_o.realMoneySpent))
	, playMoneySpent(std::move(_o.playMoneySpent))
	, fppSpent(std::move(_o.fppSpent))
	, tChipsSpent(std::move(_o.tChipsSpent))
	, wMoneySpent(std::move(_o.wMoneySpent))
	, isAamsTicket(std::move(_o.isAamsTicket))
	, aamsTicket(std::move(_o.aamsTicket))
	, playChipsSpent64(std::move(_o.playChipsSpent64))
	, rebuysDone(std::move(_o.rebuysDone))
	, addonsDone(std::move(_o.addonsDone))
	, rebuysRemaining(std::move(_o.rebuysRemaining))
	, tournSpendLimit(std::move(_o.tournSpendLimit))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY& MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::operator=(Protocol_MTL_USER_ADDON_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		errMsgBody = std::move(_o.errMsgBody);
		chipsRecieved = std::move(_o.chipsRecieved);
		realMoneySpent = std::move(_o.realMoneySpent);
		playMoneySpent = std::move(_o.playMoneySpent);
		fppSpent = std::move(_o.fppSpent);
		tChipsSpent = std::move(_o.tChipsSpent);
		wMoneySpent = std::move(_o.wMoneySpent);
		isAamsTicket = std::move(_o.isAamsTicket);
		aamsTicket = std::move(_o.aamsTicket);
		playChipsSpent64 = std::move(_o.playChipsSpent64);
		rebuysDone = std::move(_o.rebuysDone);
		addonsDone = std::move(_o.addonsDone);
		rebuysRemaining = std::move(_o.rebuysRemaining);
		tournSpendLimit = std::move(_o.tournSpendLimit);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	errMsgBody.clear();
	chipsRecieved = 0;
	realMoneySpent = 0;
	playMoneySpent = 0;
	fppSpent = 0;
	tChipsSpent = 0;
	wMoneySpent = 0;
	isAamsTicket = 0;
	aamsTicket.clear();
	playChipsSpent64 = 0;
	rebuysDone = 0;
	addonsDone = 0;
	rebuysRemaining = 0;
	tournSpendLimit.clear();
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::equals(const Protocol_MTL_USER_ADDON_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		errMsgBody.equals(_o.errMsgBody) &&
		chipsRecieved == _o.chipsRecieved &&
		realMoneySpent == _o.realMoneySpent &&
		playMoneySpent == _o.playMoneySpent &&
		fppSpent == _o.fppSpent &&
		tChipsSpent == _o.tChipsSpent &&
		wMoneySpent == _o.wMoneySpent &&
		isAamsTicket == _o.isAamsTicket &&
		aamsTicket.equals(_o.aamsTicket) &&
		playChipsSpent64 == _o.playChipsSpent64 &&
		rebuysDone == _o.rebuysDone &&
		addonsDone == _o.addonsDone &&
		rebuysRemaining == _o.rebuysRemaining &&
		tournSpendLimit.equals(_o.tournSpendLimit);
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_ADDON_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("errMsgBody=");
		errMsgBody.toTraceString(_buf);
	}
	else
	{
		_buf.append(',');
		_buf.append("chipsRecieved=");
		_buf.appendUint(chipsRecieved);
		_buf.append(',');
		_buf.append("realMoneySpent=");
		_buf.appendUint(realMoneySpent);
		_buf.append(',');
		_buf.append("playMoneySpent=");
		_buf.appendUint(playMoneySpent);
		_buf.append(',');
		_buf.append("fppSpent=");
		_buf.appendUint(fppSpent);
		_buf.append(',');
		_buf.append("tChipsSpent=");
		_buf.appendUint(tChipsSpent);
		_buf.append(',');
		_buf.append("wMoneySpent=");
		_buf.appendUint(wMoneySpent);
		_buf.append(',');
		_buf.append("isAamsTicket=");
		_buf.appendUint(isAamsTicket);
		_buf.append(',');
		_buf.append("aamsTicket=");
		_buf.append(aamsTicket);
		_buf.append(',');
		_buf.append("playChipsSpent64=");
		_buf.appendInt64(playChipsSpent64);
		_buf.append(',');
		_buf.append("rebuysDone=");
		_buf.appendUint(rebuysDone);
		_buf.append(',');
		_buf.append("addonsDone=");
		_buf.appendUint(addonsDone);
		_buf.append(',');
		_buf.append("rebuysRemaining=");
		_buf.appendInt(rebuysRemaining);
		_buf.append(',');
		_buf.append("tournSpendLimit=");
		tournSpendLimit.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
		_msg.composeMsgBody(errMsgBody);
	}
	else
	{
		_msg.composeUINT32(chipsRecieved);
		_msg.composeUINT32(realMoneySpent);
		_msg.composeUINT32(playMoneySpent);
		_msg.composeUINT32(fppSpent);
		_msg.composeUINT32(tChipsSpent);
		_msg.composeUINT32(wMoneySpent);
		_msg.composeUINT32(isAamsTicket);
		_msg.composeString(aamsTicket);
		_msg.composeINT64(playChipsSpent64);
		_msg.composeUINT16(rebuysDone);
		_msg.composeUINT16(addonsDone);
		_msg.composeINT16(rebuysRemaining);
		tournSpendLimit.composeMsg(_msg);
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
		_parser.parseMsgBody(errMsgBody);
	}
	else
	{
		_parser.parseUINT32(chipsRecieved);
		_parser.parseUINT32(realMoneySpent);
		_parser.parseUINT32(playMoneySpent);
		_parser.parseUINT32(fppSpent);
		_parser.parseUINT32(tChipsSpent);
		_parser.parseUINT32(wMoneySpent);
		_parser.parseUINT32(isAamsTicket);
		_parser.parseStringP(aamsTicket);
		_parser.parseINT64(playChipsSpent64);
		_parser.parseUINT16(rebuysDone);
		_parser.parseUINT16(addonsDone);
		_parser.parseINT16(rebuysRemaining);
		if(_parser.parseEnded()) return;
		tournSpendLimit.parseMsg(_parser);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_ADDON_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_ADDON_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errCode = 0;
	_parser.parseBYTE(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		size_t szErrMsgBody; _parser.skipMsgBody(szErrMsgBody);  /*errMsgBody*/
		AtfValidator::validateInt(_descr, "errMsgBody", szErrMsgBody, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 chipsRecieved; _parser.parseUINT32(chipsRecieved);
		AtfValidator::validateInt(_descr, "chipsRecieved", chipsRecieved, _checker, __FILE__, __LINE__);
		UINT32 realMoneySpent; _parser.parseUINT32(realMoneySpent);
		AtfValidator::validateInt(_descr, "realMoneySpent", realMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 playMoneySpent; _parser.parseUINT32(playMoneySpent);
		AtfValidator::validateInt(_descr, "playMoneySpent", playMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 fppSpent; _parser.parseUINT32(fppSpent);
		AtfValidator::validateInt(_descr, "fppSpent", fppSpent, _checker, __FILE__, __LINE__);
		UINT32 tChipsSpent; _parser.parseUINT32(tChipsSpent);
		AtfValidator::validateInt(_descr, "tChipsSpent", tChipsSpent, _checker, __FILE__, __LINE__);
		UINT32 wMoneySpent; _parser.parseUINT32(wMoneySpent);
		AtfValidator::validateInt(_descr, "wMoneySpent", wMoneySpent, _checker, __FILE__, __LINE__);
		UINT32 isAamsTicket; _parser.parseUINT32(isAamsTicket);
		AtfValidator::validateInt(_descr, "isAamsTicket", isAamsTicket, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "aamsTicket"); size_t szAamsTicket = strlen(_dummy);
		AtfValidator::validateInt(_descr, "aamsTicket", szAamsTicket, _checker, __FILE__, __LINE__);
		INT64 playChipsSpent64; _parser.parseINT64(playChipsSpent64);
		AtfValidator::validateInt(_descr, "playChipsSpent64", playChipsSpent64, _checker, __FILE__, __LINE__);
		UINT16 rebuysDone; _parser.parseUINT16(rebuysDone);
		AtfValidator::validateInt(_descr, "rebuysDone", rebuysDone, _checker, __FILE__, __LINE__);
		UINT16 addonsDone; _parser.parseUINT16(addonsDone);
		AtfValidator::validateInt(_descr, "addonsDone", addonsDone, _checker, __FILE__, __LINE__);
		INT16 rebuysRemaining; _parser.parseINT16(rebuysRemaining);
		AtfValidator::validateInt(_descr, "rebuysRemaining", rebuysRemaining, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		PString _descbuf;
		TournSpendLimit::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSpendLimit"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_DECLINE_REBUY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::Protocol_MTL_USER_DECLINE_REBUY()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::clear()
{
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::equals(const Protocol_MTL_USER_DECLINE_REBUY& _o) const
{
	return true;
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_DECLINE_REBUY).append(")");
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::composeMsg(CommMsgBody& _msg) const
{
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_DECLINE_REBUY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_DECLINE_REBUY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_SET_IMREADY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::Protocol_MTL_SET_IMREADY()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::clear()
{
}

bool MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::equals(const Protocol_MTL_SET_IMREADY& _o) const
{
	return true;
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_SET_IMREADY).append(")");
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::composeMsg(CommMsgBody& _msg) const
{
}

void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_SET_IMREADY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_SET_IMREADY_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::Protocol_MTL_SET_IMREADY_REPLY()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::clear()
{
	errCode = 0;
	userReady = false;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::equals(const Protocol_MTL_SET_IMREADY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		userReady == _o.userReady;
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_SET_IMREADY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("userReady=");
	_buf.appendUint(userReady);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeBOOL(userReady);
}

void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseBOOL(userReady);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_SET_IMREADY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_SET_IMREADY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	bool userReady; _parser.parseBOOL(userReady);
	AtfValidator::validateInt(_descr, "userReady", userReady, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_GET_IMREADY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::Protocol_MTL_GET_IMREADY()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::clear()
{
}

bool MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::equals(const Protocol_MTL_GET_IMREADY& _o) const
{
	return true;
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_GET_IMREADY).append(")");
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::composeMsg(CommMsgBody& _msg) const
{
}

void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_GET_IMREADY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_GET_IMREADY_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::Protocol_MTL_GET_IMREADY_REPLY()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::clear()
{
	errCode = 0;
	userReady = false;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::equals(const Protocol_MTL_GET_IMREADY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		userReady == _o.userReady;
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_GET_IMREADY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("userReady=");
	_buf.appendUint(userReady);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeBOOL(userReady);
}

void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseBOOL(userReady);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_GET_IMREADY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_GET_IMREADY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	bool userReady; _parser.parseBOOL(userReady);
	AtfValidator::validateInt(_descr, "userReady", userReady, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::clear()
{
	stacksReloaded = 0;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::equals(const Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY& _o) const
{
	return stacksReloaded == _o.stacksReloaded;
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_AUTO_RELOAD_STACKS_NOTIFY).append(")");
	_buf.append(',');
	_buf.append("stacksReloaded=");
	_buf.appendUint(stacksReloaded);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(stacksReloaded);
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(stacksReloaded);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_AUTO_RELOAD_STACKS_NOTIFY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 stacksReloaded; _parser.parseUINT32(stacksReloaded);
	AtfValidator::validateInt(_descr, "stacksReloaded", stacksReloaded, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_RELOAD_STACKS
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::Protocol_MTL_USER_RELOAD_STACKS()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::clear()
{
	reqStacks = 0;
	isSyncReload = false;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::equals(const Protocol_MTL_USER_RELOAD_STACKS& _o) const
{
	return reqStacks == _o.reqStacks &&
		isSyncReload == _o.isSyncReload;
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_RELOAD_STACKS).append(")");
	_buf.append(',');
	_buf.append("reqStacks=");
	_buf.appendInt(reqStacks);
	_buf.append(',');
	_buf.append("isSyncReload=");
	_buf.appendUint(isSyncReload);
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(reqStacks);
	_msg.composeBOOL(isSyncReload);
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(reqStacks);
	_parser.parseBOOL(isSyncReload);
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_RELOAD_STACKS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 reqStacks; _parser.parseINT32(reqStacks);
	AtfValidator::validateIntRange(_descr, "reqStacks", reqStacks, 0, 100, _checker, __FILE__, __LINE__);
	bool isSyncReload; _parser.parseBOOL(isSyncReload);
	AtfValidator::validateInt(_descr, "isSyncReload", isSyncReload, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_RELOAD_STACKS_REPLY
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::Protocol_MTL_USER_RELOAD_STACKS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::Protocol_MTL_USER_RELOAD_STACKS_REPLY(Protocol_MTL_USER_RELOAD_STACKS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, errMsgBody(std::move(_o.errMsgBody))
	, unusedStacks(std::move(_o.unusedStacks))
{
}

MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY& MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::operator=(Protocol_MTL_USER_RELOAD_STACKS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		errMsgBody = std::move(_o.errMsgBody);
		unusedStacks = std::move(_o.unusedStacks);
	}
	return *this;
}

#endif

void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	errMsgBody.clear();
	unusedStacks = 0;
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::equals(const Protocol_MTL_USER_RELOAD_STACKS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		errMsgBody.equals(_o.errMsgBody) &&
		unusedStacks == _o.unusedStacks;
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_RELOAD_STACKS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("errMsgBody=");
		errMsgBody.toTraceString(_buf);
	}
	else
	{
		_buf.append(',');
		_buf.append("unusedStacks=");
		_buf.appendUint(unusedStacks);
	}
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
		_msg.composeMsgBody(errMsgBody);
	}
	else
	{
		_msg.composeUINT32(unusedStacks);
	}
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
		_parser.parseMsgBody(errMsgBody);
	}
	else
	{
		_parser.parseUINT32(unusedStacks);
	}
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_RELOAD_STACKS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errCode = 0;
	_parser.parseBYTE(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		size_t szErrMsgBody; _parser.skipMsgBody(szErrMsgBody);  /*errMsgBody*/
		AtfValidator::validateInt(_descr, "errMsgBody", szErrMsgBody, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 unusedStacks; _parser.parseUINT32(unusedStacks);
		AtfValidator::validateInt(_descr, "unusedStacks", unusedStacks, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED
//=================================================================

MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED()
{
	clear();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::clear()
{
}

bool MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::equals(const Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED& _o) const
{
	return true;
}

const char *MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED).append(")");
	return _buf.c_str();
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::composeMsg(CommMsgBody& _msg) const
{
}

void MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void MTLobbyCli::perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool MTLobbyCli::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_TOURN_REG_INFO: cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TOURN_REG_INFO_REPLY: cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MTL_CHANGE_FLIGHT: cli::Protocol_MSG_MTL_CHANGE_FLIGHT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MTL_CHANGE_FLIGHT_REPLY: cli::Protocol_MSG_MTL_CHANGE_FLIGHT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MTL_GET_SAME_LEVEL_FLIGHTS: cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY: cli::Protocol_MSG_MTL_GET_SAME_LEVEL_FLIGHTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_GET_CHIP_GRAPH_DATA: cli::Protocol_MTL_GET_CHIP_GRAPH_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_GET_CHIP_GRAPH_DATA_REPLY: cli::Protocol_MTL_GET_CHIP_GRAPH_DATA_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_REGISTER_USER: cli::Protocol_MTL_LOBBY_REGISTER_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_REGISTER_USER_REPLY: cli::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS: cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY: cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_UNREGISTER_USER: cli::Protocol_MTL_LOBBY_UNREGISTER_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_UNREGISTER_USER_REPLY: cli::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER: cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER_REPLY: cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "perm_cli"))
	{
		switch(_msgId)
		{
			case MTL_CLI_GOTO_FINISH: perm_cli::Protocol_MTL_CLI_GOTO_FINISH::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_CLI_GOTO_TABLE: perm_cli::Protocol_MTL_CLI_GOTO_TABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_GET_IMREADY: perm_cli::Protocol_MTL_GET_IMREADY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_GET_IMREADY_REPLY: perm_cli::Protocol_MTL_GET_IMREADY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS: perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY: perm_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER: perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER_REPLY: perm_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_SET_IMREADY: perm_cli::Protocol_MTL_SET_IMREADY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_SET_IMREADY_REPLY: perm_cli::Protocol_MTL_SET_IMREADY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_ADDON: perm_cli::Protocol_MTL_USER_ADDON::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_ADDON_REPLY: perm_cli::Protocol_MTL_USER_ADDON_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_AUTO_RELOAD_STACKS_NOTIFY: perm_cli::Protocol_MTL_USER_AUTO_RELOAD_STACKS_NOTIFY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_DECLINE_REBUY: perm_cli::Protocol_MTL_USER_DECLINE_REBUY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED: perm_cli::Protocol_MTL_USER_LIMBO_CLIENT_ACTIONTIMER_STARTED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_REBUY: perm_cli::Protocol_MTL_USER_REBUY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_REBUY_REPLY: perm_cli::Protocol_MTL_USER_REBUY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_RELOAD_STACKS: perm_cli::Protocol_MTL_USER_RELOAD_STACKS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_RELOAD_STACKS_REPLY: perm_cli::Protocol_MTL_USER_RELOAD_STACKS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_SITIN: perm_cli::Protocol_MTL_USER_SITIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_SITIN_REPLY: perm_cli::Protocol_MTL_USER_SITIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_SITOUT: perm_cli::Protocol_MTL_USER_SITOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_USER_SITOUT_REPLY: perm_cli::Protocol_MTL_USER_SITOUT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "unauth_cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_OLYMPIC_SNAPSHOT: unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY: unauth_cli::Protocol_MSG_LOBBY_OLYMPIC_SNAPSHOT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS: unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY: unauth_cli::Protocol_MTL_LOBBY_TOURNAMENT_USER_STATS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER: unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_WHERE_IS_PLAYER_REPLY: unauth_cli::Protocol_MTL_LOBBY_WHERE_IS_PLAYER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_TOURN_TEXT_INFO: unauth_cli::Protocol_MTL_TOURN_TEXT_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_TOURN_TEXT_INFO_REPLY: unauth_cli::Protocol_MTL_TOURN_TEXT_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

