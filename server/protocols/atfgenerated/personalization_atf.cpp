/**
 * personalization_atf.cpp
 *
 * This file was auto-generated from personalization_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor personalization_atf.txt
 */
 
#include "personalization_atf.h"

//=================================================================
//                    TournTicketInfo
//=================================================================

PersonalizationATF::cli::TournTicketInfo::TournTicketInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::TournTicketInfo::TournTicketInfo(TournTicketInfo&& _o)
	: ticketId(std::move(_o.ticketId))
	, ticketName(std::move(_o.ticketName))
	, multiTourn(std::move(_o.multiTourn))
	, price(std::move(_o.price))
	, currency(std::move(_o.currency))
	, issued(std::move(_o.issued))
	, expireAt(std::move(_o.expireAt))
	, tournNumber(std::move(_o.tournNumber))
{
}

PersonalizationATF::cli::TournTicketInfo& PersonalizationATF::cli::TournTicketInfo::operator=(TournTicketInfo&& _o)
{
	if(this != &_o)
	{
		ticketId = std::move(_o.ticketId);
		ticketName = std::move(_o.ticketName);
		multiTourn = std::move(_o.multiTourn);
		price = std::move(_o.price);
		currency = std::move(_o.currency);
		issued = std::move(_o.issued);
		expireAt = std::move(_o.expireAt);
		tournNumber = std::move(_o.tournNumber);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::TournTicketInfo::clear()
{
	ticketId = 0;
	ticketName.clear();
	multiTourn = false;
	price = 0;
	currency.clear();
	issued.setNull();
	expireAt.setNull();
	tournNumber = 0;
}

bool PersonalizationATF::cli::TournTicketInfo::equals(const TournTicketInfo& _o) const
{
	return ticketId == _o.ticketId &&
		Atf::atfPStringEquals(ticketName, _o.ticketName) &&
		multiTourn == _o.multiTourn &&
		price == _o.price &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		issued.equals(_o.issued) &&
		expireAt.equals(_o.expireAt) &&
		tournNumber == _o.tournNumber;
}

const char *PersonalizationATF::cli::TournTicketInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketId=");
	_buf.appendUint(ticketId);
	_buf.append(',');
	_buf.append("ticketName=");
	_buf.append(ticketName);
	_buf.append(',');
	_buf.append("multiTourn=");
	_buf.appendUint(multiTourn);
	_buf.append(',');
	_buf.append("price=");
	_buf.appendUint(price);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("issued=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, issued);
	_buf.append(',');
	_buf.append("expireAt=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, expireAt);
	_buf.append(',');
	_buf.append("tournNumber=");
	_buf.appendInt(tournNumber);
	_buf.append('}');
	return _buf.c_str();
}

const char *PersonalizationATF::cli::TournTicketInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("ticketId", ticketId, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketName", ticketName, _buf);
	Atf::XmlElement::encodeAsXmlElement("multiTourn", multiTourn, _buf);
	Atf::XmlElement::encodeAsXmlElement("price", price, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "issued", issued);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "expireAt", expireAt);
	Atf::XmlElement::encodeAsXmlElement("tournNumber", tournNumber, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool PersonalizationATF::cli::TournTicketInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("ticketId"))
		{
			ticketId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ticketName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, ticketName)) return false;
		}
		else if (_element.equals("multiTourn"))
		{
			multiTourn = (*_value.ptr() == '1');
		}
		else if (_element.equals("price"))
		{
			price = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("issued"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, issued);
		}
		else if (_element.equals("expireAt"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, expireAt);
		}
		else if (_element.equals("tournNumber"))
		{
			tournNumber = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void PersonalizationATF::cli::TournTicketInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournTicketInfo())) // not empty
	{
		_body.composeUINT32(ticketId);
		_body.composeString(ticketName);
		_body.composeBOOL(multiTourn);
		_body.composeUINT32(price);
		_body.composeString(currency);
		_body.composeSrvTime(issued);
		_body.composeSrvTime(expireAt);
		_body.composeINT32(tournNumber);
	}

	_msg.composeMsgBody(_body);
}

void PersonalizationATF::cli::TournTicketInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(ticketId);
	_parser0.parseStringP(ticketName);
	_parser0.parseBOOL(multiTourn);
	_parser0.parseUINT32(price);
	_parser0.parseStringP(currency);
	_parser0.parseSrvTime(issued);
	_parser0.parseSrvTime(expireAt);
	_parser0.parseINT32(tournNumber);
}

const char *PersonalizationATF::cli::TournTicketInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketId", ticketId);
	_jsonstr.compose("ticketName", ticketName);
	_jsonstr.compose("multiTourn", multiTourn);
	_jsonstr.compose("price", price);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("issued", issued);
	_jsonstr.compose("expireAt", expireAt);
	_jsonstr.compose("tournNumber", tournNumber);
	return _buf.c_str();
}

void PersonalizationATF::cli::TournTicketInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketId", ticketId);
	_jparser.parseByNameThrow("ticketName", ticketName);
	_jparser.parseByNameThrow("multiTourn", multiTourn);
	_jparser.parseByNameThrow("price", price);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("issued", issued);
	_jparser.parseByNameThrow("expireAt", expireAt);
	_jparser.parseByNameThrow("tournNumber", tournNumber);
}

/* static */ void PersonalizationATF::cli::TournTicketInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 ticketId; _jparser.validateByNameThrow("ticketId", ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	PString ticketName; _jparser.validateByNameThrow("ticketName", ticketName);
	AtfValidator::validateInt(_descr, "ticketName", ticketName.length(), _checker, __FILE__, __LINE__);
	bool multiTourn; _jparser.validateByNameThrow("multiTourn", multiTourn);
	AtfValidator::validateInt(_descr, "multiTourn", multiTourn, _checker, __FILE__, __LINE__);
	UINT32 price; _jparser.validateByNameThrow("price", price);
	AtfValidator::validateInt(_descr, "price", price, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	SrvTime issued; _jparser.validateByNameThrow("issued", issued);
	AtfValidator::validateSrvDateTime(_descr, "issued", issued, _checker, __FILE__, __LINE__);
	SrvTime expireAt; _jparser.validateByNameThrow("expireAt", expireAt);
	AtfValidator::validateSrvDateTime(_descr, "expireAt", expireAt, _checker, __FILE__, __LINE__);
	INT32 tournNumber; _jparser.validateByNameThrow("tournNumber", tournNumber);
	AtfValidator::validateInt(_descr, "tournNumber", tournNumber, _checker, __FILE__, __LINE__);
}

/*static*/ void PersonalizationATF::cli::TournTicketInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 ticketId; _parser0.parseUINT32(ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "ticketName"); size_t szTicketName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketName", szTicketName, _checker, __FILE__, __LINE__);
	bool multiTourn; _parser0.parseBOOL(multiTourn);
	AtfValidator::validateInt(_descr, "multiTourn", multiTourn, _checker, __FILE__, __LINE__);
	UINT32 price; _parser0.parseUINT32(price);
	AtfValidator::validateInt(_descr, "price", price, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	SrvTime issued; _parser0.parseSrvTime(issued);
	AtfValidator::validateSrvDateTime(_descr, "issued", issued, _checker, __FILE__, __LINE__);
	SrvTime expireAt; _parser0.parseSrvTime(expireAt);
	AtfValidator::validateSrvDateTime(_descr, "expireAt", expireAt, _checker, __FILE__, __LINE__);
	INT32 tournNumber; _parser0.parseINT32(tournNumber);
	AtfValidator::validateInt(_descr, "tournNumber", tournNumber, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournCountFilter
//=================================================================

PersonalizationATF::cli::TournCountFilter::TournCountFilter()
{
	clear();
}

void PersonalizationATF::cli::TournCountFilter::clear()
{
	gameMask = (2*(UINT64)NGGameTypes::NGGame_Last-1);
}

bool PersonalizationATF::cli::TournCountFilter::equals(const TournCountFilter& _o) const
{
	return gameMask == _o.gameMask;
}

const char *PersonalizationATF::cli::TournCountFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append('}');
	return _buf.c_str();
}

const char *PersonalizationATF::cli::TournCountFilter::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameMask", gameMask, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool PersonalizationATF::cli::TournCountFilter::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameMask"))
		{
			gameMask = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void PersonalizationATF::cli::TournCountFilter::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournCountFilter())) // not empty
	{
		_body.composeUINT64(gameMask);
	}

	_msg.composeMsgBody(_body);
}

void PersonalizationATF::cli::TournCountFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(gameMask);
}

const char *PersonalizationATF::cli::TournCountFilter::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameMask", gameMask);
	return _buf.c_str();
}

void PersonalizationATF::cli::TournCountFilter::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameMask", gameMask);
}

/* static */ void PersonalizationATF::cli::TournCountFilter::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 gameMask; _jparser.validateByNameThrow("gameMask", gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
}

/*static*/ void PersonalizationATF::cli::TournCountFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_PS_Q_GET_RECENT_GAME_LIST
//=================================================================

PersonalizationATF::cli::Protocol_PS_Q_GET_RECENT_GAME_LIST::Protocol_PS_Q_GET_RECENT_GAME_LIST()
{
	clear();
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_RECENT_GAME_LIST::clear()
{
	gameTypes = 0;
	isPM = false;
}

bool PersonalizationATF::cli::Protocol_PS_Q_GET_RECENT_GAME_LIST::equals(const Protocol_PS_Q_GET_RECENT_GAME_LIST& _o) const
{
	return gameTypes == _o.gameTypes &&
		isPM == _o.isPM;
}

bool PersonalizationATF::cli::Protocol_PS_Q_GET_RECENT_GAME_LIST::equals(Atf::MessageProtocol* _other) const
{
	if (PS_Q_GET_RECENT_GAME_LIST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_Q_GET_RECENT_GAME_LIST*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_RECENT_GAME_LIST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_Q_GET_RECENT_GAME_LIST).append(")");
	_buf.append(',');
	_buf.append("gameTypes=");
	_buf.appendUint(gameTypes);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_RECENT_GAME_LIST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_RECENT_GAME_LIST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_Q_GET_RECENT_GAME_LIST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("gameTypes", gameTypes, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPM", isPM, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_Q_GET_RECENT_GAME_LIST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("gameTypes"))
			{
				gameTypes = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPM"))
			{
				isPM = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_RECENT_GAME_LIST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(gameTypes);
	_msg.composeBOOL(isPM);
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_RECENT_GAME_LIST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(gameTypes);
	_parser.parseBOOL(isPM);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_RECENT_GAME_LIST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameTypes", gameTypes);
	_jsonstr.compose("isPM", isPM);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_RECENT_GAME_LIST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameTypes", gameTypes);
	_jparser.parseByNameThrow("isPM", isPM);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_GET_RECENT_GAME_LIST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_GET_RECENT_GAME_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 gameTypes; _jparser.validateByNameThrow("gameTypes", gameTypes);
	AtfValidator::validateIntMax(_descr, "gameTypes", gameTypes, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	bool isPM; _jparser.validateByNameThrow("isPM", isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_GET_RECENT_GAME_LIST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_GET_RECENT_GAME_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 gameTypes; _parser.parseUINT32(gameTypes);
	AtfValidator::validateIntMax(_descr, "gameTypes", gameTypes, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	bool isPM; _parser.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_A_GET_RECENT_GAME_LIST
//=================================================================

PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST::Protocol_PS_A_GET_RECENT_GAME_LIST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST::Protocol_PS_A_GET_RECENT_GAME_LIST(Protocol_PS_A_GET_RECENT_GAME_LIST&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
	, pppTypes(std::move(_o.pppTypes))
{
}

PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST& PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST::operator=(Protocol_PS_A_GET_RECENT_GAME_LIST&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
		pppTypes = std::move(_o.pppTypes);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
	pppTypes.clear();
}

bool PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST::equals(const Protocol_PS_A_GET_RECENT_GAME_LIST& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder) &&
		pppTypes.equals(_o.pppTypes);
}

bool PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST::equals(Atf::MessageProtocol* _other) const
{
	if (PS_A_GET_RECENT_GAME_LIST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_A_GET_RECENT_GAME_LIST*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_A_GET_RECENT_GAME_LIST).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pppTypes=");
	pppTypes.toTraceString(_buf);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_A_GET_RECENT_GAME_LIST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tourns.toXmlString("tourns", _buf);
	tableTypes.toXmlString("tableTypes", _buf);
	sngTypes.toXmlString("sngTypes", _buf);
	sagTypes.toXmlString("sagTypes", _buf);
	zoomTypes.toXmlString("zoomTypes", _buf);
	seatFinders.toXmlString("seatFinders", _buf);
	gameOrder.toXmlString("gameOrder", _buf);
	pppTypes.toXmlString("pppTypes", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("tableTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::TableDataStruct, 4 > >::FromXmlString(_value, tableTypes)) return false;
			}
			else if (_element.equals("sngTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::SngDataStruct, 4 > >::FromXmlString(_value, sngTypes)) return false;
			}
			else if (_element.equals("sagTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::SagDataStruct, 4 > >::FromXmlString(_value, sagTypes)) return false;
			}
			else if (_element.equals("zoomTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::ZoomDataStruct, 4 > >::FromXmlString(_value, zoomTypes)) return false;
			}
			else if (_element.equals("seatFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::SeatFinderDataStruct, 4 > >::FromXmlString(_value, seatFinders)) return false;
			}
			else if (_element.equals("gameOrder"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, gameOrder)) return false;
			}
			else if (_element.equals("pppTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::PPPDataStruct, 4 > >::FromXmlString(_value, pppTypes)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tourns.composeMsg(_msg, _ignoreJSON);
	tableTypes.composeMsg(_msg, _ignoreJSON);
	sngTypes.composeMsg(_msg, _ignoreJSON);
	sagTypes.composeMsg(_msg, _ignoreJSON);
	zoomTypes.composeMsg(_msg, _ignoreJSON);
	seatFinders.composeMsg(_msg, _ignoreJSON);
	gameOrder.composeMsg(_msg, _ignoreJSON);
	pppTypes.composeMsg(_msg, _ignoreJSON);
}

void PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	pppTypes.parseMsg(_parser);
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tourns", tourns);
	_jsonstr.compose("tableTypes", tableTypes);
	_jsonstr.compose("sngTypes", sngTypes);
	_jsonstr.compose("sagTypes", sagTypes);
	_jsonstr.compose("zoomTypes", zoomTypes);
	_jsonstr.compose("seatFinders", seatFinders);
	_jsonstr.compose("gameOrder", gameOrder);
	_jsonstr.compose("pppTypes", pppTypes);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tourns", tourns);
	_jparser.parseByNameThrow("tableTypes", tableTypes);
	_jparser.parseByNameThrow("sngTypes", sngTypes);
	_jparser.parseByNameThrow("sagTypes", sagTypes);
	_jparser.parseByNameThrow("zoomTypes", zoomTypes);
	_jparser.parseByNameThrow("seatFinders", seatFinders);
	_jparser.parseByNameThrow("gameOrder", gameOrder);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("pppTypes", pppTypes);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_GET_RECENT_GAME_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< MLobbyNG::cli::TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::TableDataStruct > tableTypes; _jparser.validateByNameThrow("tableTypes", tableTypes);
	AtfValidator::validateInt(_descr, "tableTypes", tableTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::SngDataStruct > sngTypes; _jparser.validateByNameThrow("sngTypes", sngTypes);
	AtfValidator::validateInt(_descr, "sngTypes", sngTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::SagDataStruct > sagTypes; _jparser.validateByNameThrow("sagTypes", sagTypes);
	AtfValidator::validateInt(_descr, "sagTypes", sagTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::ZoomDataStruct > zoomTypes; _jparser.validateByNameThrow("zoomTypes", zoomTypes);
	AtfValidator::validateInt(_descr, "zoomTypes", zoomTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::SeatFinderDataStruct > seatFinders; _jparser.validateByNameThrow("seatFinders", seatFinders);
	AtfValidator::validateInt(_descr, "seatFinders", seatFinders.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > gameOrder; _jparser.validateByNameThrow("gameOrder", gameOrder);
	AtfValidator::validateInt(_descr, "gameOrder", gameOrder.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< MLobbyNG::cli::PPPDataStruct > pppTypes; _jparser.validateByNameThrow("pppTypes", pppTypes);
	AtfValidator::validateInt(_descr, "pppTypes", pppTypes.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_GET_RECENT_GAME_LIST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_GET_RECENT_GAME_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = Atf::LAtfVector< MLobbyNG::cli::TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = Atf::LAtfVector< MLobbyNG::cli::TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = Atf::LAtfVector< MLobbyNG::cli::SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = Atf::LAtfVector< MLobbyNG::cli::SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = Atf::LAtfVector< MLobbyNG::cli::ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = Atf::LAtfVector< MLobbyNG::cli::SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	int szPppTypes = Atf::LAtfVector< MLobbyNG::cli::PPPDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pppTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "pppTypes", szPppTypes, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST
//=================================================================

PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST(Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST&& _o)
	: gameTypes(std::move(_o.gameTypes))
	, userIntId(std::move(_o.userIntId))
	, filter(std::move(_o.filter))
{
}

PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST& PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::operator=(Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST&& _o)
{
	if(this != &_o)
	{
		gameTypes = std::move(_o.gameTypes);
		userIntId = std::move(_o.userIntId);
		filter = std::move(_o.filter);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::clear()
{
	gameTypes = 0;
	userIntId = 0;
	filter.clear();
}

bool PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::equals(const Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST& _o) const
{
	return gameTypes == _o.gameTypes &&
		userIntId == _o.userIntId &&
		filter.equals(_o.filter);
}

bool PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::equals(Atf::MessageProtocol* _other) const
{
	if (PS_Q_ADMIN_GET_RECENT_GAME_LIST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_Q_ADMIN_GET_RECENT_GAME_LIST).append(")");
	_buf.append(',');
	_buf.append("gameTypes=");
	_buf.appendUint(gameTypes);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_Q_ADMIN_GET_RECENT_GAME_LIST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("gameTypes", gameTypes, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	filter.toXmlString("filter", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("gameTypes"))
			{
				gameTypes = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< MLobbyNG::cli::GameListFilter >::FromXmlString(_value, filter)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(gameTypes);
	_msg.composeUINT32(userIntId);
	filter.composeMsg(_msg, _ignoreJSON);
}

void PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(gameTypes);
	_parser.parseUINT32(userIntId);
	filter.parseMsg(_parser);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameTypes", gameTypes);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("filter", filter);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameTypes", gameTypes);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("filter", filter);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_ADMIN_GET_RECENT_GAME_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 gameTypes; _jparser.validateByNameThrow("gameTypes", gameTypes);
	AtfValidator::validateInt(_descr, "gameTypes", gameTypes, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	MLobbyNG::cli::GameListFilter filter; _jparser.validateByNameThrow("filter", filter);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_ADMIN_GET_RECENT_GAME_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 gameTypes; _parser.parseUINT32(gameTypes);
	AtfValidator::validateInt(_descr, "gameTypes", gameTypes, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	MLobbyNG::cli::GameListFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST
//=================================================================

PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST(Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST&& _o)
	: errCode(std::move(_o.errCode))
	, errMsg(std::move(_o.errMsg))
	, tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
	, pppTypes(std::move(_o.pppTypes))
{
}

PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST& PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::operator=(Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errMsg = std::move(_o.errMsg);
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
		pppTypes = std::move(_o.pppTypes);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::clear()
{
	errCode = 0;
	errMsg.clear();
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
	pppTypes.clear();
}

bool PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::equals(const Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg) &&
		tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder) &&
		pppTypes.equals(_o.pppTypes);
}

bool PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::equals(Atf::MessageProtocol* _other) const
{
	if (PS_A_ADMIN_GET_RECENT_GAME_LIST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_A_ADMIN_GET_RECENT_GAME_LIST).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	else
	{
		_buf.append(',');
		_buf.append("tourns=");
		tourns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tableTypes=");
		tableTypes.toTraceString(_buf);
		_buf.append(',');
		_buf.append("sngTypes=");
		sngTypes.toTraceString(_buf);
		_buf.append(',');
		_buf.append("sagTypes=");
		sagTypes.toTraceString(_buf);
		_buf.append(',');
		_buf.append("zoomTypes=");
		zoomTypes.toTraceString(_buf);
		_buf.append(',');
		_buf.append("seatFinders=");
		seatFinders.toTraceString(_buf);
		_buf.append(',');
		_buf.append("gameOrder=");
		gameOrder.toTraceString(_buf);
		_buf.append(',');
		_buf.append("pppTypes=");
		pppTypes.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_A_ADMIN_GET_RECENT_GAME_LIST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	}
	else
	{
		tourns.toXmlString("tourns", _buf);
		tableTypes.toXmlString("tableTypes", _buf);
		sngTypes.toXmlString("sngTypes", _buf);
		sagTypes.toXmlString("sagTypes", _buf);
		zoomTypes.toXmlString("zoomTypes", _buf);
		seatFinders.toXmlString("seatFinders", _buf);
		gameOrder.toXmlString("gameOrder", _buf);
		pppTypes.toXmlString("pppTypes", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("tableTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::TableDataStruct, 4 > >::FromXmlString(_value, tableTypes)) return false;
			}
			else if (_element.equals("sngTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::SngDataStruct, 4 > >::FromXmlString(_value, sngTypes)) return false;
			}
			else if (_element.equals("sagTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::SagDataStruct, 4 > >::FromXmlString(_value, sagTypes)) return false;
			}
			else if (_element.equals("zoomTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::ZoomDataStruct, 4 > >::FromXmlString(_value, zoomTypes)) return false;
			}
			else if (_element.equals("seatFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::SeatFinderDataStruct, 4 > >::FromXmlString(_value, seatFinders)) return false;
			}
			else if (_element.equals("gameOrder"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, gameOrder)) return false;
			}
			else if (_element.equals("pppTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::PPPDataStruct, 4 > >::FromXmlString(_value, pppTypes)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errMsg);
	}
	else
	{
		tourns.composeMsg(_msg, _ignoreJSON);
		tableTypes.composeMsg(_msg, _ignoreJSON);
		sngTypes.composeMsg(_msg, _ignoreJSON);
		sagTypes.composeMsg(_msg, _ignoreJSON);
		zoomTypes.composeMsg(_msg, _ignoreJSON);
		seatFinders.composeMsg(_msg, _ignoreJSON);
		gameOrder.composeMsg(_msg, _ignoreJSON);
		pppTypes.composeMsg(_msg, _ignoreJSON);
	}
}

void PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errMsg);
	}
	else
	{
		tourns.parseMsg(_parser);
		tableTypes.parseMsg(_parser);
		sngTypes.parseMsg(_parser);
		sagTypes.parseMsg(_parser);
		zoomTypes.parseMsg(_parser);
		seatFinders.parseMsg(_parser);
		gameOrder.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		pppTypes.parseMsg(_parser);
	}
}

const char *PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errMsg", errMsg);
	}
	else
	{
		_jsonstr.compose("tourns", tourns);
		_jsonstr.compose("tableTypes", tableTypes);
		_jsonstr.compose("sngTypes", sngTypes);
		_jsonstr.compose("sagTypes", sagTypes);
		_jsonstr.compose("zoomTypes", zoomTypes);
		_jsonstr.compose("seatFinders", seatFinders);
		_jsonstr.compose("gameOrder", gameOrder);
		_jsonstr.compose("pppTypes", pppTypes);
	}
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errMsg", errMsg);
	}
	else
	{
		_jparser.parseByNameThrow("tourns", tourns);
		_jparser.parseByNameThrow("tableTypes", tableTypes);
		_jparser.parseByNameThrow("sngTypes", sngTypes);
		_jparser.parseByNameThrow("sagTypes", sagTypes);
		_jparser.parseByNameThrow("zoomTypes", zoomTypes);
		_jparser.parseByNameThrow("seatFinders", seatFinders);
		_jparser.parseByNameThrow("gameOrder", gameOrder);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("pppTypes", pppTypes);
	}
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_ADMIN_GET_RECENT_GAME_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
		AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< MLobbyNG::cli::TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
		AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< MLobbyNG::cli::TableDataStruct > tableTypes; _jparser.validateByNameThrow("tableTypes", tableTypes);
		AtfValidator::validateInt(_descr, "tableTypes", tableTypes.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< MLobbyNG::cli::SngDataStruct > sngTypes; _jparser.validateByNameThrow("sngTypes", sngTypes);
		AtfValidator::validateInt(_descr, "sngTypes", sngTypes.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< MLobbyNG::cli::SagDataStruct > sagTypes; _jparser.validateByNameThrow("sagTypes", sagTypes);
		AtfValidator::validateInt(_descr, "sagTypes", sagTypes.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< MLobbyNG::cli::ZoomDataStruct > zoomTypes; _jparser.validateByNameThrow("zoomTypes", zoomTypes);
		AtfValidator::validateInt(_descr, "zoomTypes", zoomTypes.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< MLobbyNG::cli::SeatFinderDataStruct > seatFinders; _jparser.validateByNameThrow("seatFinders", seatFinders);
		AtfValidator::validateInt(_descr, "seatFinders", seatFinders.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UINT32 > gameOrder; _jparser.validateByNameThrow("gameOrder", gameOrder);
		AtfValidator::validateInt(_descr, "gameOrder", gameOrder.size(), _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		Atf::AtfVectorBase< MLobbyNG::cli::PPPDataStruct > pppTypes; _jparser.validateByNameThrow("pppTypes", pppTypes);
		AtfValidator::validateInt(_descr, "pppTypes", pppTypes.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_ADMIN_GET_RECENT_GAME_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTourns = Atf::LAtfVector< MLobbyNG::cli::TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
		int szTableTypes = Atf::LAtfVector< MLobbyNG::cli::TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
		int szSngTypes = Atf::LAtfVector< MLobbyNG::cli::SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
		int szSagTypes = Atf::LAtfVector< MLobbyNG::cli::SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
		int szZoomTypes = Atf::LAtfVector< MLobbyNG::cli::ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
		int szSeatFinders = Atf::LAtfVector< MLobbyNG::cli::SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
		int szGameOrder = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		int szPppTypes = Atf::LAtfVector< MLobbyNG::cli::PPPDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pppTypes"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "pppTypes", szPppTypes, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_U_GET_CURRENTLY_SEATED_AT
//=================================================================

PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::Protocol_PS_U_GET_CURRENTLY_SEATED_AT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::Protocol_PS_U_GET_CURRENTLY_SEATED_AT(Protocol_PS_U_GET_CURRENTLY_SEATED_AT&& _o)
	: joined(std::move(_o.joined))
	, tourns(std::move(_o.tourns))
	, tables(std::move(_o.tables))
	, zoomTypes(std::move(_o.zoomTypes))
{
}

PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT& PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::operator=(Protocol_PS_U_GET_CURRENTLY_SEATED_AT&& _o)
{
	if(this != &_o)
	{
		joined = std::move(_o.joined);
		tourns = std::move(_o.tourns);
		tables = std::move(_o.tables);
		zoomTypes = std::move(_o.zoomTypes);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::clear()
{
	joined = false;
	tourns.clear();
	tables.clear();
	zoomTypes.clear();
}

bool PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::equals(const Protocol_PS_U_GET_CURRENTLY_SEATED_AT& _o) const
{
	return joined == _o.joined &&
		tourns.equals(_o.tourns) &&
		tables.equals(_o.tables) &&
		zoomTypes.equals(_o.zoomTypes);
}

bool PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::equals(Atf::MessageProtocol* _other) const
{
	if (PS_U_GET_CURRENTLY_SEATED_AT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_U_GET_CURRENTLY_SEATED_AT*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_U_GET_CURRENTLY_SEATED_AT).append(")");
	_buf.append(',');
	_buf.append("joined=");
	_buf.appendUint(joined);
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tables=");
	tables.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_U_GET_CURRENTLY_SEATED_AT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("joined", joined, _buf);
	tourns.toXmlString("tourns", _buf);
	tables.toXmlString("tables", _buf);
	zoomTypes.toXmlString("zoomTypes", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("joined"))
			{
				joined = (*_value.ptr() == '1');
			}
			else if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("tables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::TableData, 4 > >::FromXmlString(_value, tables)) return false;
			}
			else if (_element.equals("zoomTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::ZoomDataStruct, 4 > >::FromXmlString(_value, zoomTypes)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(joined);
	tourns.composeMsg(_msg, _ignoreJSON);
	tables.composeMsg(_msg, _ignoreJSON);
	zoomTypes.composeMsg(_msg, _ignoreJSON);
}

void PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(joined);
	tourns.parseMsg(_parser);
	tables.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
}

const char *PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("joined", joined);
	_jsonstr.compose("tourns", tourns);
	_jsonstr.compose("tables", tables);
	_jsonstr.compose("zoomTypes", zoomTypes);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("joined", joined);
	_jparser.parseByNameThrow("tourns", tourns);
	_jparser.parseByNameThrow("tables", tables);
	_jparser.parseByNameThrow("zoomTypes", zoomTypes);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_U_GET_CURRENTLY_SEATED_AT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool joined; _jparser.validateByNameThrow("joined", joined);
	AtfValidator::validateInt(_descr, "joined", joined, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::TableData > tables; _jparser.validateByNameThrow("tables", tables);
	AtfValidator::validateInt(_descr, "tables", tables.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::ZoomDataStruct > zoomTypes; _jparser.validateByNameThrow("zoomTypes", zoomTypes);
	AtfValidator::validateInt(_descr, "zoomTypes", zoomTypes.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_U_GET_CURRENTLY_SEATED_AT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool joined; _parser.parseBOOL(joined);
	AtfValidator::validateInt(_descr, "joined", joined, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTourns = Atf::LAtfVector< MLobbyNG::cli::TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTables = Atf::LAtfVector< MLobbyNG::cli::TableData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tables", szTables, _checker, __FILE__, __LINE__);
	int szZoomTypes = Atf::LAtfVector< MLobbyNG::cli::ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_Q_GET_TICKET_TOURNS
//=================================================================

PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS::Protocol_PS_Q_GET_TICKET_TOURNS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS::Protocol_PS_Q_GET_TICKET_TOURNS(Protocol_PS_Q_GET_TICKET_TOURNS&& _o)
	: ticketNames(std::move(_o.ticketNames))
	, gameCategoryMask(std::move(_o.gameCategoryMask))
	, ticketTournRequestMask(std::move(_o.ticketTournRequestMask))
	, isPM(std::move(_o.isPM))
{
}

PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS& PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS::operator=(Protocol_PS_Q_GET_TICKET_TOURNS&& _o)
{
	if(this != &_o)
	{
		ticketNames = std::move(_o.ticketNames);
		gameCategoryMask = std::move(_o.gameCategoryMask);
		ticketTournRequestMask = std::move(_o.ticketTournRequestMask);
		isPM = std::move(_o.isPM);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS::clear()
{
	ticketNames.clear();
	gameCategoryMask = 0;
	ticketTournRequestMask = 0;
	isPM = false;
}

bool PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS::equals(const Protocol_PS_Q_GET_TICKET_TOURNS& _o) const
{
	return ticketNames.equals(_o.ticketNames) &&
		gameCategoryMask == _o.gameCategoryMask &&
		ticketTournRequestMask == _o.ticketTournRequestMask &&
		isPM == _o.isPM;
}

bool PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS::equals(Atf::MessageProtocol* _other) const
{
	if (PS_Q_GET_TICKET_TOURNS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_Q_GET_TICKET_TOURNS*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_Q_GET_TICKET_TOURNS).append(")");
	_buf.append(',');
	_buf.append("ticketNames=");
	ticketNames.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameCategoryMask=");
	_buf.appendUint(gameCategoryMask);
	_buf.append(',');
	_buf.append("ticketTournRequestMask=");
	_buf.appendUint(ticketTournRequestMask);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_Q_GET_TICKET_TOURNS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	ticketNames.toXmlString("ticketNames", _buf);
	Atf::XmlElement::encodeAsXmlElement("gameCategoryMask", gameCategoryMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketTournRequestMask", ticketTournRequestMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPM", isPM, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("ticketNames"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, ticketNames)) return false;
			}
			else if (_element.equals("gameCategoryMask"))
			{
				gameCategoryMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ticketTournRequestMask"))
			{
				ticketTournRequestMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPM"))
			{
				isPM = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	ticketNames.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(gameCategoryMask);
	_msg.composeUINT32(ticketTournRequestMask);
	_msg.composeBOOL(isPM);
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS::parseMsg(CommMsgParser& _parser)
{
	ticketNames.parseMsg(_parser);
	_parser.parseUINT32(gameCategoryMask);
	_parser.parseUINT32(ticketTournRequestMask);
	_parser.parseBOOL(isPM);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketNames", ticketNames);
	_jsonstr.compose("gameCategoryMask", gameCategoryMask);
	_jsonstr.compose("ticketTournRequestMask", ticketTournRequestMask);
	_jsonstr.compose("isPM", isPM);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketNames", ticketNames);
	_jparser.parseByNameThrow("gameCategoryMask", gameCategoryMask);
	_jparser.parseByNameThrow("ticketTournRequestMask", ticketTournRequestMask);
	_jparser.parseByNameThrow("isPM", isPM);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_GET_TICKET_TOURNS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< PString > ticketNames; _jparser.validateByNameThrow("ticketNames", ticketNames);
	AtfValidator::validateIntMax(_descr, "ticketNames", ticketNames.size(), 100, _checker, __FILE__, __LINE__);
	UINT32 gameCategoryMask; _jparser.validateByNameThrow("gameCategoryMask", gameCategoryMask);
	AtfValidator::validateIntMax(_descr, "gameCategoryMask", gameCategoryMask, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	UINT32 ticketTournRequestMask; _jparser.validateByNameThrow("ticketTournRequestMask", ticketTournRequestMask);
	AtfValidator::validateIntMax(_descr, "ticketTournRequestMask", ticketTournRequestMask, (2*TicketTournRequest_Last-1), _checker, __FILE__, __LINE__);
	bool isPM; _jparser.validateByNameThrow("isPM", isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_TOURNS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_GET_TICKET_TOURNS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTicketNames = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketNames"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "ticketNames", szTicketNames, 100, _checker, __FILE__, __LINE__);
	UINT32 gameCategoryMask; _parser.parseUINT32(gameCategoryMask);
	AtfValidator::validateIntMax(_descr, "gameCategoryMask", gameCategoryMask, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	UINT32 ticketTournRequestMask; _parser.parseUINT32(ticketTournRequestMask);
	AtfValidator::validateIntMax(_descr, "ticketTournRequestMask", ticketTournRequestMask, (2*TicketTournRequest_Last-1), _checker, __FILE__, __LINE__);
	bool isPM; _parser.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_A_GET_TICKET_TOURNS
//=================================================================

PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS::Protocol_PS_A_GET_TICKET_TOURNS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS::Protocol_PS_A_GET_TICKET_TOURNS(Protocol_PS_A_GET_TICKET_TOURNS&& _o)
	: ticketInfos(std::move(_o.ticketInfos))
{
}

PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS& PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS::operator=(Protocol_PS_A_GET_TICKET_TOURNS&& _o)
{
	if(this != &_o)
	{
		ticketInfos = std::move(_o.ticketInfos);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS::clear()
{
	ticketInfos.clear();
}

bool PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS::equals(const Protocol_PS_A_GET_TICKET_TOURNS& _o) const
{
	return ticketInfos.equals(_o.ticketInfos);
}

bool PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS::equals(Atf::MessageProtocol* _other) const
{
	if (PS_A_GET_TICKET_TOURNS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_A_GET_TICKET_TOURNS*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_A_GET_TICKET_TOURNS).append(")");
	_buf.append(',');
	_buf.append("ticketInfos=");
	ticketInfos.toTraceString(_buf);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_A_GET_TICKET_TOURNS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	ticketInfos.toXmlString("ticketInfos", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("ticketInfos"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::OrderedTicketTournInfo, 4 > >::FromXmlString(_value, ticketInfos)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	ticketInfos.composeMsg(_msg, _ignoreJSON);
}

void PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS::parseMsg(CommMsgParser& _parser)
{
	ticketInfos.parseMsg(_parser);
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketInfos", ticketInfos);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketInfos", ticketInfos);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_GET_TICKET_TOURNS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< MLobbyNG::cli::OrderedTicketTournInfo > ticketInfos; _jparser.validateByNameThrow("ticketInfos", ticketInfos);
	AtfValidator::validateInt(_descr, "ticketInfos", ticketInfos.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_TOURNS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_GET_TICKET_TOURNS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTicketInfos = Atf::LAtfVector< MLobbyNG::cli::OrderedTicketTournInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketInfos"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "ticketInfos", szTicketInfos, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_Q_FILTER_GAMES
//=================================================================

PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES::Protocol_PS_Q_FILTER_GAMES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES::Protocol_PS_Q_FILTER_GAMES(Protocol_PS_Q_FILTER_GAMES&& _o)
	: filter(std::move(_o.filter))
	, criteria(std::move(_o.criteria))
	, clientMarkers(std::move(_o.clientMarkers))
{
}

PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES& PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES::operator=(Protocol_PS_Q_FILTER_GAMES&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		criteria = std::move(_o.criteria);
		clientMarkers = std::move(_o.clientMarkers);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES::clear()
{
	filter.clear();
	criteria.clear();
	clientMarkers.clear();
}

bool PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES::equals(const Protocol_PS_Q_FILTER_GAMES& _o) const
{
	return filter.equals(_o.filter) &&
		criteria.equals(_o.criteria) &&
		clientMarkers.equals(_o.clientMarkers);
}

bool PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES::equals(Atf::MessageProtocol* _other) const
{
	if (PS_Q_FILTER_GAMES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_Q_FILTER_GAMES*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_Q_FILTER_GAMES).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	criteria.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_Q_FILTER_GAMES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	criteria.toXmlString("criteria", _buf);
	clientMarkers.toXmlString("clientMarkers", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< MLobbyNG::cli::FilterGamesSelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("criteria"))
			{
				if(!Atf::AtfTempl< MLobbyNG::cli::FilterGamesResultCriteria >::FromXmlString(_value, criteria)) return false;
			}
			else if (_element.equals("clientMarkers"))
			{
				if(!Atf::AtfTempl< MLobbyNG::cli::ClientMarkers >::FromXmlString(_value, clientMarkers)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	criteria.composeMsg(_msg, _ignoreJSON);
	clientMarkers.composeMsg(_msg, _ignoreJSON);
}

void PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	criteria.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("criteria", criteria);
	_jsonstr.compose("clientMarkers", clientMarkers);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("criteria", criteria);
	_jparser.parseByNameThrow("clientMarkers", clientMarkers);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_FILTER_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	MLobbyNG::cli::FilterGamesSelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	MLobbyNG::cli::FilterGamesResultCriteria criteria; _jparser.validateByNameThrow("criteria", criteria);
	MLobbyNG::cli::ClientMarkers clientMarkers; _jparser.validateByNameThrow("clientMarkers", clientMarkers);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_FILTER_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_FILTER_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	MLobbyNG::cli::FilterGamesSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	MLobbyNG::cli::FilterGamesResultCriteria::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("criteria"), _fieldsWithUnparsedContent);
	MLobbyNG::cli::ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_A_FILTER_GAMES
//=================================================================

PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES::Protocol_PS_A_FILTER_GAMES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES::Protocol_PS_A_FILTER_GAMES(Protocol_PS_A_FILTER_GAMES&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
	, totalItems(std::move(_o.totalItems))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, resultRanges(std::move(_o.resultRanges))
{
}

PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES& PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES::operator=(Protocol_PS_A_FILTER_GAMES&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
		totalItems = std::move(_o.totalItems);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		resultRanges = std::move(_o.resultRanges);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
	totalItems = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	resultRanges.clear();
}

bool PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES::equals(const Protocol_PS_A_FILTER_GAMES& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder) &&
		totalItems == _o.totalItems &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		resultRanges.equals(_o.resultRanges);
}

bool PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES::equals(Atf::MessageProtocol* _other) const
{
	if (PS_A_FILTER_GAMES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_A_FILTER_GAMES*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_A_FILTER_GAMES).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendInt(totalItems);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendInt64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt64(maxBuyIn);
	_buf.append(',');
	_buf.append("resultRanges=");
	resultRanges.toTraceString(_buf);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_A_FILTER_GAMES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tourns.toXmlString("tourns", _buf);
	tableTypes.toXmlString("tableTypes", _buf);
	sngTypes.toXmlString("sngTypes", _buf);
	sagTypes.toXmlString("sagTypes", _buf);
	zoomTypes.toXmlString("zoomTypes", _buf);
	seatFinders.toXmlString("seatFinders", _buf);
	gameOrder.toXmlString("gameOrder", _buf);
	Atf::XmlElement::encodeAsXmlElement("totalItems", totalItems, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	resultRanges.toXmlString("resultRanges", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("tableTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::TableDataStruct, 4 > >::FromXmlString(_value, tableTypes)) return false;
			}
			else if (_element.equals("sngTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::SngDataStruct, 4 > >::FromXmlString(_value, sngTypes)) return false;
			}
			else if (_element.equals("sagTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::SagDataStruct, 4 > >::FromXmlString(_value, sagTypes)) return false;
			}
			else if (_element.equals("zoomTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::ZoomDataStruct, 4 > >::FromXmlString(_value, zoomTypes)) return false;
			}
			else if (_element.equals("seatFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::SeatFinderDataStruct, 4 > >::FromXmlString(_value, seatFinders)) return false;
			}
			else if (_element.equals("gameOrder"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, gameOrder)) return false;
			}
			else if (_element.equals("totalItems"))
			{
				totalItems = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minBuyIn"))
			{
				minBuyIn = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxBuyIn"))
			{
				maxBuyIn = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("resultRanges"))
			{
				if(!Atf::AtfTempl< MLobbyNG::cli::ResultRanges >::FromXmlString(_value, resultRanges)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tourns.composeMsg(_msg, _ignoreJSON);
	tableTypes.composeMsg(_msg, _ignoreJSON);
	sngTypes.composeMsg(_msg, _ignoreJSON);
	sagTypes.composeMsg(_msg, _ignoreJSON);
	zoomTypes.composeMsg(_msg, _ignoreJSON);
	seatFinders.composeMsg(_msg, _ignoreJSON);
	gameOrder.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(totalItems);
	_msg.composeINT64(minBuyIn);
	_msg.composeINT64(maxBuyIn);
	resultRanges.composeMsg(_msg, _ignoreJSON);
}

void PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
	_parser.parseINT32(totalItems);
	_parser.parseINT64(minBuyIn);
	_parser.parseINT64(maxBuyIn);
	resultRanges.parseMsg(_parser);
}

const char *PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tourns", tourns);
	_jsonstr.compose("tableTypes", tableTypes);
	_jsonstr.compose("sngTypes", sngTypes);
	_jsonstr.compose("sagTypes", sagTypes);
	_jsonstr.compose("zoomTypes", zoomTypes);
	_jsonstr.compose("seatFinders", seatFinders);
	_jsonstr.compose("gameOrder", gameOrder);
	_jsonstr.compose("totalItems", totalItems);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("resultRanges", resultRanges);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tourns", tourns);
	_jparser.parseByNameThrow("tableTypes", tableTypes);
	_jparser.parseByNameThrow("sngTypes", sngTypes);
	_jparser.parseByNameThrow("sagTypes", sagTypes);
	_jparser.parseByNameThrow("zoomTypes", zoomTypes);
	_jparser.parseByNameThrow("seatFinders", seatFinders);
	_jparser.parseByNameThrow("gameOrder", gameOrder);
	_jparser.parseByNameThrow("totalItems", totalItems);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("resultRanges", resultRanges);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_FILTER_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< MLobbyNG::cli::TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::TableDataStruct > tableTypes; _jparser.validateByNameThrow("tableTypes", tableTypes);
	AtfValidator::validateInt(_descr, "tableTypes", tableTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::SngDataStruct > sngTypes; _jparser.validateByNameThrow("sngTypes", sngTypes);
	AtfValidator::validateInt(_descr, "sngTypes", sngTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::SagDataStruct > sagTypes; _jparser.validateByNameThrow("sagTypes", sagTypes);
	AtfValidator::validateInt(_descr, "sagTypes", sagTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::ZoomDataStruct > zoomTypes; _jparser.validateByNameThrow("zoomTypes", zoomTypes);
	AtfValidator::validateInt(_descr, "zoomTypes", zoomTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::SeatFinderDataStruct > seatFinders; _jparser.validateByNameThrow("seatFinders", seatFinders);
	AtfValidator::validateInt(_descr, "seatFinders", seatFinders.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > gameOrder; _jparser.validateByNameThrow("gameOrder", gameOrder);
	AtfValidator::validateInt(_descr, "gameOrder", gameOrder.size(), _checker, __FILE__, __LINE__);
	INT32 totalItems; _jparser.validateByNameThrow("totalItems", totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	INT64 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	MLobbyNG::cli::ResultRanges resultRanges; _jparser.validateByNameThrow("resultRanges", resultRanges);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_FILTER_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_FILTER_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = Atf::LAtfVector< MLobbyNG::cli::TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = Atf::LAtfVector< MLobbyNG::cli::TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = Atf::LAtfVector< MLobbyNG::cli::SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = Atf::LAtfVector< MLobbyNG::cli::SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = Atf::LAtfVector< MLobbyNG::cli::ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = Atf::LAtfVector< MLobbyNG::cli::SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	INT32 totalItems; _parser.parseINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	INT64 minBuyIn; _parser.parseINT64(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _parser.parseINT64(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	MLobbyNG::cli::ResultRanges::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("resultRanges"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_Q_GET_BRANDED_LOBBIES
//=================================================================

PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::Protocol_PS_Q_GET_BRANDED_LOBBIES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::Protocol_PS_Q_GET_BRANDED_LOBBIES(Protocol_PS_Q_GET_BRANDED_LOBBIES&& _o)
	: currencyMask(std::move(_o.currencyMask))
	, country(std::move(_o.country))
	, isPM(std::move(_o.isPM))
{
}

PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES& PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::operator=(Protocol_PS_Q_GET_BRANDED_LOBBIES&& _o)
{
	if(this != &_o)
	{
		currencyMask = std::move(_o.currencyMask);
		country = std::move(_o.country);
		isPM = std::move(_o.isPM);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::clear()
{
	currencyMask = 0;
	country.clear();
	isPM = false;
}

bool PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::equals(const Protocol_PS_Q_GET_BRANDED_LOBBIES& _o) const
{
	return currencyMask == _o.currencyMask &&
		Atf::atfPStringEquals(country, _o.country) &&
		isPM == _o.isPM;
}

bool PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::equals(Atf::MessageProtocol* _other) const
{
	if (PS_Q_GET_BRANDED_LOBBIES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_Q_GET_BRANDED_LOBBIES*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_Q_GET_BRANDED_LOBBIES).append(")");
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_Q_GET_BRANDED_LOBBIES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("currencyMask", currencyMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPM", isPM, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("currencyMask"))
			{
				currencyMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("isPM"))
			{
				isPM = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(currencyMask);
	_msg.composeString(country);
	_msg.composeBOOL(isPM);
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(currencyMask);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(country);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isPM);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currencyMask", currencyMask);
	_jsonstr.compose("country", country);
	_jsonstr.compose("isPM", isPM);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("currencyMask", currencyMask);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("country", country);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("isPM", isPM);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_GET_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	UINT32 currencyMask; _jparser.validateByNameThrow("currencyMask", currencyMask);
	AtfValidator::validateInt(_descr, "currencyMask", currencyMask, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool isPM; _jparser.validateByNameThrow("isPM", isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_GET_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	UINT32 currencyMask; _parser.parseUINT32(currencyMask);
	AtfValidator::validateInt(_descr, "currencyMask", currencyMask, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool isPM; _parser.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_A_GET_BRANDED_LOBBIES
//=================================================================

PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES::Protocol_PS_A_GET_BRANDED_LOBBIES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES::Protocol_PS_A_GET_BRANDED_LOBBIES(Protocol_PS_A_GET_BRANDED_LOBBIES&& _o)
	: lobbies(std::move(_o.lobbies))
{
}

PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES& PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES::operator=(Protocol_PS_A_GET_BRANDED_LOBBIES&& _o)
{
	if(this != &_o)
	{
		lobbies = std::move(_o.lobbies);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES::clear()
{
	lobbies.clear();
}

bool PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES::equals(const Protocol_PS_A_GET_BRANDED_LOBBIES& _o) const
{
	return lobbies.equals(_o.lobbies);
}

bool PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES::equals(Atf::MessageProtocol* _other) const
{
	if (PS_A_GET_BRANDED_LOBBIES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_A_GET_BRANDED_LOBBIES*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_A_GET_BRANDED_LOBBIES).append(")");
	_buf.append(',');
	_buf.append("lobbies=");
	lobbies.toTraceString(_buf);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_A_GET_BRANDED_LOBBIES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	lobbies.toXmlString("lobbies", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("lobbies"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::BrandedLobbyInfo, 4 > >::FromXmlString(_value, lobbies)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	lobbies.composeMsg(_msg, _ignoreJSON);
}

void PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES::parseMsg(CommMsgParser& _parser)
{
	lobbies.parseMsg(_parser);
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("lobbies", lobbies);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("lobbies", lobbies);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_GET_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< MLobbyNG::cli::BrandedLobbyInfo > lobbies; _jparser.validateByNameThrow("lobbies", lobbies);
	AtfValidator::validateInt(_descr, "lobbies", lobbies.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_GET_BRANDED_LOBBIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_GET_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szLobbies = Atf::LAtfVector< MLobbyNG::cli::BrandedLobbyInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("lobbies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "lobbies", szLobbies, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_Q_INIT_BRANDED_LOBBIES
//=================================================================

PersonalizationATF::cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES::Protocol_PS_Q_INIT_BRANDED_LOBBIES()
{
	clear();
}

void PersonalizationATF::cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES::clear()
{
}

bool PersonalizationATF::cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES::equals(const Protocol_PS_Q_INIT_BRANDED_LOBBIES& _o) const
{
	return true;
}

bool PersonalizationATF::cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES::equals(Atf::MessageProtocol* _other) const
{
	if (PS_Q_INIT_BRANDED_LOBBIES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_Q_INIT_BRANDED_LOBBIES*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_Q_INIT_BRANDED_LOBBIES).append(")");
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_Q_INIT_BRANDED_LOBBIES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void PersonalizationATF::cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES::parseMsg(CommMsgParser& _parser)
{
}

const char *PersonalizationATF::cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_INIT_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_INIT_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_A_INIT_BRANDED_LOBBIES
//=================================================================

PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::Protocol_PS_A_INIT_BRANDED_LOBBIES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::Protocol_PS_A_INIT_BRANDED_LOBBIES(Protocol_PS_A_INIT_BRANDED_LOBBIES&& _o)
	: lobbies(std::move(_o.lobbies))
{
}

PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES& PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::operator=(Protocol_PS_A_INIT_BRANDED_LOBBIES&& _o)
{
	if(this != &_o)
	{
		lobbies = std::move(_o.lobbies);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::clear()
{
	lobbies.clear();
}

bool PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::equals(const Protocol_PS_A_INIT_BRANDED_LOBBIES& _o) const
{
	return lobbies.equals(_o.lobbies);
}

bool PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::equals(Atf::MessageProtocol* _other) const
{
	if (PS_A_INIT_BRANDED_LOBBIES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_A_INIT_BRANDED_LOBBIES*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_A_INIT_BRANDED_LOBBIES).append(")");
	_buf.append(',');
	_buf.append("lobbies=");
	lobbies.toTraceString(_buf);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_A_INIT_BRANDED_LOBBIES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	lobbies.toXmlString("lobbies", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("lobbies"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::FullBrandedLobbyInfo, 4 > >::FromXmlString(_value, lobbies)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	lobbies.composeMsg(_msg, _ignoreJSON);
}

void PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::parseMsg(CommMsgParser& _parser)
{
	lobbies.parseMsg(_parser);
}

const char *PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("lobbies", lobbies);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("lobbies", lobbies);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_INIT_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< MLobbyNG::cli::FullBrandedLobbyInfo > lobbies; _jparser.validateByNameThrow("lobbies", lobbies);
	AtfValidator::validateInt(_descr, "lobbies", lobbies.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_INIT_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szLobbies = Atf::LAtfVector< MLobbyNG::cli::FullBrandedLobbyInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("lobbies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "lobbies", szLobbies, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_Q_ADMIN_UPDATE_LOBBIES
//=================================================================

PersonalizationATF::cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES()
{
	clear();
}

void PersonalizationATF::cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES::clear()
{
}

bool PersonalizationATF::cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES::equals(const Protocol_PS_Q_ADMIN_UPDATE_LOBBIES& _o) const
{
	return true;
}

bool PersonalizationATF::cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES::equals(Atf::MessageProtocol* _other) const
{
	if (PS_Q_ADMIN_UPDATE_LOBBIES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_Q_ADMIN_UPDATE_LOBBIES*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_Q_ADMIN_UPDATE_LOBBIES).append(")");
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_Q_ADMIN_UPDATE_LOBBIES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void PersonalizationATF::cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES::parseMsg(CommMsgParser& _parser)
{
}

const char *PersonalizationATF::cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_ADMIN_UPDATE_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_ADMIN_UPDATE_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_A_ADMIN_UPDATE_LOBBIES
//=================================================================

PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::Protocol_PS_A_ADMIN_UPDATE_LOBBIES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::Protocol_PS_A_ADMIN_UPDATE_LOBBIES(Protocol_PS_A_ADMIN_UPDATE_LOBBIES&& _o)
	: errCode(std::move(_o.errCode))
	, errMsg(std::move(_o.errMsg))
{
}

PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES& PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::operator=(Protocol_PS_A_ADMIN_UPDATE_LOBBIES&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errMsg = std::move(_o.errMsg);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::clear()
{
	errCode = 0;
	errMsg.clear();
}

bool PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::equals(const Protocol_PS_A_ADMIN_UPDATE_LOBBIES& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg);
}

bool PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::equals(Atf::MessageProtocol* _other) const
{
	if (PS_A_ADMIN_UPDATE_LOBBIES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_A_ADMIN_UPDATE_LOBBIES*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_A_ADMIN_UPDATE_LOBBIES).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_A_ADMIN_UPDATE_LOBBIES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errMsg);
	}
}

void PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errMsg);
	}
}

const char *PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errMsg", errMsg);
	}
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errMsg", errMsg);
	}
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_ADMIN_UPDATE_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
		AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_ADMIN_UPDATE_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_Q_GET_SUGGESTED_GAMES
//=================================================================

PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::Protocol_PS_Q_GET_SUGGESTED_GAMES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::Protocol_PS_Q_GET_SUGGESTED_GAMES(Protocol_PS_Q_GET_SUGGESTED_GAMES&& _o)
	: filter(std::move(_o.filter))
	, clientMarkers(std::move(_o.clientMarkers))
{
}

PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES& PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::operator=(Protocol_PS_Q_GET_SUGGESTED_GAMES&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		clientMarkers = std::move(_o.clientMarkers);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::clear()
{
	filter.clear();
	clientMarkers.clear();
}

bool PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::equals(const Protocol_PS_Q_GET_SUGGESTED_GAMES& _o) const
{
	return filter.equals(_o.filter) &&
		clientMarkers.equals(_o.clientMarkers);
}

bool PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::equals(Atf::MessageProtocol* _other) const
{
	if (PS_Q_GET_SUGGESTED_GAMES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_Q_GET_SUGGESTED_GAMES*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_Q_GET_SUGGESTED_GAMES).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_Q_GET_SUGGESTED_GAMES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	clientMarkers.toXmlString("clientMarkers", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< MLobbyNG::cli::SuggestedGames2SelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("clientMarkers"))
			{
				if(!Atf::AtfTempl< MLobbyNG::cli::ClientMarkers >::FromXmlString(_value, clientMarkers)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	clientMarkers.composeMsg(_msg, _ignoreJSON);
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("clientMarkers", clientMarkers);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("clientMarkers", clientMarkers);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_GET_SUGGESTED_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	MLobbyNG::cli::SuggestedGames2SelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	MLobbyNG::cli::ClientMarkers clientMarkers; _jparser.validateByNameThrow("clientMarkers", clientMarkers);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_GET_SUGGESTED_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	MLobbyNG::cli::SuggestedGames2SelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	MLobbyNG::cli::ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_A_GET_SUGGESTED_GAMES
//=================================================================

PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES::Protocol_PS_A_GET_SUGGESTED_GAMES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES::Protocol_PS_A_GET_SUGGESTED_GAMES(Protocol_PS_A_GET_SUGGESTED_GAMES&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
{
}

PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES& PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES::operator=(Protocol_PS_A_GET_SUGGESTED_GAMES&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
}

bool PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES::equals(const Protocol_PS_A_GET_SUGGESTED_GAMES& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder);
}

bool PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES::equals(Atf::MessageProtocol* _other) const
{
	if (PS_A_GET_SUGGESTED_GAMES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_A_GET_SUGGESTED_GAMES*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_A_GET_SUGGESTED_GAMES).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_A_GET_SUGGESTED_GAMES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tourns.toXmlString("tourns", _buf);
	tableTypes.toXmlString("tableTypes", _buf);
	sngTypes.toXmlString("sngTypes", _buf);
	sagTypes.toXmlString("sagTypes", _buf);
	zoomTypes.toXmlString("zoomTypes", _buf);
	seatFinders.toXmlString("seatFinders", _buf);
	gameOrder.toXmlString("gameOrder", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("tableTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::TableDataStruct, 4 > >::FromXmlString(_value, tableTypes)) return false;
			}
			else if (_element.equals("sngTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::SngDataStruct, 4 > >::FromXmlString(_value, sngTypes)) return false;
			}
			else if (_element.equals("sagTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::SagDataStruct, 4 > >::FromXmlString(_value, sagTypes)) return false;
			}
			else if (_element.equals("zoomTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::ZoomDataStruct, 4 > >::FromXmlString(_value, zoomTypes)) return false;
			}
			else if (_element.equals("seatFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::SeatFinderDataStruct, 4 > >::FromXmlString(_value, seatFinders)) return false;
			}
			else if (_element.equals("gameOrder"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, gameOrder)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tourns.composeMsg(_msg, _ignoreJSON);
	tableTypes.composeMsg(_msg, _ignoreJSON);
	sngTypes.composeMsg(_msg, _ignoreJSON);
	sagTypes.composeMsg(_msg, _ignoreJSON);
	zoomTypes.composeMsg(_msg, _ignoreJSON);
	seatFinders.composeMsg(_msg, _ignoreJSON);
	gameOrder.composeMsg(_msg, _ignoreJSON);
}

void PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tourns", tourns);
	_jsonstr.compose("tableTypes", tableTypes);
	_jsonstr.compose("sngTypes", sngTypes);
	_jsonstr.compose("sagTypes", sagTypes);
	_jsonstr.compose("zoomTypes", zoomTypes);
	_jsonstr.compose("seatFinders", seatFinders);
	_jsonstr.compose("gameOrder", gameOrder);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tourns", tourns);
	_jparser.parseByNameThrow("tableTypes", tableTypes);
	_jparser.parseByNameThrow("sngTypes", sngTypes);
	_jparser.parseByNameThrow("sagTypes", sagTypes);
	_jparser.parseByNameThrow("zoomTypes", zoomTypes);
	_jparser.parseByNameThrow("seatFinders", seatFinders);
	_jparser.parseByNameThrow("gameOrder", gameOrder);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_GET_SUGGESTED_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< MLobbyNG::cli::TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::TableDataStruct > tableTypes; _jparser.validateByNameThrow("tableTypes", tableTypes);
	AtfValidator::validateInt(_descr, "tableTypes", tableTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::SngDataStruct > sngTypes; _jparser.validateByNameThrow("sngTypes", sngTypes);
	AtfValidator::validateInt(_descr, "sngTypes", sngTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::SagDataStruct > sagTypes; _jparser.validateByNameThrow("sagTypes", sagTypes);
	AtfValidator::validateInt(_descr, "sagTypes", sagTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::ZoomDataStruct > zoomTypes; _jparser.validateByNameThrow("zoomTypes", zoomTypes);
	AtfValidator::validateInt(_descr, "zoomTypes", zoomTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::SeatFinderDataStruct > seatFinders; _jparser.validateByNameThrow("seatFinders", seatFinders);
	AtfValidator::validateInt(_descr, "seatFinders", seatFinders.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > gameOrder; _jparser.validateByNameThrow("gameOrder", gameOrder);
	AtfValidator::validateInt(_descr, "gameOrder", gameOrder.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_GET_SUGGESTED_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_GET_SUGGESTED_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = Atf::LAtfVector< MLobbyNG::cli::TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = Atf::LAtfVector< MLobbyNG::cli::TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = Atf::LAtfVector< MLobbyNG::cli::SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = Atf::LAtfVector< MLobbyNG::cli::SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = Atf::LAtfVector< MLobbyNG::cli::ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = Atf::LAtfVector< MLobbyNG::cli::SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_Q_SEARCH_BY_NAME
//=================================================================

PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME::Protocol_PS_Q_SEARCH_BY_NAME()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME::Protocol_PS_Q_SEARCH_BY_NAME(Protocol_PS_Q_SEARCH_BY_NAME&& _o)
	: filter(std::move(_o.filter))
	, criteria(std::move(_o.criteria))
	, clientMarkers(std::move(_o.clientMarkers))
{
}

PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME& PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME::operator=(Protocol_PS_Q_SEARCH_BY_NAME&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		criteria = std::move(_o.criteria);
		clientMarkers = std::move(_o.clientMarkers);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME::clear()
{
	filter.clear();
	criteria.clear();
	clientMarkers.clear();
}

bool PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME::equals(const Protocol_PS_Q_SEARCH_BY_NAME& _o) const
{
	return filter.equals(_o.filter) &&
		criteria.equals(_o.criteria) &&
		clientMarkers.equals(_o.clientMarkers);
}

bool PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME::equals(Atf::MessageProtocol* _other) const
{
	if (PS_Q_SEARCH_BY_NAME != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_Q_SEARCH_BY_NAME*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_Q_SEARCH_BY_NAME).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	criteria.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_Q_SEARCH_BY_NAME).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	criteria.toXmlString("criteria", _buf);
	clientMarkers.toXmlString("clientMarkers", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< MLobbyNG::cli::NameSearchSelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("criteria"))
			{
				if(!Atf::AtfTempl< MLobbyNG::cli::FilterGamesResultCriteria >::FromXmlString(_value, criteria)) return false;
			}
			else if (_element.equals("clientMarkers"))
			{
				if(!Atf::AtfTempl< MLobbyNG::cli::ClientMarkers >::FromXmlString(_value, clientMarkers)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	criteria.composeMsg(_msg, _ignoreJSON);
	clientMarkers.composeMsg(_msg, _ignoreJSON);
}

void PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	criteria.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("criteria", criteria);
	_jsonstr.compose("clientMarkers", clientMarkers);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("criteria", criteria);
	_jparser.parseByNameThrow("clientMarkers", clientMarkers);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_SEARCH_BY_NAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	MLobbyNG::cli::NameSearchSelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	MLobbyNG::cli::FilterGamesResultCriteria criteria; _jparser.validateByNameThrow("criteria", criteria);
	MLobbyNG::cli::ClientMarkers clientMarkers; _jparser.validateByNameThrow("clientMarkers", clientMarkers);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_SEARCH_BY_NAME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_SEARCH_BY_NAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	MLobbyNG::cli::NameSearchSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	MLobbyNG::cli::FilterGamesResultCriteria::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("criteria"), _fieldsWithUnparsedContent);
	MLobbyNG::cli::ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_A_SEARCH_BY_NAME
//=================================================================

PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME::Protocol_PS_A_SEARCH_BY_NAME()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME::Protocol_PS_A_SEARCH_BY_NAME(Protocol_PS_A_SEARCH_BY_NAME&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
{
}

PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME& PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME::operator=(Protocol_PS_A_SEARCH_BY_NAME&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
}

bool PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME::equals(const Protocol_PS_A_SEARCH_BY_NAME& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder);
}

bool PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME::equals(Atf::MessageProtocol* _other) const
{
	if (PS_A_SEARCH_BY_NAME != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_A_SEARCH_BY_NAME*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_A_SEARCH_BY_NAME).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_A_SEARCH_BY_NAME).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tourns.toXmlString("tourns", _buf);
	tableTypes.toXmlString("tableTypes", _buf);
	sngTypes.toXmlString("sngTypes", _buf);
	sagTypes.toXmlString("sagTypes", _buf);
	zoomTypes.toXmlString("zoomTypes", _buf);
	seatFinders.toXmlString("seatFinders", _buf);
	gameOrder.toXmlString("gameOrder", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("tableTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::TableDataStruct, 4 > >::FromXmlString(_value, tableTypes)) return false;
			}
			else if (_element.equals("sngTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::SngDataStruct, 4 > >::FromXmlString(_value, sngTypes)) return false;
			}
			else if (_element.equals("sagTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::SagDataStruct, 4 > >::FromXmlString(_value, sagTypes)) return false;
			}
			else if (_element.equals("zoomTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::ZoomDataStruct, 4 > >::FromXmlString(_value, zoomTypes)) return false;
			}
			else if (_element.equals("seatFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MLobbyNG::cli::SeatFinderDataStruct, 4 > >::FromXmlString(_value, seatFinders)) return false;
			}
			else if (_element.equals("gameOrder"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, gameOrder)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tourns.composeMsg(_msg, _ignoreJSON);
	tableTypes.composeMsg(_msg, _ignoreJSON);
	sngTypes.composeMsg(_msg, _ignoreJSON);
	sagTypes.composeMsg(_msg, _ignoreJSON);
	zoomTypes.composeMsg(_msg, _ignoreJSON);
	seatFinders.composeMsg(_msg, _ignoreJSON);
	gameOrder.composeMsg(_msg, _ignoreJSON);
}

void PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
}

const char *PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tourns", tourns);
	_jsonstr.compose("tableTypes", tableTypes);
	_jsonstr.compose("sngTypes", sngTypes);
	_jsonstr.compose("sagTypes", sagTypes);
	_jsonstr.compose("zoomTypes", zoomTypes);
	_jsonstr.compose("seatFinders", seatFinders);
	_jsonstr.compose("gameOrder", gameOrder);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tourns", tourns);
	_jparser.parseByNameThrow("tableTypes", tableTypes);
	_jparser.parseByNameThrow("sngTypes", sngTypes);
	_jparser.parseByNameThrow("sagTypes", sagTypes);
	_jparser.parseByNameThrow("zoomTypes", zoomTypes);
	_jparser.parseByNameThrow("seatFinders", seatFinders);
	_jparser.parseByNameThrow("gameOrder", gameOrder);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_SEARCH_BY_NAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< MLobbyNG::cli::TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::TableDataStruct > tableTypes; _jparser.validateByNameThrow("tableTypes", tableTypes);
	AtfValidator::validateInt(_descr, "tableTypes", tableTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::SngDataStruct > sngTypes; _jparser.validateByNameThrow("sngTypes", sngTypes);
	AtfValidator::validateInt(_descr, "sngTypes", sngTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::SagDataStruct > sagTypes; _jparser.validateByNameThrow("sagTypes", sagTypes);
	AtfValidator::validateInt(_descr, "sagTypes", sagTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::ZoomDataStruct > zoomTypes; _jparser.validateByNameThrow("zoomTypes", zoomTypes);
	AtfValidator::validateInt(_descr, "zoomTypes", zoomTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MLobbyNG::cli::SeatFinderDataStruct > seatFinders; _jparser.validateByNameThrow("seatFinders", seatFinders);
	AtfValidator::validateInt(_descr, "seatFinders", seatFinders.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > gameOrder; _jparser.validateByNameThrow("gameOrder", gameOrder);
	AtfValidator::validateInt(_descr, "gameOrder", gameOrder.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_SEARCH_BY_NAME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_SEARCH_BY_NAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = Atf::LAtfVector< MLobbyNG::cli::TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = Atf::LAtfVector< MLobbyNG::cli::TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = Atf::LAtfVector< MLobbyNG::cli::SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = Atf::LAtfVector< MLobbyNG::cli::SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = Atf::LAtfVector< MLobbyNG::cli::ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = Atf::LAtfVector< MLobbyNG::cli::SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_Q_GET_TICKET_COUNTS
//=================================================================

PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_COUNTS::Protocol_PS_Q_GET_TICKET_COUNTS()
{
	clear();
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_COUNTS::clear()
{
	filter.clear();
}

bool PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_COUNTS::equals(const Protocol_PS_Q_GET_TICKET_COUNTS& _o) const
{
	return filter.equals(_o.filter);
}

bool PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_COUNTS::equals(Atf::MessageProtocol* _other) const
{
	if (PS_Q_GET_TICKET_COUNTS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_Q_GET_TICKET_COUNTS*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_COUNTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_Q_GET_TICKET_COUNTS).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_COUNTS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_COUNTS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_Q_GET_TICKET_COUNTS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_COUNTS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< TournCountFilter >::FromXmlString(_value, filter)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_COUNTS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_COUNTS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	filter.parseMsg(_parser);
}

const char *PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_COUNTS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_COUNTS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("filter", filter);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_COUNTS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_GET_TICKET_COUNTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	TournCountFilter filter; _jparser.validateByNameThrow("filter", filter);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_Q_GET_TICKET_COUNTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_Q_GET_TICKET_COUNTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	PString _descbuf;
	TournCountFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_PS_A_GET_TICKET_COUNTS
//=================================================================

PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS::Protocol_PS_A_GET_TICKET_COUNTS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS::Protocol_PS_A_GET_TICKET_COUNTS(Protocol_PS_A_GET_TICKET_COUNTS&& _o)
	: tickets(std::move(_o.tickets))
{
}

PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS& PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS::operator=(Protocol_PS_A_GET_TICKET_COUNTS&& _o)
{
	if(this != &_o)
	{
		tickets = std::move(_o.tickets);
	}
	return *this;
}

#endif

void PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS::clear()
{
	tickets.clear();
}

bool PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS::equals(const Protocol_PS_A_GET_TICKET_COUNTS& _o) const
{
	return tickets.equals(_o.tickets);
}

bool PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS::equals(Atf::MessageProtocol* _other) const
{
	if (PS_A_GET_TICKET_COUNTS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_PS_A_GET_TICKET_COUNTS*)_other));
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(PS_A_GET_TICKET_COUNTS).append(")");
	_buf.append(',');
	_buf.append("tickets=");
	tickets.toTraceString(_buf);
	return _buf.c_str();
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(PS_A_GET_TICKET_COUNTS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tickets.toXmlString("tickets", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tickets"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournTicketInfo, 4 > >::FromXmlString(_value, tickets)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tickets.composeMsg(_msg, _ignoreJSON);
}

void PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS::parseMsg(CommMsgParser& _parser)
{
	tickets.parseMsg(_parser);
}

const char *PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tickets", tickets);
	return _buf.c_str();
}

void PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tickets", tickets);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_GET_TICKET_COUNTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TournTicketInfo > tickets; _jparser.validateByNameThrow("tickets", tickets);
	AtfValidator::validateInt(_descr, "tickets", tickets.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void PersonalizationATF::cli::Protocol_PS_A_GET_TICKET_COUNTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "PS_A_GET_TICKET_COUNTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTickets = Atf::LAtfVector< TournTicketInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* PersonalizationATF::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case PS_A_ADMIN_GET_RECENT_GAME_LIST: _obj = new cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST(); break;
			case PS_A_ADMIN_UPDATE_LOBBIES: _obj = new cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES(); break;
			case PS_A_FILTER_GAMES: _obj = new cli::Protocol_PS_A_FILTER_GAMES(); break;
			case PS_A_GET_BRANDED_LOBBIES: _obj = new cli::Protocol_PS_A_GET_BRANDED_LOBBIES(); break;
			case PS_A_GET_RECENT_GAME_LIST: _obj = new cli::Protocol_PS_A_GET_RECENT_GAME_LIST(); break;
			case PS_A_GET_SUGGESTED_GAMES: _obj = new cli::Protocol_PS_A_GET_SUGGESTED_GAMES(); break;
			case PS_A_GET_TICKET_COUNTS: _obj = new cli::Protocol_PS_A_GET_TICKET_COUNTS(); break;
			case PS_A_GET_TICKET_TOURNS: _obj = new cli::Protocol_PS_A_GET_TICKET_TOURNS(); break;
			case PS_A_INIT_BRANDED_LOBBIES: _obj = new cli::Protocol_PS_A_INIT_BRANDED_LOBBIES(); break;
			case PS_A_SEARCH_BY_NAME: _obj = new cli::Protocol_PS_A_SEARCH_BY_NAME(); break;
			case PS_Q_ADMIN_GET_RECENT_GAME_LIST: _obj = new cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST(); break;
			case PS_Q_ADMIN_UPDATE_LOBBIES: _obj = new cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES(); break;
			case PS_Q_FILTER_GAMES: _obj = new cli::Protocol_PS_Q_FILTER_GAMES(); break;
			case PS_Q_GET_BRANDED_LOBBIES: _obj = new cli::Protocol_PS_Q_GET_BRANDED_LOBBIES(); break;
			case PS_Q_GET_RECENT_GAME_LIST: _obj = new cli::Protocol_PS_Q_GET_RECENT_GAME_LIST(); break;
			case PS_Q_GET_SUGGESTED_GAMES: _obj = new cli::Protocol_PS_Q_GET_SUGGESTED_GAMES(); break;
			case PS_Q_GET_TICKET_COUNTS: _obj = new cli::Protocol_PS_Q_GET_TICKET_COUNTS(); break;
			case PS_Q_GET_TICKET_TOURNS: _obj = new cli::Protocol_PS_Q_GET_TICKET_TOURNS(); break;
			case PS_Q_INIT_BRANDED_LOBBIES: _obj = new cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES(); break;
			case PS_Q_SEARCH_BY_NAME: _obj = new cli::Protocol_PS_Q_SEARCH_BY_NAME(); break;
			case PS_U_GET_CURRENTLY_SEATED_AT: _obj = new cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT(); break;
		}
	}
	
	return _obj;
}

/* static */ bool PersonalizationATF::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case PS_A_ADMIN_GET_RECENT_GAME_LIST: cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_A_ADMIN_UPDATE_LOBBIES: cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_A_FILTER_GAMES: cli::Protocol_PS_A_FILTER_GAMES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_A_GET_BRANDED_LOBBIES: cli::Protocol_PS_A_GET_BRANDED_LOBBIES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_A_GET_RECENT_GAME_LIST: cli::Protocol_PS_A_GET_RECENT_GAME_LIST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_A_GET_SUGGESTED_GAMES: cli::Protocol_PS_A_GET_SUGGESTED_GAMES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_A_GET_TICKET_COUNTS: cli::Protocol_PS_A_GET_TICKET_COUNTS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_A_GET_TICKET_TOURNS: cli::Protocol_PS_A_GET_TICKET_TOURNS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_A_INIT_BRANDED_LOBBIES: cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_A_SEARCH_BY_NAME: cli::Protocol_PS_A_SEARCH_BY_NAME::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_ADMIN_GET_RECENT_GAME_LIST: cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_ADMIN_UPDATE_LOBBIES: cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_FILTER_GAMES: cli::Protocol_PS_Q_FILTER_GAMES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_GET_BRANDED_LOBBIES: cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_GET_RECENT_GAME_LIST: cli::Protocol_PS_Q_GET_RECENT_GAME_LIST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_GET_SUGGESTED_GAMES: cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_GET_TICKET_COUNTS: cli::Protocol_PS_Q_GET_TICKET_COUNTS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_GET_TICKET_TOURNS: cli::Protocol_PS_Q_GET_TICKET_TOURNS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_INIT_BRANDED_LOBBIES: cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_SEARCH_BY_NAME: cli::Protocol_PS_Q_SEARCH_BY_NAME::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case PS_U_GET_CURRENTLY_SEATED_AT: cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool PersonalizationATF::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case PS_A_ADMIN_GET_RECENT_GAME_LIST: cli::Protocol_PS_A_ADMIN_GET_RECENT_GAME_LIST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_A_ADMIN_UPDATE_LOBBIES: cli::Protocol_PS_A_ADMIN_UPDATE_LOBBIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_A_FILTER_GAMES: cli::Protocol_PS_A_FILTER_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_A_GET_BRANDED_LOBBIES: cli::Protocol_PS_A_GET_BRANDED_LOBBIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_A_GET_RECENT_GAME_LIST: cli::Protocol_PS_A_GET_RECENT_GAME_LIST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_A_GET_SUGGESTED_GAMES: cli::Protocol_PS_A_GET_SUGGESTED_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_A_GET_TICKET_COUNTS: cli::Protocol_PS_A_GET_TICKET_COUNTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_A_GET_TICKET_TOURNS: cli::Protocol_PS_A_GET_TICKET_TOURNS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_A_INIT_BRANDED_LOBBIES: cli::Protocol_PS_A_INIT_BRANDED_LOBBIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_A_SEARCH_BY_NAME: cli::Protocol_PS_A_SEARCH_BY_NAME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_ADMIN_GET_RECENT_GAME_LIST: cli::Protocol_PS_Q_ADMIN_GET_RECENT_GAME_LIST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_ADMIN_UPDATE_LOBBIES: cli::Protocol_PS_Q_ADMIN_UPDATE_LOBBIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_FILTER_GAMES: cli::Protocol_PS_Q_FILTER_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_GET_BRANDED_LOBBIES: cli::Protocol_PS_Q_GET_BRANDED_LOBBIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_GET_RECENT_GAME_LIST: cli::Protocol_PS_Q_GET_RECENT_GAME_LIST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_GET_SUGGESTED_GAMES: cli::Protocol_PS_Q_GET_SUGGESTED_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_GET_TICKET_COUNTS: cli::Protocol_PS_Q_GET_TICKET_COUNTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_GET_TICKET_TOURNS: cli::Protocol_PS_Q_GET_TICKET_TOURNS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_INIT_BRANDED_LOBBIES: cli::Protocol_PS_Q_INIT_BRANDED_LOBBIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_Q_SEARCH_BY_NAME: cli::Protocol_PS_Q_SEARCH_BY_NAME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case PS_U_GET_CURRENTLY_SEATED_AT: cli::Protocol_PS_U_GET_CURRENTLY_SEATED_AT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

