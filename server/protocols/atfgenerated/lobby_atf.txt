#include "dbm.h"
#include "seatmanstruct_cli.h"
#include "lobby.h"
#include "UserDefStructs.h"
#include "Common_atf${ATF_THIN_FILENAME_SUFFIX}.h"
#include "sites.h"
#include "clientplatforms.h"
#include "newsmessages.h"
#include "table.h"
#include "timezone.h"
#include "tlbbop.h"
#include "brandimgs${ATF_THIN_FILENAME_SUFFIX}.h"
#include "../storm/TableCommonStructs${ATF_THIN_FILENAME_SUFFIX}.h"

#define TOP_LEVEL_NAMESPACE Lobby

namespace cli
{
	Message MSG_LOBBY_SUBMIT_STARCODE
	{
		PString starCode maxlen 10000;
	};

	Message MSG_LOBBY_SUBMIT_STARCODE_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
		else
		{
			PString successDescr;
		}
	};

	Message MSG_LOBBY_CLIENT_CURR_CONV_OPT
	{
		PString notUsedStr maxlen 20;
		bool doConvertBuyIn;
		bool doConvertWinnings;
	};

	Message MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
		else
		{
			UINT64 flags2;
		}
	};

	Message MSG_LOBBY_INIT_NETVERIFY_SESSION
	{
		PString redirectorUrl maxlen 10000;
	};

	Message MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
		else
		{
			PString url;
		}
	};

	Message MSG_LOBBY_PLAYING_HISTORY_AUDIT
	{
		PString notUsedStr maxlen 20;
		SrvDate startDate;
		SrvDate endDate;
		PString password maxlen 1000;
		bool includeFPP;
		UINT32 reportFormat max 100; // defined as eReportFormat under srvshared/crmserver.h
		bool isHtmlForClient;
		UINT32 reportFlags; // no limit
	};

	Message MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
	};

	Message MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT
	{
		PString notUsedStr maxlen 20;
		SrvDate startDate;
		SrvDate endDate;
		PString password maxlen 1000;
		UINT32 reportFormat max 100;
	};

	Message MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY
	{
		INT16 errCode;
		if( errCode != 0 )
		{
			PString errDescr;
		}
	};

	// same as in unauth connection
	Message MSG_LOBBY_CHALLENGE_QUESTION
	{
		UINT32 locale max MAX_LOCALES;
	};
	struct ChallengeQuestion
	{
		UINT32 id;
		PString txt;
	};
	Message MSG_LOBBY_CHALLENGE_QUESTION_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
		else
		{
			l2vector<ChallengeQuestion> challenges;
		}
	};

	Message MSG_LOBBY_GET_PLAYING_TIME_LIMIT // see alse lobbyetc
	{
	};
	Message MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
		else
		{
			INT32 limit;
			UINT32 autoLimiHour;
		}
	};

	Message MSG_LOBBY_SET_PLAYING_TIME_LIMIT // see also lobbyetc
	{
		INT32 limit min -1 max 100000000; // -1 means no limit
	};
	Message MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
		else
		{
			bool effectiveNow;
		}
	};

	Message MSG_LOBBY_RESEND_ACTIVATION_EMAIL
	{
	};
	Message MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
	};

	Message MSG_LOBBY_RESEND_MOBILE_VALIDATION // see alse lobbyprotocols_thin.h
	{
		PString unusedStr maxlen 20;
		bool newCode parseEndOptB4Me;
	};
	Message MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY
	{
		INT16 errCode;
		PString errDesc;
	};

	Message MSG_LOBBY_GET_CLIENT_OPTIONS // see alse lobbyetc
	{
		UINT32 optionType min eClientCustomOptionsBegin max eClientCustomOptionsEnd parseEndOptB4Me;
	};
	Message MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
		else
		{
			CommMsgBody
			{
				PBlock encodedPropStr;
			};
		}
	};

	Message MSG_LOBBY_SET_CLIENT_OPTIONS // see alse lobbyetc
	{
		CommMsgBody body maxsize USER_PROPERTYSTR_LEN; // server does not know the format and saves it to DB directly
		UINT32 propType min eClientCustomOptionsBegin max eClientCustomOptionsEnd parseEndOptB4Me;
	};
	Message MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
	};

	MsgBodyStruct WaitOnTable
	{
		UINT32 tableId32;
		UINT32 clubId;
		PString server;
		PString serverObject;
		PString tableName;
		PString specialName;
		BYTE game;
		BYTE limit;
		bool isHiLo;
		PString currency;
		UINT32 stakeLo;
		UINT32 stakeHi;
		bool isPlayMoney;
		UINT32 numPlayers;
		UINT32 maxPlayers;
		bool isOneOnOne;
		UINT32 waitListSize;
		UINT32 waitListPos;
		UINT32 scalePM;
		UINT64 tableId;
	};
	Message MSG_LOBBY_WAIT_ON_TABLES
	{
	};
	Message MSG_LOBBY_WAIT_ON_TABLES_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
		else
		{
			vector<WaitOnTable> waitOnTables;
		}
	};

	Message MSG_LOBBY_SOCIAL_SHARE_HAND
	{
		PString tournamentName maxlen 1000;
		PString tableName maxlen 1000;
		PString nick maxlen 1000;
		PString handText maxlen 100000; // hand history, can be long
		PString heroTheme maxlen 1000;
		PString opponentTheme maxlen 1000;
		PString longText maxlen 1000;
		PString	shortText maxlen 256;
		bool showHoleCards;
		bool showRealTableName;
		bool showAmountInBB;
		bool showRealNicks;
		bool showHandId;
		bool showHeroNick;
		PString typeOfShow maxlen 1000;
		PString language maxlen 128 parseEndOptB4Me;
		PString methodOfShare maxlen 1000 parseEndOptB4Me;
		PString client maxlen 1000;
	};
	Message MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
		else
		{
			PString encUrl;
			PString psapiUrl;
		}
	};

	Message MSG_LOBBY_BE_AVC_VALIDATE
	{
		UINT32 avc; // no limit
	};
	Message MSG_LOBBY_BE_AVC_VALIDATE_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
	};

	Message MSG_LOBBY_BE_AVC_RESEND
	{
	};
	Message MSG_LOBBY_BE_AVC_RESEND_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
	};

	Message MSG_LOBBY_REPORT_FIRST_LOGIN
	{
		PString installIdDeprecated maxlen 40;
		UINT32 siteId max PokerStars_Last;
		UINT32 platformId max Client_Last;
		Common${ATF_THIN_NAMESPACE_SUFFIX}::AtfShared::LoginExtra extraData parseEndOptB4Me;
	};

	Message MSG_LOBBY_IP_CHECK
	{
		BYTE code max 6; // hard-coded in client/server
		if (code == 0)
		{
			UINT32 lobbyIp;
			UINT32 pingIp;
		}
		else
		{
			UINT32 errCode;
            UINT32 myIpi; // server does not use the information
		}
	};

	struct TableSize
	{
		BYTE min; // no limit
		BYTE max; // no limit
	};
	// NO LONGER SENT BY NATIVE CLIENT
	Message MSG_CLI_LOBBY_FIND_QUICKSTART_SNG
	{
		UINT32 sngId;
		BYTE game min HandTypeNone max HandType_Last;
		BYTE hiLo max 1;
		BYTE structure min StructLimit max PotStruct_Last;
		BYTE speed max SpeedDisplay_LastSlot-1;
		bool isPlayMoney;
		PString currency maxlen 7;   // old client still sends it 
		UINT32 minPlayersFrom max 1000000;
		UINT32 minPlayersTo max 1000000;
		UINT32 minBuyIn max 2000000000;
		UINT32 maxBuyIn max 2000000000;
		UINT32 flags parseEndOptB4Me; // no limit
		vector<TableSize> tableSizes maxsize 10240;
	};
	Message MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY
	{
		UINT32 sngId;
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
		else
		{
			UINT32 tournId;
			PString server;
			UINT32 tournFlags;
			UINT32 tournFlagsServInt;
			bool isStarted;
		}
	};

	struct DurationSize
	{
		UINT16 minD; // no limit
		UINT16 maxD; // no limit
	};
	// NO LONGER SENT BY NATIVE CLIENT
	Message MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2
	{
		UINT32 sngId;
		BYTE game min HandTypeNone max HandType_Last;
		BYTE hiLo max 1;
		BYTE structure min StructLimit max PotStruct_Last;
		UINT32 minPlayersFrom max 1000000;
		UINT32 minPlayersTo max 1000000;
		UINT64 minBuyIn max 1000000000000ull; // 1 trillion should be enough
		UINT64 maxBuyIn max 1000000000000ull; // 1 trillion should be enough
		UINT32 flags  max (qsftSpeedDisplayLast*2-1);
		vector<TableSize> tableSizes maxsize 10240;
		vector<DurationSize> durationSizes maxsize 10240 parseEndOptB4Me;
	};
	Message MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY
	{
        UINT32 sngId;
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
		else
		{
			UINT32 tournId;
			PString server;
			UINT32 tournFlags;
			UINT32 tournFlagsServInt;
			UINT32 sngScriptId;
			bool isStarted;
		}
	};

	Message MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3
	{
		UINT32 sngId;
		BYTE game min HandTypeNone max HandType_Last;
		BYTE hiLo max 1;
		BYTE structure max PotStruct_Last; // remove min StructLimit as client sometiems sends 0
		UINT32 minPlayersFrom max 1000000;
		UINT32 minPlayersTo max 1000000;
		UINT64 minBuyIn max 1000000000000ull; // 1 trillion should be enough
		UINT64 maxBuyIn max 1000000000000ull; // 1 trillion should be enough
		UINT32 flags max (qsftSpeedDisplayLast*2-1);
		vector<TableSize> tableSizes maxsize 10240;
		vector<DurationSize> durationSizes maxsize 10240 parseEndOptB4Me;
	};
	Message MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY
	{
        UINT32 sngId;
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
		else
		{
			UINT32 tournId;
			PString server;
			UINT32 tournFlags;
			UINT32 tournFlagsServInt;
			UINT32 sngScriptId;
			bool isStarted;
		}
	};

	Message MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT
	{
		BYTE tournStatType; // not used on the server side
		vector<UINT32> tournIds maxsize 10240;
		vector<UINT64> handIds maxsize 10240;
	};
	Message MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
	};

	Message MSG_LOBBY_GET_USER_CAPS
	{
	};
	Message MSG_LOBBY_GET_USER_CAPS_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
		else
		{
			UINT32 maxTablesLimitPM;
			UINT32 maxTablesLimitRM;
		}
	};

	Message MSG_LOBBY_DISABLE_SNG_AUTO_UNREG
	{
		bool setPriv;
	};

	Message MSG_LOBBY_TARGET_NEWS_DESKTOP
	{
		bool onlyTargetBanner parseEndOptB4Me;
		UINT32 newsTypeMask min eTargetNewsGeneral max eTargetNewsAll parseEndOptB4Me;
	};

	Message MSG_LOBBY_TARGET_NEWS_MOBILE
	{
		UINT32 clientDownloadSource; // flag, no limit on it
		UINT32 newsProductMask min eTargetNewsGeneral max eTargetNewsAll parseEndOptB4Me;
	};

	Message MSG_CLI_LOBBY_CONFIRM_POPUP
	{
		UINT32 confirmId; // no limit
		bool understood parseEndOptB4Me;
	};

	Message MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF
	{
		PString internalRef maxlen 500;
	};
	Message MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
		else
		{
			UINT32 tournamentId;
			PString server;
		}
	};

	Message MSG_LOBBY_GET_SIMILAR_SATELLITES
	{
		UINT32 tournId; // no limit
	};
	MsgBodyStruct SatelliteTourn
	{
		UINT32 tournamentId;
		SrvTime whenStart;
		BYTE game;
		BYTE structure;
		BYTE isHiLo;
		BYTE isPlayMoney;
		PString currency;
		UINT32 scalePM;
		UINT32 buyIn;
		UINT32 rake;
		UINT32 knockout;
		UINT32 fppBuyIn;
		UINT64 admissionPrice;
		PString admissionId;
		UINT32 status;
		UINT32 statusBits;
		UINT32 tournFlags;
		UINT64 tournFlags2;
		UINT32 servIntFlags;
		UINT32 maxPlayers;
		UINT32 players;
		PString server;
		PString serverObj;
	};
	Message MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
		else
		{
			vector<SatelliteTourn> satelliteTourns;
		}
	};

	Message MSG_LOBBY_JOIN_SEATFINDER
	{
		UINT32 seatFinderId; // no limit
		INT32 buyIn min 0 max 2000000000;
		PString password maxlen 1000;
		INT8 autoRebuyOpt min _autoRebuyDisabled max _autoRebuyBigBets;
		INT16 autoRebuyBigBets min 0 max 1000;
		INT16 fallUnderBigBets min 0 max 1000;
		INT16 fallUnderPercents min 0 max 100;
	};
	Message MSG_LOBBY_JOIN_SEATFINDER_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
			UINT32 seatFinderId;
		}
		else
		{
			UINT32 seatFinderId;
			INT32 placeInList;
		}
	};

	Message MSG_LOBBY_UNJOIN_SEATFINDER
	{
		UINT32 seatFinderId; // no limit
	};
	Message MSG_LOBBY_UNJOIN_SEATFINDER_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
			UINT32 seatFinderId;
		}
		else
		{
			UINT32 seatFinderId;
		}
	};

    Message MSG_LOBBY_GET_JOINED_SEATFINDERS
    {
           // empty
    };
    struct SeatFinder
    {
         UINT32 seatFinderId;
         INT32 placeInList;
         BYTE game;
         BYTE structure;
         BYTE isHiLo;
         BYTE isRealMoney;
         PString currency;
         INT32 loBet;
         INT32 hiBet;
    };
    Message MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY
    {
           vector<SeatFinder> seatFinders;
    };
       
    Message MSG_LOBBY_SEATFINDER_CHECK_CHIPS
    {
           UINT32 seatFinderId; // no limit
    };     
    MsgBodyStruct SeatFinderCli_MsgBodyStruct
    {
           UINT32 id;
           PString currency;
           INT8 isHiLo;
           INT32 loBet;
           INT32 hiBet;
           INT32 cap;
           INT8 game;
           INT8 limit;
           INT32 minBuyIn;
           INT32 maxBuyIn;
           INT32 ante;
           bool isFast;
           INT8 maxPlayers;
           INT32 chipsQuantum;
           INT32 scalePM;
           TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::TableStakes tableStakes parseEndOptB4Me;
           vector<INT64> variableAntes parseEndOptB4Me;
    };     
    Message MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY
    {
           INT16 errCode;
           if( errCode )
           {
                  PString errDescr;
                  // what is after is specific to the error
           }
           else
           {
                  INT32 availChips;
                  INT32 defaultBuyIn;
                  SeatFinderCli_MsgBodyStruct seatFinderCli;
                  INT32 userRollId;
                  BYTE clientServiceFlag;
                  INT64 playChips;
           }
    };
	
	Message MSG_LOBBY_UPDATE_DOB
	{
		PString notUsedStr maxlen 20;
		SrvDate dob;
	};
	Message MSG_LOBBY_UPDATE_DOB_REPLY
	{
		INT16 errCode;
		PString errDesc;
	};

	Message MSG_LOBBY_FIND_TOURN
	{
		UINT32 id; // no limit
	};
	Message MSG_LOBBY_FIND_TOURN_REPLY
	{
        INT16 errCode;
        if( errCode )
            {
                PString errDescr;
            }
            else
            {
                UINT32 tournamentId;
                PString server;
                UINT32 tournFlags;
                UINT64 tournFlags2;
           }
	};

	Message MSG_WEB_FIND_TOURN
	{
		UINT32 id; // no limit
	};
	Message MSG_WEB_FIND_TOURN_REPLY
	{
        INT16 errCode;
        if( errCode )
        {
            PString errDescr;
        }
        else
        {
            UINT32 tournamentId;
            PString server;
            UINT32 tournFlags;
            UINT64 tournFlags2;
        }
	};

	struct Text
	{
		PString text1 maxlen 10000;
		PString text2 maxlen 10000;
	};
	struct Name
	{
		PString name maxlen 10000;
	};
	Message MSG_LOBBY_CHAT_COMPL
	{
		UINT64 handId; // no limit
		PString tableName maxlen TABLE_NAME_LEN;
		PString comment maxlen 1000;
		UINT32 tableId32; // no limit
		vector<Text> texts maxsize 10000;
		vector<Name> names maxsize 10000;
		UINT32 tournId; // no limit
		PString finalTableText maxlen 10000 parseEndOptB4Me;
		UINT32 zoomReplayId parseEndOptB4Me; // no limit
		UINT64 tableId parseEndOptB4Me; // no limit
	};

	// Sent by server to client
	Message MSG_LOBBY_CLI_BOUNCED
	{
		PString email;
	};
	
	//Replied to server by client
	Message MSG_LOBBY_CLI_BOUNCED_REPLY
	{
		PString notUsedStr maxlen 20;
		BYTE reset max 1; // Actually behaves as boolean.
		bool sendValidationCode;
	};
	
	// Replied with MSG_LOBBY_CREATE_TOURNAMENT_REPLY
	Message MSG_LOBBY_CREATE_USERTOURN
	{
		PString notUsedStr maxlen 20;
		PString password maxlen 1000;
		BYTE game max HandType_Last;
		BYTE isHL max 1; // Behaves as boolean.
		BYTE limit max PotStruct_Last;
		BYTE mon max 12;
		BYTE day max 31;
		BYTE hour max 23;
		BYTE minute max 59;
		INT32 buyIn min -2000000000 max 20000000;
		INT32 rake min -2000000000 max 20000000;
		PString message maxlen 1000;
		PString name maxlen 200;
		BYTE olymp max 1; // Behaves as boolean
	};
	
	struct TournamentCreationError
	{
		PString userId;
		UINT32 error_code;
		PString errDescr;
	};
	Message MSG_LOBBY_CREATE_TOURNAMENT_REPLY
	{
		INT16 errCode;
		if( errCode != 0 )
		{
			PString errDescr;
		}
		else
		{
			UINT32 tournId;
			UINT32 timeLeft;
			vector<TournamentCreationError> errors;
			PString warning;
			PString restartWarning;
		}
	};
	
	Message MSG_LOBBY_REGISTER_TOURN_USER
	{
		UINT32 tournId; // no limits for id
		PString notUsedStr maxlen 20;
		UINT32 buyInRM max 2000000000;
		UINT32 buyInPlay; // no limits
		UINT32 buyInFpp max 2000000000;
		PString tournPwd maxlen 1000;
		BYTE useTicket max 1;
		UINT32 buyInT max 2000000000;
		UINT32 buyInW max 0; // not used any more
		CommMsgBody currencyContext maxlen 10000 parseEndOptB4Me; // not used
		PString isoCode maxlen 10 parseEndOptB4Me; // not used
		BYTE game parseEndOptB4Me; // not used
		BYTE highLo parseEndOptB4Me; // not used
		BYTE structure parseEndOptB4Me; // not used
		SrvTime startTime parseEndOptB4Me; // not used
		bool allowLateRegistration parseEndOptB4Me;
		bool preferRegistrationIntoLateTarget parseEndOptB4Me; 
	};
	
	Message MSG_LOBBY_REGISTER_TOURN_USER_REPLY
	{
		INT16 errCode;
		PString errDesc;
		if( !errCode || errCode == ALREADY_REGISTERED )
		{
			INT16 allIn;
			PString text;
			UINT32 tournId;
		}
		if( !errCode )
		{
			bool seatAvail;
			PString srv;
			PString socialToken;
			PString clientNotification;
		}
	};
	
	// this message has no reply message
	Message MSG_LOBBY_PUBLISH_VIP_STATUS
	{
		PString notUsedStr maxlen 20;
		bool setPriv;
	};

    // NO LONGER SENT BY NATIVE CLIENT
	// this message has no reply message
	Message MSG_LOBBY_HIDE_MOBILE_ICON
	{
		bool setPriv;
	};
	
	Message MSG_LOBBY_SET_TABLE_LIMITS2
	{
		PString notUsedStr maxlen 20;
		PString currency maxlen 5;
		INT32 limit1 min -1; // -1 means no limit, no max limit
		BYTE limitType1 min eTableLimitTypeAny max (numLimitTypes-1);
		INT32 limit2 min -1; // -1 means no limit, no max limit
		BYTE limitType2 min eTableLimitTypeAny max (numLimitTypes-1);
	};
	
	Message MSG_LOBBY_SET_TABLE_LIMITS2_REPLY
	{
		INT16 errCode;
		BYTE limitType1;
		INT16 errorCode1;
		if(errorCode1)
		{
			PString errDescr1;
		}
		else
		{
			bool effectiveNow1;
		}
		
		BYTE limitType2;
		INT16 errorCode2;
		
		if(errorCode2)
		{
			PString errDescr2;
		}
		else
		{
			bool effectiveNow2;
		}
		
		UINT32 limit;
		UINT32 waitingIncreaseLimitDays1;
		UINT32 waitingIncreaseLimitDays2;
	};
	
	Message MSG_LOBBY_SET_TOURN_LIMITS
	{
		PString notUsedStr maxlen 20;
		PString currency maxlen 5;
		INT32 limit1 min -1; // // -1 means no limit, no max limit
		BYTE limitType1 min eTableLimitTypeAny max (numLimitTypes-1);
		INT32 limit2 min -1; // // -1 means no limit, no max limit
		BYTE limitType2 min eTableLimitTypeAny max (numLimitTypes-1);	
	};
	
	Message MSG_LOBBY_SET_TOURN_LIMITS_REPLY
	{
		INT16 errCode;
		BYTE limitType1;
		INT16 errorCode1;
		if(errorCode1)
		{
			PString errDescr1;
		}
		else
		{
			bool effectiveNow1;
		}
		
		BYTE limitType2;
		INT16 errorCode2;
		
		if(errorCode2)
		{
			PString errDescr2;
		}
		else
		{
			bool effectiveNow2;
		}
		
		UINT32 limit;
		UINT32 waitingIncreaseLimitDays1;
		UINT32 waitingIncreaseLimitDays2;
	};
	
	Message MSG_LOBBY_IT_DOCUMENT
	{
		// empty message
	};
	
	Message MSG_LOBBY_IT_DOCUMENT_REPLY
	{
		INT16 errCode;
		PString sqlErr;
	};
	
	Message MSG_LOBBY_CLI_REMATCH_ACCEPT
	{
		UINT32 tournId; // id is not limited
		UINT32 buyInRM max 2000000000;
		UINT32 buyInPlay; // no limit
		UINT32 buyInFpp max 2000000000;
		UINT32 buyInT max 2000000000;
		UINT32 buyInW max 0;
		CommMsgBody currencyContext maxlen 10000; // not used
		UINT32 dummy32; // not used - no limit
		UINT64 dummy64; // not used - no limit
		BYTE useTicket max 1 parseEndOptB4Me;
	};
	
	Message MSG_LOBBY_CLI_REMATCH_DECLINE
	{
		UINT32 tournId; // no limit
	};
	// no reply
    
	Message MSG_LOBBY_MIGRATION_GET_INFO
	{
		PString notUsedStr maxlen 20;
		UINT32 type min eMigrationTypeTransfer max eMigrationTypeLast;
	};
	
	Message MSG_LOBBY_MIGRATION_GET_INFO_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			PString linkedUserId;
			PString linkedUserCity;
			INT32 cashBalance;
			INT32 tBalance;
			INT32 wBalance;
			INT32 fppBalance;
			INT32 monthlyVpp;
			INT32 yearlyVpp;
			INT32 tickets;
			INT32 bonuses;
			INT32 exchangeRate;
			INT32 migrationType;
			bool bonusEligible;
			SrvDate birthDate;
		}
	};
	
	Message MSG_LOBBY_MIGRATION_LINK
	{
		PString notUsedStr maxlen 20;
		UINT32 type min eMigrationTypeTransfer max eMigrationTypeLast;
		PString linkedUser maxlen 20;
		SrvDate dob;
	};
	
	Message MSG_LOBBY_MIGRATION_LINK_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			PString linkedUserId;
			PString linkedUserCity;
			INT32 cashBalance;
			INT32 tBalance;
			INT32 wBalance;
			INT32 fppBalance;
			INT32 monthlyVpp;
			INT32 yearlyVpp;
			INT32 tickets;
			INT32 bonuses;
			INT32 exchangeRate;
			INT32 migrationType;
			bool bonusEligible;
			SrvDate birthDate;
		}
	};

    // NO LONGER SENT BY NATIVE CLIENT
	Message MSG_LOBBY_MIGRATION_TRANSFER
	{
		// TODO: Ask payments group to put the limits for this message
		PString notUsedStr maxlen 20;
		UINT32 cashBalance max MAX_BANKROLL_SIZE;
		UINT32 tBalance max MAX_BANKROLL_SIZE;
		UINT32 wBalance max 0; // no longer used
		UINT32 fppBalance max MAX_BANKROLL_SIZE;
		UINT32 exchangeRate; // no limit
	};
	
	Message MSG_LOBBY_MIGRATION_TRANSFER_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			INT32 cashAmtEuro;
			UINT32 fppAmt;
			PString linkedUserId;
			PString city;
		}
	};
	
	Message MSG_LOBBY_MIGRATION_CONVERT
	{
		PString notUsedStr maxlen 20;
		UINT32 exchangeRate; // no limit
	};
	
	Message MSG_LOBBY_MIGRATION_CONVERT_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
	};
	
	Message MSG_LOBBY_SET_PROMO_IMAGE
	{
		bool doSet;
		PString promoImageCode maxlen 10000;
	};
	
	Message MSG_LOBBY_SET_PROMO_IMAGE_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
	};
	
	Message MSG_LOBBY_GET_PROMO_IMAGE
	{
		// empty
	};
	
	Message MSG_LOBBY_GET_PROMO_IMAGE_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			PString promoImageCode;
		}
	};
	
	Message MSG_LOBBY_FR_AVC_VALIDATE
	{
		UINT32 avc; // no limit
	};
	
	Message MSG_LOBBY_FR_AVC_VALIDATE_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			bool fullyValidated;
			bool is1stTime;
		}
	};
	
	Message MSG_LOBBY_FR_AVC_RESEND
	{
		// empty
	};
	
	Message MSG_LOBBY_FR_AVC_RESEND_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
	};
	
	Message MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP
	{
		PString notUsedStr maxlen 20;
		bool setPriv;
	};
    // no reply
	
	Message MSG_LOBBY_CANCEL_RESERVED_SEAT
	{
		UINT32 tableId32; // no limit
		BYTE seat max 10; 
		UINT64 tableId parseEndOptB4Me; // no limit
	};
	
	Message MSG_LOBBY_FIND_SIMILAR_TABLE
	{
		UINT32 tableId32; // no limit
		BYTE minPlayers max 10;
		UINT32 clientReqId parseEndOptB4Me; // no limit
		UINT32 searchFlags min eSeatManFlags_None max eSeatManFlags_Last parseEndOptB4Me;
		UINT64 currTableId parseEndOptB4Me; // no limit
	};
	
	Message MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
			UINT32 clientReqId;
			UINT32 searchFlags;
		}
		else
		{
			PString server;
			UINT32 tableId;
			BYTE seat;
			UINT32 clientReqId;
			UINT32 useDecrSearch;
			BYTE numOfPlayersInDecrSearchTable;
			UINT16 waitingForSeatReservationTimeout;
			bool isThereDealing;
			UINT64 tableId64;
			PString serverObject;
		}
	};
	
    // NO LONGER SENT BY NATIVE CLIENT
	Message MSG_LOBBY_FIND_SIMILAR_TABLE_STOP
	{
		// empty
	};
	
	Message MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE
	{
		UINT32 typeId; // no limit
		BYTE minPlayers max 10;
		UINT32 clientReqId; // no limit
		UINT32 searchFlags min eSeatManFlags_None max eSeatManFlags_Last;
	};
	
	// same as in unauth connection
	Message MSG_LOBBY_FIND_TABLE_TO_OBSERVE
	{
		UINT32 typeId; // id has no limits
		UINT32 clientReqId; // id has no limits
	};
	
	Message MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
			UINT32 clientReqId;
		}
		else
		{	PString server;
			UINT32 tableId;
			UINT32 clientReqId;
			UINT64 tableId64;
			PString serverObject;
		}
	};
	
	struct BuyInRange
	{
		UINT16 bottomMin; // no limit
		UINT16 topMin; // no limit
		UINT16 bottomMax; // no limit
		UINT16 topMax; // no limit
	};
	
	struct BuyInRanges
	{
		bool isRevert;
		vector<BuyInRange> buyInRanges maxsize 10240;
	};
	
	struct SeatManAdvSearchCriteria
	{
		UINT32 minAvgPot;
		UINT32 minAvgStack;
		BYTE minPlayersFlop;
		BYTE minVpip;
		UINT16 minHandsHour;
	};
	
    // NO LONGER SENT BY NATIVE CLIENT
	Message MSG_LOBBY_FIND_SEAT_MANAGER_TABLE
	{		
		BYTE minPlayers max 10; 
		BYTE game min 1 max HandType_Last;
		BYTE hiLo max 1;
		BYTE structure min StructLimit max PotStruct_Last;
		BYTE maxPlayersMin min 2 max 1000000;
		BYTE maxPlayersMax min 2 max 1000000;
		UINT32 minLoBet32 max 2000000000;
		UINT32 minHiBet32 max 2000000000;
		UINT32 maxLoBet32 max 2000000000;
		UINT32 maxHiBet32 max 2000000000;
		bool capOn;
		BYTE speedBM max eSeatManSpeed_Last;
		UINT32 currencyBM max eSeatManCurrency_Last;
		BuyInRanges buyInRanges;
		SeatManAdvSearchCriteria seatManAdvSearchCriteria parseEndOptB4Me;
		UINT32 clientReqId parseEndOptB4Me; // no limit
		UINT32 searchFlags min eSeatManFlags_None max eSeatManFlags_Last parseEndOptB4Me;
	};
	
	Message MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
			UINT32 clientReqId;
			UINT32 searchFlags;
		}
		else
		{
			PString server;
			UINT32 tableId;
			BYTE seat;
			UINT32 clientReqId;
			UINT32 useDecrSearch;
			BYTE numOfPlayersInDecrSearchTable;
			UINT16 waitingForSeatReservationTimeout;
			bool isThereDealing;
			UINT64 tableId64;
			PString serverObject;
		}
	};
	
	Message MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2
	{
		BYTE minPlayers max 10;
		BYTE game min 1 max HandType_Last;
		BYTE hiLo max 1;
		BYTE structure min 0 max PotStruct_Last; // mobile client sometimes sends 0
		BYTE maxPlayersMin min 2 max 1000000;
		BYTE maxPlayersMax min 2 max 1000000;
		INT64 minLoBet max 2000000000;
		INT64 minHiBet max 2000000000;
		INT64 maxLoBet max 2000000000;
		INT64 maxHiBet max 2000000000;
		bool capOn;
		BYTE speedBM max (eSeatManSpeed_Last*2-1); // can be a mask
		UINT32 currencyBM max eSeatManCurrency_Last;
		BuyInRanges buyInRanges;
		SeatManAdvSearchCriteria seatManAdvSearchCriteria parseEndOptB4Me;
		UINT32 clientReqId parseEndOptB4Me; // no limit
		UINT32 searchFlags min eSeatManFlags_None max eSeatManFlags_Last parseEndOptB4Me;
	};
	
	// Message MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2_REPLY same as MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY
	
	Message MSG_LOBBY_GET_BUYIN_LIMIT
	{
		// empty
	};
	
	Message MSG_LOBBY_GET_BUYIN_LIMIT_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			INT32 limit;
			UINT32 autoLimitHour;
		}
	};
	
	Message MSG_LOBBY_SET_BUYIN_LIMIT
	{
		INT32 limit min -1; // max is not limited
		UINT32 flags parseEndOptB4Me; // this param is sent by client, but not used by server
		UINT64 flagsEx parseEndOptB4Me; // this param is sent by client, but not used by server
	};
	
	Message MSG_LOBBY_SET_BUYIN_LIMIT_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			bool effectiveNow;
		}
	};
	
	Message MSG_LOBBY_GET_BUYIN_LIMIT_EX
	{
		// empty
	};
	
	MsgBodyStruct LimitEx
	{
		INT32 limitType min 0 max 1000;
		INT32 amount min -1;
	};
	
	Message MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			l2vector<LimitEx> limitEx;
		}
	};
	
	Message MSG_LOBBY_SET_BUYIN_LIMIT_EX
	{
		l2vector<LimitEx> limitEx maxsize 10000;
	};
	
	MsgBodyStruct LimitExReply
	{
		INT32 limitType;
		INT16 errCodeLimit;
		if(errCodeLimit)
		{
			PString errMsg;
		}
		else
		{
			INT32 amount;
			bool effectiveNow;
		}
	};
	
	Message MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			vector<LimitExReply> limitExReply;
		}
	};
	
	// NO LONGER SENT BY NATIVE CLIENT
	Message MSG_LOBBY_HISTORY_REQUEST
	{
		PString notUsed maxlen 20;
		INT8 type min HAND_HISTORY_LAST_HANDS max HAND_HISTORY_TOURNAMENT; //see: HAND_HISTORY_* defines in dbm.h  These values could be changed to an enum.
		if(type == HAND_HISTORY_LAST_HANDS)
		{
			UINT32 numRequested min 1 max MAX_HANDS_ALLOWED; //see: dbm.h
		}
        else if (type == HAND_HISTORY_LAST_SECONDS)
        {
            UINT32 numRequested min 1 max 604800; // 1 week
        }
        else if (type == HAND_HISTORY_TOURNAMENT)
        {
            UINT32 numRequested; // no limit for tournid
        } 
		else if (type == HAND_HISTORY_HAND_IDS)
		{
			UINT32 numRequested min 1 max 1; //1 only valid value
			UINT32 handId; // no limit
			UINT64 handId64 parseEndOptB4Me; // no limit
		}
		UINT32 locale min LOCALE_DEFAULT max MAX_LOCALES parseEndOptB4Me; //see: i18n.localedef.h
	};
	
	Message MSG_LOBBY_HISTORY_REQUEST_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
		else
		{
			PString email;
		}
	};
	
	Message MSG_LOBBY_ACTIVATE_ACCOUNT
	{
		PString notUsed maxlen 20; //Not used
		UINT32 unique; // no limit
	};
	
	Message MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
		else
		{
			bool firstTimeActivation;
			UINT32 siteId;
			PString promoName;
			bool usePromoDeposit;
			PString email;
			PString country;
			UINT32 locale;
		}
	};
	
	Message MSG_LOBBY_CANCEL_USERTOURN
	{
		PString notUsedStr maxlen 20;
		UINT32 tournId; // id has no limits
	};
	
	Message MSG_LOBBY_CANCEL_USERTOURN_REPLY
	{
		INT16 errCode;
		PString errDescr;
	};
	
	Message MSG_LOBBY_CLIENT_QUEST // reply message MSG_LOBBY_CLIENT_QUEST_REPLY is not used
	{
		UINT32 type max 1000000;
		PString descr maxlen 200; // UserProp str value in DB
		UINT32 fpp max 2000000000;
	};
	
	Message MSG_LOBBY_DONT_SHOW_WHERE
	{
		PString notUsedStr maxlen 20;
		bool b;
	};
	
	Message MSG_LOBBY_DONT_SHOW_WHERE_REPLY
	{
		INT16 err_code;
		PString errDescr;
		bool dontShowWhere;
	};
	
	Message MSG_LOBBY_DONT_SHOW_PERSONAL_INFO
	{
		PString notUsedStr maxlen 20;
		bool setPriv;
	};
    // no reply
	
	Message MSG_LOBBY_SET_TOURN_EMAIL_FLAGS
	{
		PString notUsedStr maxlen 20;
		bool b;
	};
	
	Message MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY
	{
		INT16 err_code;
		PString errDescr;
		bool dontShowWhere;
	};

	
	//--------------------------------------------- MSG_LOBBY_USER_TOURNTICKETS2 ------------------------------------------
	MsgBodyStruct TournTicketInfoBody // reply only
	{
		UINT32 ticketId;
		PString admissionCode;
		bool isMulti;
		UINT32 ticketTypeValue;
		CommSrvTime issued;
		CommSrvTime expDate;
		PString currency;
		INT32 numTourns;
		UINT32 ticketTypeFlags;
	};
	
	Message MSG_LOBBY_USER_TOURNTICKETS2 // 472, PYR-14750
	{
		PString unusedStr maxlen USER_NAME_LEN parseEndOptB4Me;
	};
	
	Message MSG_LOBBY_USER_TOURNTICKETS2_REPLY // 473
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			vector<TournTicketInfoBody> tickets;
		}
	};
	
	//--------------------------------------------- MSG_LOBBY_TICKET_TOURNTIDS ------------------------------------------
	MsgBodyStruct SingleTournamentBody // reply only
	{
		UINT32 tournamentId;
		UINT32 status;
		UINT32 tournFlags;
		CommSrvTime whenStart;
		UINT32 entrants;
		UINT32 minPlayers;
		UINT32 buyIn;
		BYTE game;
		BYTE isHiLo;
		BYTE structure;
		BYTE isPlayMoney;
		PString server;
		UINT32 rake;
		UINT32 knockout;
		UINT32 fppBuyIn;
		BYTE isRestricted;
		PString currency;
		UINT32 statusBits;
		I18nPString name;
		UINT64 tournFlags2; // PYR-28752
	};
	
	Message MSG_LOBBY_TICKET_TOURNTIDS // 474, PYR-14750
	{
		PString unusedStr maxlen USER_NAME_LEN parseEndOptB4Me;
		UINT32 ticketId; // no limit
	};
	
	Message MSG_LOBBY_TICKET_TOURNTIDS_REPLY // 475
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			UINT32 ticketId;
			vector<SingleTournamentBody> tournaments;
		}
	};
	
	//--------------------------------------------- MSG_LOBBY_CLI_TEAM_PS_ONLINE ------------------------------------------
	MsgBodyStruct TeamOnlineBody // reply only
	{
		bool isPlay;
		PString userId;
		PString name;
		PString country;
		PString displayCountry;
	};
	
	Message MSG_LOBBY_CLI_TEAM_PS_ONLINE // 332
	{
		// empty
	};
	
	Message MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY // 333
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			vector<TeamOnlineBody> teams;
		}
	};
	
	//--------------------------------------------- MSG_LOBBY_TIMEZONE_SET ------------------------------------------
	Message MSG_LOBBY_TIMEZONE_SET // 383
	{
		PString unusedStr maxlen USER_NAME_LEN;
        // change max from eTzCUSTOM_end to 65537 as old client still sends it
		UINT32 timezone min eTzUTC max 65537; // FIXME (tz&0xFFFF) is used in code for checking
		PString tzName maxlen 100;
	};
	
	Message MSG_LOBBY_TIMEZONE_SET_REPLY // 384
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			UINT32 timeZone;
		}
	};
	
	//--------------------------------------------- MSG_LOBBY_EXCLUDE_PLAYER ------------------------------------------
	Message MSG_LOBBY_EXCLUDE_PLAYER // 335
	{
		PString unusedStr maxlen USER_NAME_LEN;
		INT32 days min -12 max 36500; // ~100 years //#10979 if the value is negative, it means hours, not days
		UINT32 dummyFlags; // no limit, not used by server
		UINT64 dummyFlags2; // no limit, not used by server
		bool groupSelfExclusion parseEndOptB4Me;
		BYTE version parseEndOptB4Me;
	};
	
	Message MSG_LOBBY_EXCLUDE_PLAYER_REPLY // 336
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			INT32 days;
			CommSrvTime until;
			INT32 requestedDays;
			UINT32 seFlags;
		}
	};
	
	//--------------------------------------------- MSG_LOBBY_INTELLIPOKER_SIGNUP ------------------------------------------
	Message MSG_LOBBY_INTELLIPOKER_SIGNUP // 357
	{
		PString unusedStr maxlen USER_NAME_LEN;
		PString pwd maxlen 100;
		PString language maxlen 100 parseEndOptB4Me;
	};
	
	Message MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY // 358
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			UINT32 code;
			PString info;
			PString url;
			PString urlCaption;
		}
	};
	
	//--------------------------------------------- MSG_LOBBY_INTELLIPOKER_PWD ------------------------------------------
	Message MSG_LOBBY_INTELLIPOKER_PWD // 359
	{
		PString unusedStr maxlen USER_NAME_LEN;
		PString pwd maxlen 100;
	};
	
	Message MSG_LOBBY_INTELLIPOKER_PWD_REPLY // 360
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			UINT32 code;
			PString info;
			PString url;
			PString urlCaption;
		}
	};
	
	//--------------------------------------------- MSG_LOBBY_GET_CONSENTS ------------------------------------------
	MsgBodyStruct ConsentBody // reply only
	{
		UINT32 id;
		UINT32 status;
		PString empty;
		PString empty2;
	};
	
	Message MSG_LOBBY_GET_CONSENTS // 1107
	{
		PString unusedStr maxlen 20 parseEndOptB4Me;
	};
	
	Message MSG_LOBBY_GET_CONSENTS_REPLY // 1108
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			vector<ConsentBody> consents;
		}
	};

	Message MSG_LOBBY_USER_STATS
	{
		PString notUsedStr maxlen 20;
		INT32 numHands min 1 max 2000;
	};
	
	Message MSG_LOBBY_USER_STATS_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
		else
		{
			PString email;
		}
	};
	
	Message MSG_LOBBY_TOURN_STATS
	{
		BYTE requestType min TOURN_STATS_TOURN_ID max TOURN_STATS_TOURN_ID_NOSTAT;
		PString notUsedStr maxlen 20;
		UINT32 tournIdOrCount; // no limit (application logic checks the limit)
	};
	
	Message MSG_LOBBY_TOURN_STATS_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
		else
		{
			PString email;
		}
	};
	
	Message MSG_LOBBY_LOGOUT
	{
		UINT32 flags parseEndOptB4Me;
	};
    Message MSG_LOBBY_LOGOUT_CONFIRM
    {
        // empty
    };
	
	Message MSG_LOBBY_ADMIN_INFO
	{
		PString message maxlen 10000; //Outbound message from Lobby to Client
	};
	
	Message MSG_LOBBY_ADMIN_INFO_REPLY
	{
		// Inbound message from Client to Lobby
	};
	
	Message MSG_LOBBY_GET_TLB
	{
		PString notUsed maxlen 20;
		SrvDate dateFrom;
		SrvDate dateTo;
	};
	
	Message MSG_LOBBY_GET_TLB_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
		else
		{
			PString email;
		}
	};
	Message MSG_LOBBY_USER_PROPS
	{
		// empty
	};
	
	struct StellarBonus
	{
		UINT32 vppThreshold;
		UINT32 amount;
	};
	
	struct MilestoneBonusOld
	{
		UINT32 vppThreshold;
	};
	
	MsgBodyStruct MilestoneBonusNew
	{
		CommMsgBody
		{
			UINT32 license;
			UINT32 vppThreshold;
			UINT32 amount;
		};
	};
	
	struct VIPLevel
	{
		UINT32 statusId;
		UINT32 minFpp;
		UINT32 fppBonusRate;
		UINT32 vipToKeepYearlyStatus;
	};
	
	struct RawVIPLevel
	{
		CommMsgBody
		{
			UINT32 statusId;
			UINT32 type;
			UINT32 minFpp;
			UINT32 fppBonusRate;
			UINT32 vipToKeepYearlyStatus;
			UINT32 lastMonthForYearly;
			UINT32 missableMonthsYearly;
		};
	};
	
	struct CountryData
	{
		PString country;
		vector<PString> prefixes;
	};
	
	MsgBodyStruct CountriesMsgBody
	{
		vector<CountryData> countries;
	};
	
	MsgBodyStruct ClientFeatureVisibility
	{
		UINT64 clientFeatureVisibilityOnMask;
		UINT64 clientFeatureVisibilityOffMask;
		UINT64 clientFeatureVisibilityOnMask2;
		UINT64 clientFeatureVisibilityOffMask2;
	};
	
	struct HallOfFameLevel
	{
		UINT32 levelId;
		UINT32 ltVppThreshold;
		BYTE flags;
	};
	
	MsgBodyStruct HallOfFameLevels
	{
		vector<HallOfFameLevel> levels;
	};
	
	Message MSG_LOBBY_USER_PROPS_REPLY
	{
		UINT32 privs;
		UINT32 flags;
		UINT32 locale;
		PString country;
		UINT32 emLocale;
		UINT64 privs2;
		UINT32 vipStatus;
		UINT32 timeZone;
		UINT32 origUserIntId;
		UINT32 userIntId;
		UINT64 flags2;
		UINT32 vppCounter1;
		UINT32 vppCounter2;
		vector<StellarBonus> stellarBonuses;
		bool uiStatsAllowed;
		bool rmTransersAllowed;
		UINT32 obsolete; //Always zero
		BYTE findSimilarTableFlag;
		vector<MilestoneBonusOld> milestoneBonusesOld;
		vector<VIPLevel> vipLevels;
		bool hgEnabled;
		UINT32 cppCountr3;
		bool fastDepositEnabled;
		CountriesMsgBody countries;
		bool handSharingEnabledForSiteAndBrand;
		bool itAccVerificationOpen; //Always true
		bool allowSmsValidationForNewInstallId;
		PString userWebId;
		vector<RawVIPLevel> rawVIPLevels;
		UINT32 chatModeratorRestrictions;
		vector<MilestoneBonusNew> milestoneBonusesNew;
		bool allowSmsPwdReset;
		HallOfFameLevels hallOfFameLevels;
		UINT32 lifetimeFpp;
		UINT32 otherFlags;
		ClientFeatureVisibility clientFeatureVisibility;
		UINT64 privs3;
		SrvTime registered;
		PString state;
		UINT32 licenseId parseEndOptB4Me;
	};
	
	struct TournInfo
	{
		SrvTime startTime;
		UINT32 tournId;
		UINT32 buyIn;
		UINT32 fppBuyIn;
		UINT32 rake;
		BYTE game;
		BYTE isHiLo;
		BYTE structure;
		BYTE isPlayMoney;
		BYTE isSitAndGo;
		BYTE isRunning;
	};
	
	Message MSG_LOBBY_FIND_TOURN_REG
	{
		PString notUsed maxlen 20;
	};
	
	Message MSG_LOBBY_FIND_TOURN_REG_REPLY
	{
		INT16 errCode;
		vector<TournInfo> tournInfo;
		vector<PString> serverName;
		vector<PString> currency;
	};
	
	MsgBodyStruct TournInfo2
	{
		CommMsgBody
		{
			TournInfo tournInfo;
			PString serverAddress;
			PString currency;
			UINT32 clubId;
		};
		UINT32 scalePm;
		UINT64 flags2;
	};
	
	Message MSG_LOBBY_FIND_TOURN_REG2
	{
		PString notUsed maxlen 20;
	};
	
	Message MSG_LOBBY_FIND_TOURN_REG2_REPLY
	{
		INT16 errCode;
		vector<TournInfo2> tournInfo;
	};
	
	Message MSG_LOBBY_FIND_WAIT
	{
		PString notUsed maxlen 20;
	};

	struct TableInfo
	{
		UINT32 tableId;
		UINT32 order;
	};
	
	struct ServerInfo
	{
		PString serverName;
		PString serverObject;
	};
	
	Message MSG_LOBBY_FIND_WAIT_REPLY
	{
		INT16 errCode;
		vector<TableInfo> tables;
		vector<ServerInfo> servers;
		vector<UINT32> totals;
	};

	struct LeaderPoints
	{
		PString player;
		UINT32 points;
	};
		
	struct TlbVector
	{
		PString lastTimestamp;
		BYTE tlbType;
		SrvTime timeFrom;
		SrvTime timeTo;
		vector<LeaderPoints> leaderPoints;
		UINT32 userPlace;
		UINT32 userPoints;
	};
		
	Message MSG_LOBBY_CLI_GET_TLB_STANDIDNS2
	{
		PString notUsed maxlen 20;
		BYTE tlbListType min eTlbYear max TlbStandingsListType_last;
		PString uniqueIdStr maxlen 30;
	};
	
	Message MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
		else
		{
			TlbVector tableVector;
			SrvTime lastUpdated;
		}
	};
	
	struct PlayerTableData
	{
		PString serverAddress;
		PString serverInstance;
		UINT32 tableIdOld;
		PString tableName;
		PString tableSpecialSuffix;
		bool isPlayMoney;
		UINT32 loBet;
		UINT32 hiBet;
		BYTE game;
		BYTE structure;
		bool isHiLo;
		PString currency;
		UINT32 scalePm;
		UINT64 tableId;
		BYTE maxPlayers;
	};
	
	struct PlayerTournData
	{
		PString serverAddress;
		UINT32 tournId;
		bool isSitAndGo;
		bool isPlayMoney;
		UINT32 buyIn;
		UINT32 rake;
		UINT32 fppBuyIn;
		BYTE game;
		BYTE structure;
		bool isHiLo;
		UINT32 status;
		PString currency;
		UINT32 scalePm;
		bool needAdmission;
		INT64 admissionPrice;
		bool isPrivate;
	};
	
	struct PlayerBlitzData
	{
		PString serverAddress;
		PString serverInstance;
		UINT32 blitzId;
		PString blitzName;
		PString blitzSpecialSuffix;
		bool isPlayMoney;
		UINT32 loBet;
		UINT32 hiBet;
		BYTE game;
		BYTE structure;
		bool isHiLo;
		PString currency;
		UINT32 scalePm;
	};
	
	Message MSG_LOBBY_FIND_PLAYER2
	{
		PString notUsed maxlen 20;
		PString playerName maxlen 20;
	};
	
	Message MSG_LOBBY_FIND_PLAYER2_REPLY
	{
		PString playerName;
		vector<PlayerTableData> playerTables;
		vector<PlayerTournData> playerTourns;
		vector<PlayerBlitzData> playerBlitz;
	};
	
	Message MSG_LOBBY_FIND_PLAYER3
	{
		PString playerName maxlen 1000; // client does not limit the userId properly
	};
	
	Message MSG_LOBBY_FIND_PLAYER3_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
		else
		{
			PString playerName;
			vector<PlayerTableData> playerTables;
			vector<PlayerTournData> playerTourns;
			vector<PlayerBlitzData> playerBlitz;
		}
	};
	
	Message MSG_WEB_FIND_PLAYER2
	{
		PString notUsed maxlen 20;
		PString playerName maxlen 20;
	};
	
	Message MSG_WEB_FIND_PLAYER2_REPLY
	{
		PString playerName;
		vector<PlayerTableData> playerTables;
		vector<PlayerTournData> playerTourns;
		vector<PlayerBlitzData> playerBlitz;
	};
	
	Message MSG_WEB_FIND_PLAYER3
	{
		PString playerName maxlen 20;
	};
	
	Message MSG_WEB_FIND_PLAYER3_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
		else
		{
			PString playerName;
			vector<PlayerTableData> playerTables;
			vector<PlayerTournData> playerTourns;
			vector<PlayerBlitzData> playerBlitz;
		}
	};
	
	MsgBodyStruct Reacquisition
	{
		PString ticketId;
		SrvTime when;
		UINT32 reacquisition;
		UINT32 cost;
	};
	
	MsgBodyStruct ITTournData
	{
		PString itId;
		PString ticketId;
		UINT32 cost;
		UINT32 status;
		vector<Reacquisition> reacquisitions;
	};
	
	struct ITTournVectorData
	{
		UINT32 tournId;
		ITTournData tournData;
	};
	
	MsgBodyStruct ITAddOn
	{
		PString ticketId;
		SrvTime when;
		UINT32 reacquisition;
		UINT32 addOn;
	};
	
	MsgBodyStruct ITTableData
	{
		vector<ITAddOn> addOns;
		UINT64 tableId;
	};
	
	struct ITTableVectorData
	{
		UINT32 tableId;
		ITTableData tableData;
	};
	
	Message MSG_LOBBY_FIND_TOURN_REG_IT
	{
		PString notUsed maxlen 20;
	};
	
	Message MSG_LOBBY_FIND_TOURN_REG_IT_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDesc;
		}
		else
		{
			vector<ITTournVectorData> tournVectorData;
			vector<ITTableVectorData> tableVectorData;
		}
	};
	
	Message MSG_LOBBY_FIND_TOURN_IT
	{
		PString notUsed maxlen 20;
	};
	
	Message MSG_LOBBY_FIND_TOURN_IT_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDesc;
		}
		else
		{
			vector<ITTournVectorData> tournVectorData;
			vector<ITTableVectorData> tableVectorData;
		}
	};
	
	Message MSG_LOBBY_VALIDATE_MOBILE
	{
		PString notUsedStr maxlen 20;
		UINT32 unique; // no limit
	};
	
	Message MSG_LOBBY_VALIDATE_MOBILE_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
	};
	
	Message MSG_LOBBY_GET_SELFEXCLUDED_STR
	{
		PString originalError maxlen 1000 parseEndOptB4Me;
	};
	
	Message MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY
	{
		INT16 errCode;
		PString errDesc;
	};
	
	Message MSG_LOBBY_VALIDATE_NEWINSTALL
	{
		UINT32 validationCode; // no limit
	};
	
	Message MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDesc;
		}
	};
	
	Message MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE
	{
		//
	};
	
	Message MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDesc;
		}
	};
	
	struct UserProperties
	{
		INT32 propType;
		INT32 propInt;
		PString propStr;
		SrvTime when;
	};
	
	MsgBodyStruct PhoneValidationInfo
	{
		BYTE validation;
		PString countryCode;
		PString verifiedNumber;
		PString dialingInfo;
		PString phone;
	};
	
	Message MSG_LOBBY_GET_USER_INFO
	{
		PString notUsedStr maxlen 20;
		bool needImage parseEndOptB4Me;
		bool needPwdUpdate parseEndOptB4Me;
		
	};
		
	Message MSG_LOBBY_GET_USER_INFO_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
		else
		{
			PString fullName1;
			PString fullName2;
			PString fullName3;
			PString fullName4;
			PString fullName5;
			PString fullName6;
			PString fullName7;
			PString fullName8;
			PBlock imgData;
			UINT32 priv1;
			UINT32 priv2;
			UINT32 priv3;
			UINT32 priv4;
			UINT32 priv5;
			UINT32 priv6;
			UINT32 priv7;
			SrvDate dob;
			PString phoneNum;
			PhoneValidationInfo phoneValidation;
			PString firstName;
			PString onlyLastName;
			PString fiscalCode;
			vector<UserProperties> userProps;
			UINT64 flags2;
			UINT32 imgId;
			PString sex;
			PString mobile;
			bool addressStateLocked;
			SrvTime registered;
			PhoneValidationInfo mobilePhoneValidation;
			PString promoImgCode;
			UINT32 pwdUpdateTime;
			UINT64 privileges3;
			INT8 missedMonths;
			SrvDate vipStatusUntil;
			INT8 missableMonthsYearly;
			vector<BrandProt${ATF_THIN_NAMESPACE_SUFFIX}::AvatarImg> gameAvatars; // PYR-54689
		}
	};

	Message MSG_LOBBY_WAITING_LIST
	{
		PString notUsedStr maxlen 20;
		BYTE listType; // no limit
		UINT32 tableId32; // no limit
		UINT64 tableId64 parseEndOptB4Me; // no limit
	};
	
	Message MSG_LOBBY_WAITING_LIST_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			//CLIENT FIX NEEDED: The format here depends on information not available in the message. Mainly whether or not the table is play money.
			PString errDescr;
		}
		else
		{
			UINT32 tableId32;
			UINT64 tableId64;
		}
	};
	
    // server does absolutely nothing, even no reply, should be removed
	Message MSG_LOBBY_LIST_REMOVE
	{
		// empty
	};
	
	Message MSG_LOBBY_LEAVE_WAITING_LIST
	{
		PString notUsedStr maxlen 20;
		BYTE listType; // no limit
		UINT32 tableId32; // no limit
		UINT64 tableId64 parseEndOptB4Me; // no limit
	};
	
	Message MSG_LOBBY_LEAVE_WAITING_LIST_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
		else
		{
			UINT32 tableId32;
			UINT64 tableId;
		}
	};
	
	Message MSG_LOBBY_LEAVE_ALL_WAITING_LISTS
	{
		INT32 flags parseEndOptB4Me; // no limit
	};
	
	Message MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
		else
		{
			UINT32 numTables;
			UINT32 flags;
		}
	};
	
	Message MSG_WAITING_INVITED_REPLY
	{
		PString notUsedStr maxlen 20;
		UINT32 tableId32; // no limit
		BYTE answer max 1;
		bool leaveLists parseEndOptB4Me;
		UINT64 tableId64 parseEndOptB4Me; // no limit
	};
};


namespace lobby_unauth
{	
    // NO LONGER SENT BY NATIVE CLIENT (old client still sends it)
	Message MSG_LOBBY_CLIENT_ERROR
	{		
		PString userId maxlen 20;
		PString info maxlen 100000;
	};
	Message MSG_LOBBY_CLIENT_ERROR_REPLY
	{
		// empty
	};
	
	Message MSG_LOBBY_REPORT_INSTALL
	{
		PString installId maxlen 100; 
		PString wuid maxlen 1000;
		PString promo maxlen 1000;
		PString whenStr maxlen 100 parseEndOptB4Me;
		UINT32 siteId max PokerStars_Last parseEndOptB4Me;
		UINT32 platformId max Client_Last;
		Common${ATF_THIN_NAMESPACE_SUFFIX}::AtfShared::LoginExtra extraData parseEndOptB4Me;
	};
	// no reply
	
	// NO LONGER SENT BY NATIVE CLIENT (definitely useless)
	Message MSG_LOBBY_PROMO_COUNTRY
	{
		// empty
	};
	Message MSG_LOBBY_PROMO_COUNTRY_REPLY
	{
		UINT32 uint32Val; // always 0
	};
	
	Message MSG_LOBBY_GET_SATELLITES_TO_TOURN
	{
		UINT32 id; // no limit
		UINT32 locale max MAX_LOCALES parseEndOptB4Me;
	};
	struct SatelliteStruct
	{
		UINT32 tournamentId;
		PString server;
		PString serverObj; // always empty
		PString publisherName; // always empty
		CommSrvTime whenStart;
		UINT32 buyIn;
		UINT32 rake;
		UINT32 fppBuyIn;
		BYTE isRestricted;
		BYTE isPwdProtected;
		PString localeStr;
		PString admissionId;
		BYTE isPlayMoney;
		UINT32 satelliteTarget;
		UINT32 minPlayers;
		UINT32 tournFlags;
		BYTE game;
		BYTE isHiLo;
		BYTE structure;
		UINT32 tournMask;
		UINT32 tournSites;
		UINT32 whenStartEncode;
		UINT32 tournMask2;
		UINT32 status;
		UINT32 entrants;	
	};
	Message MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY
	{
		UINT32 id;
		vector<SatelliteStruct> satellites;
	};
	
	Message MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX
	{
		UINT32 id; // no limit
		UINT32 locale max MAX_LOCALES;
	};
	MsgBodyStruct SatelliteStructEx
	{
		UINT32 tournamentId;
		PString server;
		PString serverObj; // always empty
		PString publisherName; // always empty
		CommSrvTime whenStart;
		UINT32 buyIn;
		UINT32 rake;
		UINT32 fppBuyIn;
		BYTE isRestricted;
		BYTE isPwdProtected;
		PString localeStr;
		PString admissionId;
		BYTE isPlayMoney;
		UINT32 satelliteTarget;
		UINT32 minPlayers;
		UINT32 tournFlags;
		BYTE game;
		BYTE isHiLo;
		BYTE structure;
		UINT32 tournMask;
		PSiteMask tournSites;
		UINT32 whenStartEncode;
		UINT32 tournMask2;
		UINT32 status;
		UINT32 entrants;	
	};
	Message MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY
	{
		UINT32 id;
		vector<SatelliteStructEx> satellites;
	};

	Message MSG_LOBBY_GET_TABLE_BY_ID
	{
		UINT32 tableId32; // no limit
		UINT32 tournId; // no limit
		UINT64 tableId default tableId32 parseEndOptB4Me;
	};
	Message MSG_LOBBY_GET_TABLE_BY_ID_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
		else
		{
			PString server;
			PString serverObj;
		}
	};	
	
	Message MSG_LOBBY_GET_CAPTCHA
	{
		PString userId maxlen 20;
	};
	Message MSG_LOBBY_GET_CAPTCHA_REPLY
	{
		INT16 errCode;
		if( errCode )
		{
			PString errDescr;
		}
		else
		{
			PBlock image;
			PBlock checksum;
		}	
	};	
	
	// no check on monet message as it will be obsoleted soon and it is not using async-call to internal server modules
	// Message MSG_LOBBY_REPORT_UN_AUTH_MONET
	
	// same as in auth connection
	Message MSG_LOBBY_CHALLENGE_QUESTION
	{
		UINT32 locale max MAX_LOCALES;
	};
	struct ChallengeQuestion
	{
		UINT32 id;
		PString txt;
	};
	Message MSG_LOBBY_CHALLENGE_QUESTION_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
		else
		{
			l2vector<ChallengeQuestion> challenges;
		}
	};
	
	Message MSG_LOBBY_UPDATE_BY_LICENSE
	{
		UINT32 platform max Client_Last;
		UINT32 license max eLicenceLast;
		UINT32 site max PokerStars_Last parseEndOptB4Me;
	};
	Message MSG_LOBBY_UPDATE_BY_LICENSE_REPLY
	{
		INT16 errCode;
		if ( errCode )
		{
			PString errDesc;
		}
		else
		{
			PString updateFolder;
		}		
	};
	
	// same as in auth connection
	Message MSG_LOBBY_FIND_TABLE_TO_OBSERVE
	{
		UINT32 typeId; // no limit
		UINT32 clientReqId; // no limit
	};	
	Message MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
			UINT32 clientReqId;
		}
		else
		{	PString server;
			UINT32 tableId;
			UINT32 clientReqId;
			UINT64 tableId64;
			PString serverObject;
		}
	};
	
	struct Publication
	{
		PString name maxlen 1000;
	};
	Message MSG_LOBBY_CHECK_PUBLICATIONS
	{
		vector<Publication> publications maxsize 1000 parseEndOptB4Me;
	};
	Message MSG_LOBBY_CHECK_PUBLICATIONS_REPLY
	{
		vector<bool> publicationExist;
	};
};

namespace Personalization
{
	MsgBodyStruct GameConnectInfo
	{
		UINT64 gameId;
		PString server;
		PString serverObject;
		UINT32 scriptId;
		UINT32 category;		// enum GameCategoryTypes
		bool shouldOpen;
	};
	
	Message MSG_LOBBY_PS_USER_AT
	{
		PString userId maxlen 200;
	};
	
	Message MSG_LOBBY_PS_USER_AT_REPLY
	{
		vector<GameConnectInfo> tableConnInfo;
		vector<GameConnectInfo> tournConnInfo;
		vector<GameConnectInfo> blitzTournConnInfo;
		vector<GameConnectInfo> blitzConnInfo;
	};
	
	struct TableStaticDataStruct
	{
		UINT64	tableId;
		PString name;
		PString serverAddress;
		PString serverInstance;
		BYTE	isPlayMoney;
		BYTE	game;
		BYTE	isHiLo;
		BYTE	maxPlayers;
		UINT32	tableFlags;	
		UINT32  tableInstanceFlags;
		UINT16	chatLang;
		BYTE	structure;
		UINT32	loBet;
		UINT32	hiBet;
		UINT32	ante;
		UINT32	cap;
		PString	specialName;
		PString	currency;
		UINT32	minChipsLimit;
		UINT32	maxBuyIn;
		BYTE	icon;
		BYTE	filter;
		bool	countryRestrictionInverted;
		vector<PString> restrictedCountries;
		UINT32	scalePM;
		UINT32	defaultBuyIn;
		UINT64	tableFlags2;	
		UINT32	brandMask;
		INT32	poolBlockMinHands;
		UINT32  tableTypeId;
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::TableStakes tableStakes;
		vector<INT64> variableAntes;
		PSiteMask visibilityMaskEx;
	};
	
	MsgBodyStruct TableData
	{
		TableStaticDataStruct staticData;
	};
	
	Message MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS
	{
		vector<UINT64> tableIds;
	};
	
	Message MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY
	{
		INT16 errCode;
		if (errCode)
		{
			PString errDescr;
		}
		else
		{
			vector<TableData> tables;
		}
	};
};
