/**
 * globalpublisherclientprot_thin.cpp
 *
 * This file was auto-generated from globalpublisherclientprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin globalpublisherclientprot.txt
 */
 
#include "globalpublisherclientprot_thin.h"

//=================================================================
//                Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA
//=================================================================

GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA()
{
	clear();
}

void GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA::clear()
{
}

bool GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA::equals(const Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA& _o) const
{
	return true;
}

const char *GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA).append(")");
	return _buf.c_str();
}

void GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA::composeMsg(CommMsgBody& _msg) const
{
}

void GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY
//=================================================================

GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY(Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
{
}

GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY& GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY::operator=(Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
	}
	return *this;
}

#endif

void GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY::clear()
{
	errCode = 0;
	errString.clear();
}

bool GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY::equals(const Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

const char *GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

void GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errString);
	}
}

void GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errString);
	}
}

/*static*/ void GlobalPublisherClient::Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    BuildAndVersionPublData
//=================================================================

GlobalPublisherClient::BuildAndVersionPublData::BuildAndVersionPublData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::BuildAndVersionPublData::BuildAndVersionPublData(BuildAndVersionPublData&& _o)
	: build(std::move(_o.build))
	, version(std::move(_o.version))
{
}

GlobalPublisherClient::BuildAndVersionPublData& GlobalPublisherClient::BuildAndVersionPublData::operator=(BuildAndVersionPublData&& _o)
{
	if(this != &_o)
	{
		build = std::move(_o.build);
		version = std::move(_o.version);
	}
	return *this;
}

#endif

void GlobalPublisherClient::BuildAndVersionPublData::clear()
{
	build.clear();
	version.clear();
}

bool GlobalPublisherClient::BuildAndVersionPublData::equals(const BuildAndVersionPublData& _o) const
{
	return build.equals(_o.build) &&
		version.equals(_o.version);
}

const char *GlobalPublisherClient::BuildAndVersionPublData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("build=");
	_buf.append(build);
	_buf.append(',');
	_buf.append("version=");
	_buf.append(version);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::BuildAndVersionPublData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(build);
	_msg.composeString(version);
}

void GlobalPublisherClient::BuildAndVersionPublData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(build);
	_parser.parseStringP(version);
}

/*static*/ void GlobalPublisherClient::BuildAndVersionPublData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "build"); size_t szBuild = strlen(_dummy);
	AtfValidator::validateInt(_descr, "build", szBuild, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "version"); size_t szVersion = strlen(_dummy);
	AtfValidator::validateInt(_descr, "version", szVersion, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ServerTimePublData
//=================================================================

GlobalPublisherClient::ServerTimePublData::ServerTimePublData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::ServerTimePublData::ServerTimePublData(ServerTimePublData&& _o)
	: srvTime(std::move(_o.srvTime))
	, encodedTime(std::move(_o.encodedTime))
{
}

GlobalPublisherClient::ServerTimePublData& GlobalPublisherClient::ServerTimePublData::operator=(ServerTimePublData&& _o)
{
	if(this != &_o)
	{
		srvTime = std::move(_o.srvTime);
		encodedTime = std::move(_o.encodedTime);
	}
	return *this;
}

#endif

void GlobalPublisherClient::ServerTimePublData::clear()
{
	srvTime.setNull();
	encodedTime = 0;
}

bool GlobalPublisherClient::ServerTimePublData::equals(const ServerTimePublData& _o) const
{
	return srvTime.equals(_o.srvTime) &&
		encodedTime == _o.encodedTime;
}

const char *GlobalPublisherClient::ServerTimePublData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("srvTime=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, srvTime);
	_buf.append(',');
	_buf.append("encodedTime=");
	_buf.appendUint64(encodedTime);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::ServerTimePublData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(srvTime);
	_msg.composeUINT64(encodedTime);
}

void GlobalPublisherClient::ServerTimePublData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(srvTime);
	_parser.parseUINT64(encodedTime);
}

/*static*/ void GlobalPublisherClient::ServerTimePublData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	SrvTime srvTime; _parser.parseSrvTime(srvTime);
	AtfValidator::validateSrvDateTime(_descr, "srvTime", srvTime, _checker, __FILE__, __LINE__);
	UINT64 encodedTime; _parser.parseUINT64(encodedTime);
	AtfValidator::validateUint(_descr, "encodedTime", encodedTime, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    DataMiningPublData
//=================================================================

GlobalPublisherClient::DataMiningPublData::DataMiningPublData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::DataMiningPublData::DataMiningPublData(DataMiningPublData&& _o)
	: dataMining(std::move(_o.dataMining))
{
}

GlobalPublisherClient::DataMiningPublData& GlobalPublisherClient::DataMiningPublData::operator=(DataMiningPublData&& _o)
{
	if(this != &_o)
	{
		dataMining = std::move(_o.dataMining);
	}
	return *this;
}

#endif

void GlobalPublisherClient::DataMiningPublData::clear()
{
	dataMining = 0;
}

bool GlobalPublisherClient::DataMiningPublData::equals(const DataMiningPublData& _o) const
{
	return dataMining == _o.dataMining;
}

const char *GlobalPublisherClient::DataMiningPublData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("dataMining=");
	_buf.appendUint(dataMining);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::DataMiningPublData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(dataMining);
}

void GlobalPublisherClient::DataMiningPublData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(dataMining);
}

/*static*/ void GlobalPublisherClient::DataMiningPublData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 dataMining; _parser.parseUINT32(dataMining);
	AtfValidator::validateInt(_descr, "dataMining", dataMining, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ServerConnectionInfoPublData
//=================================================================

GlobalPublisherClient::ServerConnectionInfoPublData::ServerConnectionInfoPublData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::ServerConnectionInfoPublData::ServerConnectionInfoPublData(ServerConnectionInfoPublData&& _o)
	: address(std::move(_o.address))
	, instance(std::move(_o.instance))
	, serverStatus(std::move(_o.serverStatus))
{
}

GlobalPublisherClient::ServerConnectionInfoPublData& GlobalPublisherClient::ServerConnectionInfoPublData::operator=(ServerConnectionInfoPublData&& _o)
{
	if(this != &_o)
	{
		address = std::move(_o.address);
		instance = std::move(_o.instance);
		serverStatus = std::move(_o.serverStatus);
	}
	return *this;
}

#endif

void GlobalPublisherClient::ServerConnectionInfoPublData::clear()
{
	address.clear();
	instance.clear();
	serverStatus = eGlobalPublisherAvailabilityStatus_Unknown;
}

bool GlobalPublisherClient::ServerConnectionInfoPublData::equals(const ServerConnectionInfoPublData& _o) const
{
	return address.equals(_o.address) &&
		instance.equals(_o.instance) &&
		serverStatus == _o.serverStatus;
}

const char *GlobalPublisherClient::ServerConnectionInfoPublData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("instance=");
	_buf.append(instance);
	_buf.append(',');
	_buf.append("serverStatus=");
	_buf.appendInt(serverStatus);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::ServerConnectionInfoPublData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(address);
	_msg.composeString(instance);
	_msg.composeINT32(serverStatus);
}

void GlobalPublisherClient::ServerConnectionInfoPublData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(address);
	_parser.parseStringP(instance);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(serverStatus);
}

/*static*/ void GlobalPublisherClient::ServerConnectionInfoPublData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "address", szAddress, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "instance"); size_t szInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "instance", szInstance, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT32 serverStatus; _parser.parseINT32(serverStatus);
	AtfValidator::validateInt(_descr, "serverStatus", serverStatus, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    MonetData
//=================================================================

GlobalPublisherClient::MonetData::MonetData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::MonetData::MonetData(MonetData&& _o)
	: name(std::move(_o.name))
	, value(std::move(_o.value))
{
}

GlobalPublisherClient::MonetData& GlobalPublisherClient::MonetData::operator=(MonetData&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		value = std::move(_o.value);
	}
	return *this;
}

#endif

void GlobalPublisherClient::MonetData::clear()
{
	name.clear();
	value.clear();
}

bool GlobalPublisherClient::MonetData::equals(const MonetData& _o) const
{
	return name.equals(_o.name) &&
		value.size() == _o.value.size() && memcmp(value.ptr(), _o.value.ptr(), value.size()) == 0;
}

const char *GlobalPublisherClient::MonetData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("value=");
	ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, value);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::MonetData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(name);
	_msg._composeVarBlock(value.ptr(), value.size());
}

void GlobalPublisherClient::MonetData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
	_parser.parsePBlock(value);
}

/*static*/ void GlobalPublisherClient::MonetData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	const BYTE* value; size_t szValue; _parser._parseVarBlock(value, szValue);  /*value*/
	AtfValidator::validateInt(_descr, "value", szValue, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    MonetPublData
//=================================================================

GlobalPublisherClient::MonetPublData::MonetPublData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::MonetPublData::MonetPublData(MonetPublData&& _o)
	: vMonetData(std::move(_o.vMonetData))
{
}

GlobalPublisherClient::MonetPublData& GlobalPublisherClient::MonetPublData::operator=(MonetPublData&& _o)
{
	if(this != &_o)
	{
		vMonetData = std::move(_o.vMonetData);
	}
	return *this;
}

#endif

void GlobalPublisherClient::MonetPublData::clear()
{
	vMonetData.clear();
}

bool GlobalPublisherClient::MonetPublData::equals(const MonetPublData& _o) const
{
	return vMonetData.equals(_o.vMonetData);
}

const char *GlobalPublisherClient::MonetPublData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("vMonetData=");
	vMonetData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::MonetPublData::composeMsg(CommMsgBody& _msg) const
{
	vMonetData.composeMsg(_msg);
}

void GlobalPublisherClient::MonetPublData::parseMsg(CommMsgParser& _parser)
{
	vMonetData.parseMsg(_parser);
}

/*static*/ void GlobalPublisherClient::MonetPublData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szVMonetData = ThinAtf::LAtfVector< MonetData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("vMonetData"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "vMonetData", szVMonetData, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    NVP
//=================================================================

GlobalPublisherClient::NVP::NVP()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::NVP::NVP(NVP&& _o)
	: name(std::move(_o.name))
	, value(std::move(_o.value))
{
}

GlobalPublisherClient::NVP& GlobalPublisherClient::NVP::operator=(NVP&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		value = std::move(_o.value);
	}
	return *this;
}

#endif

void GlobalPublisherClient::NVP::clear()
{
	name.clear();
	value.clear();
}

bool GlobalPublisherClient::NVP::equals(const NVP& _o) const
{
	return name.equals(_o.name) &&
		value.equals(_o.value);
}

const char *GlobalPublisherClient::NVP::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("value=");
	_buf.append(value);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::NVP::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(NVP())) // not empty
	{
		_body.composeString(name);
		_body.composeString(value);
	}

	_msg.composeMsgBody(_body);
}

void GlobalPublisherClient::NVP::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(name);
	_parser0.parseStringP(value);
}

/*static*/ void GlobalPublisherClient::NVP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "value"); size_t szValue = strlen(_dummy);
	AtfValidator::validateInt(_descr, "value", szValue, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    HelpSupportPortalPublData
//=================================================================

GlobalPublisherClient::HelpSupportPortalPublData::HelpSupportPortalPublData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::HelpSupportPortalPublData::HelpSupportPortalPublData(HelpSupportPortalPublData&& _o)
	: helpSupportPortal(std::move(_o.helpSupportPortal))
{
}

GlobalPublisherClient::HelpSupportPortalPublData& GlobalPublisherClient::HelpSupportPortalPublData::operator=(HelpSupportPortalPublData&& _o)
{
	if(this != &_o)
	{
		helpSupportPortal = std::move(_o.helpSupportPortal);
	}
	return *this;
}

#endif

void GlobalPublisherClient::HelpSupportPortalPublData::clear()
{
	helpSupportPortal.clear();
}

bool GlobalPublisherClient::HelpSupportPortalPublData::equals(const HelpSupportPortalPublData& _o) const
{
	return helpSupportPortal.equals(_o.helpSupportPortal);
}

const char *GlobalPublisherClient::HelpSupportPortalPublData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("helpSupportPortal=");
	helpSupportPortal.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::HelpSupportPortalPublData::composeMsg(CommMsgBody& _msg) const
{
	helpSupportPortal.composeMsg(_msg);
}

void GlobalPublisherClient::HelpSupportPortalPublData::parseMsg(CommMsgParser& _parser)
{
	helpSupportPortal.parseMsg(_parser);
}

/*static*/ void GlobalPublisherClient::HelpSupportPortalPublData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szHelpSupportPortal = ThinAtf::LAtfVector< NVP, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("helpSupportPortal"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "helpSupportPortal", szHelpSupportPortal, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ATFExtendedFlag
//=================================================================

GlobalPublisherClient::ATFExtendedFlag::ATFExtendedFlag()
{
	clear();
}

void GlobalPublisherClient::ATFExtendedFlag::clear()
{
	featureMask = 0;
	featureMask2 = 0;
}

bool GlobalPublisherClient::ATFExtendedFlag::equals(const ATFExtendedFlag& _o) const
{
	return featureMask == _o.featureMask &&
		featureMask2 == _o.featureMask2;
}

const char *GlobalPublisherClient::ATFExtendedFlag::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("featureMask=");
	_buf.appendUint64(featureMask);
	_buf.append(',');
	_buf.append("featureMask2=");
	_buf.appendUint64(featureMask2);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::ATFExtendedFlag::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ATFExtendedFlag())) // not empty
	{
		_body.composeUINT64(featureMask);
		_body.composeUINT64(featureMask2);
	}

	_msg.composeMsgBody(_body);
}

void GlobalPublisherClient::ATFExtendedFlag::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(featureMask);
	_parser0.parseUINT64(featureMask2);
}

/*static*/ void GlobalPublisherClient::ATFExtendedFlag::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT64 featureMask; _parser0.parseUINT64(featureMask);
	AtfValidator::validateUint(_descr, "featureMask", featureMask, _checker, __FILE__, __LINE__);
	UINT64 featureMask2; _parser0.parseUINT64(featureMask2);
	AtfValidator::validateUint(_descr, "featureMask2", featureMask2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ATFClientDeviceSpecificFeature
//=================================================================

GlobalPublisherClient::ATFClientDeviceSpecificFeature::ATFClientDeviceSpecificFeature()
{
	clear();
}

void GlobalPublisherClient::ATFClientDeviceSpecificFeature::clear()
{
	clientDevice = 0;
	featuresMask.clear();
}

bool GlobalPublisherClient::ATFClientDeviceSpecificFeature::equals(const ATFClientDeviceSpecificFeature& _o) const
{
	return clientDevice == _o.clientDevice &&
		featuresMask.equals(_o.featuresMask);
}

const char *GlobalPublisherClient::ATFClientDeviceSpecificFeature::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("clientDevice=");
	_buf.appendUint(clientDevice);
	_buf.append(',');
	_buf.append("featuresMask=");
	featuresMask.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::ATFClientDeviceSpecificFeature::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ATFClientDeviceSpecificFeature())) // not empty
	{
		_body.composeUINT32(clientDevice);
		featuresMask.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void GlobalPublisherClient::ATFClientDeviceSpecificFeature::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(clientDevice);
	featuresMask.parseMsg(_parser0);
}

/*static*/ void GlobalPublisherClient::ATFClientDeviceSpecificFeature::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 clientDevice; _parser0.parseUINT32(clientDevice);
	AtfValidator::validateInt(_descr, "clientDevice", clientDevice, _checker, __FILE__, __LINE__);
	PString _descbuf;
	ATFExtendedFlag::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("featuresMask"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ATFClientTypeSpecificFeature
//=================================================================

GlobalPublisherClient::ATFClientTypeSpecificFeature::ATFClientTypeSpecificFeature()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::ATFClientTypeSpecificFeature::ATFClientTypeSpecificFeature(ATFClientTypeSpecificFeature&& _o)
	: clientType(std::move(_o.clientType))
	, featuresMask(std::move(_o.featuresMask))
	, clientDeviceSpecificFeatures(std::move(_o.clientDeviceSpecificFeatures))
{
}

GlobalPublisherClient::ATFClientTypeSpecificFeature& GlobalPublisherClient::ATFClientTypeSpecificFeature::operator=(ATFClientTypeSpecificFeature&& _o)
{
	if(this != &_o)
	{
		clientType = std::move(_o.clientType);
		featuresMask = std::move(_o.featuresMask);
		clientDeviceSpecificFeatures = std::move(_o.clientDeviceSpecificFeatures);
	}
	return *this;
}

#endif

void GlobalPublisherClient::ATFClientTypeSpecificFeature::clear()
{
	clientType = 0;
	featuresMask.clear();
	clientDeviceSpecificFeatures.clear();
}

bool GlobalPublisherClient::ATFClientTypeSpecificFeature::equals(const ATFClientTypeSpecificFeature& _o) const
{
	return clientType == _o.clientType &&
		featuresMask.equals(_o.featuresMask) &&
		clientDeviceSpecificFeatures.equals(_o.clientDeviceSpecificFeatures);
}

const char *GlobalPublisherClient::ATFClientTypeSpecificFeature::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("clientType=");
	_buf.appendUint(clientType);
	_buf.append(',');
	_buf.append("featuresMask=");
	featuresMask.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientDeviceSpecificFeatures=");
	clientDeviceSpecificFeatures.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::ATFClientTypeSpecificFeature::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ATFClientTypeSpecificFeature())) // not empty
	{
		_body.composeUINT32(clientType);
		featuresMask.composeMsg(_body);
		clientDeviceSpecificFeatures.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void GlobalPublisherClient::ATFClientTypeSpecificFeature::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(clientType);
	featuresMask.parseMsg(_parser0);
	clientDeviceSpecificFeatures.parseMsg(_parser0);
}

/*static*/ void GlobalPublisherClient::ATFClientTypeSpecificFeature::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 clientType; _parser0.parseUINT32(clientType);
	AtfValidator::validateInt(_descr, "clientType", clientType, _checker, __FILE__, __LINE__);
	PString _descbuf;
	ATFExtendedFlag::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("featuresMask"), _fieldsWithUnparsedContent);
	int szClientDeviceSpecificFeatures = ThinAtf::LAtfVector< ATFClientDeviceSpecificFeature, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("clientDeviceSpecificFeatures"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "clientDeviceSpecificFeatures", szClientDeviceSpecificFeatures, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ATFClientPlatformSpecificFeature
//=================================================================

GlobalPublisherClient::ATFClientPlatformSpecificFeature::ATFClientPlatformSpecificFeature()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::ATFClientPlatformSpecificFeature::ATFClientPlatformSpecificFeature(ATFClientPlatformSpecificFeature&& _o)
	: clientPlatform(std::move(_o.clientPlatform))
	, featuresMask(std::move(_o.featuresMask))
	, clientTypeSpecificFeatures(std::move(_o.clientTypeSpecificFeatures))
{
}

GlobalPublisherClient::ATFClientPlatformSpecificFeature& GlobalPublisherClient::ATFClientPlatformSpecificFeature::operator=(ATFClientPlatformSpecificFeature&& _o)
{
	if(this != &_o)
	{
		clientPlatform = std::move(_o.clientPlatform);
		featuresMask = std::move(_o.featuresMask);
		clientTypeSpecificFeatures = std::move(_o.clientTypeSpecificFeatures);
	}
	return *this;
}

#endif

void GlobalPublisherClient::ATFClientPlatformSpecificFeature::clear()
{
	clientPlatform = 0;
	featuresMask.clear();
	clientTypeSpecificFeatures.clear();
}

bool GlobalPublisherClient::ATFClientPlatformSpecificFeature::equals(const ATFClientPlatformSpecificFeature& _o) const
{
	return clientPlatform == _o.clientPlatform &&
		featuresMask.equals(_o.featuresMask) &&
		clientTypeSpecificFeatures.equals(_o.clientTypeSpecificFeatures);
}

const char *GlobalPublisherClient::ATFClientPlatformSpecificFeature::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("clientPlatform=");
	_buf.appendUint(clientPlatform);
	_buf.append(',');
	_buf.append("featuresMask=");
	featuresMask.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientTypeSpecificFeatures=");
	clientTypeSpecificFeatures.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::ATFClientPlatformSpecificFeature::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ATFClientPlatformSpecificFeature())) // not empty
	{
		_body.composeUINT32(clientPlatform);
		featuresMask.composeMsg(_body);
		clientTypeSpecificFeatures.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void GlobalPublisherClient::ATFClientPlatformSpecificFeature::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(clientPlatform);
	featuresMask.parseMsg(_parser0);
	clientTypeSpecificFeatures.parseMsg(_parser0);
}

/*static*/ void GlobalPublisherClient::ATFClientPlatformSpecificFeature::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 clientPlatform; _parser0.parseUINT32(clientPlatform);
	AtfValidator::validateInt(_descr, "clientPlatform", clientPlatform, _checker, __FILE__, __LINE__);
	PString _descbuf;
	ATFExtendedFlag::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("featuresMask"), _fieldsWithUnparsedContent);
	int szClientTypeSpecificFeatures = ThinAtf::LAtfVector< ATFClientTypeSpecificFeature, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("clientTypeSpecificFeatures"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "clientTypeSpecificFeatures", szClientTypeSpecificFeatures, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ATFSiteFeaturesVisibility
//=================================================================

GlobalPublisherClient::ATFSiteFeaturesVisibility::ATFSiteFeaturesVisibility()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::ATFSiteFeaturesVisibility::ATFSiteFeaturesVisibility(ATFSiteFeaturesVisibility&& _o)
	: brandId(std::move(_o.brandId))
	, siteId(std::move(_o.siteId))
	, clientFeaturesMask(std::move(_o.clientFeaturesMask))
	, clientPlatformSpecificFeatures(std::move(_o.clientPlatformSpecificFeatures))
{
}

GlobalPublisherClient::ATFSiteFeaturesVisibility& GlobalPublisherClient::ATFSiteFeaturesVisibility::operator=(ATFSiteFeaturesVisibility&& _o)
{
	if(this != &_o)
	{
		brandId = std::move(_o.brandId);
		siteId = std::move(_o.siteId);
		clientFeaturesMask = std::move(_o.clientFeaturesMask);
		clientPlatformSpecificFeatures = std::move(_o.clientPlatformSpecificFeatures);
	}
	return *this;
}

#endif

void GlobalPublisherClient::ATFSiteFeaturesVisibility::clear()
{
	brandId = 0;
	siteId = 0;
	clientFeaturesMask.clear();
	clientPlatformSpecificFeatures.clear();
}

bool GlobalPublisherClient::ATFSiteFeaturesVisibility::equals(const ATFSiteFeaturesVisibility& _o) const
{
	return brandId == _o.brandId &&
		siteId == _o.siteId &&
		clientFeaturesMask.equals(_o.clientFeaturesMask) &&
		clientPlatformSpecificFeatures.equals(_o.clientPlatformSpecificFeatures);
}

const char *GlobalPublisherClient::ATFSiteFeaturesVisibility::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("clientFeaturesMask=");
	clientFeaturesMask.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientPlatformSpecificFeatures=");
	clientPlatformSpecificFeatures.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::ATFSiteFeaturesVisibility::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ATFSiteFeaturesVisibility())) // not empty
	{
		_body.composeUINT32(brandId);
		_body.composeUINT32(siteId);
		clientFeaturesMask.composeMsg(_body);
		clientPlatformSpecificFeatures.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void GlobalPublisherClient::ATFSiteFeaturesVisibility::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(brandId);
	_parser0.parseUINT32(siteId);
	clientFeaturesMask.parseMsg(_parser0);
	clientPlatformSpecificFeatures.parseMsg(_parser0);
}

/*static*/ void GlobalPublisherClient::ATFSiteFeaturesVisibility::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateInt(_descr, "brandId", brandId, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	ATFExtendedFlag::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("clientFeaturesMask"), _fieldsWithUnparsedContent);
	int szClientPlatformSpecificFeatures = ThinAtf::LAtfVector< ATFClientPlatformSpecificFeature, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("clientPlatformSpecificFeatures"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "clientPlatformSpecificFeatures", szClientPlatformSpecificFeatures, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ATFCountryException
//=================================================================

GlobalPublisherClient::ATFCountryException::ATFCountryException()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::ATFCountryException::ATFCountryException(ATFCountryException&& _o)
	: country(std::move(_o.country))
	, featureMaskOn(std::move(_o.featureMaskOn))
	, featureMaskOff(std::move(_o.featureMaskOff))
	, brandIdMask(std::move(_o.brandIdMask))
	, siteVisibilityMask(std::move(_o.siteVisibilityMask))
	, siteVisibilityMaskEx(std::move(_o.siteVisibilityMaskEx))
{
}

GlobalPublisherClient::ATFCountryException& GlobalPublisherClient::ATFCountryException::operator=(ATFCountryException&& _o)
{
	if(this != &_o)
	{
		country = std::move(_o.country);
		featureMaskOn = std::move(_o.featureMaskOn);
		featureMaskOff = std::move(_o.featureMaskOff);
		brandIdMask = std::move(_o.brandIdMask);
		siteVisibilityMask = std::move(_o.siteVisibilityMask);
		siteVisibilityMaskEx = std::move(_o.siteVisibilityMaskEx);
	}
	return *this;
}

#endif

void GlobalPublisherClient::ATFCountryException::clear()
{
	country.clear();
	featureMaskOn.clear();
	featureMaskOff.clear();
	brandIdMask = 0;
	siteVisibilityMask = 0;
	siteVisibilityMaskEx.clear();
}

bool GlobalPublisherClient::ATFCountryException::equals(const ATFCountryException& _o) const
{
	return country.equals(_o.country) &&
		featureMaskOn.equals(_o.featureMaskOn) &&
		featureMaskOff.equals(_o.featureMaskOff) &&
		brandIdMask == _o.brandIdMask &&
		siteVisibilityMask == _o.siteVisibilityMask &&
		siteVisibilityMaskEx.equals(_o.siteVisibilityMaskEx);
}

const char *GlobalPublisherClient::ATFCountryException::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("featureMaskOn=");
	featureMaskOn.toTraceString(_buf);
	_buf.append(',');
	_buf.append("featureMaskOff=");
	featureMaskOff.toTraceString(_buf);
	_buf.append(',');
	_buf.append("brandIdMask=");
	_buf.appendUint(brandIdMask);
	_buf.append(',');
	_buf.append("siteVisibilityMask=");
	_buf.appendUint(siteVisibilityMask);
	_buf.append(',');
	_buf.append("siteVisibilityMaskEx=");
	siteVisibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::ATFCountryException::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ATFCountryException())) // not empty
	{
		_body.composeString(country);
		featureMaskOn.composeMsg(_body);
		featureMaskOff.composeMsg(_body);
		_body.composeUINT32(brandIdMask);
		_body.composeUINT32(siteVisibilityMask);
		siteVisibilityMaskEx.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void GlobalPublisherClient::ATFCountryException::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(country);
	featureMaskOn.parseMsg(_parser0);
	featureMaskOff.parseMsg(_parser0);
	_parser0.parseUINT32(brandIdMask);
	_parser0.parseUINT32(siteVisibilityMask);
	if(_parser0.parseEnded()) return;
	siteVisibilityMaskEx.parseMsg(_parser0);
}

/*static*/ void GlobalPublisherClient::ATFCountryException::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	PString _descbuf;
	ATFExtendedFlag::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("featureMaskOn"), _fieldsWithUnparsedContent);
	ATFExtendedFlag::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("featureMaskOff"), _fieldsWithUnparsedContent);
	UINT32 brandIdMask; _parser0.parseUINT32(brandIdMask);
	AtfValidator::validateInt(_descr, "brandIdMask", brandIdMask, _checker, __FILE__, __LINE__);
	UINT32 siteVisibilityMask; _parser0.parseUINT32(siteVisibilityMask);
	AtfValidator::validateInt(_descr, "siteVisibilityMask", siteVisibilityMask, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("siteVisibilityMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ATFClientFeaturesVisibilityEx
//=================================================================

GlobalPublisherClient::ATFClientFeaturesVisibilityEx::ATFClientFeaturesVisibilityEx()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::ATFClientFeaturesVisibilityEx::ATFClientFeaturesVisibilityEx(ATFClientFeaturesVisibilityEx&& _o)
	: siteFeaturesVisibilities(std::move(_o.siteFeaturesVisibilities))
	, countryExceptions(std::move(_o.countryExceptions))
{
}

GlobalPublisherClient::ATFClientFeaturesVisibilityEx& GlobalPublisherClient::ATFClientFeaturesVisibilityEx::operator=(ATFClientFeaturesVisibilityEx&& _o)
{
	if(this != &_o)
	{
		siteFeaturesVisibilities = std::move(_o.siteFeaturesVisibilities);
		countryExceptions = std::move(_o.countryExceptions);
	}
	return *this;
}

#endif

void GlobalPublisherClient::ATFClientFeaturesVisibilityEx::clear()
{
	siteFeaturesVisibilities.clear();
	countryExceptions.clear();
}

bool GlobalPublisherClient::ATFClientFeaturesVisibilityEx::equals(const ATFClientFeaturesVisibilityEx& _o) const
{
	return siteFeaturesVisibilities.equals(_o.siteFeaturesVisibilities) &&
		countryExceptions.equals(_o.countryExceptions);
}

const char *GlobalPublisherClient::ATFClientFeaturesVisibilityEx::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("siteFeaturesVisibilities=");
	siteFeaturesVisibilities.toTraceString(_buf);
	_buf.append(',');
	_buf.append("countryExceptions=");
	countryExceptions.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::ATFClientFeaturesVisibilityEx::composeMsg(CommMsgBody& _msg) const
{
	siteFeaturesVisibilities.composeMsg(_msg);
	countryExceptions.composeMsg(_msg);
}

void GlobalPublisherClient::ATFClientFeaturesVisibilityEx::parseMsg(CommMsgParser& _parser)
{
	siteFeaturesVisibilities.parseMsg(_parser);
	countryExceptions.parseMsg(_parser);
}

/*static*/ void GlobalPublisherClient::ATFClientFeaturesVisibilityEx::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szSiteFeaturesVisibilities = ThinAtf::LAtfVector< ATFSiteFeaturesVisibility, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("siteFeaturesVisibilities"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "siteFeaturesVisibilities", szSiteFeaturesVisibilities, _checker, __FILE__, __LINE__);
	int szCountryExceptions = ThinAtf::LAtfVector< ATFCountryException, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("countryExceptions"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "countryExceptions", szCountryExceptions, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ClientVersionInfo
//=================================================================

GlobalPublisherClient::ClientVersionInfo::ClientVersionInfo()
{
	clear();
}

void GlobalPublisherClient::ClientVersionInfo::clear()
{
	platformId = 0;
	siteId = 0;
	minClientVersion = 0;
}

bool GlobalPublisherClient::ClientVersionInfo::equals(const ClientVersionInfo& _o) const
{
	return platformId == _o.platformId &&
		siteId == _o.siteId &&
		minClientVersion == _o.minClientVersion;
}

const char *GlobalPublisherClient::ClientVersionInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("platformId=");
	_buf.appendUint(platformId);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("minClientVersion=");
	_buf.appendUint(minClientVersion);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::ClientVersionInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ClientVersionInfo())) // not empty
	{
		_body.composeUINT32(platformId);
		_body.composeUINT32(siteId);
		_body.composeUINT32(minClientVersion);
	}

	_msg.composeMsgBody(_body);
}

void GlobalPublisherClient::ClientVersionInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(platformId);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(minClientVersion);
}

/*static*/ void GlobalPublisherClient::ClientVersionInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 platformId; _parser0.parseUINT32(platformId);
	AtfValidator::validateInt(_descr, "platformId", platformId, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	UINT32 minClientVersion; _parser0.parseUINT32(minClientVersion);
	AtfValidator::validateInt(_descr, "minClientVersion", minClientVersion, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MinClientVersionPublication
//=================================================================

GlobalPublisherClient::MinClientVersionPublication::MinClientVersionPublication()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::MinClientVersionPublication::MinClientVersionPublication(MinClientVersionPublication&& _o)
	: versions(std::move(_o.versions))
{
}

GlobalPublisherClient::MinClientVersionPublication& GlobalPublisherClient::MinClientVersionPublication::operator=(MinClientVersionPublication&& _o)
{
	if(this != &_o)
	{
		versions = std::move(_o.versions);
	}
	return *this;
}

#endif

void GlobalPublisherClient::MinClientVersionPublication::clear()
{
	versions.clear();
}

bool GlobalPublisherClient::MinClientVersionPublication::equals(const MinClientVersionPublication& _o) const
{
	return versions.equals(_o.versions);
}

const char *GlobalPublisherClient::MinClientVersionPublication::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("versions=");
	versions.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::MinClientVersionPublication::composeMsg(CommMsgBody& _msg) const
{
	versions.composeMsg(_msg);
}

void GlobalPublisherClient::MinClientVersionPublication::parseMsg(CommMsgParser& _parser)
{
	versions.parseMsg(_parser);
}

/*static*/ void GlobalPublisherClient::MinClientVersionPublication::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szVersions = ThinAtf::LAtfVector< ClientVersionInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("versions"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "versions", szVersions, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CurrencyRate
//=================================================================

GlobalPublisherClient::CurrencyRate::CurrencyRate()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::CurrencyRate::CurrencyRate(CurrencyRate&& _o)
	: currencyCode(std::move(_o.currencyCode))
	, convRateM(std::move(_o.convRateM))
{
}

GlobalPublisherClient::CurrencyRate& GlobalPublisherClient::CurrencyRate::operator=(CurrencyRate&& _o)
{
	if(this != &_o)
	{
		currencyCode = std::move(_o.currencyCode);
		convRateM = std::move(_o.convRateM);
	}
	return *this;
}

#endif

void GlobalPublisherClient::CurrencyRate::clear()
{
	currencyCode.clear();
	convRateM = 0;
}

bool GlobalPublisherClient::CurrencyRate::equals(const CurrencyRate& _o) const
{
	return currencyCode.equals(_o.currencyCode) &&
		convRateM == _o.convRateM;
}

const char *GlobalPublisherClient::CurrencyRate::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currencyCode=");
	_buf.append(currencyCode);
	_buf.append(',');
	_buf.append("convRateM=");
	_buf.appendInt64(convRateM);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::CurrencyRate::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CurrencyRate())) // not empty
	{
		_body.composeString(currencyCode);
		_body.composeINT64(convRateM);
	}

	_msg.composeMsgBody(_body);
}

void GlobalPublisherClient::CurrencyRate::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currencyCode);
	_parser0.parseINT64(convRateM);
}

/*static*/ void GlobalPublisherClient::CurrencyRate::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currencyCode"); size_t szCurrencyCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currencyCode", szCurrencyCode, _checker, __FILE__, __LINE__);
	INT64 convRateM; _parser0.parseINT64(convRateM);
	AtfValidator::validateInt(_descr, "convRateM", convRateM, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CurrencyRatePublication
//=================================================================

GlobalPublisherClient::CurrencyRatePublication::CurrencyRatePublication()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

GlobalPublisherClient::CurrencyRatePublication::CurrencyRatePublication(CurrencyRatePublication&& _o)
	: currencyRates(std::move(_o.currencyRates))
{
}

GlobalPublisherClient::CurrencyRatePublication& GlobalPublisherClient::CurrencyRatePublication::operator=(CurrencyRatePublication&& _o)
{
	if(this != &_o)
	{
		currencyRates = std::move(_o.currencyRates);
	}
	return *this;
}

#endif

void GlobalPublisherClient::CurrencyRatePublication::clear()
{
	currencyRates.clear();
}

bool GlobalPublisherClient::CurrencyRatePublication::equals(const CurrencyRatePublication& _o) const
{
	return currencyRates.equals(_o.currencyRates);
}

const char *GlobalPublisherClient::CurrencyRatePublication::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currencyRates=");
	currencyRates.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void GlobalPublisherClient::CurrencyRatePublication::composeMsg(CommMsgBody& _msg) const
{
	currencyRates.composeMsg(_msg);
}

void GlobalPublisherClient::CurrencyRatePublication::parseMsg(CommMsgParser& _parser)
{
	currencyRates.parseMsg(_parser);
}

/*static*/ void GlobalPublisherClient::CurrencyRatePublication::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szCurrencyRates = ThinAtf::LAtfVector< CurrencyRate, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("currencyRates"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "currencyRates", szCurrencyRates, _checker, __FILE__, __LINE__);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool GlobalPublisherClient::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA: Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY: Protocol_MSG_GLOBALPUBLISHER_ADMIN_REREAD_INIDATA_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

